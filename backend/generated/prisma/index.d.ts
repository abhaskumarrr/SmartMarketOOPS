
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model TradeLog
 * 
 */
export type TradeLog = $Result.DefaultSelection<Prisma.$TradeLogPayload>
/**
 * Model Bot
 * 
 */
export type Bot = $Result.DefaultSelection<Prisma.$BotPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model Metric
 * 
 */
export type Metric = $Result.DefaultSelection<Prisma.$MetricPayload>
/**
 * Model TradingSignal
 * 
 */
export type TradingSignal = $Result.DefaultSelection<Prisma.$TradingSignalPayload>
/**
 * Model RiskSettings
 * 
 */
export type RiskSettings = $Result.DefaultSelection<Prisma.$RiskSettingsPayload>
/**
 * Model RiskAlert
 * 
 */
export type RiskAlert = $Result.DefaultSelection<Prisma.$RiskAlertPayload>
/**
 * Model CircuitBreaker
 * 
 */
export type CircuitBreaker = $Result.DefaultSelection<Prisma.$CircuitBreakerPayload>
/**
 * Model TradingStrategy
 * 
 */
export type TradingStrategy = $Result.DefaultSelection<Prisma.$TradingStrategyPayload>
/**
 * Model StrategyExecution
 * 
 */
export type StrategyExecution = $Result.DefaultSelection<Prisma.$StrategyExecutionPayload>
/**
 * Model StrategyExecutionResult
 * 
 */
export type StrategyExecutionResult = $Result.DefaultSelection<Prisma.$StrategyExecutionResultPayload>
/**
 * Model MLModel
 * 
 */
export type MLModel = $Result.DefaultSelection<Prisma.$MLModelPayload>
/**
 * Model MLPrediction
 * 
 */
export type MLPrediction = $Result.DefaultSelection<Prisma.$MLPredictionPayload>
/**
 * Model MLTrainingJob
 * 
 */
export type MLTrainingJob = $Result.DefaultSelection<Prisma.$MLTrainingJobPayload>
/**
 * Model BridgeConfig
 * 
 */
export type BridgeConfig = $Result.DefaultSelection<Prisma.$BridgeConfigPayload>
/**
 * Model PerformanceTest
 * 
 */
export type PerformanceTest = $Result.DefaultSelection<Prisma.$PerformanceTestPayload>
/**
 * Model PerformanceTestResult
 * 
 */
export type PerformanceTestResult = $Result.DefaultSelection<Prisma.$PerformanceTestResultPayload>
/**
 * Model OptimizationRecommendation
 * 
 */
export type OptimizationRecommendation = $Result.DefaultSelection<Prisma.$OptimizationRecommendationPayload>
/**
 * Model ABTest
 * 
 */
export type ABTest = $Result.DefaultSelection<Prisma.$ABTestPayload>
/**
 * Model ABTestResult
 * 
 */
export type ABTestResult = $Result.DefaultSelection<Prisma.$ABTestResultPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model DecisionLog
 * 
 */
export type DecisionLog = $Result.DefaultSelection<Prisma.$DecisionLogPayload>
/**
 * Model AuditTrail
 * 
 */
export type AuditTrail = $Result.DefaultSelection<Prisma.$AuditTrailPayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradeLog`: Exposes CRUD operations for the **TradeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeLogs
    * const tradeLogs = await prisma.tradeLog.findMany()
    * ```
    */
  get tradeLog(): Prisma.TradeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bot`: Exposes CRUD operations for the **Bot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bot.findMany()
    * ```
    */
  get bot(): Prisma.BotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradingSignal`: Exposes CRUD operations for the **TradingSignal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradingSignals
    * const tradingSignals = await prisma.tradingSignal.findMany()
    * ```
    */
  get tradingSignal(): Prisma.TradingSignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskSettings`: Exposes CRUD operations for the **RiskSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskSettings
    * const riskSettings = await prisma.riskSettings.findMany()
    * ```
    */
  get riskSettings(): Prisma.RiskSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskAlert`: Exposes CRUD operations for the **RiskAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAlerts
    * const riskAlerts = await prisma.riskAlert.findMany()
    * ```
    */
  get riskAlert(): Prisma.RiskAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.circuitBreaker`: Exposes CRUD operations for the **CircuitBreaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CircuitBreakers
    * const circuitBreakers = await prisma.circuitBreaker.findMany()
    * ```
    */
  get circuitBreaker(): Prisma.CircuitBreakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradingStrategy`: Exposes CRUD operations for the **TradingStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradingStrategies
    * const tradingStrategies = await prisma.tradingStrategy.findMany()
    * ```
    */
  get tradingStrategy(): Prisma.TradingStrategyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strategyExecution`: Exposes CRUD operations for the **StrategyExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrategyExecutions
    * const strategyExecutions = await prisma.strategyExecution.findMany()
    * ```
    */
  get strategyExecution(): Prisma.StrategyExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strategyExecutionResult`: Exposes CRUD operations for the **StrategyExecutionResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrategyExecutionResults
    * const strategyExecutionResults = await prisma.strategyExecutionResult.findMany()
    * ```
    */
  get strategyExecutionResult(): Prisma.StrategyExecutionResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mLModel`: Exposes CRUD operations for the **MLModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MLModels
    * const mLModels = await prisma.mLModel.findMany()
    * ```
    */
  get mLModel(): Prisma.MLModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mLPrediction`: Exposes CRUD operations for the **MLPrediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MLPredictions
    * const mLPredictions = await prisma.mLPrediction.findMany()
    * ```
    */
  get mLPrediction(): Prisma.MLPredictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mLTrainingJob`: Exposes CRUD operations for the **MLTrainingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MLTrainingJobs
    * const mLTrainingJobs = await prisma.mLTrainingJob.findMany()
    * ```
    */
  get mLTrainingJob(): Prisma.MLTrainingJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bridgeConfig`: Exposes CRUD operations for the **BridgeConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BridgeConfigs
    * const bridgeConfigs = await prisma.bridgeConfig.findMany()
    * ```
    */
  get bridgeConfig(): Prisma.BridgeConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceTest`: Exposes CRUD operations for the **PerformanceTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceTests
    * const performanceTests = await prisma.performanceTest.findMany()
    * ```
    */
  get performanceTest(): Prisma.PerformanceTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceTestResult`: Exposes CRUD operations for the **PerformanceTestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceTestResults
    * const performanceTestResults = await prisma.performanceTestResult.findMany()
    * ```
    */
  get performanceTestResult(): Prisma.PerformanceTestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optimizationRecommendation`: Exposes CRUD operations for the **OptimizationRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptimizationRecommendations
    * const optimizationRecommendations = await prisma.optimizationRecommendation.findMany()
    * ```
    */
  get optimizationRecommendation(): Prisma.OptimizationRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aBTest`: Exposes CRUD operations for the **ABTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABTests
    * const aBTests = await prisma.aBTest.findMany()
    * ```
    */
  get aBTest(): Prisma.ABTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aBTestResult`: Exposes CRUD operations for the **ABTestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABTestResults
    * const aBTestResults = await prisma.aBTestResult.findMany()
    * ```
    */
  get aBTestResult(): Prisma.ABTestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decisionLog`: Exposes CRUD operations for the **DecisionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DecisionLogs
    * const decisionLogs = await prisma.decisionLog.findMany()
    * ```
    */
  get decisionLog(): Prisma.DecisionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditTrail`: Exposes CRUD operations for the **AuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditTrails
    * const auditTrails = await prisma.auditTrail.findMany()
    * ```
    */
  get auditTrail(): Prisma.AuditTrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    ApiKey: 'ApiKey',
    TradeLog: 'TradeLog',
    Bot: 'Bot',
    Position: 'Position',
    Metric: 'Metric',
    TradingSignal: 'TradingSignal',
    RiskSettings: 'RiskSettings',
    RiskAlert: 'RiskAlert',
    CircuitBreaker: 'CircuitBreaker',
    TradingStrategy: 'TradingStrategy',
    StrategyExecution: 'StrategyExecution',
    StrategyExecutionResult: 'StrategyExecutionResult',
    MLModel: 'MLModel',
    MLPrediction: 'MLPrediction',
    MLTrainingJob: 'MLTrainingJob',
    BridgeConfig: 'BridgeConfig',
    PerformanceTest: 'PerformanceTest',
    PerformanceTestResult: 'PerformanceTestResult',
    OptimizationRecommendation: 'OptimizationRecommendation',
    ABTest: 'ABTest',
    ABTestResult: 'ABTestResult',
    PerformanceMetric: 'PerformanceMetric',
    Order: 'Order',
    DecisionLog: 'DecisionLog',
    AuditTrail: 'AuditTrail',
    AuditEvent: 'AuditEvent',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "apiKey" | "tradeLog" | "bot" | "position" | "metric" | "tradingSignal" | "riskSettings" | "riskAlert" | "circuitBreaker" | "tradingStrategy" | "strategyExecution" | "strategyExecutionResult" | "mLModel" | "mLPrediction" | "mLTrainingJob" | "bridgeConfig" | "performanceTest" | "performanceTestResult" | "optimizationRecommendation" | "aBTest" | "aBTestResult" | "performanceMetric" | "order" | "decisionLog" | "auditTrail" | "auditEvent" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      TradeLog: {
        payload: Prisma.$TradeLogPayload<ExtArgs>
        fields: Prisma.TradeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          findFirst: {
            args: Prisma.TradeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          findMany: {
            args: Prisma.TradeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>[]
          }
          create: {
            args: Prisma.TradeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          createMany: {
            args: Prisma.TradeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>[]
          }
          delete: {
            args: Prisma.TradeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          update: {
            args: Prisma.TradeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          deleteMany: {
            args: Prisma.TradeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>[]
          }
          upsert: {
            args: Prisma.TradeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeLogPayload>
          }
          aggregate: {
            args: Prisma.TradeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeLog>
          }
          groupBy: {
            args: Prisma.TradeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TradeLogCountAggregateOutputType> | number
          }
        }
      }
      Bot: {
        payload: Prisma.$BotPayload<ExtArgs>
        fields: Prisma.BotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findFirst: {
            args: Prisma.BotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findMany: {
            args: Prisma.BotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          create: {
            args: Prisma.BotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          createMany: {
            args: Prisma.BotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          delete: {
            args: Prisma.BotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          update: {
            args: Prisma.BotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          deleteMany: {
            args: Prisma.BotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          upsert: {
            args: Prisma.BotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          aggregate: {
            args: Prisma.BotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBot>
          }
          groupBy: {
            args: Prisma.BotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotCountArgs<ExtArgs>
            result: $Utils.Optional<BotCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: Prisma.$MetricPayload<ExtArgs>
        fields: Prisma.MetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      TradingSignal: {
        payload: Prisma.$TradingSignalPayload<ExtArgs>
        fields: Prisma.TradingSignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradingSignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradingSignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          findFirst: {
            args: Prisma.TradingSignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradingSignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          findMany: {
            args: Prisma.TradingSignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>[]
          }
          create: {
            args: Prisma.TradingSignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          createMany: {
            args: Prisma.TradingSignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradingSignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>[]
          }
          delete: {
            args: Prisma.TradingSignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          update: {
            args: Prisma.TradingSignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          deleteMany: {
            args: Prisma.TradingSignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradingSignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradingSignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>[]
          }
          upsert: {
            args: Prisma.TradingSignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingSignalPayload>
          }
          aggregate: {
            args: Prisma.TradingSignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradingSignal>
          }
          groupBy: {
            args: Prisma.TradingSignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradingSignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradingSignalCountArgs<ExtArgs>
            result: $Utils.Optional<TradingSignalCountAggregateOutputType> | number
          }
        }
      }
      RiskSettings: {
        payload: Prisma.$RiskSettingsPayload<ExtArgs>
        fields: Prisma.RiskSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          findFirst: {
            args: Prisma.RiskSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          findMany: {
            args: Prisma.RiskSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>[]
          }
          create: {
            args: Prisma.RiskSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          createMany: {
            args: Prisma.RiskSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>[]
          }
          delete: {
            args: Prisma.RiskSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          update: {
            args: Prisma.RiskSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          deleteMany: {
            args: Prisma.RiskSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>[]
          }
          upsert: {
            args: Prisma.RiskSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskSettingsPayload>
          }
          aggregate: {
            args: Prisma.RiskSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskSettings>
          }
          groupBy: {
            args: Prisma.RiskSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<RiskSettingsCountAggregateOutputType> | number
          }
        }
      }
      RiskAlert: {
        payload: Prisma.$RiskAlertPayload<ExtArgs>
        fields: Prisma.RiskAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          findFirst: {
            args: Prisma.RiskAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          findMany: {
            args: Prisma.RiskAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>[]
          }
          create: {
            args: Prisma.RiskAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          createMany: {
            args: Prisma.RiskAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>[]
          }
          delete: {
            args: Prisma.RiskAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          update: {
            args: Prisma.RiskAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          deleteMany: {
            args: Prisma.RiskAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>[]
          }
          upsert: {
            args: Prisma.RiskAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAlertPayload>
          }
          aggregate: {
            args: Prisma.RiskAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAlert>
          }
          groupBy: {
            args: Prisma.RiskAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAlertCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAlertCountAggregateOutputType> | number
          }
        }
      }
      CircuitBreaker: {
        payload: Prisma.$CircuitBreakerPayload<ExtArgs>
        fields: Prisma.CircuitBreakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircuitBreakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircuitBreakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          findFirst: {
            args: Prisma.CircuitBreakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircuitBreakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          findMany: {
            args: Prisma.CircuitBreakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>[]
          }
          create: {
            args: Prisma.CircuitBreakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          createMany: {
            args: Prisma.CircuitBreakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircuitBreakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>[]
          }
          delete: {
            args: Prisma.CircuitBreakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          update: {
            args: Prisma.CircuitBreakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          deleteMany: {
            args: Prisma.CircuitBreakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircuitBreakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CircuitBreakerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>[]
          }
          upsert: {
            args: Prisma.CircuitBreakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircuitBreakerPayload>
          }
          aggregate: {
            args: Prisma.CircuitBreakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircuitBreaker>
          }
          groupBy: {
            args: Prisma.CircuitBreakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircuitBreakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircuitBreakerCountArgs<ExtArgs>
            result: $Utils.Optional<CircuitBreakerCountAggregateOutputType> | number
          }
        }
      }
      TradingStrategy: {
        payload: Prisma.$TradingStrategyPayload<ExtArgs>
        fields: Prisma.TradingStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradingStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradingStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          findFirst: {
            args: Prisma.TradingStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradingStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          findMany: {
            args: Prisma.TradingStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>[]
          }
          create: {
            args: Prisma.TradingStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          createMany: {
            args: Prisma.TradingStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradingStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>[]
          }
          delete: {
            args: Prisma.TradingStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          update: {
            args: Prisma.TradingStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          deleteMany: {
            args: Prisma.TradingStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradingStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradingStrategyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>[]
          }
          upsert: {
            args: Prisma.TradingStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradingStrategyPayload>
          }
          aggregate: {
            args: Prisma.TradingStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradingStrategy>
          }
          groupBy: {
            args: Prisma.TradingStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradingStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradingStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<TradingStrategyCountAggregateOutputType> | number
          }
        }
      }
      StrategyExecution: {
        payload: Prisma.$StrategyExecutionPayload<ExtArgs>
        fields: Prisma.StrategyExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          findFirst: {
            args: Prisma.StrategyExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          findMany: {
            args: Prisma.StrategyExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>[]
          }
          create: {
            args: Prisma.StrategyExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          createMany: {
            args: Prisma.StrategyExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>[]
          }
          delete: {
            args: Prisma.StrategyExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          update: {
            args: Prisma.StrategyExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          deleteMany: {
            args: Prisma.StrategyExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StrategyExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>[]
          }
          upsert: {
            args: Prisma.StrategyExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionPayload>
          }
          aggregate: {
            args: Prisma.StrategyExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategyExecution>
          }
          groupBy: {
            args: Prisma.StrategyExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyExecutionCountAggregateOutputType> | number
          }
        }
      }
      StrategyExecutionResult: {
        payload: Prisma.$StrategyExecutionResultPayload<ExtArgs>
        fields: Prisma.StrategyExecutionResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrategyExecutionResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrategyExecutionResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          findFirst: {
            args: Prisma.StrategyExecutionResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrategyExecutionResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          findMany: {
            args: Prisma.StrategyExecutionResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>[]
          }
          create: {
            args: Prisma.StrategyExecutionResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          createMany: {
            args: Prisma.StrategyExecutionResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrategyExecutionResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>[]
          }
          delete: {
            args: Prisma.StrategyExecutionResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          update: {
            args: Prisma.StrategyExecutionResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          deleteMany: {
            args: Prisma.StrategyExecutionResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrategyExecutionResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StrategyExecutionResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>[]
          }
          upsert: {
            args: Prisma.StrategyExecutionResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrategyExecutionResultPayload>
          }
          aggregate: {
            args: Prisma.StrategyExecutionResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrategyExecutionResult>
          }
          groupBy: {
            args: Prisma.StrategyExecutionResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrategyExecutionResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrategyExecutionResultCountArgs<ExtArgs>
            result: $Utils.Optional<StrategyExecutionResultCountAggregateOutputType> | number
          }
        }
      }
      MLModel: {
        payload: Prisma.$MLModelPayload<ExtArgs>
        fields: Prisma.MLModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MLModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MLModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          findFirst: {
            args: Prisma.MLModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MLModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          findMany: {
            args: Prisma.MLModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          create: {
            args: Prisma.MLModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          createMany: {
            args: Prisma.MLModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MLModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          delete: {
            args: Prisma.MLModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          update: {
            args: Prisma.MLModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          deleteMany: {
            args: Prisma.MLModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MLModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MLModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          upsert: {
            args: Prisma.MLModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          aggregate: {
            args: Prisma.MLModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMLModel>
          }
          groupBy: {
            args: Prisma.MLModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<MLModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MLModelCountArgs<ExtArgs>
            result: $Utils.Optional<MLModelCountAggregateOutputType> | number
          }
        }
      }
      MLPrediction: {
        payload: Prisma.$MLPredictionPayload<ExtArgs>
        fields: Prisma.MLPredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MLPredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MLPredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          findFirst: {
            args: Prisma.MLPredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MLPredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          findMany: {
            args: Prisma.MLPredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>[]
          }
          create: {
            args: Prisma.MLPredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          createMany: {
            args: Prisma.MLPredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MLPredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>[]
          }
          delete: {
            args: Prisma.MLPredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          update: {
            args: Prisma.MLPredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          deleteMany: {
            args: Prisma.MLPredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MLPredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MLPredictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>[]
          }
          upsert: {
            args: Prisma.MLPredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLPredictionPayload>
          }
          aggregate: {
            args: Prisma.MLPredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMLPrediction>
          }
          groupBy: {
            args: Prisma.MLPredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MLPredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MLPredictionCountArgs<ExtArgs>
            result: $Utils.Optional<MLPredictionCountAggregateOutputType> | number
          }
        }
      }
      MLTrainingJob: {
        payload: Prisma.$MLTrainingJobPayload<ExtArgs>
        fields: Prisma.MLTrainingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MLTrainingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MLTrainingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          findFirst: {
            args: Prisma.MLTrainingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MLTrainingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          findMany: {
            args: Prisma.MLTrainingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>[]
          }
          create: {
            args: Prisma.MLTrainingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          createMany: {
            args: Prisma.MLTrainingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MLTrainingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>[]
          }
          delete: {
            args: Prisma.MLTrainingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          update: {
            args: Prisma.MLTrainingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          deleteMany: {
            args: Prisma.MLTrainingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MLTrainingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MLTrainingJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>[]
          }
          upsert: {
            args: Prisma.MLTrainingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLTrainingJobPayload>
          }
          aggregate: {
            args: Prisma.MLTrainingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMLTrainingJob>
          }
          groupBy: {
            args: Prisma.MLTrainingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<MLTrainingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.MLTrainingJobCountArgs<ExtArgs>
            result: $Utils.Optional<MLTrainingJobCountAggregateOutputType> | number
          }
        }
      }
      BridgeConfig: {
        payload: Prisma.$BridgeConfigPayload<ExtArgs>
        fields: Prisma.BridgeConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BridgeConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BridgeConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          findFirst: {
            args: Prisma.BridgeConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BridgeConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          findMany: {
            args: Prisma.BridgeConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>[]
          }
          create: {
            args: Prisma.BridgeConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          createMany: {
            args: Prisma.BridgeConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BridgeConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>[]
          }
          delete: {
            args: Prisma.BridgeConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          update: {
            args: Prisma.BridgeConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          deleteMany: {
            args: Prisma.BridgeConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BridgeConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BridgeConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>[]
          }
          upsert: {
            args: Prisma.BridgeConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BridgeConfigPayload>
          }
          aggregate: {
            args: Prisma.BridgeConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBridgeConfig>
          }
          groupBy: {
            args: Prisma.BridgeConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BridgeConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BridgeConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BridgeConfigCountAggregateOutputType> | number
          }
        }
      }
      PerformanceTest: {
        payload: Prisma.$PerformanceTestPayload<ExtArgs>
        fields: Prisma.PerformanceTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          findFirst: {
            args: Prisma.PerformanceTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          findMany: {
            args: Prisma.PerformanceTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>[]
          }
          create: {
            args: Prisma.PerformanceTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          createMany: {
            args: Prisma.PerformanceTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>[]
          }
          delete: {
            args: Prisma.PerformanceTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          update: {
            args: Prisma.PerformanceTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestPayload>
          }
          aggregate: {
            args: Prisma.PerformanceTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceTest>
          }
          groupBy: {
            args: Prisma.PerformanceTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceTestCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceTestCountAggregateOutputType> | number
          }
        }
      }
      PerformanceTestResult: {
        payload: Prisma.$PerformanceTestResultPayload<ExtArgs>
        fields: Prisma.PerformanceTestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceTestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceTestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          findFirst: {
            args: Prisma.PerformanceTestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceTestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          findMany: {
            args: Prisma.PerformanceTestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>[]
          }
          create: {
            args: Prisma.PerformanceTestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          createMany: {
            args: Prisma.PerformanceTestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceTestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>[]
          }
          delete: {
            args: Prisma.PerformanceTestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          update: {
            args: Prisma.PerformanceTestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceTestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceTestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceTestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceTestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceTestResultPayload>
          }
          aggregate: {
            args: Prisma.PerformanceTestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceTestResult>
          }
          groupBy: {
            args: Prisma.PerformanceTestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceTestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceTestResultCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceTestResultCountAggregateOutputType> | number
          }
        }
      }
      OptimizationRecommendation: {
        payload: Prisma.$OptimizationRecommendationPayload<ExtArgs>
        fields: Prisma.OptimizationRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptimizationRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptimizationRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          findFirst: {
            args: Prisma.OptimizationRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptimizationRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          findMany: {
            args: Prisma.OptimizationRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>[]
          }
          create: {
            args: Prisma.OptimizationRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          createMany: {
            args: Prisma.OptimizationRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptimizationRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>[]
          }
          delete: {
            args: Prisma.OptimizationRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          update: {
            args: Prisma.OptimizationRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.OptimizationRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptimizationRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptimizationRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.OptimizationRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptimizationRecommendationPayload>
          }
          aggregate: {
            args: Prisma.OptimizationRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptimizationRecommendation>
          }
          groupBy: {
            args: Prisma.OptimizationRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptimizationRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptimizationRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<OptimizationRecommendationCountAggregateOutputType> | number
          }
        }
      }
      ABTest: {
        payload: Prisma.$ABTestPayload<ExtArgs>
        fields: Prisma.ABTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          findFirst: {
            args: Prisma.ABTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          findMany: {
            args: Prisma.ABTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          create: {
            args: Prisma.ABTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          createMany: {
            args: Prisma.ABTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ABTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          delete: {
            args: Prisma.ABTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          update: {
            args: Prisma.ABTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          deleteMany: {
            args: Prisma.ABTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ABTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ABTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          upsert: {
            args: Prisma.ABTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          aggregate: {
            args: Prisma.ABTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateABTest>
          }
          groupBy: {
            args: Prisma.ABTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ABTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABTestCountArgs<ExtArgs>
            result: $Utils.Optional<ABTestCountAggregateOutputType> | number
          }
        }
      }
      ABTestResult: {
        payload: Prisma.$ABTestResultPayload<ExtArgs>
        fields: Prisma.ABTestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABTestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABTestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          findFirst: {
            args: Prisma.ABTestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABTestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          findMany: {
            args: Prisma.ABTestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>[]
          }
          create: {
            args: Prisma.ABTestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          createMany: {
            args: Prisma.ABTestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ABTestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>[]
          }
          delete: {
            args: Prisma.ABTestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          update: {
            args: Prisma.ABTestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          deleteMany: {
            args: Prisma.ABTestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ABTestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ABTestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>[]
          }
          upsert: {
            args: Prisma.ABTestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestResultPayload>
          }
          aggregate: {
            args: Prisma.ABTestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateABTestResult>
          }
          groupBy: {
            args: Prisma.ABTestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ABTestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABTestResultCountArgs<ExtArgs>
            result: $Utils.Optional<ABTestResultCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      DecisionLog: {
        payload: Prisma.$DecisionLogPayload<ExtArgs>
        fields: Prisma.DecisionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecisionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecisionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          findFirst: {
            args: Prisma.DecisionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecisionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          findMany: {
            args: Prisma.DecisionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>[]
          }
          create: {
            args: Prisma.DecisionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          createMany: {
            args: Prisma.DecisionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecisionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>[]
          }
          delete: {
            args: Prisma.DecisionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          update: {
            args: Prisma.DecisionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          deleteMany: {
            args: Prisma.DecisionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecisionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DecisionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>[]
          }
          upsert: {
            args: Prisma.DecisionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          aggregate: {
            args: Prisma.DecisionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecisionLog>
          }
          groupBy: {
            args: Prisma.DecisionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecisionLogCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionLogCountAggregateOutputType> | number
          }
        }
      }
      AuditTrail: {
        payload: Prisma.$AuditTrailPayload<ExtArgs>
        fields: Prisma.AuditTrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditTrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditTrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findFirst: {
            args: Prisma.AuditTrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditTrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findMany: {
            args: Prisma.AuditTrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          create: {
            args: Prisma.AuditTrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          createMany: {
            args: Prisma.AuditTrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditTrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          delete: {
            args: Prisma.AuditTrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          update: {
            args: Prisma.AuditTrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          deleteMany: {
            args: Prisma.AuditTrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditTrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditTrailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          upsert: {
            args: Prisma.AuditTrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          aggregate: {
            args: Prisma.AuditTrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditTrail>
          }
          groupBy: {
            args: Prisma.AuditTrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditTrailCountArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    apiKey?: ApiKeyOmit
    tradeLog?: TradeLogOmit
    bot?: BotOmit
    position?: PositionOmit
    metric?: MetricOmit
    tradingSignal?: TradingSignalOmit
    riskSettings?: RiskSettingsOmit
    riskAlert?: RiskAlertOmit
    circuitBreaker?: CircuitBreakerOmit
    tradingStrategy?: TradingStrategyOmit
    strategyExecution?: StrategyExecutionOmit
    strategyExecutionResult?: StrategyExecutionResultOmit
    mLModel?: MLModelOmit
    mLPrediction?: MLPredictionOmit
    mLTrainingJob?: MLTrainingJobOmit
    bridgeConfig?: BridgeConfigOmit
    performanceTest?: PerformanceTestOmit
    performanceTestResult?: PerformanceTestResultOmit
    optimizationRecommendation?: OptimizationRecommendationOmit
    aBTest?: ABTestOmit
    aBTestResult?: ABTestResultOmit
    performanceMetric?: PerformanceMetricOmit
    order?: OrderOmit
    decisionLog?: DecisionLogOmit
    auditTrail?: AuditTrailOmit
    auditEvent?: AuditEventOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apiKeys: number
    tradeLogs: number
    bots: number
    positions: number
    sessions: number
    riskSettings: number
    riskAlerts: number
    orders: number
    auditLogs: number
    decisionLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    tradeLogs?: boolean | UserCountOutputTypeCountTradeLogsArgs
    bots?: boolean | UserCountOutputTypeCountBotsArgs
    positions?: boolean | UserCountOutputTypeCountPositionsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    riskSettings?: boolean | UserCountOutputTypeCountRiskSettingsArgs
    riskAlerts?: boolean | UserCountOutputTypeCountRiskAlertsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    decisionLogs?: boolean | UserCountOutputTypeCountDecisionLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRiskSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRiskAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDecisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Count Type BotCountOutputType
   */

  export type BotCountOutputType = {
    positions: number
    riskSettings: number
    orders: number
    decisionLogs: number
  }

  export type BotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | BotCountOutputTypeCountPositionsArgs
    riskSettings?: boolean | BotCountOutputTypeCountRiskSettingsArgs
    orders?: boolean | BotCountOutputTypeCountOrdersArgs
    decisionLogs?: boolean | BotCountOutputTypeCountDecisionLogsArgs
  }

  // Custom InputTypes
  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotCountOutputType
     */
    select?: BotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountRiskSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskSettingsWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountDecisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    orders: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PositionCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type TradingSignalCountOutputType
   */

  export type TradingSignalCountOutputType = {
    orders: number
  }

  export type TradingSignalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TradingSignalCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * TradingSignalCountOutputType without action
   */
  export type TradingSignalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignalCountOutputType
     */
    select?: TradingSignalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TradingSignalCountOutputType without action
   */
  export type TradingSignalCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type TradingStrategyCountOutputType
   */

  export type TradingStrategyCountOutputType = {
    executions: number
    orders: number
    decisionLogs: number
  }

  export type TradingStrategyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | TradingStrategyCountOutputTypeCountExecutionsArgs
    orders?: boolean | TradingStrategyCountOutputTypeCountOrdersArgs
    decisionLogs?: boolean | TradingStrategyCountOutputTypeCountDecisionLogsArgs
  }

  // Custom InputTypes
  /**
   * TradingStrategyCountOutputType without action
   */
  export type TradingStrategyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategyCountOutputType
     */
    select?: TradingStrategyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TradingStrategyCountOutputType without action
   */
  export type TradingStrategyCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyExecutionWhereInput
  }

  /**
   * TradingStrategyCountOutputType without action
   */
  export type TradingStrategyCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * TradingStrategyCountOutputType without action
   */
  export type TradingStrategyCountOutputTypeCountDecisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Count Type StrategyExecutionCountOutputType
   */

  export type StrategyExecutionCountOutputType = {
    results: number
  }

  export type StrategyExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | StrategyExecutionCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * StrategyExecutionCountOutputType without action
   */
  export type StrategyExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionCountOutputType
     */
    select?: StrategyExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StrategyExecutionCountOutputType without action
   */
  export type StrategyExecutionCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyExecutionResultWhereInput
  }


  /**
   * Count Type MLModelCountOutputType
   */

  export type MLModelCountOutputType = {
    predictions: number
  }

  export type MLModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predictions?: boolean | MLModelCountOutputTypeCountPredictionsArgs
  }

  // Custom InputTypes
  /**
   * MLModelCountOutputType without action
   */
  export type MLModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModelCountOutputType
     */
    select?: MLModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MLModelCountOutputType without action
   */
  export type MLModelCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MLPredictionWhereInput
  }


  /**
   * Count Type PerformanceTestCountOutputType
   */

  export type PerformanceTestCountOutputType = {
    results: number
  }

  export type PerformanceTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | PerformanceTestCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * PerformanceTestCountOutputType without action
   */
  export type PerformanceTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestCountOutputType
     */
    select?: PerformanceTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerformanceTestCountOutputType without action
   */
  export type PerformanceTestCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceTestResultWhereInput
  }


  /**
   * Count Type PerformanceTestResultCountOutputType
   */

  export type PerformanceTestResultCountOutputType = {
    recommendations: number
  }

  export type PerformanceTestResultCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendations?: boolean | PerformanceTestResultCountOutputTypeCountRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * PerformanceTestResultCountOutputType without action
   */
  export type PerformanceTestResultCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResultCountOutputType
     */
    select?: PerformanceTestResultCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerformanceTestResultCountOutputType without action
   */
  export type PerformanceTestResultCountOutputTypeCountRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptimizationRecommendationWhereInput
  }


  /**
   * Count Type ABTestCountOutputType
   */

  export type ABTestCountOutputType = {
    results: number
  }

  export type ABTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | ABTestCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * ABTestCountOutputType without action
   */
  export type ABTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestCountOutputType
     */
    select?: ABTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ABTestCountOutputType without action
   */
  export type ABTestCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestResultWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    auditTrails: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditTrails?: boolean | OrderCountOutputTypeCountAuditTrailsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAuditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
  }


  /**
   * Count Type AuditTrailCountOutputType
   */

  export type AuditTrailCountOutputType = {
    events: number
    decisionLogs: number
  }

  export type AuditTrailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | AuditTrailCountOutputTypeCountEventsArgs
    decisionLogs?: boolean | AuditTrailCountOutputTypeCountDecisionLogsArgs
  }

  // Custom InputTypes
  /**
   * AuditTrailCountOutputType without action
   */
  export type AuditTrailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrailCountOutputType
     */
    select?: AuditTrailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditTrailCountOutputType without action
   */
  export type AuditTrailCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }

  /**
   * AuditTrailCountOutputType without action
   */
  export type AuditTrailCountOutputTypeCountDecisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    oauthProvider: string | null
    oauthId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    oauthProvider: string | null
    oauthId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    isVerified: number
    verificationToken: number
    verificationTokenExpiry: number
    resetToken: number
    resetTokenExpiry: number
    lastLoginAt: number
    oauthProvider: number
    oauthId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    oauthProvider?: true
    oauthId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    oauthProvider?: true
    oauthId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiry?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    oauthProvider?: true
    oauthId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: string
    isVerified: boolean
    verificationToken: string | null
    verificationTokenExpiry: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    oauthProvider: string | null
    oauthId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    tradeLogs?: boolean | User$tradeLogsArgs<ExtArgs>
    bots?: boolean | User$botsArgs<ExtArgs>
    positions?: boolean | User$positionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    riskSettings?: boolean | User$riskSettingsArgs<ExtArgs>
    riskAlerts?: boolean | User$riskAlertsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    decisionLogs?: boolean | User$decisionLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiry?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "isVerified" | "verificationToken" | "verificationTokenExpiry" | "resetToken" | "resetTokenExpiry" | "lastLoginAt" | "oauthProvider" | "oauthId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    tradeLogs?: boolean | User$tradeLogsArgs<ExtArgs>
    bots?: boolean | User$botsArgs<ExtArgs>
    positions?: boolean | User$positionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    riskSettings?: boolean | User$riskSettingsArgs<ExtArgs>
    riskAlerts?: boolean | User$riskAlertsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    decisionLogs?: boolean | User$decisionLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      tradeLogs: Prisma.$TradeLogPayload<ExtArgs>[]
      bots: Prisma.$BotPayload<ExtArgs>[]
      positions: Prisma.$PositionPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      riskSettings: Prisma.$RiskSettingsPayload<ExtArgs>[]
      riskAlerts: Prisma.$RiskAlertPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      decisionLogs: Prisma.$DecisionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: string
      isVerified: boolean
      verificationToken: string | null
      verificationTokenExpiry: Date | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      lastLoginAt: Date | null
      oauthProvider: string | null
      oauthId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradeLogs<T extends User$tradeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$tradeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bots<T extends User$botsArgs<ExtArgs> = {}>(args?: Subset<T, User$botsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    positions<T extends User$positionsArgs<ExtArgs> = {}>(args?: Subset<T, User$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    riskSettings<T extends User$riskSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$riskSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    riskAlerts<T extends User$riskAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$riskAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decisionLogs<T extends User$decisionLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$decisionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly oauthProvider: FieldRef<"User", 'String'>
    readonly oauthId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.tradeLogs
   */
  export type User$tradeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    where?: TradeLogWhereInput
    orderBy?: TradeLogOrderByWithRelationInput | TradeLogOrderByWithRelationInput[]
    cursor?: TradeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeLogScalarFieldEnum | TradeLogScalarFieldEnum[]
  }

  /**
   * User.bots
   */
  export type User$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * User.positions
   */
  export type User$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.riskSettings
   */
  export type User$riskSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    where?: RiskSettingsWhereInput
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    cursor?: RiskSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskSettingsScalarFieldEnum | RiskSettingsScalarFieldEnum[]
  }

  /**
   * User.riskAlerts
   */
  export type User$riskAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    where?: RiskAlertWhereInput
    orderBy?: RiskAlertOrderByWithRelationInput | RiskAlertOrderByWithRelationInput[]
    cursor?: RiskAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskAlertScalarFieldEnum | RiskAlertScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.decisionLogs
   */
  export type User$decisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    isValid: boolean | null
    expiresAt: Date | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    rememberMe: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    isValid: boolean | null
    expiresAt: Date | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    rememberMe: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    refreshToken: number
    ipAddress: number
    userAgent: number
    deviceId: number
    isValid: number
    expiresAt: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    rememberMe: number
    metadata: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    isValid?: true
    expiresAt?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    rememberMe?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    isValid?: true
    expiresAt?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    rememberMe?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    isValid?: true
    expiresAt?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    rememberMe?: true
    metadata?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    isValid: boolean
    expiresAt: Date
    lastActiveAt: Date
    createdAt: Date
    updatedAt: Date
    rememberMe: boolean
    metadata: JsonValue | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    isValid?: boolean
    expiresAt?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rememberMe?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    isValid?: boolean
    expiresAt?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rememberMe?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    isValid?: boolean
    expiresAt?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rememberMe?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    isValid?: boolean
    expiresAt?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rememberMe?: boolean
    metadata?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "refreshToken" | "ipAddress" | "userAgent" | "deviceId" | "isValid" | "expiresAt" | "lastActiveAt" | "createdAt" | "updatedAt" | "rememberMe" | "metadata", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      refreshToken: string | null
      ipAddress: string | null
      userAgent: string | null
      deviceId: string | null
      isValid: boolean
      expiresAt: Date
      lastActiveAt: Date
      createdAt: Date
      updatedAt: Date
      rememberMe: boolean
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly deviceId: FieldRef<"Session", 'String'>
    readonly isValid: FieldRef<"Session", 'Boolean'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly lastActiveAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly rememberMe: FieldRef<"Session", 'Boolean'>
    readonly metadata: FieldRef<"Session", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    encryptedData: string | null
    userId: string | null
    name: string | null
    scopes: string | null
    expiry: Date | null
    environment: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    ipRestrictions: string | null
    hashedSecret: string | null
    usageCount: number | null
    isDefault: boolean | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    encryptedData: string | null
    userId: string | null
    name: string | null
    scopes: string | null
    expiry: Date | null
    environment: string | null
    createdAt: Date | null
    lastUsedAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    ipRestrictions: string | null
    hashedSecret: string | null
    usageCount: number | null
    isDefault: boolean | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    key: number
    encryptedData: number
    userId: number
    name: number
    scopes: number
    expiry: number
    environment: number
    createdAt: number
    lastUsedAt: number
    isRevoked: number
    revokedAt: number
    revokedBy: number
    revokedReason: number
    ipRestrictions: number
    hashedSecret: number
    usageCount: number
    isDefault: number
    rateLimits: number
    metadata: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeySumAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    key?: true
    encryptedData?: true
    userId?: true
    name?: true
    scopes?: true
    expiry?: true
    environment?: true
    createdAt?: true
    lastUsedAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    ipRestrictions?: true
    hashedSecret?: true
    usageCount?: true
    isDefault?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    key?: true
    encryptedData?: true
    userId?: true
    name?: true
    scopes?: true
    expiry?: true
    environment?: true
    createdAt?: true
    lastUsedAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    ipRestrictions?: true
    hashedSecret?: true
    usageCount?: true
    isDefault?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    key?: true
    encryptedData?: true
    userId?: true
    name?: true
    scopes?: true
    expiry?: true
    environment?: true
    createdAt?: true
    lastUsedAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    ipRestrictions?: true
    hashedSecret?: true
    usageCount?: true
    isDefault?: true
    rateLimits?: true
    metadata?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    key: string
    encryptedData: string
    userId: string
    name: string
    scopes: string
    expiry: Date
    environment: string
    createdAt: Date
    lastUsedAt: Date | null
    isRevoked: boolean
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    ipRestrictions: string | null
    hashedSecret: string | null
    usageCount: number
    isDefault: boolean
    rateLimits: JsonValue | null
    metadata: JsonValue | null
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    encryptedData?: boolean
    userId?: boolean
    name?: boolean
    scopes?: boolean
    expiry?: boolean
    environment?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    ipRestrictions?: boolean
    hashedSecret?: boolean
    usageCount?: boolean
    isDefault?: boolean
    rateLimits?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    encryptedData?: boolean
    userId?: boolean
    name?: boolean
    scopes?: boolean
    expiry?: boolean
    environment?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    ipRestrictions?: boolean
    hashedSecret?: boolean
    usageCount?: boolean
    isDefault?: boolean
    rateLimits?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    encryptedData?: boolean
    userId?: boolean
    name?: boolean
    scopes?: boolean
    expiry?: boolean
    environment?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    ipRestrictions?: boolean
    hashedSecret?: boolean
    usageCount?: boolean
    isDefault?: boolean
    rateLimits?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    key?: boolean
    encryptedData?: boolean
    userId?: boolean
    name?: boolean
    scopes?: boolean
    expiry?: boolean
    environment?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    ipRestrictions?: boolean
    hashedSecret?: boolean
    usageCount?: boolean
    isDefault?: boolean
    rateLimits?: boolean
    metadata?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "encryptedData" | "userId" | "name" | "scopes" | "expiry" | "environment" | "createdAt" | "lastUsedAt" | "isRevoked" | "revokedAt" | "revokedBy" | "revokedReason" | "ipRestrictions" | "hashedSecret" | "usageCount" | "isDefault" | "rateLimits" | "metadata", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      encryptedData: string
      userId: string
      name: string
      scopes: string
      expiry: Date
      environment: string
      createdAt: Date
      lastUsedAt: Date | null
      isRevoked: boolean
      revokedAt: Date | null
      revokedBy: string | null
      revokedReason: string | null
      ipRestrictions: string | null
      hashedSecret: string | null
      usageCount: number
      isDefault: boolean
      rateLimits: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly encryptedData: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly scopes: FieldRef<"ApiKey", 'String'>
    readonly expiry: FieldRef<"ApiKey", 'DateTime'>
    readonly environment: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly isRevoked: FieldRef<"ApiKey", 'Boolean'>
    readonly revokedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly revokedBy: FieldRef<"ApiKey", 'String'>
    readonly revokedReason: FieldRef<"ApiKey", 'String'>
    readonly ipRestrictions: FieldRef<"ApiKey", 'String'>
    readonly hashedSecret: FieldRef<"ApiKey", 'String'>
    readonly usageCount: FieldRef<"ApiKey", 'Int'>
    readonly isDefault: FieldRef<"ApiKey", 'Boolean'>
    readonly rateLimits: FieldRef<"ApiKey", 'Json'>
    readonly metadata: FieldRef<"ApiKey", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model TradeLog
   */

  export type AggregateTradeLog = {
    _count: TradeLogCountAggregateOutputType | null
    _avg: TradeLogAvgAggregateOutputType | null
    _sum: TradeLogSumAggregateOutputType | null
    _min: TradeLogMinAggregateOutputType | null
    _max: TradeLogMaxAggregateOutputType | null
  }

  export type TradeLogAvgAggregateOutputType = {
    amount: number | null
    price: number | null
  }

  export type TradeLogSumAggregateOutputType = {
    amount: number | null
    price: number | null
  }

  export type TradeLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    instrument: string | null
    amount: number | null
    price: number | null
    timestamp: Date | null
    orderId: string | null
    type: string | null
    status: string | null
  }

  export type TradeLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    instrument: string | null
    amount: number | null
    price: number | null
    timestamp: Date | null
    orderId: string | null
    type: string | null
    status: string | null
  }

  export type TradeLogCountAggregateOutputType = {
    id: number
    userId: number
    instrument: number
    amount: number
    price: number
    timestamp: number
    orderId: number
    type: number
    status: number
    _all: number
  }


  export type TradeLogAvgAggregateInputType = {
    amount?: true
    price?: true
  }

  export type TradeLogSumAggregateInputType = {
    amount?: true
    price?: true
  }

  export type TradeLogMinAggregateInputType = {
    id?: true
    userId?: true
    instrument?: true
    amount?: true
    price?: true
    timestamp?: true
    orderId?: true
    type?: true
    status?: true
  }

  export type TradeLogMaxAggregateInputType = {
    id?: true
    userId?: true
    instrument?: true
    amount?: true
    price?: true
    timestamp?: true
    orderId?: true
    type?: true
    status?: true
  }

  export type TradeLogCountAggregateInputType = {
    id?: true
    userId?: true
    instrument?: true
    amount?: true
    price?: true
    timestamp?: true
    orderId?: true
    type?: true
    status?: true
    _all?: true
  }

  export type TradeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeLog to aggregate.
     */
    where?: TradeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLogs to fetch.
     */
    orderBy?: TradeLogOrderByWithRelationInput | TradeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeLogs
    **/
    _count?: true | TradeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeLogMaxAggregateInputType
  }

  export type GetTradeLogAggregateType<T extends TradeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeLog[P]>
      : GetScalarType<T[P], AggregateTradeLog[P]>
  }




  export type TradeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeLogWhereInput
    orderBy?: TradeLogOrderByWithAggregationInput | TradeLogOrderByWithAggregationInput[]
    by: TradeLogScalarFieldEnum[] | TradeLogScalarFieldEnum
    having?: TradeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeLogCountAggregateInputType | true
    _avg?: TradeLogAvgAggregateInputType
    _sum?: TradeLogSumAggregateInputType
    _min?: TradeLogMinAggregateInputType
    _max?: TradeLogMaxAggregateInputType
  }

  export type TradeLogGroupByOutputType = {
    id: string
    userId: string
    instrument: string
    amount: number
    price: number
    timestamp: Date
    orderId: string | null
    type: string
    status: string
    _count: TradeLogCountAggregateOutputType | null
    _avg: TradeLogAvgAggregateOutputType | null
    _sum: TradeLogSumAggregateOutputType | null
    _min: TradeLogMinAggregateOutputType | null
    _max: TradeLogMaxAggregateOutputType | null
  }

  type GetTradeLogGroupByPayload<T extends TradeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TradeLogGroupByOutputType[P]>
        }
      >
    >


  export type TradeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrument?: boolean
    amount?: boolean
    price?: boolean
    timestamp?: boolean
    orderId?: boolean
    type?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeLog"]>

  export type TradeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrument?: boolean
    amount?: boolean
    price?: boolean
    timestamp?: boolean
    orderId?: boolean
    type?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeLog"]>

  export type TradeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrument?: boolean
    amount?: boolean
    price?: boolean
    timestamp?: boolean
    orderId?: boolean
    type?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeLog"]>

  export type TradeLogSelectScalar = {
    id?: boolean
    userId?: boolean
    instrument?: boolean
    amount?: boolean
    price?: boolean
    timestamp?: boolean
    orderId?: boolean
    type?: boolean
    status?: boolean
  }

  export type TradeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "instrument" | "amount" | "price" | "timestamp" | "orderId" | "type" | "status", ExtArgs["result"]["tradeLog"]>
  export type TradeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TradeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TradeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TradeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      instrument: string
      amount: number
      price: number
      timestamp: Date
      orderId: string | null
      type: string
      status: string
    }, ExtArgs["result"]["tradeLog"]>
    composites: {}
  }

  type TradeLogGetPayload<S extends boolean | null | undefined | TradeLogDefaultArgs> = $Result.GetResult<Prisma.$TradeLogPayload, S>

  type TradeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeLogCountAggregateInputType | true
    }

  export interface TradeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeLog'], meta: { name: 'TradeLog' } }
    /**
     * Find zero or one TradeLog that matches the filter.
     * @param {TradeLogFindUniqueArgs} args - Arguments to find a TradeLog
     * @example
     * // Get one TradeLog
     * const tradeLog = await prisma.tradeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeLogFindUniqueArgs>(args: SelectSubset<T, TradeLogFindUniqueArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeLogFindUniqueOrThrowArgs} args - Arguments to find a TradeLog
     * @example
     * // Get one TradeLog
     * const tradeLog = await prisma.tradeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogFindFirstArgs} args - Arguments to find a TradeLog
     * @example
     * // Get one TradeLog
     * const tradeLog = await prisma.tradeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeLogFindFirstArgs>(args?: SelectSubset<T, TradeLogFindFirstArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogFindFirstOrThrowArgs} args - Arguments to find a TradeLog
     * @example
     * // Get one TradeLog
     * const tradeLog = await prisma.tradeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeLogs
     * const tradeLogs = await prisma.tradeLog.findMany()
     * 
     * // Get first 10 TradeLogs
     * const tradeLogs = await prisma.tradeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeLogWithIdOnly = await prisma.tradeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeLogFindManyArgs>(args?: SelectSubset<T, TradeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradeLog.
     * @param {TradeLogCreateArgs} args - Arguments to create a TradeLog.
     * @example
     * // Create one TradeLog
     * const TradeLog = await prisma.tradeLog.create({
     *   data: {
     *     // ... data to create a TradeLog
     *   }
     * })
     * 
     */
    create<T extends TradeLogCreateArgs>(args: SelectSubset<T, TradeLogCreateArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradeLogs.
     * @param {TradeLogCreateManyArgs} args - Arguments to create many TradeLogs.
     * @example
     * // Create many TradeLogs
     * const tradeLog = await prisma.tradeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeLogCreateManyArgs>(args?: SelectSubset<T, TradeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeLogs and returns the data saved in the database.
     * @param {TradeLogCreateManyAndReturnArgs} args - Arguments to create many TradeLogs.
     * @example
     * // Create many TradeLogs
     * const tradeLog = await prisma.tradeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeLogs and only return the `id`
     * const tradeLogWithIdOnly = await prisma.tradeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradeLog.
     * @param {TradeLogDeleteArgs} args - Arguments to delete one TradeLog.
     * @example
     * // Delete one TradeLog
     * const TradeLog = await prisma.tradeLog.delete({
     *   where: {
     *     // ... filter to delete one TradeLog
     *   }
     * })
     * 
     */
    delete<T extends TradeLogDeleteArgs>(args: SelectSubset<T, TradeLogDeleteArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradeLog.
     * @param {TradeLogUpdateArgs} args - Arguments to update one TradeLog.
     * @example
     * // Update one TradeLog
     * const tradeLog = await prisma.tradeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeLogUpdateArgs>(args: SelectSubset<T, TradeLogUpdateArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradeLogs.
     * @param {TradeLogDeleteManyArgs} args - Arguments to filter TradeLogs to delete.
     * @example
     * // Delete a few TradeLogs
     * const { count } = await prisma.tradeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeLogDeleteManyArgs>(args?: SelectSubset<T, TradeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeLogs
     * const tradeLog = await prisma.tradeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeLogUpdateManyArgs>(args: SelectSubset<T, TradeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeLogs and returns the data updated in the database.
     * @param {TradeLogUpdateManyAndReturnArgs} args - Arguments to update many TradeLogs.
     * @example
     * // Update many TradeLogs
     * const tradeLog = await prisma.tradeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradeLogs and only return the `id`
     * const tradeLogWithIdOnly = await prisma.tradeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TradeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradeLog.
     * @param {TradeLogUpsertArgs} args - Arguments to update or create a TradeLog.
     * @example
     * // Update or create a TradeLog
     * const tradeLog = await prisma.tradeLog.upsert({
     *   create: {
     *     // ... data to create a TradeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeLog we want to update
     *   }
     * })
     */
    upsert<T extends TradeLogUpsertArgs>(args: SelectSubset<T, TradeLogUpsertArgs<ExtArgs>>): Prisma__TradeLogClient<$Result.GetResult<Prisma.$TradeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogCountArgs} args - Arguments to filter TradeLogs to count.
     * @example
     * // Count the number of TradeLogs
     * const count = await prisma.tradeLog.count({
     *   where: {
     *     // ... the filter for the TradeLogs we want to count
     *   }
     * })
    **/
    count<T extends TradeLogCountArgs>(
      args?: Subset<T, TradeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeLogAggregateArgs>(args: Subset<T, TradeLogAggregateArgs>): Prisma.PrismaPromise<GetTradeLogAggregateType<T>>

    /**
     * Group by TradeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeLogGroupByArgs['orderBy'] }
        : { orderBy?: TradeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeLog model
   */
  readonly fields: TradeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeLog model
   */
  interface TradeLogFieldRefs {
    readonly id: FieldRef<"TradeLog", 'String'>
    readonly userId: FieldRef<"TradeLog", 'String'>
    readonly instrument: FieldRef<"TradeLog", 'String'>
    readonly amount: FieldRef<"TradeLog", 'Float'>
    readonly price: FieldRef<"TradeLog", 'Float'>
    readonly timestamp: FieldRef<"TradeLog", 'DateTime'>
    readonly orderId: FieldRef<"TradeLog", 'String'>
    readonly type: FieldRef<"TradeLog", 'String'>
    readonly status: FieldRef<"TradeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TradeLog findUnique
   */
  export type TradeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter, which TradeLog to fetch.
     */
    where: TradeLogWhereUniqueInput
  }

  /**
   * TradeLog findUniqueOrThrow
   */
  export type TradeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter, which TradeLog to fetch.
     */
    where: TradeLogWhereUniqueInput
  }

  /**
   * TradeLog findFirst
   */
  export type TradeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter, which TradeLog to fetch.
     */
    where?: TradeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLogs to fetch.
     */
    orderBy?: TradeLogOrderByWithRelationInput | TradeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeLogs.
     */
    cursor?: TradeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeLogs.
     */
    distinct?: TradeLogScalarFieldEnum | TradeLogScalarFieldEnum[]
  }

  /**
   * TradeLog findFirstOrThrow
   */
  export type TradeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter, which TradeLog to fetch.
     */
    where?: TradeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLogs to fetch.
     */
    orderBy?: TradeLogOrderByWithRelationInput | TradeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeLogs.
     */
    cursor?: TradeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeLogs.
     */
    distinct?: TradeLogScalarFieldEnum | TradeLogScalarFieldEnum[]
  }

  /**
   * TradeLog findMany
   */
  export type TradeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter, which TradeLogs to fetch.
     */
    where?: TradeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeLogs to fetch.
     */
    orderBy?: TradeLogOrderByWithRelationInput | TradeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeLogs.
     */
    cursor?: TradeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeLogs.
     */
    skip?: number
    distinct?: TradeLogScalarFieldEnum | TradeLogScalarFieldEnum[]
  }

  /**
   * TradeLog create
   */
  export type TradeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeLog.
     */
    data: XOR<TradeLogCreateInput, TradeLogUncheckedCreateInput>
  }

  /**
   * TradeLog createMany
   */
  export type TradeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeLogs.
     */
    data: TradeLogCreateManyInput | TradeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeLog createManyAndReturn
   */
  export type TradeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * The data used to create many TradeLogs.
     */
    data: TradeLogCreateManyInput | TradeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeLog update
   */
  export type TradeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeLog.
     */
    data: XOR<TradeLogUpdateInput, TradeLogUncheckedUpdateInput>
    /**
     * Choose, which TradeLog to update.
     */
    where: TradeLogWhereUniqueInput
  }

  /**
   * TradeLog updateMany
   */
  export type TradeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeLogs.
     */
    data: XOR<TradeLogUpdateManyMutationInput, TradeLogUncheckedUpdateManyInput>
    /**
     * Filter which TradeLogs to update
     */
    where?: TradeLogWhereInput
    /**
     * Limit how many TradeLogs to update.
     */
    limit?: number
  }

  /**
   * TradeLog updateManyAndReturn
   */
  export type TradeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * The data used to update TradeLogs.
     */
    data: XOR<TradeLogUpdateManyMutationInput, TradeLogUncheckedUpdateManyInput>
    /**
     * Filter which TradeLogs to update
     */
    where?: TradeLogWhereInput
    /**
     * Limit how many TradeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeLog upsert
   */
  export type TradeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeLog to update in case it exists.
     */
    where: TradeLogWhereUniqueInput
    /**
     * In case the TradeLog found by the `where` argument doesn't exist, create a new TradeLog with this data.
     */
    create: XOR<TradeLogCreateInput, TradeLogUncheckedCreateInput>
    /**
     * In case the TradeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeLogUpdateInput, TradeLogUncheckedUpdateInput>
  }

  /**
   * TradeLog delete
   */
  export type TradeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
    /**
     * Filter which TradeLog to delete.
     */
    where: TradeLogWhereUniqueInput
  }

  /**
   * TradeLog deleteMany
   */
  export type TradeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeLogs to delete
     */
    where?: TradeLogWhereInput
    /**
     * Limit how many TradeLogs to delete.
     */
    limit?: number
  }

  /**
   * TradeLog without action
   */
  export type TradeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeLog
     */
    select?: TradeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeLog
     */
    omit?: TradeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeLogInclude<ExtArgs> | null
  }


  /**
   * Model Bot
   */

  export type AggregateBot = {
    _count: BotCountAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  export type BotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    symbol: string | null
    strategy: string | null
    timeframe: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    symbol: string | null
    strategy: string | null
    timeframe: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    symbol: number
    strategy: number
    timeframe: number
    parameters: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    strategy?: true
    timeframe?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    strategy?: true
    timeframe?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    strategy?: true
    timeframe?: true
    parameters?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bot to aggregate.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bots
    **/
    _count?: true | BotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotMaxAggregateInputType
  }

  export type GetBotAggregateType<T extends BotAggregateArgs> = {
        [P in keyof T & keyof AggregateBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot[P]>
      : GetScalarType<T[P], AggregateBot[P]>
  }




  export type BotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
    orderBy?: BotOrderByWithAggregationInput | BotOrderByWithAggregationInput[]
    by: BotScalarFieldEnum[] | BotScalarFieldEnum
    having?: BotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotCountAggregateInputType | true
    _min?: BotMinAggregateInputType
    _max?: BotMaxAggregateInputType
  }

  export type BotGroupByOutputType = {
    id: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BotCountAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  type GetBotGroupByPayload<T extends BotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotGroupByOutputType[P]>
            : GetScalarType<T[P], BotGroupByOutputType[P]>
        }
      >
    >


  export type BotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    strategy?: boolean
    timeframe?: boolean
    parameters?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    positions?: boolean | Bot$positionsArgs<ExtArgs>
    riskSettings?: boolean | Bot$riskSettingsArgs<ExtArgs>
    orders?: boolean | Bot$ordersArgs<ExtArgs>
    decisionLogs?: boolean | Bot$decisionLogsArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    strategy?: boolean
    timeframe?: boolean
    parameters?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    strategy?: boolean
    timeframe?: boolean
    parameters?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    strategy?: boolean
    timeframe?: boolean
    parameters?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "symbol" | "strategy" | "timeframe" | "parameters" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["bot"]>
  export type BotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    positions?: boolean | Bot$positionsArgs<ExtArgs>
    riskSettings?: boolean | Bot$riskSettingsArgs<ExtArgs>
    orders?: boolean | Bot$ordersArgs<ExtArgs>
    decisionLogs?: boolean | Bot$decisionLogsArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      positions: Prisma.$PositionPayload<ExtArgs>[]
      riskSettings: Prisma.$RiskSettingsPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      decisionLogs: Prisma.$DecisionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      symbol: string
      strategy: string
      timeframe: string
      parameters: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bot"]>
    composites: {}
  }

  type BotGetPayload<S extends boolean | null | undefined | BotDefaultArgs> = $Result.GetResult<Prisma.$BotPayload, S>

  type BotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotCountAggregateInputType | true
    }

  export interface BotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bot'], meta: { name: 'Bot' } }
    /**
     * Find zero or one Bot that matches the filter.
     * @param {BotFindUniqueArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotFindUniqueArgs>(args: SelectSubset<T, BotFindUniqueArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotFindUniqueOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotFindUniqueOrThrowArgs>(args: SelectSubset<T, BotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotFindFirstArgs>(args?: SelectSubset<T, BotFindFirstArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotFindFirstOrThrowArgs>(args?: SelectSubset<T, BotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bot.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botWithIdOnly = await prisma.bot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotFindManyArgs>(args?: SelectSubset<T, BotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bot.
     * @param {BotCreateArgs} args - Arguments to create a Bot.
     * @example
     * // Create one Bot
     * const Bot = await prisma.bot.create({
     *   data: {
     *     // ... data to create a Bot
     *   }
     * })
     * 
     */
    create<T extends BotCreateArgs>(args: SelectSubset<T, BotCreateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bots.
     * @param {BotCreateManyArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotCreateManyArgs>(args?: SelectSubset<T, BotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bots and returns the data saved in the database.
     * @param {BotCreateManyAndReturnArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotCreateManyAndReturnArgs>(args?: SelectSubset<T, BotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bot.
     * @param {BotDeleteArgs} args - Arguments to delete one Bot.
     * @example
     * // Delete one Bot
     * const Bot = await prisma.bot.delete({
     *   where: {
     *     // ... filter to delete one Bot
     *   }
     * })
     * 
     */
    delete<T extends BotDeleteArgs>(args: SelectSubset<T, BotDeleteArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bot.
     * @param {BotUpdateArgs} args - Arguments to update one Bot.
     * @example
     * // Update one Bot
     * const bot = await prisma.bot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotUpdateArgs>(args: SelectSubset<T, BotUpdateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bots.
     * @param {BotDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotDeleteManyArgs>(args?: SelectSubset<T, BotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotUpdateManyArgs>(args: SelectSubset<T, BotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots and returns the data updated in the database.
     * @param {BotUpdateManyAndReturnArgs} args - Arguments to update many Bots.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotUpdateManyAndReturnArgs>(args: SelectSubset<T, BotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bot.
     * @param {BotUpsertArgs} args - Arguments to update or create a Bot.
     * @example
     * // Update or create a Bot
     * const bot = await prisma.bot.upsert({
     *   create: {
     *     // ... data to create a Bot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot we want to update
     *   }
     * })
     */
    upsert<T extends BotUpsertArgs>(args: SelectSubset<T, BotUpsertArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bot.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends BotCountArgs>(
      args?: Subset<T, BotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotAggregateArgs>(args: Subset<T, BotAggregateArgs>): Prisma.PrismaPromise<GetBotAggregateType<T>>

    /**
     * Group by Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotGroupByArgs['orderBy'] }
        : { orderBy?: BotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bot model
   */
  readonly fields: BotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    positions<T extends Bot$positionsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    riskSettings<T extends Bot$riskSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$riskSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Bot$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Bot$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decisionLogs<T extends Bot$decisionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$decisionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bot model
   */
  interface BotFieldRefs {
    readonly id: FieldRef<"Bot", 'String'>
    readonly userId: FieldRef<"Bot", 'String'>
    readonly name: FieldRef<"Bot", 'String'>
    readonly symbol: FieldRef<"Bot", 'String'>
    readonly strategy: FieldRef<"Bot", 'String'>
    readonly timeframe: FieldRef<"Bot", 'String'>
    readonly parameters: FieldRef<"Bot", 'Json'>
    readonly isActive: FieldRef<"Bot", 'Boolean'>
    readonly createdAt: FieldRef<"Bot", 'DateTime'>
    readonly updatedAt: FieldRef<"Bot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bot findUnique
   */
  export type BotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findUniqueOrThrow
   */
  export type BotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findFirst
   */
  export type BotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findFirstOrThrow
   */
  export type BotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findMany
   */
  export type BotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bots to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot create
   */
  export type BotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to create a Bot.
     */
    data: XOR<BotCreateInput, BotUncheckedCreateInput>
  }

  /**
   * Bot createMany
   */
  export type BotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bot createManyAndReturn
   */
  export type BotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot update
   */
  export type BotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to update a Bot.
     */
    data: XOR<BotUpdateInput, BotUncheckedUpdateInput>
    /**
     * Choose, which Bot to update.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot updateMany
   */
  export type BotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
  }

  /**
   * Bot updateManyAndReturn
   */
  export type BotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot upsert
   */
  export type BotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The filter to search for the Bot to update in case it exists.
     */
    where: BotWhereUniqueInput
    /**
     * In case the Bot found by the `where` argument doesn't exist, create a new Bot with this data.
     */
    create: XOR<BotCreateInput, BotUncheckedCreateInput>
    /**
     * In case the Bot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUpdateInput, BotUncheckedUpdateInput>
  }

  /**
   * Bot delete
   */
  export type BotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter which Bot to delete.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot deleteMany
   */
  export type BotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bots to delete
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to delete.
     */
    limit?: number
  }

  /**
   * Bot.positions
   */
  export type Bot$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Bot.riskSettings
   */
  export type Bot$riskSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    where?: RiskSettingsWhereInput
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    cursor?: RiskSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskSettingsScalarFieldEnum | RiskSettingsScalarFieldEnum[]
  }

  /**
   * Bot.orders
   */
  export type Bot$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Bot.decisionLogs
   */
  export type Bot$decisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * Bot without action
   */
  export type BotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    entryPrice: number | null
    currentPrice: number | null
    amount: number | null
    leverage: number | null
    takeProfitPrice: number | null
    stopLossPrice: number | null
    pnl: number | null
  }

  export type PositionSumAggregateOutputType = {
    entryPrice: number | null
    currentPrice: number | null
    amount: number | null
    leverage: number | null
    takeProfitPrice: number | null
    stopLossPrice: number | null
    pnl: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    symbol: string | null
    side: string | null
    entryPrice: number | null
    currentPrice: number | null
    amount: number | null
    leverage: number | null
    takeProfitPrice: number | null
    stopLossPrice: number | null
    status: string | null
    pnl: number | null
    openedAt: Date | null
    closedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    symbol: string | null
    side: string | null
    entryPrice: number | null
    currentPrice: number | null
    amount: number | null
    leverage: number | null
    takeProfitPrice: number | null
    stopLossPrice: number | null
    status: string | null
    pnl: number | null
    openedAt: Date | null
    closedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    userId: number
    botId: number
    symbol: number
    side: number
    entryPrice: number
    currentPrice: number
    amount: number
    leverage: number
    takeProfitPrice: number
    stopLossPrice: number
    status: number
    pnl: number
    openedAt: number
    closedAt: number
    metadata: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    entryPrice?: true
    currentPrice?: true
    amount?: true
    leverage?: true
    takeProfitPrice?: true
    stopLossPrice?: true
    pnl?: true
  }

  export type PositionSumAggregateInputType = {
    entryPrice?: true
    currentPrice?: true
    amount?: true
    leverage?: true
    takeProfitPrice?: true
    stopLossPrice?: true
    pnl?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    symbol?: true
    side?: true
    entryPrice?: true
    currentPrice?: true
    amount?: true
    leverage?: true
    takeProfitPrice?: true
    stopLossPrice?: true
    status?: true
    pnl?: true
    openedAt?: true
    closedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    symbol?: true
    side?: true
    entryPrice?: true
    currentPrice?: true
    amount?: true
    leverage?: true
    takeProfitPrice?: true
    stopLossPrice?: true
    status?: true
    pnl?: true
    openedAt?: true
    closedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    symbol?: true
    side?: true
    entryPrice?: true
    currentPrice?: true
    amount?: true
    leverage?: true
    takeProfitPrice?: true
    stopLossPrice?: true
    status?: true
    pnl?: true
    openedAt?: true
    closedAt?: true
    metadata?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    userId: string
    botId: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice: number | null
    amount: number
    leverage: number
    takeProfitPrice: number | null
    stopLossPrice: number | null
    status: string
    pnl: number | null
    openedAt: Date
    closedAt: Date | null
    metadata: JsonValue | null
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    symbol?: boolean
    side?: boolean
    entryPrice?: boolean
    currentPrice?: boolean
    amount?: boolean
    leverage?: boolean
    takeProfitPrice?: boolean
    stopLossPrice?: boolean
    status?: boolean
    pnl?: boolean
    openedAt?: boolean
    closedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
    orders?: boolean | Position$ordersArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    symbol?: boolean
    side?: boolean
    entryPrice?: boolean
    currentPrice?: boolean
    amount?: boolean
    leverage?: boolean
    takeProfitPrice?: boolean
    stopLossPrice?: boolean
    status?: boolean
    pnl?: boolean
    openedAt?: boolean
    closedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    symbol?: boolean
    side?: boolean
    entryPrice?: boolean
    currentPrice?: boolean
    amount?: boolean
    leverage?: boolean
    takeProfitPrice?: boolean
    stopLossPrice?: boolean
    status?: boolean
    pnl?: boolean
    openedAt?: boolean
    closedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    userId?: boolean
    botId?: boolean
    symbol?: boolean
    side?: boolean
    entryPrice?: boolean
    currentPrice?: boolean
    amount?: boolean
    leverage?: boolean
    takeProfitPrice?: boolean
    stopLossPrice?: boolean
    status?: boolean
    pnl?: boolean
    openedAt?: boolean
    closedAt?: boolean
    metadata?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "botId" | "symbol" | "side" | "entryPrice" | "currentPrice" | "amount" | "leverage" | "takeProfitPrice" | "stopLossPrice" | "status" | "pnl" | "openedAt" | "closedAt" | "metadata", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
    orders?: boolean | Position$ordersArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
  }
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | Position$botArgs<ExtArgs>
  }

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bot: Prisma.$BotPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      botId: string | null
      symbol: string
      side: string
      entryPrice: number
      currentPrice: number | null
      amount: number
      leverage: number
      takeProfitPrice: number | null
      stopLossPrice: number | null
      status: string
      pnl: number | null
      openedAt: Date
      closedAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bot<T extends Position$botArgs<ExtArgs> = {}>(args?: Subset<T, Position$botArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Position$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Position$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly userId: FieldRef<"Position", 'String'>
    readonly botId: FieldRef<"Position", 'String'>
    readonly symbol: FieldRef<"Position", 'String'>
    readonly side: FieldRef<"Position", 'String'>
    readonly entryPrice: FieldRef<"Position", 'Float'>
    readonly currentPrice: FieldRef<"Position", 'Float'>
    readonly amount: FieldRef<"Position", 'Float'>
    readonly leverage: FieldRef<"Position", 'Float'>
    readonly takeProfitPrice: FieldRef<"Position", 'Float'>
    readonly stopLossPrice: FieldRef<"Position", 'Float'>
    readonly status: FieldRef<"Position", 'String'>
    readonly pnl: FieldRef<"Position", 'Float'>
    readonly openedAt: FieldRef<"Position", 'DateTime'>
    readonly closedAt: FieldRef<"Position", 'DateTime'>
    readonly metadata: FieldRef<"Position", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.bot
   */
  export type Position$botArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
  }

  /**
   * Position.orders
   */
  export type Position$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model Metric
   */

  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    value: number | null
  }

  export type MetricSumAggregateOutputType = {
    value: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    recordedAt: Date | null
  }

  export type MetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    recordedAt: Date | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    name: number
    value: number
    recordedAt: number
    tags: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    value?: true
  }

  export type MetricSumAggregateInputType = {
    value?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    recordedAt?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    recordedAt?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    recordedAt?: true
    tags?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithAggregationInput | MetricOrderByWithAggregationInput[]
    by: MetricScalarFieldEnum[] | MetricScalarFieldEnum
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }

  export type MetricGroupByOutputType = {
    id: string
    name: string
    value: number
    recordedAt: Date
    tags: JsonValue | null
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    recordedAt?: boolean
    tags?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    recordedAt?: boolean
    tags?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    recordedAt?: boolean
    tags?: boolean
  }, ExtArgs["result"]["metric"]>

  export type MetricSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    recordedAt?: boolean
    tags?: boolean
  }

  export type MetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "recordedAt" | "tags", ExtArgs["result"]["metric"]>

  export type $MetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: number
      recordedAt: Date
      tags: Prisma.JsonValue | null
    }, ExtArgs["result"]["metric"]>
    composites: {}
  }

  type MetricGetPayload<S extends boolean | null | undefined | MetricDefaultArgs> = $Result.GetResult<Prisma.$MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricFindUniqueArgs>(args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricFindFirstArgs>(args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricFindManyArgs>(args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
     */
    create<T extends MetricCreateArgs>(args: SelectSubset<T, MetricCreateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metrics.
     * @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricCreateManyArgs>(args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metrics and returns the data saved in the database.
     * @param {MetricCreateManyAndReturnArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metrics and only return the `id`
     * const metricWithIdOnly = await prisma.metric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetricCreateManyAndReturnArgs>(args?: SelectSubset<T, MetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
     */
    delete<T extends MetricDeleteArgs>(args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricUpdateArgs>(args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricDeleteManyArgs>(args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricUpdateManyArgs>(args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics and returns the data updated in the database.
     * @param {MetricUpdateManyAndReturnArgs} args - Arguments to update many Metrics.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Metrics and only return the `id`
     * const metricWithIdOnly = await prisma.metric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetricUpdateManyAndReturnArgs>(args: SelectSubset<T, MetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
     */
    upsert<T extends MetricUpsertArgs>(args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metric model
   */
  readonly fields: MetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metric model
   */
  interface MetricFieldRefs {
    readonly id: FieldRef<"Metric", 'String'>
    readonly name: FieldRef<"Metric", 'String'>
    readonly value: FieldRef<"Metric", 'Float'>
    readonly recordedAt: FieldRef<"Metric", 'DateTime'>
    readonly tags: FieldRef<"Metric", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Metric findUnique
   */
  export type MetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findFirst
   */
  export type MetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }

  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric createManyAndReturn
   */
  export type MetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to update.
     */
    limit?: number
  }

  /**
   * Metric updateManyAndReturn
   */
  export type MetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to update.
     */
    limit?: number
  }

  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }

  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
    /**
     * Limit how many Metrics to delete.
     */
    limit?: number
  }

  /**
   * Metric without action
   */
  export type MetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metric
     */
    omit?: MetricOmit<ExtArgs> | null
  }


  /**
   * Model TradingSignal
   */

  export type AggregateTradingSignal = {
    _count: TradingSignalCountAggregateOutputType | null
    _avg: TradingSignalAvgAggregateOutputType | null
    _sum: TradingSignalSumAggregateOutputType | null
    _min: TradingSignalMinAggregateOutputType | null
    _max: TradingSignalMaxAggregateOutputType | null
  }

  export type TradingSignalAvgAggregateOutputType = {
    price: number | null
    targetPrice: number | null
    stopLoss: number | null
    confidenceScore: number | null
    expectedReturn: number | null
    expectedRisk: number | null
    riskRewardRatio: number | null
  }

  export type TradingSignalSumAggregateOutputType = {
    price: number | null
    targetPrice: number | null
    stopLoss: number | null
    confidenceScore: number | null
    expectedReturn: number | null
    expectedRisk: number | null
    riskRewardRatio: number | null
  }

  export type TradingSignalMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    type: string | null
    direction: string | null
    strength: string | null
    timeframe: string | null
    price: number | null
    targetPrice: number | null
    stopLoss: number | null
    confidenceScore: number | null
    expectedReturn: number | null
    expectedRisk: number | null
    riskRewardRatio: number | null
    generatedAt: Date | null
    expiresAt: Date | null
    source: string | null
    validatedAt: Date | null
    validationStatus: boolean | null
    validationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradingSignalMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    type: string | null
    direction: string | null
    strength: string | null
    timeframe: string | null
    price: number | null
    targetPrice: number | null
    stopLoss: number | null
    confidenceScore: number | null
    expectedReturn: number | null
    expectedRisk: number | null
    riskRewardRatio: number | null
    generatedAt: Date | null
    expiresAt: Date | null
    source: string | null
    validatedAt: Date | null
    validationStatus: boolean | null
    validationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradingSignalCountAggregateOutputType = {
    id: number
    symbol: number
    type: number
    direction: number
    strength: number
    timeframe: number
    price: number
    targetPrice: number
    stopLoss: number
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: number
    expiresAt: number
    source: number
    metadata: number
    predictionValues: number
    validatedAt: number
    validationStatus: number
    validationReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradingSignalAvgAggregateInputType = {
    price?: true
    targetPrice?: true
    stopLoss?: true
    confidenceScore?: true
    expectedReturn?: true
    expectedRisk?: true
    riskRewardRatio?: true
  }

  export type TradingSignalSumAggregateInputType = {
    price?: true
    targetPrice?: true
    stopLoss?: true
    confidenceScore?: true
    expectedReturn?: true
    expectedRisk?: true
    riskRewardRatio?: true
  }

  export type TradingSignalMinAggregateInputType = {
    id?: true
    symbol?: true
    type?: true
    direction?: true
    strength?: true
    timeframe?: true
    price?: true
    targetPrice?: true
    stopLoss?: true
    confidenceScore?: true
    expectedReturn?: true
    expectedRisk?: true
    riskRewardRatio?: true
    generatedAt?: true
    expiresAt?: true
    source?: true
    validatedAt?: true
    validationStatus?: true
    validationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradingSignalMaxAggregateInputType = {
    id?: true
    symbol?: true
    type?: true
    direction?: true
    strength?: true
    timeframe?: true
    price?: true
    targetPrice?: true
    stopLoss?: true
    confidenceScore?: true
    expectedReturn?: true
    expectedRisk?: true
    riskRewardRatio?: true
    generatedAt?: true
    expiresAt?: true
    source?: true
    validatedAt?: true
    validationStatus?: true
    validationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradingSignalCountAggregateInputType = {
    id?: true
    symbol?: true
    type?: true
    direction?: true
    strength?: true
    timeframe?: true
    price?: true
    targetPrice?: true
    stopLoss?: true
    confidenceScore?: true
    expectedReturn?: true
    expectedRisk?: true
    riskRewardRatio?: true
    generatedAt?: true
    expiresAt?: true
    source?: true
    metadata?: true
    predictionValues?: true
    validatedAt?: true
    validationStatus?: true
    validationReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradingSignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradingSignal to aggregate.
     */
    where?: TradingSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingSignals to fetch.
     */
    orderBy?: TradingSignalOrderByWithRelationInput | TradingSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradingSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradingSignals
    **/
    _count?: true | TradingSignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradingSignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradingSignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradingSignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradingSignalMaxAggregateInputType
  }

  export type GetTradingSignalAggregateType<T extends TradingSignalAggregateArgs> = {
        [P in keyof T & keyof AggregateTradingSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradingSignal[P]>
      : GetScalarType<T[P], AggregateTradingSignal[P]>
  }




  export type TradingSignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradingSignalWhereInput
    orderBy?: TradingSignalOrderByWithAggregationInput | TradingSignalOrderByWithAggregationInput[]
    by: TradingSignalScalarFieldEnum[] | TradingSignalScalarFieldEnum
    having?: TradingSignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradingSignalCountAggregateInputType | true
    _avg?: TradingSignalAvgAggregateInputType
    _sum?: TradingSignalSumAggregateInputType
    _min?: TradingSignalMinAggregateInputType
    _max?: TradingSignalMaxAggregateInputType
  }

  export type TradingSignalGroupByOutputType = {
    id: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice: number | null
    stopLoss: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date
    expiresAt: Date | null
    source: string
    metadata: JsonValue
    predictionValues: JsonValue
    validatedAt: Date | null
    validationStatus: boolean
    validationReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TradingSignalCountAggregateOutputType | null
    _avg: TradingSignalAvgAggregateOutputType | null
    _sum: TradingSignalSumAggregateOutputType | null
    _min: TradingSignalMinAggregateOutputType | null
    _max: TradingSignalMaxAggregateOutputType | null
  }

  type GetTradingSignalGroupByPayload<T extends TradingSignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradingSignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradingSignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradingSignalGroupByOutputType[P]>
            : GetScalarType<T[P], TradingSignalGroupByOutputType[P]>
        }
      >
    >


  export type TradingSignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    type?: boolean
    direction?: boolean
    strength?: boolean
    timeframe?: boolean
    price?: boolean
    targetPrice?: boolean
    stopLoss?: boolean
    confidenceScore?: boolean
    expectedReturn?: boolean
    expectedRisk?: boolean
    riskRewardRatio?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    source?: boolean
    metadata?: boolean
    predictionValues?: boolean
    validatedAt?: boolean
    validationStatus?: boolean
    validationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | TradingSignal$ordersArgs<ExtArgs>
    _count?: boolean | TradingSignalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradingSignal"]>

  export type TradingSignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    type?: boolean
    direction?: boolean
    strength?: boolean
    timeframe?: boolean
    price?: boolean
    targetPrice?: boolean
    stopLoss?: boolean
    confidenceScore?: boolean
    expectedReturn?: boolean
    expectedRisk?: boolean
    riskRewardRatio?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    source?: boolean
    metadata?: boolean
    predictionValues?: boolean
    validatedAt?: boolean
    validationStatus?: boolean
    validationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradingSignal"]>

  export type TradingSignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    type?: boolean
    direction?: boolean
    strength?: boolean
    timeframe?: boolean
    price?: boolean
    targetPrice?: boolean
    stopLoss?: boolean
    confidenceScore?: boolean
    expectedReturn?: boolean
    expectedRisk?: boolean
    riskRewardRatio?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    source?: boolean
    metadata?: boolean
    predictionValues?: boolean
    validatedAt?: boolean
    validationStatus?: boolean
    validationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradingSignal"]>

  export type TradingSignalSelectScalar = {
    id?: boolean
    symbol?: boolean
    type?: boolean
    direction?: boolean
    strength?: boolean
    timeframe?: boolean
    price?: boolean
    targetPrice?: boolean
    stopLoss?: boolean
    confidenceScore?: boolean
    expectedReturn?: boolean
    expectedRisk?: boolean
    riskRewardRatio?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    source?: boolean
    metadata?: boolean
    predictionValues?: boolean
    validatedAt?: boolean
    validationStatus?: boolean
    validationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradingSignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "type" | "direction" | "strength" | "timeframe" | "price" | "targetPrice" | "stopLoss" | "confidenceScore" | "expectedReturn" | "expectedRisk" | "riskRewardRatio" | "generatedAt" | "expiresAt" | "source" | "metadata" | "predictionValues" | "validatedAt" | "validationStatus" | "validationReason" | "createdAt" | "updatedAt", ExtArgs["result"]["tradingSignal"]>
  export type TradingSignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TradingSignal$ordersArgs<ExtArgs>
    _count?: boolean | TradingSignalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TradingSignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TradingSignalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TradingSignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradingSignal"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      type: string
      direction: string
      strength: string
      timeframe: string
      price: number
      targetPrice: number | null
      stopLoss: number | null
      confidenceScore: number
      expectedReturn: number
      expectedRisk: number
      riskRewardRatio: number
      generatedAt: Date
      expiresAt: Date | null
      source: string
      metadata: Prisma.JsonValue
      predictionValues: Prisma.JsonValue
      validatedAt: Date | null
      validationStatus: boolean
      validationReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tradingSignal"]>
    composites: {}
  }

  type TradingSignalGetPayload<S extends boolean | null | undefined | TradingSignalDefaultArgs> = $Result.GetResult<Prisma.$TradingSignalPayload, S>

  type TradingSignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradingSignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradingSignalCountAggregateInputType | true
    }

  export interface TradingSignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradingSignal'], meta: { name: 'TradingSignal' } }
    /**
     * Find zero or one TradingSignal that matches the filter.
     * @param {TradingSignalFindUniqueArgs} args - Arguments to find a TradingSignal
     * @example
     * // Get one TradingSignal
     * const tradingSignal = await prisma.tradingSignal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradingSignalFindUniqueArgs>(args: SelectSubset<T, TradingSignalFindUniqueArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradingSignal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradingSignalFindUniqueOrThrowArgs} args - Arguments to find a TradingSignal
     * @example
     * // Get one TradingSignal
     * const tradingSignal = await prisma.tradingSignal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradingSignalFindUniqueOrThrowArgs>(args: SelectSubset<T, TradingSignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradingSignal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalFindFirstArgs} args - Arguments to find a TradingSignal
     * @example
     * // Get one TradingSignal
     * const tradingSignal = await prisma.tradingSignal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradingSignalFindFirstArgs>(args?: SelectSubset<T, TradingSignalFindFirstArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradingSignal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalFindFirstOrThrowArgs} args - Arguments to find a TradingSignal
     * @example
     * // Get one TradingSignal
     * const tradingSignal = await prisma.tradingSignal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradingSignalFindFirstOrThrowArgs>(args?: SelectSubset<T, TradingSignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradingSignals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradingSignals
     * const tradingSignals = await prisma.tradingSignal.findMany()
     * 
     * // Get first 10 TradingSignals
     * const tradingSignals = await prisma.tradingSignal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradingSignalWithIdOnly = await prisma.tradingSignal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradingSignalFindManyArgs>(args?: SelectSubset<T, TradingSignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradingSignal.
     * @param {TradingSignalCreateArgs} args - Arguments to create a TradingSignal.
     * @example
     * // Create one TradingSignal
     * const TradingSignal = await prisma.tradingSignal.create({
     *   data: {
     *     // ... data to create a TradingSignal
     *   }
     * })
     * 
     */
    create<T extends TradingSignalCreateArgs>(args: SelectSubset<T, TradingSignalCreateArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradingSignals.
     * @param {TradingSignalCreateManyArgs} args - Arguments to create many TradingSignals.
     * @example
     * // Create many TradingSignals
     * const tradingSignal = await prisma.tradingSignal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradingSignalCreateManyArgs>(args?: SelectSubset<T, TradingSignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradingSignals and returns the data saved in the database.
     * @param {TradingSignalCreateManyAndReturnArgs} args - Arguments to create many TradingSignals.
     * @example
     * // Create many TradingSignals
     * const tradingSignal = await prisma.tradingSignal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradingSignals and only return the `id`
     * const tradingSignalWithIdOnly = await prisma.tradingSignal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradingSignalCreateManyAndReturnArgs>(args?: SelectSubset<T, TradingSignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradingSignal.
     * @param {TradingSignalDeleteArgs} args - Arguments to delete one TradingSignal.
     * @example
     * // Delete one TradingSignal
     * const TradingSignal = await prisma.tradingSignal.delete({
     *   where: {
     *     // ... filter to delete one TradingSignal
     *   }
     * })
     * 
     */
    delete<T extends TradingSignalDeleteArgs>(args: SelectSubset<T, TradingSignalDeleteArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradingSignal.
     * @param {TradingSignalUpdateArgs} args - Arguments to update one TradingSignal.
     * @example
     * // Update one TradingSignal
     * const tradingSignal = await prisma.tradingSignal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradingSignalUpdateArgs>(args: SelectSubset<T, TradingSignalUpdateArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradingSignals.
     * @param {TradingSignalDeleteManyArgs} args - Arguments to filter TradingSignals to delete.
     * @example
     * // Delete a few TradingSignals
     * const { count } = await prisma.tradingSignal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradingSignalDeleteManyArgs>(args?: SelectSubset<T, TradingSignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradingSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradingSignals
     * const tradingSignal = await prisma.tradingSignal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradingSignalUpdateManyArgs>(args: SelectSubset<T, TradingSignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradingSignals and returns the data updated in the database.
     * @param {TradingSignalUpdateManyAndReturnArgs} args - Arguments to update many TradingSignals.
     * @example
     * // Update many TradingSignals
     * const tradingSignal = await prisma.tradingSignal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradingSignals and only return the `id`
     * const tradingSignalWithIdOnly = await prisma.tradingSignal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradingSignalUpdateManyAndReturnArgs>(args: SelectSubset<T, TradingSignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradingSignal.
     * @param {TradingSignalUpsertArgs} args - Arguments to update or create a TradingSignal.
     * @example
     * // Update or create a TradingSignal
     * const tradingSignal = await prisma.tradingSignal.upsert({
     *   create: {
     *     // ... data to create a TradingSignal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradingSignal we want to update
     *   }
     * })
     */
    upsert<T extends TradingSignalUpsertArgs>(args: SelectSubset<T, TradingSignalUpsertArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradingSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalCountArgs} args - Arguments to filter TradingSignals to count.
     * @example
     * // Count the number of TradingSignals
     * const count = await prisma.tradingSignal.count({
     *   where: {
     *     // ... the filter for the TradingSignals we want to count
     *   }
     * })
    **/
    count<T extends TradingSignalCountArgs>(
      args?: Subset<T, TradingSignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradingSignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradingSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradingSignalAggregateArgs>(args: Subset<T, TradingSignalAggregateArgs>): Prisma.PrismaPromise<GetTradingSignalAggregateType<T>>

    /**
     * Group by TradingSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingSignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradingSignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradingSignalGroupByArgs['orderBy'] }
        : { orderBy?: TradingSignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradingSignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradingSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradingSignal model
   */
  readonly fields: TradingSignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradingSignal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradingSignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends TradingSignal$ordersArgs<ExtArgs> = {}>(args?: Subset<T, TradingSignal$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradingSignal model
   */
  interface TradingSignalFieldRefs {
    readonly id: FieldRef<"TradingSignal", 'String'>
    readonly symbol: FieldRef<"TradingSignal", 'String'>
    readonly type: FieldRef<"TradingSignal", 'String'>
    readonly direction: FieldRef<"TradingSignal", 'String'>
    readonly strength: FieldRef<"TradingSignal", 'String'>
    readonly timeframe: FieldRef<"TradingSignal", 'String'>
    readonly price: FieldRef<"TradingSignal", 'Float'>
    readonly targetPrice: FieldRef<"TradingSignal", 'Float'>
    readonly stopLoss: FieldRef<"TradingSignal", 'Float'>
    readonly confidenceScore: FieldRef<"TradingSignal", 'Int'>
    readonly expectedReturn: FieldRef<"TradingSignal", 'Float'>
    readonly expectedRisk: FieldRef<"TradingSignal", 'Float'>
    readonly riskRewardRatio: FieldRef<"TradingSignal", 'Float'>
    readonly generatedAt: FieldRef<"TradingSignal", 'DateTime'>
    readonly expiresAt: FieldRef<"TradingSignal", 'DateTime'>
    readonly source: FieldRef<"TradingSignal", 'String'>
    readonly metadata: FieldRef<"TradingSignal", 'Json'>
    readonly predictionValues: FieldRef<"TradingSignal", 'Json'>
    readonly validatedAt: FieldRef<"TradingSignal", 'DateTime'>
    readonly validationStatus: FieldRef<"TradingSignal", 'Boolean'>
    readonly validationReason: FieldRef<"TradingSignal", 'String'>
    readonly createdAt: FieldRef<"TradingSignal", 'DateTime'>
    readonly updatedAt: FieldRef<"TradingSignal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradingSignal findUnique
   */
  export type TradingSignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter, which TradingSignal to fetch.
     */
    where: TradingSignalWhereUniqueInput
  }

  /**
   * TradingSignal findUniqueOrThrow
   */
  export type TradingSignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter, which TradingSignal to fetch.
     */
    where: TradingSignalWhereUniqueInput
  }

  /**
   * TradingSignal findFirst
   */
  export type TradingSignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter, which TradingSignal to fetch.
     */
    where?: TradingSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingSignals to fetch.
     */
    orderBy?: TradingSignalOrderByWithRelationInput | TradingSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradingSignals.
     */
    cursor?: TradingSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradingSignals.
     */
    distinct?: TradingSignalScalarFieldEnum | TradingSignalScalarFieldEnum[]
  }

  /**
   * TradingSignal findFirstOrThrow
   */
  export type TradingSignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter, which TradingSignal to fetch.
     */
    where?: TradingSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingSignals to fetch.
     */
    orderBy?: TradingSignalOrderByWithRelationInput | TradingSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradingSignals.
     */
    cursor?: TradingSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradingSignals.
     */
    distinct?: TradingSignalScalarFieldEnum | TradingSignalScalarFieldEnum[]
  }

  /**
   * TradingSignal findMany
   */
  export type TradingSignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter, which TradingSignals to fetch.
     */
    where?: TradingSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingSignals to fetch.
     */
    orderBy?: TradingSignalOrderByWithRelationInput | TradingSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradingSignals.
     */
    cursor?: TradingSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingSignals.
     */
    skip?: number
    distinct?: TradingSignalScalarFieldEnum | TradingSignalScalarFieldEnum[]
  }

  /**
   * TradingSignal create
   */
  export type TradingSignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * The data needed to create a TradingSignal.
     */
    data: XOR<TradingSignalCreateInput, TradingSignalUncheckedCreateInput>
  }

  /**
   * TradingSignal createMany
   */
  export type TradingSignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradingSignals.
     */
    data: TradingSignalCreateManyInput | TradingSignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradingSignal createManyAndReturn
   */
  export type TradingSignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * The data used to create many TradingSignals.
     */
    data: TradingSignalCreateManyInput | TradingSignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradingSignal update
   */
  export type TradingSignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * The data needed to update a TradingSignal.
     */
    data: XOR<TradingSignalUpdateInput, TradingSignalUncheckedUpdateInput>
    /**
     * Choose, which TradingSignal to update.
     */
    where: TradingSignalWhereUniqueInput
  }

  /**
   * TradingSignal updateMany
   */
  export type TradingSignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradingSignals.
     */
    data: XOR<TradingSignalUpdateManyMutationInput, TradingSignalUncheckedUpdateManyInput>
    /**
     * Filter which TradingSignals to update
     */
    where?: TradingSignalWhereInput
    /**
     * Limit how many TradingSignals to update.
     */
    limit?: number
  }

  /**
   * TradingSignal updateManyAndReturn
   */
  export type TradingSignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * The data used to update TradingSignals.
     */
    data: XOR<TradingSignalUpdateManyMutationInput, TradingSignalUncheckedUpdateManyInput>
    /**
     * Filter which TradingSignals to update
     */
    where?: TradingSignalWhereInput
    /**
     * Limit how many TradingSignals to update.
     */
    limit?: number
  }

  /**
   * TradingSignal upsert
   */
  export type TradingSignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * The filter to search for the TradingSignal to update in case it exists.
     */
    where: TradingSignalWhereUniqueInput
    /**
     * In case the TradingSignal found by the `where` argument doesn't exist, create a new TradingSignal with this data.
     */
    create: XOR<TradingSignalCreateInput, TradingSignalUncheckedCreateInput>
    /**
     * In case the TradingSignal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradingSignalUpdateInput, TradingSignalUncheckedUpdateInput>
  }

  /**
   * TradingSignal delete
   */
  export type TradingSignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    /**
     * Filter which TradingSignal to delete.
     */
    where: TradingSignalWhereUniqueInput
  }

  /**
   * TradingSignal deleteMany
   */
  export type TradingSignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradingSignals to delete
     */
    where?: TradingSignalWhereInput
    /**
     * Limit how many TradingSignals to delete.
     */
    limit?: number
  }

  /**
   * TradingSignal.orders
   */
  export type TradingSignal$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * TradingSignal without action
   */
  export type TradingSignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
  }


  /**
   * Model RiskSettings
   */

  export type AggregateRiskSettings = {
    _count: RiskSettingsCountAggregateOutputType | null
    _avg: RiskSettingsAvgAggregateOutputType | null
    _sum: RiskSettingsSumAggregateOutputType | null
    _min: RiskSettingsMinAggregateOutputType | null
    _max: RiskSettingsMaxAggregateOutputType | null
  }

  export type RiskSettingsAvgAggregateOutputType = {
    riskPercentage: number | null
    maxPositionSize: number | null
    kellyFraction: number | null
    winRate: number | null
    stopLossValue: number | null
    trailingCallback: number | null
    trailingStep: number | null
    timeLimit: number | null
    takeProfitValue: number | null
    trailingActivation: number | null
    maxRiskPerTrade: number | null
    maxRiskPerSymbol: number | null
    maxRiskPerDirection: number | null
    maxTotalRisk: number | null
    maxDrawdown: number | null
    maxPositions: number | null
    maxDailyLoss: number | null
    cooldownPeriod: number | null
    volatilityLookback: number | null
    maxDailyLossBreaker: number | null
    maxDrawdownBreaker: number | null
    volatilityMultiplier: number | null
    consecutiveLossesBreaker: number | null
    tradingPause: number | null
  }

  export type RiskSettingsSumAggregateOutputType = {
    riskPercentage: number | null
    maxPositionSize: number | null
    kellyFraction: number | null
    winRate: number | null
    stopLossValue: number | null
    trailingCallback: number | null
    trailingStep: number | null
    timeLimit: number | null
    takeProfitValue: number | null
    trailingActivation: number | null
    maxRiskPerTrade: number | null
    maxRiskPerSymbol: number | null
    maxRiskPerDirection: number | null
    maxTotalRisk: number | null
    maxDrawdown: number | null
    maxPositions: number | null
    maxDailyLoss: number | null
    cooldownPeriod: number | null
    volatilityLookback: number | null
    maxDailyLossBreaker: number | null
    maxDrawdownBreaker: number | null
    volatilityMultiplier: number | null
    consecutiveLossesBreaker: number | null
    tradingPause: number | null
  }

  export type RiskSettingsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    botId: string | null
    isActive: boolean | null
    positionSizingMethod: string | null
    riskPercentage: number | null
    maxPositionSize: number | null
    kellyFraction: number | null
    winRate: number | null
    stopLossType: string | null
    stopLossValue: number | null
    trailingCallback: number | null
    trailingStep: number | null
    timeLimit: number | null
    takeProfitType: string | null
    takeProfitValue: number | null
    trailingActivation: number | null
    maxRiskPerTrade: number | null
    maxRiskPerSymbol: number | null
    maxRiskPerDirection: number | null
    maxTotalRisk: number | null
    maxDrawdown: number | null
    maxPositions: number | null
    maxDailyLoss: number | null
    cooldownPeriod: number | null
    volatilityLookback: number | null
    circuitBreakerEnabled: boolean | null
    maxDailyLossBreaker: number | null
    maxDrawdownBreaker: number | null
    volatilityMultiplier: number | null
    consecutiveLossesBreaker: number | null
    tradingPause: number | null
    marketWideEnabled: boolean | null
    enableManualOverride: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskSettingsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    botId: string | null
    isActive: boolean | null
    positionSizingMethod: string | null
    riskPercentage: number | null
    maxPositionSize: number | null
    kellyFraction: number | null
    winRate: number | null
    stopLossType: string | null
    stopLossValue: number | null
    trailingCallback: number | null
    trailingStep: number | null
    timeLimit: number | null
    takeProfitType: string | null
    takeProfitValue: number | null
    trailingActivation: number | null
    maxRiskPerTrade: number | null
    maxRiskPerSymbol: number | null
    maxRiskPerDirection: number | null
    maxTotalRisk: number | null
    maxDrawdown: number | null
    maxPositions: number | null
    maxDailyLoss: number | null
    cooldownPeriod: number | null
    volatilityLookback: number | null
    circuitBreakerEnabled: boolean | null
    maxDailyLossBreaker: number | null
    maxDrawdownBreaker: number | null
    volatilityMultiplier: number | null
    consecutiveLossesBreaker: number | null
    tradingPause: number | null
    marketWideEnabled: boolean | null
    enableManualOverride: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskSettingsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    botId: number
    isActive: number
    positionSizingMethod: number
    riskPercentage: number
    maxPositionSize: number
    kellyFraction: number
    winRate: number
    customSizingParams: number
    stopLossType: number
    stopLossValue: number
    trailingCallback: number
    trailingStep: number
    timeLimit: number
    stopLossLevels: number
    takeProfitType: number
    takeProfitValue: number
    trailingActivation: number
    takeProfitLevels: number
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled: number
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled: number
    enableManualOverride: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskSettingsAvgAggregateInputType = {
    riskPercentage?: true
    maxPositionSize?: true
    kellyFraction?: true
    winRate?: true
    stopLossValue?: true
    trailingCallback?: true
    trailingStep?: true
    timeLimit?: true
    takeProfitValue?: true
    trailingActivation?: true
    maxRiskPerTrade?: true
    maxRiskPerSymbol?: true
    maxRiskPerDirection?: true
    maxTotalRisk?: true
    maxDrawdown?: true
    maxPositions?: true
    maxDailyLoss?: true
    cooldownPeriod?: true
    volatilityLookback?: true
    maxDailyLossBreaker?: true
    maxDrawdownBreaker?: true
    volatilityMultiplier?: true
    consecutiveLossesBreaker?: true
    tradingPause?: true
  }

  export type RiskSettingsSumAggregateInputType = {
    riskPercentage?: true
    maxPositionSize?: true
    kellyFraction?: true
    winRate?: true
    stopLossValue?: true
    trailingCallback?: true
    trailingStep?: true
    timeLimit?: true
    takeProfitValue?: true
    trailingActivation?: true
    maxRiskPerTrade?: true
    maxRiskPerSymbol?: true
    maxRiskPerDirection?: true
    maxTotalRisk?: true
    maxDrawdown?: true
    maxPositions?: true
    maxDailyLoss?: true
    cooldownPeriod?: true
    volatilityLookback?: true
    maxDailyLossBreaker?: true
    maxDrawdownBreaker?: true
    volatilityMultiplier?: true
    consecutiveLossesBreaker?: true
    tradingPause?: true
  }

  export type RiskSettingsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    isActive?: true
    positionSizingMethod?: true
    riskPercentage?: true
    maxPositionSize?: true
    kellyFraction?: true
    winRate?: true
    stopLossType?: true
    stopLossValue?: true
    trailingCallback?: true
    trailingStep?: true
    timeLimit?: true
    takeProfitType?: true
    takeProfitValue?: true
    trailingActivation?: true
    maxRiskPerTrade?: true
    maxRiskPerSymbol?: true
    maxRiskPerDirection?: true
    maxTotalRisk?: true
    maxDrawdown?: true
    maxPositions?: true
    maxDailyLoss?: true
    cooldownPeriod?: true
    volatilityLookback?: true
    circuitBreakerEnabled?: true
    maxDailyLossBreaker?: true
    maxDrawdownBreaker?: true
    volatilityMultiplier?: true
    consecutiveLossesBreaker?: true
    tradingPause?: true
    marketWideEnabled?: true
    enableManualOverride?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskSettingsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    isActive?: true
    positionSizingMethod?: true
    riskPercentage?: true
    maxPositionSize?: true
    kellyFraction?: true
    winRate?: true
    stopLossType?: true
    stopLossValue?: true
    trailingCallback?: true
    trailingStep?: true
    timeLimit?: true
    takeProfitType?: true
    takeProfitValue?: true
    trailingActivation?: true
    maxRiskPerTrade?: true
    maxRiskPerSymbol?: true
    maxRiskPerDirection?: true
    maxTotalRisk?: true
    maxDrawdown?: true
    maxPositions?: true
    maxDailyLoss?: true
    cooldownPeriod?: true
    volatilityLookback?: true
    circuitBreakerEnabled?: true
    maxDailyLossBreaker?: true
    maxDrawdownBreaker?: true
    volatilityMultiplier?: true
    consecutiveLossesBreaker?: true
    tradingPause?: true
    marketWideEnabled?: true
    enableManualOverride?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskSettingsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    isActive?: true
    positionSizingMethod?: true
    riskPercentage?: true
    maxPositionSize?: true
    kellyFraction?: true
    winRate?: true
    customSizingParams?: true
    stopLossType?: true
    stopLossValue?: true
    trailingCallback?: true
    trailingStep?: true
    timeLimit?: true
    stopLossLevels?: true
    takeProfitType?: true
    takeProfitValue?: true
    trailingActivation?: true
    takeProfitLevels?: true
    maxRiskPerTrade?: true
    maxRiskPerSymbol?: true
    maxRiskPerDirection?: true
    maxTotalRisk?: true
    maxDrawdown?: true
    maxPositions?: true
    maxDailyLoss?: true
    cooldownPeriod?: true
    volatilityLookback?: true
    circuitBreakerEnabled?: true
    maxDailyLossBreaker?: true
    maxDrawdownBreaker?: true
    volatilityMultiplier?: true
    consecutiveLossesBreaker?: true
    tradingPause?: true
    marketWideEnabled?: true
    enableManualOverride?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskSettings to aggregate.
     */
    where?: RiskSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskSettings to fetch.
     */
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskSettings
    **/
    _count?: true | RiskSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskSettingsMaxAggregateInputType
  }

  export type GetRiskSettingsAggregateType<T extends RiskSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskSettings[P]>
      : GetScalarType<T[P], AggregateRiskSettings[P]>
  }




  export type RiskSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskSettingsWhereInput
    orderBy?: RiskSettingsOrderByWithAggregationInput | RiskSettingsOrderByWithAggregationInput[]
    by: RiskSettingsScalarFieldEnum[] | RiskSettingsScalarFieldEnum
    having?: RiskSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskSettingsCountAggregateInputType | true
    _avg?: RiskSettingsAvgAggregateInputType
    _sum?: RiskSettingsSumAggregateInputType
    _min?: RiskSettingsMinAggregateInputType
    _max?: RiskSettingsMaxAggregateInputType
  }

  export type RiskSettingsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    userId: string
    botId: string | null
    isActive: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction: number | null
    winRate: number | null
    customSizingParams: JsonValue | null
    stopLossType: string
    stopLossValue: number
    trailingCallback: number | null
    trailingStep: number | null
    timeLimit: number | null
    stopLossLevels: JsonValue | null
    takeProfitType: string
    takeProfitValue: number
    trailingActivation: number | null
    takeProfitLevels: JsonValue | null
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled: boolean
    enableManualOverride: boolean
    createdAt: Date
    updatedAt: Date
    _count: RiskSettingsCountAggregateOutputType | null
    _avg: RiskSettingsAvgAggregateOutputType | null
    _sum: RiskSettingsSumAggregateOutputType | null
    _min: RiskSettingsMinAggregateOutputType | null
    _max: RiskSettingsMaxAggregateOutputType | null
  }

  type GetRiskSettingsGroupByPayload<T extends RiskSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], RiskSettingsGroupByOutputType[P]>
        }
      >
    >


  export type RiskSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    isActive?: boolean
    positionSizingMethod?: boolean
    riskPercentage?: boolean
    maxPositionSize?: boolean
    kellyFraction?: boolean
    winRate?: boolean
    customSizingParams?: boolean
    stopLossType?: boolean
    stopLossValue?: boolean
    trailingCallback?: boolean
    trailingStep?: boolean
    timeLimit?: boolean
    stopLossLevels?: boolean
    takeProfitType?: boolean
    takeProfitValue?: boolean
    trailingActivation?: boolean
    takeProfitLevels?: boolean
    maxRiskPerTrade?: boolean
    maxRiskPerSymbol?: boolean
    maxRiskPerDirection?: boolean
    maxTotalRisk?: boolean
    maxDrawdown?: boolean
    maxPositions?: boolean
    maxDailyLoss?: boolean
    cooldownPeriod?: boolean
    volatilityLookback?: boolean
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker?: boolean
    maxDrawdownBreaker?: boolean
    volatilityMultiplier?: boolean
    consecutiveLossesBreaker?: boolean
    tradingPause?: boolean
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }, ExtArgs["result"]["riskSettings"]>

  export type RiskSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    isActive?: boolean
    positionSizingMethod?: boolean
    riskPercentage?: boolean
    maxPositionSize?: boolean
    kellyFraction?: boolean
    winRate?: boolean
    customSizingParams?: boolean
    stopLossType?: boolean
    stopLossValue?: boolean
    trailingCallback?: boolean
    trailingStep?: boolean
    timeLimit?: boolean
    stopLossLevels?: boolean
    takeProfitType?: boolean
    takeProfitValue?: boolean
    trailingActivation?: boolean
    takeProfitLevels?: boolean
    maxRiskPerTrade?: boolean
    maxRiskPerSymbol?: boolean
    maxRiskPerDirection?: boolean
    maxTotalRisk?: boolean
    maxDrawdown?: boolean
    maxPositions?: boolean
    maxDailyLoss?: boolean
    cooldownPeriod?: boolean
    volatilityLookback?: boolean
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker?: boolean
    maxDrawdownBreaker?: boolean
    volatilityMultiplier?: boolean
    consecutiveLossesBreaker?: boolean
    tradingPause?: boolean
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }, ExtArgs["result"]["riskSettings"]>

  export type RiskSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    isActive?: boolean
    positionSizingMethod?: boolean
    riskPercentage?: boolean
    maxPositionSize?: boolean
    kellyFraction?: boolean
    winRate?: boolean
    customSizingParams?: boolean
    stopLossType?: boolean
    stopLossValue?: boolean
    trailingCallback?: boolean
    trailingStep?: boolean
    timeLimit?: boolean
    stopLossLevels?: boolean
    takeProfitType?: boolean
    takeProfitValue?: boolean
    trailingActivation?: boolean
    takeProfitLevels?: boolean
    maxRiskPerTrade?: boolean
    maxRiskPerSymbol?: boolean
    maxRiskPerDirection?: boolean
    maxTotalRisk?: boolean
    maxDrawdown?: boolean
    maxPositions?: boolean
    maxDailyLoss?: boolean
    cooldownPeriod?: boolean
    volatilityLookback?: boolean
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker?: boolean
    maxDrawdownBreaker?: boolean
    volatilityMultiplier?: boolean
    consecutiveLossesBreaker?: boolean
    tradingPause?: boolean
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }, ExtArgs["result"]["riskSettings"]>

  export type RiskSettingsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    isActive?: boolean
    positionSizingMethod?: boolean
    riskPercentage?: boolean
    maxPositionSize?: boolean
    kellyFraction?: boolean
    winRate?: boolean
    customSizingParams?: boolean
    stopLossType?: boolean
    stopLossValue?: boolean
    trailingCallback?: boolean
    trailingStep?: boolean
    timeLimit?: boolean
    stopLossLevels?: boolean
    takeProfitType?: boolean
    takeProfitValue?: boolean
    trailingActivation?: boolean
    takeProfitLevels?: boolean
    maxRiskPerTrade?: boolean
    maxRiskPerSymbol?: boolean
    maxRiskPerDirection?: boolean
    maxTotalRisk?: boolean
    maxDrawdown?: boolean
    maxPositions?: boolean
    maxDailyLoss?: boolean
    cooldownPeriod?: boolean
    volatilityLookback?: boolean
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker?: boolean
    maxDrawdownBreaker?: boolean
    volatilityMultiplier?: boolean
    consecutiveLossesBreaker?: boolean
    tradingPause?: boolean
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RiskSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "botId" | "isActive" | "positionSizingMethod" | "riskPercentage" | "maxPositionSize" | "kellyFraction" | "winRate" | "customSizingParams" | "stopLossType" | "stopLossValue" | "trailingCallback" | "trailingStep" | "timeLimit" | "stopLossLevels" | "takeProfitType" | "takeProfitValue" | "trailingActivation" | "takeProfitLevels" | "maxRiskPerTrade" | "maxRiskPerSymbol" | "maxRiskPerDirection" | "maxTotalRisk" | "maxDrawdown" | "maxPositions" | "maxDailyLoss" | "cooldownPeriod" | "volatilityLookback" | "circuitBreakerEnabled" | "maxDailyLossBreaker" | "maxDrawdownBreaker" | "volatilityMultiplier" | "consecutiveLossesBreaker" | "tradingPause" | "marketWideEnabled" | "enableManualOverride" | "createdAt" | "updatedAt", ExtArgs["result"]["riskSettings"]>
  export type RiskSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }
  export type RiskSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }
  export type RiskSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bot?: boolean | RiskSettings$botArgs<ExtArgs>
  }

  export type $RiskSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bot: Prisma.$BotPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      userId: string
      botId: string | null
      isActive: boolean
      positionSizingMethod: string
      riskPercentage: number
      maxPositionSize: number
      kellyFraction: number | null
      winRate: number | null
      customSizingParams: Prisma.JsonValue | null
      stopLossType: string
      stopLossValue: number
      trailingCallback: number | null
      trailingStep: number | null
      timeLimit: number | null
      stopLossLevels: Prisma.JsonValue | null
      takeProfitType: string
      takeProfitValue: number
      trailingActivation: number | null
      takeProfitLevels: Prisma.JsonValue | null
      maxRiskPerTrade: number
      maxRiskPerSymbol: number
      maxRiskPerDirection: number
      maxTotalRisk: number
      maxDrawdown: number
      maxPositions: number
      maxDailyLoss: number
      cooldownPeriod: number
      volatilityLookback: number
      circuitBreakerEnabled: boolean
      maxDailyLossBreaker: number
      maxDrawdownBreaker: number
      volatilityMultiplier: number
      consecutiveLossesBreaker: number
      tradingPause: number
      marketWideEnabled: boolean
      enableManualOverride: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskSettings"]>
    composites: {}
  }

  type RiskSettingsGetPayload<S extends boolean | null | undefined | RiskSettingsDefaultArgs> = $Result.GetResult<Prisma.$RiskSettingsPayload, S>

  type RiskSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskSettingsCountAggregateInputType | true
    }

  export interface RiskSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskSettings'], meta: { name: 'RiskSettings' } }
    /**
     * Find zero or one RiskSettings that matches the filter.
     * @param {RiskSettingsFindUniqueArgs} args - Arguments to find a RiskSettings
     * @example
     * // Get one RiskSettings
     * const riskSettings = await prisma.riskSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskSettingsFindUniqueArgs>(args: SelectSubset<T, RiskSettingsFindUniqueArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskSettingsFindUniqueOrThrowArgs} args - Arguments to find a RiskSettings
     * @example
     * // Get one RiskSettings
     * const riskSettings = await prisma.riskSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsFindFirstArgs} args - Arguments to find a RiskSettings
     * @example
     * // Get one RiskSettings
     * const riskSettings = await prisma.riskSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskSettingsFindFirstArgs>(args?: SelectSubset<T, RiskSettingsFindFirstArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsFindFirstOrThrowArgs} args - Arguments to find a RiskSettings
     * @example
     * // Get one RiskSettings
     * const riskSettings = await prisma.riskSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskSettings
     * const riskSettings = await prisma.riskSettings.findMany()
     * 
     * // Get first 10 RiskSettings
     * const riskSettings = await prisma.riskSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskSettingsWithIdOnly = await prisma.riskSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskSettingsFindManyArgs>(args?: SelectSubset<T, RiskSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskSettings.
     * @param {RiskSettingsCreateArgs} args - Arguments to create a RiskSettings.
     * @example
     * // Create one RiskSettings
     * const RiskSettings = await prisma.riskSettings.create({
     *   data: {
     *     // ... data to create a RiskSettings
     *   }
     * })
     * 
     */
    create<T extends RiskSettingsCreateArgs>(args: SelectSubset<T, RiskSettingsCreateArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskSettings.
     * @param {RiskSettingsCreateManyArgs} args - Arguments to create many RiskSettings.
     * @example
     * // Create many RiskSettings
     * const riskSettings = await prisma.riskSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskSettingsCreateManyArgs>(args?: SelectSubset<T, RiskSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskSettings and returns the data saved in the database.
     * @param {RiskSettingsCreateManyAndReturnArgs} args - Arguments to create many RiskSettings.
     * @example
     * // Create many RiskSettings
     * const riskSettings = await prisma.riskSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskSettings and only return the `id`
     * const riskSettingsWithIdOnly = await prisma.riskSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskSettings.
     * @param {RiskSettingsDeleteArgs} args - Arguments to delete one RiskSettings.
     * @example
     * // Delete one RiskSettings
     * const RiskSettings = await prisma.riskSettings.delete({
     *   where: {
     *     // ... filter to delete one RiskSettings
     *   }
     * })
     * 
     */
    delete<T extends RiskSettingsDeleteArgs>(args: SelectSubset<T, RiskSettingsDeleteArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskSettings.
     * @param {RiskSettingsUpdateArgs} args - Arguments to update one RiskSettings.
     * @example
     * // Update one RiskSettings
     * const riskSettings = await prisma.riskSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskSettingsUpdateArgs>(args: SelectSubset<T, RiskSettingsUpdateArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskSettings.
     * @param {RiskSettingsDeleteManyArgs} args - Arguments to filter RiskSettings to delete.
     * @example
     * // Delete a few RiskSettings
     * const { count } = await prisma.riskSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskSettingsDeleteManyArgs>(args?: SelectSubset<T, RiskSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskSettings
     * const riskSettings = await prisma.riskSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskSettingsUpdateManyArgs>(args: SelectSubset<T, RiskSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskSettings and returns the data updated in the database.
     * @param {RiskSettingsUpdateManyAndReturnArgs} args - Arguments to update many RiskSettings.
     * @example
     * // Update many RiskSettings
     * const riskSettings = await prisma.riskSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskSettings and only return the `id`
     * const riskSettingsWithIdOnly = await prisma.riskSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskSettings.
     * @param {RiskSettingsUpsertArgs} args - Arguments to update or create a RiskSettings.
     * @example
     * // Update or create a RiskSettings
     * const riskSettings = await prisma.riskSettings.upsert({
     *   create: {
     *     // ... data to create a RiskSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskSettings we want to update
     *   }
     * })
     */
    upsert<T extends RiskSettingsUpsertArgs>(args: SelectSubset<T, RiskSettingsUpsertArgs<ExtArgs>>): Prisma__RiskSettingsClient<$Result.GetResult<Prisma.$RiskSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsCountArgs} args - Arguments to filter RiskSettings to count.
     * @example
     * // Count the number of RiskSettings
     * const count = await prisma.riskSettings.count({
     *   where: {
     *     // ... the filter for the RiskSettings we want to count
     *   }
     * })
    **/
    count<T extends RiskSettingsCountArgs>(
      args?: Subset<T, RiskSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskSettingsAggregateArgs>(args: Subset<T, RiskSettingsAggregateArgs>): Prisma.PrismaPromise<GetRiskSettingsAggregateType<T>>

    /**
     * Group by RiskSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskSettingsGroupByArgs['orderBy'] }
        : { orderBy?: RiskSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskSettings model
   */
  readonly fields: RiskSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bot<T extends RiskSettings$botArgs<ExtArgs> = {}>(args?: Subset<T, RiskSettings$botArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskSettings model
   */
  interface RiskSettingsFieldRefs {
    readonly id: FieldRef<"RiskSettings", 'String'>
    readonly name: FieldRef<"RiskSettings", 'String'>
    readonly description: FieldRef<"RiskSettings", 'String'>
    readonly userId: FieldRef<"RiskSettings", 'String'>
    readonly botId: FieldRef<"RiskSettings", 'String'>
    readonly isActive: FieldRef<"RiskSettings", 'Boolean'>
    readonly positionSizingMethod: FieldRef<"RiskSettings", 'String'>
    readonly riskPercentage: FieldRef<"RiskSettings", 'Float'>
    readonly maxPositionSize: FieldRef<"RiskSettings", 'Float'>
    readonly kellyFraction: FieldRef<"RiskSettings", 'Float'>
    readonly winRate: FieldRef<"RiskSettings", 'Float'>
    readonly customSizingParams: FieldRef<"RiskSettings", 'Json'>
    readonly stopLossType: FieldRef<"RiskSettings", 'String'>
    readonly stopLossValue: FieldRef<"RiskSettings", 'Float'>
    readonly trailingCallback: FieldRef<"RiskSettings", 'Float'>
    readonly trailingStep: FieldRef<"RiskSettings", 'Float'>
    readonly timeLimit: FieldRef<"RiskSettings", 'Int'>
    readonly stopLossLevels: FieldRef<"RiskSettings", 'Json'>
    readonly takeProfitType: FieldRef<"RiskSettings", 'String'>
    readonly takeProfitValue: FieldRef<"RiskSettings", 'Float'>
    readonly trailingActivation: FieldRef<"RiskSettings", 'Float'>
    readonly takeProfitLevels: FieldRef<"RiskSettings", 'Json'>
    readonly maxRiskPerTrade: FieldRef<"RiskSettings", 'Float'>
    readonly maxRiskPerSymbol: FieldRef<"RiskSettings", 'Float'>
    readonly maxRiskPerDirection: FieldRef<"RiskSettings", 'Float'>
    readonly maxTotalRisk: FieldRef<"RiskSettings", 'Float'>
    readonly maxDrawdown: FieldRef<"RiskSettings", 'Float'>
    readonly maxPositions: FieldRef<"RiskSettings", 'Int'>
    readonly maxDailyLoss: FieldRef<"RiskSettings", 'Float'>
    readonly cooldownPeriod: FieldRef<"RiskSettings", 'Int'>
    readonly volatilityLookback: FieldRef<"RiskSettings", 'Int'>
    readonly circuitBreakerEnabled: FieldRef<"RiskSettings", 'Boolean'>
    readonly maxDailyLossBreaker: FieldRef<"RiskSettings", 'Float'>
    readonly maxDrawdownBreaker: FieldRef<"RiskSettings", 'Float'>
    readonly volatilityMultiplier: FieldRef<"RiskSettings", 'Float'>
    readonly consecutiveLossesBreaker: FieldRef<"RiskSettings", 'Int'>
    readonly tradingPause: FieldRef<"RiskSettings", 'Int'>
    readonly marketWideEnabled: FieldRef<"RiskSettings", 'Boolean'>
    readonly enableManualOverride: FieldRef<"RiskSettings", 'Boolean'>
    readonly createdAt: FieldRef<"RiskSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskSettings findUnique
   */
  export type RiskSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RiskSettings to fetch.
     */
    where: RiskSettingsWhereUniqueInput
  }

  /**
   * RiskSettings findUniqueOrThrow
   */
  export type RiskSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RiskSettings to fetch.
     */
    where: RiskSettingsWhereUniqueInput
  }

  /**
   * RiskSettings findFirst
   */
  export type RiskSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RiskSettings to fetch.
     */
    where?: RiskSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskSettings to fetch.
     */
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskSettings.
     */
    cursor?: RiskSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskSettings.
     */
    distinct?: RiskSettingsScalarFieldEnum | RiskSettingsScalarFieldEnum[]
  }

  /**
   * RiskSettings findFirstOrThrow
   */
  export type RiskSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RiskSettings to fetch.
     */
    where?: RiskSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskSettings to fetch.
     */
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskSettings.
     */
    cursor?: RiskSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskSettings.
     */
    distinct?: RiskSettingsScalarFieldEnum | RiskSettingsScalarFieldEnum[]
  }

  /**
   * RiskSettings findMany
   */
  export type RiskSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RiskSettings to fetch.
     */
    where?: RiskSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskSettings to fetch.
     */
    orderBy?: RiskSettingsOrderByWithRelationInput | RiskSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskSettings.
     */
    cursor?: RiskSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskSettings.
     */
    skip?: number
    distinct?: RiskSettingsScalarFieldEnum | RiskSettingsScalarFieldEnum[]
  }

  /**
   * RiskSettings create
   */
  export type RiskSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskSettings.
     */
    data: XOR<RiskSettingsCreateInput, RiskSettingsUncheckedCreateInput>
  }

  /**
   * RiskSettings createMany
   */
  export type RiskSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskSettings.
     */
    data: RiskSettingsCreateManyInput | RiskSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskSettings createManyAndReturn
   */
  export type RiskSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many RiskSettings.
     */
    data: RiskSettingsCreateManyInput | RiskSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskSettings update
   */
  export type RiskSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskSettings.
     */
    data: XOR<RiskSettingsUpdateInput, RiskSettingsUncheckedUpdateInput>
    /**
     * Choose, which RiskSettings to update.
     */
    where: RiskSettingsWhereUniqueInput
  }

  /**
   * RiskSettings updateMany
   */
  export type RiskSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskSettings.
     */
    data: XOR<RiskSettingsUpdateManyMutationInput, RiskSettingsUncheckedUpdateManyInput>
    /**
     * Filter which RiskSettings to update
     */
    where?: RiskSettingsWhereInput
    /**
     * Limit how many RiskSettings to update.
     */
    limit?: number
  }

  /**
   * RiskSettings updateManyAndReturn
   */
  export type RiskSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * The data used to update RiskSettings.
     */
    data: XOR<RiskSettingsUpdateManyMutationInput, RiskSettingsUncheckedUpdateManyInput>
    /**
     * Filter which RiskSettings to update
     */
    where?: RiskSettingsWhereInput
    /**
     * Limit how many RiskSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskSettings upsert
   */
  export type RiskSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskSettings to update in case it exists.
     */
    where: RiskSettingsWhereUniqueInput
    /**
     * In case the RiskSettings found by the `where` argument doesn't exist, create a new RiskSettings with this data.
     */
    create: XOR<RiskSettingsCreateInput, RiskSettingsUncheckedCreateInput>
    /**
     * In case the RiskSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskSettingsUpdateInput, RiskSettingsUncheckedUpdateInput>
  }

  /**
   * RiskSettings delete
   */
  export type RiskSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
    /**
     * Filter which RiskSettings to delete.
     */
    where: RiskSettingsWhereUniqueInput
  }

  /**
   * RiskSettings deleteMany
   */
  export type RiskSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskSettings to delete
     */
    where?: RiskSettingsWhereInput
    /**
     * Limit how many RiskSettings to delete.
     */
    limit?: number
  }

  /**
   * RiskSettings.bot
   */
  export type RiskSettings$botArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
  }

  /**
   * RiskSettings without action
   */
  export type RiskSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskSettings
     */
    select?: RiskSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskSettings
     */
    omit?: RiskSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskSettingsInclude<ExtArgs> | null
  }


  /**
   * Model RiskAlert
   */

  export type AggregateRiskAlert = {
    _count: RiskAlertCountAggregateOutputType | null
    _min: RiskAlertMinAggregateOutputType | null
    _max: RiskAlertMaxAggregateOutputType | null
  }

  export type RiskAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    level: string | null
    message: string | null
    timestamp: Date | null
    acknowledged: boolean | null
    resolvedAt: Date | null
  }

  export type RiskAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    level: string | null
    message: string | null
    timestamp: Date | null
    acknowledged: boolean | null
    resolvedAt: Date | null
  }

  export type RiskAlertCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    level: number
    message: number
    details: number
    timestamp: number
    acknowledged: number
    resolvedAt: number
    _all: number
  }


  export type RiskAlertMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    level?: true
    message?: true
    timestamp?: true
    acknowledged?: true
    resolvedAt?: true
  }

  export type RiskAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    level?: true
    message?: true
    timestamp?: true
    acknowledged?: true
    resolvedAt?: true
  }

  export type RiskAlertCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    level?: true
    message?: true
    details?: true
    timestamp?: true
    acknowledged?: true
    resolvedAt?: true
    _all?: true
  }

  export type RiskAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAlert to aggregate.
     */
    where?: RiskAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAlerts to fetch.
     */
    orderBy?: RiskAlertOrderByWithRelationInput | RiskAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAlerts
    **/
    _count?: true | RiskAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAlertMaxAggregateInputType
  }

  export type GetRiskAlertAggregateType<T extends RiskAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAlert[P]>
      : GetScalarType<T[P], AggregateRiskAlert[P]>
  }




  export type RiskAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAlertWhereInput
    orderBy?: RiskAlertOrderByWithAggregationInput | RiskAlertOrderByWithAggregationInput[]
    by: RiskAlertScalarFieldEnum[] | RiskAlertScalarFieldEnum
    having?: RiskAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAlertCountAggregateInputType | true
    _min?: RiskAlertMinAggregateInputType
    _max?: RiskAlertMaxAggregateInputType
  }

  export type RiskAlertGroupByOutputType = {
    id: string
    userId: string
    type: string
    level: string
    message: string
    details: JsonValue
    timestamp: Date
    acknowledged: boolean
    resolvedAt: Date | null
    _count: RiskAlertCountAggregateOutputType | null
    _min: RiskAlertMinAggregateOutputType | null
    _max: RiskAlertMaxAggregateOutputType | null
  }

  type GetRiskAlertGroupByPayload<T extends RiskAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAlertGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAlertGroupByOutputType[P]>
        }
      >
    >


  export type RiskAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    details?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAlert"]>

  export type RiskAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    details?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAlert"]>

  export type RiskAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    details?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAlert"]>

  export type RiskAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    level?: boolean
    message?: boolean
    details?: boolean
    timestamp?: boolean
    acknowledged?: boolean
    resolvedAt?: boolean
  }

  export type RiskAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "level" | "message" | "details" | "timestamp" | "acknowledged" | "resolvedAt", ExtArgs["result"]["riskAlert"]>
  export type RiskAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RiskAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RiskAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RiskAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      level: string
      message: string
      details: Prisma.JsonValue
      timestamp: Date
      acknowledged: boolean
      resolvedAt: Date | null
    }, ExtArgs["result"]["riskAlert"]>
    composites: {}
  }

  type RiskAlertGetPayload<S extends boolean | null | undefined | RiskAlertDefaultArgs> = $Result.GetResult<Prisma.$RiskAlertPayload, S>

  type RiskAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskAlertCountAggregateInputType | true
    }

  export interface RiskAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAlert'], meta: { name: 'RiskAlert' } }
    /**
     * Find zero or one RiskAlert that matches the filter.
     * @param {RiskAlertFindUniqueArgs} args - Arguments to find a RiskAlert
     * @example
     * // Get one RiskAlert
     * const riskAlert = await prisma.riskAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAlertFindUniqueArgs>(args: SelectSubset<T, RiskAlertFindUniqueArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskAlertFindUniqueOrThrowArgs} args - Arguments to find a RiskAlert
     * @example
     * // Get one RiskAlert
     * const riskAlert = await prisma.riskAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertFindFirstArgs} args - Arguments to find a RiskAlert
     * @example
     * // Get one RiskAlert
     * const riskAlert = await prisma.riskAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAlertFindFirstArgs>(args?: SelectSubset<T, RiskAlertFindFirstArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertFindFirstOrThrowArgs} args - Arguments to find a RiskAlert
     * @example
     * // Get one RiskAlert
     * const riskAlert = await prisma.riskAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAlerts
     * const riskAlerts = await prisma.riskAlert.findMany()
     * 
     * // Get first 10 RiskAlerts
     * const riskAlerts = await prisma.riskAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAlertWithIdOnly = await prisma.riskAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAlertFindManyArgs>(args?: SelectSubset<T, RiskAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskAlert.
     * @param {RiskAlertCreateArgs} args - Arguments to create a RiskAlert.
     * @example
     * // Create one RiskAlert
     * const RiskAlert = await prisma.riskAlert.create({
     *   data: {
     *     // ... data to create a RiskAlert
     *   }
     * })
     * 
     */
    create<T extends RiskAlertCreateArgs>(args: SelectSubset<T, RiskAlertCreateArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskAlerts.
     * @param {RiskAlertCreateManyArgs} args - Arguments to create many RiskAlerts.
     * @example
     * // Create many RiskAlerts
     * const riskAlert = await prisma.riskAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAlertCreateManyArgs>(args?: SelectSubset<T, RiskAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAlerts and returns the data saved in the database.
     * @param {RiskAlertCreateManyAndReturnArgs} args - Arguments to create many RiskAlerts.
     * @example
     * // Create many RiskAlerts
     * const riskAlert = await prisma.riskAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAlerts and only return the `id`
     * const riskAlertWithIdOnly = await prisma.riskAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskAlert.
     * @param {RiskAlertDeleteArgs} args - Arguments to delete one RiskAlert.
     * @example
     * // Delete one RiskAlert
     * const RiskAlert = await prisma.riskAlert.delete({
     *   where: {
     *     // ... filter to delete one RiskAlert
     *   }
     * })
     * 
     */
    delete<T extends RiskAlertDeleteArgs>(args: SelectSubset<T, RiskAlertDeleteArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskAlert.
     * @param {RiskAlertUpdateArgs} args - Arguments to update one RiskAlert.
     * @example
     * // Update one RiskAlert
     * const riskAlert = await prisma.riskAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAlertUpdateArgs>(args: SelectSubset<T, RiskAlertUpdateArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskAlerts.
     * @param {RiskAlertDeleteManyArgs} args - Arguments to filter RiskAlerts to delete.
     * @example
     * // Delete a few RiskAlerts
     * const { count } = await prisma.riskAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAlertDeleteManyArgs>(args?: SelectSubset<T, RiskAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAlerts
     * const riskAlert = await prisma.riskAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAlertUpdateManyArgs>(args: SelectSubset<T, RiskAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAlerts and returns the data updated in the database.
     * @param {RiskAlertUpdateManyAndReturnArgs} args - Arguments to update many RiskAlerts.
     * @example
     * // Update many RiskAlerts
     * const riskAlert = await prisma.riskAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskAlerts and only return the `id`
     * const riskAlertWithIdOnly = await prisma.riskAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskAlert.
     * @param {RiskAlertUpsertArgs} args - Arguments to update or create a RiskAlert.
     * @example
     * // Update or create a RiskAlert
     * const riskAlert = await prisma.riskAlert.upsert({
     *   create: {
     *     // ... data to create a RiskAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAlert we want to update
     *   }
     * })
     */
    upsert<T extends RiskAlertUpsertArgs>(args: SelectSubset<T, RiskAlertUpsertArgs<ExtArgs>>): Prisma__RiskAlertClient<$Result.GetResult<Prisma.$RiskAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertCountArgs} args - Arguments to filter RiskAlerts to count.
     * @example
     * // Count the number of RiskAlerts
     * const count = await prisma.riskAlert.count({
     *   where: {
     *     // ... the filter for the RiskAlerts we want to count
     *   }
     * })
    **/
    count<T extends RiskAlertCountArgs>(
      args?: Subset<T, RiskAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAlertAggregateArgs>(args: Subset<T, RiskAlertAggregateArgs>): Prisma.PrismaPromise<GetRiskAlertAggregateType<T>>

    /**
     * Group by RiskAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAlertGroupByArgs['orderBy'] }
        : { orderBy?: RiskAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAlert model
   */
  readonly fields: RiskAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAlert model
   */
  interface RiskAlertFieldRefs {
    readonly id: FieldRef<"RiskAlert", 'String'>
    readonly userId: FieldRef<"RiskAlert", 'String'>
    readonly type: FieldRef<"RiskAlert", 'String'>
    readonly level: FieldRef<"RiskAlert", 'String'>
    readonly message: FieldRef<"RiskAlert", 'String'>
    readonly details: FieldRef<"RiskAlert", 'Json'>
    readonly timestamp: FieldRef<"RiskAlert", 'DateTime'>
    readonly acknowledged: FieldRef<"RiskAlert", 'Boolean'>
    readonly resolvedAt: FieldRef<"RiskAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskAlert findUnique
   */
  export type RiskAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter, which RiskAlert to fetch.
     */
    where: RiskAlertWhereUniqueInput
  }

  /**
   * RiskAlert findUniqueOrThrow
   */
  export type RiskAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter, which RiskAlert to fetch.
     */
    where: RiskAlertWhereUniqueInput
  }

  /**
   * RiskAlert findFirst
   */
  export type RiskAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter, which RiskAlert to fetch.
     */
    where?: RiskAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAlerts to fetch.
     */
    orderBy?: RiskAlertOrderByWithRelationInput | RiskAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAlerts.
     */
    cursor?: RiskAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAlerts.
     */
    distinct?: RiskAlertScalarFieldEnum | RiskAlertScalarFieldEnum[]
  }

  /**
   * RiskAlert findFirstOrThrow
   */
  export type RiskAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter, which RiskAlert to fetch.
     */
    where?: RiskAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAlerts to fetch.
     */
    orderBy?: RiskAlertOrderByWithRelationInput | RiskAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAlerts.
     */
    cursor?: RiskAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAlerts.
     */
    distinct?: RiskAlertScalarFieldEnum | RiskAlertScalarFieldEnum[]
  }

  /**
   * RiskAlert findMany
   */
  export type RiskAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter, which RiskAlerts to fetch.
     */
    where?: RiskAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAlerts to fetch.
     */
    orderBy?: RiskAlertOrderByWithRelationInput | RiskAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAlerts.
     */
    cursor?: RiskAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAlerts.
     */
    skip?: number
    distinct?: RiskAlertScalarFieldEnum | RiskAlertScalarFieldEnum[]
  }

  /**
   * RiskAlert create
   */
  export type RiskAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAlert.
     */
    data: XOR<RiskAlertCreateInput, RiskAlertUncheckedCreateInput>
  }

  /**
   * RiskAlert createMany
   */
  export type RiskAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAlerts.
     */
    data: RiskAlertCreateManyInput | RiskAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAlert createManyAndReturn
   */
  export type RiskAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * The data used to create many RiskAlerts.
     */
    data: RiskAlertCreateManyInput | RiskAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAlert update
   */
  export type RiskAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAlert.
     */
    data: XOR<RiskAlertUpdateInput, RiskAlertUncheckedUpdateInput>
    /**
     * Choose, which RiskAlert to update.
     */
    where: RiskAlertWhereUniqueInput
  }

  /**
   * RiskAlert updateMany
   */
  export type RiskAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAlerts.
     */
    data: XOR<RiskAlertUpdateManyMutationInput, RiskAlertUncheckedUpdateManyInput>
    /**
     * Filter which RiskAlerts to update
     */
    where?: RiskAlertWhereInput
    /**
     * Limit how many RiskAlerts to update.
     */
    limit?: number
  }

  /**
   * RiskAlert updateManyAndReturn
   */
  export type RiskAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * The data used to update RiskAlerts.
     */
    data: XOR<RiskAlertUpdateManyMutationInput, RiskAlertUncheckedUpdateManyInput>
    /**
     * Filter which RiskAlerts to update
     */
    where?: RiskAlertWhereInput
    /**
     * Limit how many RiskAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAlert upsert
   */
  export type RiskAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAlert to update in case it exists.
     */
    where: RiskAlertWhereUniqueInput
    /**
     * In case the RiskAlert found by the `where` argument doesn't exist, create a new RiskAlert with this data.
     */
    create: XOR<RiskAlertCreateInput, RiskAlertUncheckedCreateInput>
    /**
     * In case the RiskAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAlertUpdateInput, RiskAlertUncheckedUpdateInput>
  }

  /**
   * RiskAlert delete
   */
  export type RiskAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
    /**
     * Filter which RiskAlert to delete.
     */
    where: RiskAlertWhereUniqueInput
  }

  /**
   * RiskAlert deleteMany
   */
  export type RiskAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAlerts to delete
     */
    where?: RiskAlertWhereInput
    /**
     * Limit how many RiskAlerts to delete.
     */
    limit?: number
  }

  /**
   * RiskAlert without action
   */
  export type RiskAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAlert
     */
    select?: RiskAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAlert
     */
    omit?: RiskAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAlertInclude<ExtArgs> | null
  }


  /**
   * Model CircuitBreaker
   */

  export type AggregateCircuitBreaker = {
    _count: CircuitBreakerCountAggregateOutputType | null
    _avg: CircuitBreakerAvgAggregateOutputType | null
    _sum: CircuitBreakerSumAggregateOutputType | null
    _min: CircuitBreakerMinAggregateOutputType | null
    _max: CircuitBreakerMaxAggregateOutputType | null
  }

  export type CircuitBreakerAvgAggregateOutputType = {
    threshold: number | null
    recoveryThreshold: number | null
    cooldownMinutes: number | null
  }

  export type CircuitBreakerSumAggregateOutputType = {
    threshold: number | null
    recoveryThreshold: number | null
    cooldownMinutes: number | null
  }

  export type CircuitBreakerMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    botId: string | null
    type: string | null
    isGlobal: boolean | null
    isActive: boolean | null
    threshold: number | null
    recoveryThreshold: number | null
    cooldownMinutes: number | null
    action: string | null
    lastTriggered: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircuitBreakerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    botId: string | null
    type: string | null
    isGlobal: boolean | null
    isActive: boolean | null
    threshold: number | null
    recoveryThreshold: number | null
    cooldownMinutes: number | null
    action: string | null
    lastTriggered: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircuitBreakerCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    botId: number
    type: number
    isGlobal: number
    isActive: number
    threshold: number
    recoveryThreshold: number
    cooldownMinutes: number
    action: number
    lastTriggered: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CircuitBreakerAvgAggregateInputType = {
    threshold?: true
    recoveryThreshold?: true
    cooldownMinutes?: true
  }

  export type CircuitBreakerSumAggregateInputType = {
    threshold?: true
    recoveryThreshold?: true
    cooldownMinutes?: true
  }

  export type CircuitBreakerMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    type?: true
    isGlobal?: true
    isActive?: true
    threshold?: true
    recoveryThreshold?: true
    cooldownMinutes?: true
    action?: true
    lastTriggered?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircuitBreakerMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    type?: true
    isGlobal?: true
    isActive?: true
    threshold?: true
    recoveryThreshold?: true
    cooldownMinutes?: true
    action?: true
    lastTriggered?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircuitBreakerCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    botId?: true
    type?: true
    isGlobal?: true
    isActive?: true
    threshold?: true
    recoveryThreshold?: true
    cooldownMinutes?: true
    action?: true
    lastTriggered?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CircuitBreakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircuitBreaker to aggregate.
     */
    where?: CircuitBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakers to fetch.
     */
    orderBy?: CircuitBreakerOrderByWithRelationInput | CircuitBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircuitBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CircuitBreakers
    **/
    _count?: true | CircuitBreakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircuitBreakerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircuitBreakerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircuitBreakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircuitBreakerMaxAggregateInputType
  }

  export type GetCircuitBreakerAggregateType<T extends CircuitBreakerAggregateArgs> = {
        [P in keyof T & keyof AggregateCircuitBreaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircuitBreaker[P]>
      : GetScalarType<T[P], AggregateCircuitBreaker[P]>
  }




  export type CircuitBreakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircuitBreakerWhereInput
    orderBy?: CircuitBreakerOrderByWithAggregationInput | CircuitBreakerOrderByWithAggregationInput[]
    by: CircuitBreakerScalarFieldEnum[] | CircuitBreakerScalarFieldEnum
    having?: CircuitBreakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircuitBreakerCountAggregateInputType | true
    _avg?: CircuitBreakerAvgAggregateInputType
    _sum?: CircuitBreakerSumAggregateInputType
    _min?: CircuitBreakerMinAggregateInputType
    _max?: CircuitBreakerMaxAggregateInputType
  }

  export type CircuitBreakerGroupByOutputType = {
    id: string
    name: string
    description: string | null
    userId: string
    botId: string | null
    type: string
    isGlobal: boolean
    isActive: boolean
    threshold: number
    recoveryThreshold: number | null
    cooldownMinutes: number
    action: string
    lastTriggered: Date | null
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CircuitBreakerCountAggregateOutputType | null
    _avg: CircuitBreakerAvgAggregateOutputType | null
    _sum: CircuitBreakerSumAggregateOutputType | null
    _min: CircuitBreakerMinAggregateOutputType | null
    _max: CircuitBreakerMaxAggregateOutputType | null
  }

  type GetCircuitBreakerGroupByPayload<T extends CircuitBreakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircuitBreakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircuitBreakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircuitBreakerGroupByOutputType[P]>
            : GetScalarType<T[P], CircuitBreakerGroupByOutputType[P]>
        }
      >
    >


  export type CircuitBreakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    type?: boolean
    isGlobal?: boolean
    isActive?: boolean
    threshold?: boolean
    recoveryThreshold?: boolean
    cooldownMinutes?: boolean
    action?: boolean
    lastTriggered?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circuitBreaker"]>

  export type CircuitBreakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    type?: boolean
    isGlobal?: boolean
    isActive?: boolean
    threshold?: boolean
    recoveryThreshold?: boolean
    cooldownMinutes?: boolean
    action?: boolean
    lastTriggered?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circuitBreaker"]>

  export type CircuitBreakerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    type?: boolean
    isGlobal?: boolean
    isActive?: boolean
    threshold?: boolean
    recoveryThreshold?: boolean
    cooldownMinutes?: boolean
    action?: boolean
    lastTriggered?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circuitBreaker"]>

  export type CircuitBreakerSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    botId?: boolean
    type?: boolean
    isGlobal?: boolean
    isActive?: boolean
    threshold?: boolean
    recoveryThreshold?: boolean
    cooldownMinutes?: boolean
    action?: boolean
    lastTriggered?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CircuitBreakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "botId" | "type" | "isGlobal" | "isActive" | "threshold" | "recoveryThreshold" | "cooldownMinutes" | "action" | "lastTriggered" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["circuitBreaker"]>

  export type $CircuitBreakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CircuitBreaker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      userId: string
      botId: string | null
      type: string
      isGlobal: boolean
      isActive: boolean
      threshold: number
      recoveryThreshold: number | null
      cooldownMinutes: number
      action: string
      lastTriggered: Date | null
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["circuitBreaker"]>
    composites: {}
  }

  type CircuitBreakerGetPayload<S extends boolean | null | undefined | CircuitBreakerDefaultArgs> = $Result.GetResult<Prisma.$CircuitBreakerPayload, S>

  type CircuitBreakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CircuitBreakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CircuitBreakerCountAggregateInputType | true
    }

  export interface CircuitBreakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CircuitBreaker'], meta: { name: 'CircuitBreaker' } }
    /**
     * Find zero or one CircuitBreaker that matches the filter.
     * @param {CircuitBreakerFindUniqueArgs} args - Arguments to find a CircuitBreaker
     * @example
     * // Get one CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircuitBreakerFindUniqueArgs>(args: SelectSubset<T, CircuitBreakerFindUniqueArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CircuitBreaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CircuitBreakerFindUniqueOrThrowArgs} args - Arguments to find a CircuitBreaker
     * @example
     * // Get one CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircuitBreakerFindUniqueOrThrowArgs>(args: SelectSubset<T, CircuitBreakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircuitBreaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerFindFirstArgs} args - Arguments to find a CircuitBreaker
     * @example
     * // Get one CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircuitBreakerFindFirstArgs>(args?: SelectSubset<T, CircuitBreakerFindFirstArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircuitBreaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerFindFirstOrThrowArgs} args - Arguments to find a CircuitBreaker
     * @example
     * // Get one CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircuitBreakerFindFirstOrThrowArgs>(args?: SelectSubset<T, CircuitBreakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CircuitBreakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CircuitBreakers
     * const circuitBreakers = await prisma.circuitBreaker.findMany()
     * 
     * // Get first 10 CircuitBreakers
     * const circuitBreakers = await prisma.circuitBreaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circuitBreakerWithIdOnly = await prisma.circuitBreaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircuitBreakerFindManyArgs>(args?: SelectSubset<T, CircuitBreakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CircuitBreaker.
     * @param {CircuitBreakerCreateArgs} args - Arguments to create a CircuitBreaker.
     * @example
     * // Create one CircuitBreaker
     * const CircuitBreaker = await prisma.circuitBreaker.create({
     *   data: {
     *     // ... data to create a CircuitBreaker
     *   }
     * })
     * 
     */
    create<T extends CircuitBreakerCreateArgs>(args: SelectSubset<T, CircuitBreakerCreateArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CircuitBreakers.
     * @param {CircuitBreakerCreateManyArgs} args - Arguments to create many CircuitBreakers.
     * @example
     * // Create many CircuitBreakers
     * const circuitBreaker = await prisma.circuitBreaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircuitBreakerCreateManyArgs>(args?: SelectSubset<T, CircuitBreakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CircuitBreakers and returns the data saved in the database.
     * @param {CircuitBreakerCreateManyAndReturnArgs} args - Arguments to create many CircuitBreakers.
     * @example
     * // Create many CircuitBreakers
     * const circuitBreaker = await prisma.circuitBreaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CircuitBreakers and only return the `id`
     * const circuitBreakerWithIdOnly = await prisma.circuitBreaker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircuitBreakerCreateManyAndReturnArgs>(args?: SelectSubset<T, CircuitBreakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CircuitBreaker.
     * @param {CircuitBreakerDeleteArgs} args - Arguments to delete one CircuitBreaker.
     * @example
     * // Delete one CircuitBreaker
     * const CircuitBreaker = await prisma.circuitBreaker.delete({
     *   where: {
     *     // ... filter to delete one CircuitBreaker
     *   }
     * })
     * 
     */
    delete<T extends CircuitBreakerDeleteArgs>(args: SelectSubset<T, CircuitBreakerDeleteArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CircuitBreaker.
     * @param {CircuitBreakerUpdateArgs} args - Arguments to update one CircuitBreaker.
     * @example
     * // Update one CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircuitBreakerUpdateArgs>(args: SelectSubset<T, CircuitBreakerUpdateArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CircuitBreakers.
     * @param {CircuitBreakerDeleteManyArgs} args - Arguments to filter CircuitBreakers to delete.
     * @example
     * // Delete a few CircuitBreakers
     * const { count } = await prisma.circuitBreaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircuitBreakerDeleteManyArgs>(args?: SelectSubset<T, CircuitBreakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircuitBreakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CircuitBreakers
     * const circuitBreaker = await prisma.circuitBreaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircuitBreakerUpdateManyArgs>(args: SelectSubset<T, CircuitBreakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircuitBreakers and returns the data updated in the database.
     * @param {CircuitBreakerUpdateManyAndReturnArgs} args - Arguments to update many CircuitBreakers.
     * @example
     * // Update many CircuitBreakers
     * const circuitBreaker = await prisma.circuitBreaker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CircuitBreakers and only return the `id`
     * const circuitBreakerWithIdOnly = await prisma.circuitBreaker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CircuitBreakerUpdateManyAndReturnArgs>(args: SelectSubset<T, CircuitBreakerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CircuitBreaker.
     * @param {CircuitBreakerUpsertArgs} args - Arguments to update or create a CircuitBreaker.
     * @example
     * // Update or create a CircuitBreaker
     * const circuitBreaker = await prisma.circuitBreaker.upsert({
     *   create: {
     *     // ... data to create a CircuitBreaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CircuitBreaker we want to update
     *   }
     * })
     */
    upsert<T extends CircuitBreakerUpsertArgs>(args: SelectSubset<T, CircuitBreakerUpsertArgs<ExtArgs>>): Prisma__CircuitBreakerClient<$Result.GetResult<Prisma.$CircuitBreakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CircuitBreakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerCountArgs} args - Arguments to filter CircuitBreakers to count.
     * @example
     * // Count the number of CircuitBreakers
     * const count = await prisma.circuitBreaker.count({
     *   where: {
     *     // ... the filter for the CircuitBreakers we want to count
     *   }
     * })
    **/
    count<T extends CircuitBreakerCountArgs>(
      args?: Subset<T, CircuitBreakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircuitBreakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CircuitBreaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircuitBreakerAggregateArgs>(args: Subset<T, CircuitBreakerAggregateArgs>): Prisma.PrismaPromise<GetCircuitBreakerAggregateType<T>>

    /**
     * Group by CircuitBreaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitBreakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircuitBreakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircuitBreakerGroupByArgs['orderBy'] }
        : { orderBy?: CircuitBreakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircuitBreakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircuitBreakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CircuitBreaker model
   */
  readonly fields: CircuitBreakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CircuitBreaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircuitBreakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CircuitBreaker model
   */
  interface CircuitBreakerFieldRefs {
    readonly id: FieldRef<"CircuitBreaker", 'String'>
    readonly name: FieldRef<"CircuitBreaker", 'String'>
    readonly description: FieldRef<"CircuitBreaker", 'String'>
    readonly userId: FieldRef<"CircuitBreaker", 'String'>
    readonly botId: FieldRef<"CircuitBreaker", 'String'>
    readonly type: FieldRef<"CircuitBreaker", 'String'>
    readonly isGlobal: FieldRef<"CircuitBreaker", 'Boolean'>
    readonly isActive: FieldRef<"CircuitBreaker", 'Boolean'>
    readonly threshold: FieldRef<"CircuitBreaker", 'Float'>
    readonly recoveryThreshold: FieldRef<"CircuitBreaker", 'Float'>
    readonly cooldownMinutes: FieldRef<"CircuitBreaker", 'Int'>
    readonly action: FieldRef<"CircuitBreaker", 'String'>
    readonly lastTriggered: FieldRef<"CircuitBreaker", 'DateTime'>
    readonly status: FieldRef<"CircuitBreaker", 'String'>
    readonly metadata: FieldRef<"CircuitBreaker", 'Json'>
    readonly createdAt: FieldRef<"CircuitBreaker", 'DateTime'>
    readonly updatedAt: FieldRef<"CircuitBreaker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CircuitBreaker findUnique
   */
  export type CircuitBreakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter, which CircuitBreaker to fetch.
     */
    where: CircuitBreakerWhereUniqueInput
  }

  /**
   * CircuitBreaker findUniqueOrThrow
   */
  export type CircuitBreakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter, which CircuitBreaker to fetch.
     */
    where: CircuitBreakerWhereUniqueInput
  }

  /**
   * CircuitBreaker findFirst
   */
  export type CircuitBreakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter, which CircuitBreaker to fetch.
     */
    where?: CircuitBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakers to fetch.
     */
    orderBy?: CircuitBreakerOrderByWithRelationInput | CircuitBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircuitBreakers.
     */
    cursor?: CircuitBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircuitBreakers.
     */
    distinct?: CircuitBreakerScalarFieldEnum | CircuitBreakerScalarFieldEnum[]
  }

  /**
   * CircuitBreaker findFirstOrThrow
   */
  export type CircuitBreakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter, which CircuitBreaker to fetch.
     */
    where?: CircuitBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakers to fetch.
     */
    orderBy?: CircuitBreakerOrderByWithRelationInput | CircuitBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircuitBreakers.
     */
    cursor?: CircuitBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircuitBreakers.
     */
    distinct?: CircuitBreakerScalarFieldEnum | CircuitBreakerScalarFieldEnum[]
  }

  /**
   * CircuitBreaker findMany
   */
  export type CircuitBreakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter, which CircuitBreakers to fetch.
     */
    where?: CircuitBreakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircuitBreakers to fetch.
     */
    orderBy?: CircuitBreakerOrderByWithRelationInput | CircuitBreakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CircuitBreakers.
     */
    cursor?: CircuitBreakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircuitBreakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircuitBreakers.
     */
    skip?: number
    distinct?: CircuitBreakerScalarFieldEnum | CircuitBreakerScalarFieldEnum[]
  }

  /**
   * CircuitBreaker create
   */
  export type CircuitBreakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * The data needed to create a CircuitBreaker.
     */
    data: XOR<CircuitBreakerCreateInput, CircuitBreakerUncheckedCreateInput>
  }

  /**
   * CircuitBreaker createMany
   */
  export type CircuitBreakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CircuitBreakers.
     */
    data: CircuitBreakerCreateManyInput | CircuitBreakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircuitBreaker createManyAndReturn
   */
  export type CircuitBreakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * The data used to create many CircuitBreakers.
     */
    data: CircuitBreakerCreateManyInput | CircuitBreakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircuitBreaker update
   */
  export type CircuitBreakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * The data needed to update a CircuitBreaker.
     */
    data: XOR<CircuitBreakerUpdateInput, CircuitBreakerUncheckedUpdateInput>
    /**
     * Choose, which CircuitBreaker to update.
     */
    where: CircuitBreakerWhereUniqueInput
  }

  /**
   * CircuitBreaker updateMany
   */
  export type CircuitBreakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CircuitBreakers.
     */
    data: XOR<CircuitBreakerUpdateManyMutationInput, CircuitBreakerUncheckedUpdateManyInput>
    /**
     * Filter which CircuitBreakers to update
     */
    where?: CircuitBreakerWhereInput
    /**
     * Limit how many CircuitBreakers to update.
     */
    limit?: number
  }

  /**
   * CircuitBreaker updateManyAndReturn
   */
  export type CircuitBreakerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * The data used to update CircuitBreakers.
     */
    data: XOR<CircuitBreakerUpdateManyMutationInput, CircuitBreakerUncheckedUpdateManyInput>
    /**
     * Filter which CircuitBreakers to update
     */
    where?: CircuitBreakerWhereInput
    /**
     * Limit how many CircuitBreakers to update.
     */
    limit?: number
  }

  /**
   * CircuitBreaker upsert
   */
  export type CircuitBreakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * The filter to search for the CircuitBreaker to update in case it exists.
     */
    where: CircuitBreakerWhereUniqueInput
    /**
     * In case the CircuitBreaker found by the `where` argument doesn't exist, create a new CircuitBreaker with this data.
     */
    create: XOR<CircuitBreakerCreateInput, CircuitBreakerUncheckedCreateInput>
    /**
     * In case the CircuitBreaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircuitBreakerUpdateInput, CircuitBreakerUncheckedUpdateInput>
  }

  /**
   * CircuitBreaker delete
   */
  export type CircuitBreakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
    /**
     * Filter which CircuitBreaker to delete.
     */
    where: CircuitBreakerWhereUniqueInput
  }

  /**
   * CircuitBreaker deleteMany
   */
  export type CircuitBreakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircuitBreakers to delete
     */
    where?: CircuitBreakerWhereInput
    /**
     * Limit how many CircuitBreakers to delete.
     */
    limit?: number
  }

  /**
   * CircuitBreaker without action
   */
  export type CircuitBreakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircuitBreaker
     */
    select?: CircuitBreakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircuitBreaker
     */
    omit?: CircuitBreakerOmit<ExtArgs> | null
  }


  /**
   * Model TradingStrategy
   */

  export type AggregateTradingStrategy = {
    _count: TradingStrategyCountAggregateOutputType | null
    _min: TradingStrategyMinAggregateOutputType | null
    _max: TradingStrategyMaxAggregateOutputType | null
  }

  export type TradingStrategyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    timeHorizon: string | null
    userId: string | null
    isPublic: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradingStrategyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    timeHorizon: string | null
    userId: string | null
    isPublic: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradingStrategyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    timeHorizon: number
    symbols: number
    entryRules: number
    exitRules: number
    positionSizing: number
    riskManagement: number
    userId: number
    isPublic: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradingStrategyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    timeHorizon?: true
    userId?: true
    isPublic?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradingStrategyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    timeHorizon?: true
    userId?: true
    isPublic?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradingStrategyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    timeHorizon?: true
    symbols?: true
    entryRules?: true
    exitRules?: true
    positionSizing?: true
    riskManagement?: true
    userId?: true
    isPublic?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradingStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradingStrategy to aggregate.
     */
    where?: TradingStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingStrategies to fetch.
     */
    orderBy?: TradingStrategyOrderByWithRelationInput | TradingStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradingStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradingStrategies
    **/
    _count?: true | TradingStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradingStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradingStrategyMaxAggregateInputType
  }

  export type GetTradingStrategyAggregateType<T extends TradingStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateTradingStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradingStrategy[P]>
      : GetScalarType<T[P], AggregateTradingStrategy[P]>
  }




  export type TradingStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradingStrategyWhereInput
    orderBy?: TradingStrategyOrderByWithAggregationInput | TradingStrategyOrderByWithAggregationInput[]
    by: TradingStrategyScalarFieldEnum[] | TradingStrategyScalarFieldEnum
    having?: TradingStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradingStrategyCountAggregateInputType | true
    _min?: TradingStrategyMinAggregateInputType
    _max?: TradingStrategyMaxAggregateInputType
  }

  export type TradingStrategyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    timeHorizon: string
    symbols: string[]
    entryRules: JsonValue
    exitRules: JsonValue
    positionSizing: JsonValue
    riskManagement: JsonValue
    userId: string
    isPublic: boolean
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TradingStrategyCountAggregateOutputType | null
    _min: TradingStrategyMinAggregateOutputType | null
    _max: TradingStrategyMaxAggregateOutputType | null
  }

  type GetTradingStrategyGroupByPayload<T extends TradingStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradingStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradingStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradingStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], TradingStrategyGroupByOutputType[P]>
        }
      >
    >


  export type TradingStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    timeHorizon?: boolean
    symbols?: boolean
    entryRules?: boolean
    exitRules?: boolean
    positionSizing?: boolean
    riskManagement?: boolean
    userId?: boolean
    isPublic?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    executions?: boolean | TradingStrategy$executionsArgs<ExtArgs>
    orders?: boolean | TradingStrategy$ordersArgs<ExtArgs>
    decisionLogs?: boolean | TradingStrategy$decisionLogsArgs<ExtArgs>
    _count?: boolean | TradingStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradingStrategy"]>

  export type TradingStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    timeHorizon?: boolean
    symbols?: boolean
    entryRules?: boolean
    exitRules?: boolean
    positionSizing?: boolean
    riskManagement?: boolean
    userId?: boolean
    isPublic?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradingStrategy"]>

  export type TradingStrategySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    timeHorizon?: boolean
    symbols?: boolean
    entryRules?: boolean
    exitRules?: boolean
    positionSizing?: boolean
    riskManagement?: boolean
    userId?: boolean
    isPublic?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradingStrategy"]>

  export type TradingStrategySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    timeHorizon?: boolean
    symbols?: boolean
    entryRules?: boolean
    exitRules?: boolean
    positionSizing?: boolean
    riskManagement?: boolean
    userId?: boolean
    isPublic?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradingStrategyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "timeHorizon" | "symbols" | "entryRules" | "exitRules" | "positionSizing" | "riskManagement" | "userId" | "isPublic" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["tradingStrategy"]>
  export type TradingStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | TradingStrategy$executionsArgs<ExtArgs>
    orders?: boolean | TradingStrategy$ordersArgs<ExtArgs>
    decisionLogs?: boolean | TradingStrategy$decisionLogsArgs<ExtArgs>
    _count?: boolean | TradingStrategyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TradingStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TradingStrategyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TradingStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradingStrategy"
    objects: {
      executions: Prisma.$StrategyExecutionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      decisionLogs: Prisma.$DecisionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      timeHorizon: string
      symbols: string[]
      entryRules: Prisma.JsonValue
      exitRules: Prisma.JsonValue
      positionSizing: Prisma.JsonValue
      riskManagement: Prisma.JsonValue
      userId: string
      isPublic: boolean
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tradingStrategy"]>
    composites: {}
  }

  type TradingStrategyGetPayload<S extends boolean | null | undefined | TradingStrategyDefaultArgs> = $Result.GetResult<Prisma.$TradingStrategyPayload, S>

  type TradingStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradingStrategyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradingStrategyCountAggregateInputType | true
    }

  export interface TradingStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradingStrategy'], meta: { name: 'TradingStrategy' } }
    /**
     * Find zero or one TradingStrategy that matches the filter.
     * @param {TradingStrategyFindUniqueArgs} args - Arguments to find a TradingStrategy
     * @example
     * // Get one TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradingStrategyFindUniqueArgs>(args: SelectSubset<T, TradingStrategyFindUniqueArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradingStrategy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradingStrategyFindUniqueOrThrowArgs} args - Arguments to find a TradingStrategy
     * @example
     * // Get one TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradingStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, TradingStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradingStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyFindFirstArgs} args - Arguments to find a TradingStrategy
     * @example
     * // Get one TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradingStrategyFindFirstArgs>(args?: SelectSubset<T, TradingStrategyFindFirstArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradingStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyFindFirstOrThrowArgs} args - Arguments to find a TradingStrategy
     * @example
     * // Get one TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradingStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, TradingStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradingStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradingStrategies
     * const tradingStrategies = await prisma.tradingStrategy.findMany()
     * 
     * // Get first 10 TradingStrategies
     * const tradingStrategies = await prisma.tradingStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradingStrategyWithIdOnly = await prisma.tradingStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradingStrategyFindManyArgs>(args?: SelectSubset<T, TradingStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradingStrategy.
     * @param {TradingStrategyCreateArgs} args - Arguments to create a TradingStrategy.
     * @example
     * // Create one TradingStrategy
     * const TradingStrategy = await prisma.tradingStrategy.create({
     *   data: {
     *     // ... data to create a TradingStrategy
     *   }
     * })
     * 
     */
    create<T extends TradingStrategyCreateArgs>(args: SelectSubset<T, TradingStrategyCreateArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradingStrategies.
     * @param {TradingStrategyCreateManyArgs} args - Arguments to create many TradingStrategies.
     * @example
     * // Create many TradingStrategies
     * const tradingStrategy = await prisma.tradingStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradingStrategyCreateManyArgs>(args?: SelectSubset<T, TradingStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradingStrategies and returns the data saved in the database.
     * @param {TradingStrategyCreateManyAndReturnArgs} args - Arguments to create many TradingStrategies.
     * @example
     * // Create many TradingStrategies
     * const tradingStrategy = await prisma.tradingStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradingStrategies and only return the `id`
     * const tradingStrategyWithIdOnly = await prisma.tradingStrategy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradingStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, TradingStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradingStrategy.
     * @param {TradingStrategyDeleteArgs} args - Arguments to delete one TradingStrategy.
     * @example
     * // Delete one TradingStrategy
     * const TradingStrategy = await prisma.tradingStrategy.delete({
     *   where: {
     *     // ... filter to delete one TradingStrategy
     *   }
     * })
     * 
     */
    delete<T extends TradingStrategyDeleteArgs>(args: SelectSubset<T, TradingStrategyDeleteArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradingStrategy.
     * @param {TradingStrategyUpdateArgs} args - Arguments to update one TradingStrategy.
     * @example
     * // Update one TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradingStrategyUpdateArgs>(args: SelectSubset<T, TradingStrategyUpdateArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradingStrategies.
     * @param {TradingStrategyDeleteManyArgs} args - Arguments to filter TradingStrategies to delete.
     * @example
     * // Delete a few TradingStrategies
     * const { count } = await prisma.tradingStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradingStrategyDeleteManyArgs>(args?: SelectSubset<T, TradingStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradingStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradingStrategies
     * const tradingStrategy = await prisma.tradingStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradingStrategyUpdateManyArgs>(args: SelectSubset<T, TradingStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradingStrategies and returns the data updated in the database.
     * @param {TradingStrategyUpdateManyAndReturnArgs} args - Arguments to update many TradingStrategies.
     * @example
     * // Update many TradingStrategies
     * const tradingStrategy = await prisma.tradingStrategy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradingStrategies and only return the `id`
     * const tradingStrategyWithIdOnly = await prisma.tradingStrategy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradingStrategyUpdateManyAndReturnArgs>(args: SelectSubset<T, TradingStrategyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradingStrategy.
     * @param {TradingStrategyUpsertArgs} args - Arguments to update or create a TradingStrategy.
     * @example
     * // Update or create a TradingStrategy
     * const tradingStrategy = await prisma.tradingStrategy.upsert({
     *   create: {
     *     // ... data to create a TradingStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradingStrategy we want to update
     *   }
     * })
     */
    upsert<T extends TradingStrategyUpsertArgs>(args: SelectSubset<T, TradingStrategyUpsertArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradingStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyCountArgs} args - Arguments to filter TradingStrategies to count.
     * @example
     * // Count the number of TradingStrategies
     * const count = await prisma.tradingStrategy.count({
     *   where: {
     *     // ... the filter for the TradingStrategies we want to count
     *   }
     * })
    **/
    count<T extends TradingStrategyCountArgs>(
      args?: Subset<T, TradingStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradingStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradingStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradingStrategyAggregateArgs>(args: Subset<T, TradingStrategyAggregateArgs>): Prisma.PrismaPromise<GetTradingStrategyAggregateType<T>>

    /**
     * Group by TradingStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradingStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradingStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradingStrategyGroupByArgs['orderBy'] }
        : { orderBy?: TradingStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradingStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradingStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradingStrategy model
   */
  readonly fields: TradingStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradingStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradingStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    executions<T extends TradingStrategy$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TradingStrategy$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends TradingStrategy$ordersArgs<ExtArgs> = {}>(args?: Subset<T, TradingStrategy$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decisionLogs<T extends TradingStrategy$decisionLogsArgs<ExtArgs> = {}>(args?: Subset<T, TradingStrategy$decisionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradingStrategy model
   */
  interface TradingStrategyFieldRefs {
    readonly id: FieldRef<"TradingStrategy", 'String'>
    readonly name: FieldRef<"TradingStrategy", 'String'>
    readonly description: FieldRef<"TradingStrategy", 'String'>
    readonly type: FieldRef<"TradingStrategy", 'String'>
    readonly timeHorizon: FieldRef<"TradingStrategy", 'String'>
    readonly symbols: FieldRef<"TradingStrategy", 'String[]'>
    readonly entryRules: FieldRef<"TradingStrategy", 'Json'>
    readonly exitRules: FieldRef<"TradingStrategy", 'Json'>
    readonly positionSizing: FieldRef<"TradingStrategy", 'Json'>
    readonly riskManagement: FieldRef<"TradingStrategy", 'Json'>
    readonly userId: FieldRef<"TradingStrategy", 'String'>
    readonly isPublic: FieldRef<"TradingStrategy", 'Boolean'>
    readonly isActive: FieldRef<"TradingStrategy", 'Boolean'>
    readonly metadata: FieldRef<"TradingStrategy", 'Json'>
    readonly createdAt: FieldRef<"TradingStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"TradingStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradingStrategy findUnique
   */
  export type TradingStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter, which TradingStrategy to fetch.
     */
    where: TradingStrategyWhereUniqueInput
  }

  /**
   * TradingStrategy findUniqueOrThrow
   */
  export type TradingStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter, which TradingStrategy to fetch.
     */
    where: TradingStrategyWhereUniqueInput
  }

  /**
   * TradingStrategy findFirst
   */
  export type TradingStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter, which TradingStrategy to fetch.
     */
    where?: TradingStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingStrategies to fetch.
     */
    orderBy?: TradingStrategyOrderByWithRelationInput | TradingStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradingStrategies.
     */
    cursor?: TradingStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradingStrategies.
     */
    distinct?: TradingStrategyScalarFieldEnum | TradingStrategyScalarFieldEnum[]
  }

  /**
   * TradingStrategy findFirstOrThrow
   */
  export type TradingStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter, which TradingStrategy to fetch.
     */
    where?: TradingStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingStrategies to fetch.
     */
    orderBy?: TradingStrategyOrderByWithRelationInput | TradingStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradingStrategies.
     */
    cursor?: TradingStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradingStrategies.
     */
    distinct?: TradingStrategyScalarFieldEnum | TradingStrategyScalarFieldEnum[]
  }

  /**
   * TradingStrategy findMany
   */
  export type TradingStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter, which TradingStrategies to fetch.
     */
    where?: TradingStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradingStrategies to fetch.
     */
    orderBy?: TradingStrategyOrderByWithRelationInput | TradingStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradingStrategies.
     */
    cursor?: TradingStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradingStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradingStrategies.
     */
    skip?: number
    distinct?: TradingStrategyScalarFieldEnum | TradingStrategyScalarFieldEnum[]
  }

  /**
   * TradingStrategy create
   */
  export type TradingStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a TradingStrategy.
     */
    data: XOR<TradingStrategyCreateInput, TradingStrategyUncheckedCreateInput>
  }

  /**
   * TradingStrategy createMany
   */
  export type TradingStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradingStrategies.
     */
    data: TradingStrategyCreateManyInput | TradingStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradingStrategy createManyAndReturn
   */
  export type TradingStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * The data used to create many TradingStrategies.
     */
    data: TradingStrategyCreateManyInput | TradingStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradingStrategy update
   */
  export type TradingStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a TradingStrategy.
     */
    data: XOR<TradingStrategyUpdateInput, TradingStrategyUncheckedUpdateInput>
    /**
     * Choose, which TradingStrategy to update.
     */
    where: TradingStrategyWhereUniqueInput
  }

  /**
   * TradingStrategy updateMany
   */
  export type TradingStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradingStrategies.
     */
    data: XOR<TradingStrategyUpdateManyMutationInput, TradingStrategyUncheckedUpdateManyInput>
    /**
     * Filter which TradingStrategies to update
     */
    where?: TradingStrategyWhereInput
    /**
     * Limit how many TradingStrategies to update.
     */
    limit?: number
  }

  /**
   * TradingStrategy updateManyAndReturn
   */
  export type TradingStrategyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * The data used to update TradingStrategies.
     */
    data: XOR<TradingStrategyUpdateManyMutationInput, TradingStrategyUncheckedUpdateManyInput>
    /**
     * Filter which TradingStrategies to update
     */
    where?: TradingStrategyWhereInput
    /**
     * Limit how many TradingStrategies to update.
     */
    limit?: number
  }

  /**
   * TradingStrategy upsert
   */
  export type TradingStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the TradingStrategy to update in case it exists.
     */
    where: TradingStrategyWhereUniqueInput
    /**
     * In case the TradingStrategy found by the `where` argument doesn't exist, create a new TradingStrategy with this data.
     */
    create: XOR<TradingStrategyCreateInput, TradingStrategyUncheckedCreateInput>
    /**
     * In case the TradingStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradingStrategyUpdateInput, TradingStrategyUncheckedUpdateInput>
  }

  /**
   * TradingStrategy delete
   */
  export type TradingStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    /**
     * Filter which TradingStrategy to delete.
     */
    where: TradingStrategyWhereUniqueInput
  }

  /**
   * TradingStrategy deleteMany
   */
  export type TradingStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradingStrategies to delete
     */
    where?: TradingStrategyWhereInput
    /**
     * Limit how many TradingStrategies to delete.
     */
    limit?: number
  }

  /**
   * TradingStrategy.executions
   */
  export type TradingStrategy$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    where?: StrategyExecutionWhereInput
    orderBy?: StrategyExecutionOrderByWithRelationInput | StrategyExecutionOrderByWithRelationInput[]
    cursor?: StrategyExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrategyExecutionScalarFieldEnum | StrategyExecutionScalarFieldEnum[]
  }

  /**
   * TradingStrategy.orders
   */
  export type TradingStrategy$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * TradingStrategy.decisionLogs
   */
  export type TradingStrategy$decisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * TradingStrategy without action
   */
  export type TradingStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
  }


  /**
   * Model StrategyExecution
   */

  export type AggregateStrategyExecution = {
    _count: StrategyExecutionCountAggregateOutputType | null
    _avg: StrategyExecutionAvgAggregateOutputType | null
    _sum: StrategyExecutionSumAggregateOutputType | null
    _min: StrategyExecutionMinAggregateOutputType | null
    _max: StrategyExecutionMaxAggregateOutputType | null
  }

  export type StrategyExecutionAvgAggregateOutputType = {
    runningTimeMs: number | null
  }

  export type StrategyExecutionSumAggregateOutputType = {
    runningTimeMs: number | null
  }

  export type StrategyExecutionMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    userId: string | null
    status: string | null
    startedAt: Date | null
    stoppedAt: Date | null
    runningTimeMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyExecutionMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    userId: string | null
    status: string | null
    startedAt: Date | null
    stoppedAt: Date | null
    runningTimeMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyExecutionCountAggregateOutputType = {
    id: number
    strategyId: number
    userId: number
    status: number
    startedAt: number
    stoppedAt: number
    runningTimeMs: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StrategyExecutionAvgAggregateInputType = {
    runningTimeMs?: true
  }

  export type StrategyExecutionSumAggregateInputType = {
    runningTimeMs?: true
  }

  export type StrategyExecutionMinAggregateInputType = {
    id?: true
    strategyId?: true
    userId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    runningTimeMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyExecutionMaxAggregateInputType = {
    id?: true
    strategyId?: true
    userId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    runningTimeMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyExecutionCountAggregateInputType = {
    id?: true
    strategyId?: true
    userId?: true
    status?: true
    startedAt?: true
    stoppedAt?: true
    runningTimeMs?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StrategyExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyExecution to aggregate.
     */
    where?: StrategyExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutions to fetch.
     */
    orderBy?: StrategyExecutionOrderByWithRelationInput | StrategyExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrategyExecutions
    **/
    _count?: true | StrategyExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategyExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategyExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyExecutionMaxAggregateInputType
  }

  export type GetStrategyExecutionAggregateType<T extends StrategyExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategyExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategyExecution[P]>
      : GetScalarType<T[P], AggregateStrategyExecution[P]>
  }




  export type StrategyExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyExecutionWhereInput
    orderBy?: StrategyExecutionOrderByWithAggregationInput | StrategyExecutionOrderByWithAggregationInput[]
    by: StrategyExecutionScalarFieldEnum[] | StrategyExecutionScalarFieldEnum
    having?: StrategyExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyExecutionCountAggregateInputType | true
    _avg?: StrategyExecutionAvgAggregateInputType
    _sum?: StrategyExecutionSumAggregateInputType
    _min?: StrategyExecutionMinAggregateInputType
    _max?: StrategyExecutionMaxAggregateInputType
  }

  export type StrategyExecutionGroupByOutputType = {
    id: string
    strategyId: string
    userId: string
    status: string
    startedAt: Date
    stoppedAt: Date | null
    runningTimeMs: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StrategyExecutionCountAggregateOutputType | null
    _avg: StrategyExecutionAvgAggregateOutputType | null
    _sum: StrategyExecutionSumAggregateOutputType | null
    _min: StrategyExecutionMinAggregateOutputType | null
    _max: StrategyExecutionMaxAggregateOutputType | null
  }

  type GetStrategyExecutionGroupByPayload<T extends StrategyExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyExecutionGroupByOutputType[P]>
        }
      >
    >


  export type StrategyExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    runningTimeMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
    results?: boolean | StrategyExecution$resultsArgs<ExtArgs>
    _count?: boolean | StrategyExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecution"]>

  export type StrategyExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    runningTimeMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecution"]>

  export type StrategyExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    runningTimeMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecution"]>

  export type StrategyExecutionSelectScalar = {
    id?: boolean
    strategyId?: boolean
    userId?: boolean
    status?: boolean
    startedAt?: boolean
    stoppedAt?: boolean
    runningTimeMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StrategyExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "strategyId" | "userId" | "status" | "startedAt" | "stoppedAt" | "runningTimeMs" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["strategyExecution"]>
  export type StrategyExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
    results?: boolean | StrategyExecution$resultsArgs<ExtArgs>
    _count?: boolean | StrategyExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StrategyExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
  }
  export type StrategyExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strategy?: boolean | TradingStrategyDefaultArgs<ExtArgs>
  }

  export type $StrategyExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrategyExecution"
    objects: {
      strategy: Prisma.$TradingStrategyPayload<ExtArgs>
      results: Prisma.$StrategyExecutionResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategyId: string
      userId: string
      status: string
      startedAt: Date
      stoppedAt: Date | null
      runningTimeMs: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["strategyExecution"]>
    composites: {}
  }

  type StrategyExecutionGetPayload<S extends boolean | null | undefined | StrategyExecutionDefaultArgs> = $Result.GetResult<Prisma.$StrategyExecutionPayload, S>

  type StrategyExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StrategyExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrategyExecutionCountAggregateInputType | true
    }

  export interface StrategyExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrategyExecution'], meta: { name: 'StrategyExecution' } }
    /**
     * Find zero or one StrategyExecution that matches the filter.
     * @param {StrategyExecutionFindUniqueArgs} args - Arguments to find a StrategyExecution
     * @example
     * // Get one StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyExecutionFindUniqueArgs>(args: SelectSubset<T, StrategyExecutionFindUniqueArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StrategyExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StrategyExecutionFindUniqueOrThrowArgs} args - Arguments to find a StrategyExecution
     * @example
     * // Get one StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StrategyExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionFindFirstArgs} args - Arguments to find a StrategyExecution
     * @example
     * // Get one StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyExecutionFindFirstArgs>(args?: SelectSubset<T, StrategyExecutionFindFirstArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StrategyExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionFindFirstOrThrowArgs} args - Arguments to find a StrategyExecution
     * @example
     * // Get one StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StrategyExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrategyExecutions
     * const strategyExecutions = await prisma.strategyExecution.findMany()
     * 
     * // Get first 10 StrategyExecutions
     * const strategyExecutions = await prisma.strategyExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyExecutionWithIdOnly = await prisma.strategyExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyExecutionFindManyArgs>(args?: SelectSubset<T, StrategyExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StrategyExecution.
     * @param {StrategyExecutionCreateArgs} args - Arguments to create a StrategyExecution.
     * @example
     * // Create one StrategyExecution
     * const StrategyExecution = await prisma.strategyExecution.create({
     *   data: {
     *     // ... data to create a StrategyExecution
     *   }
     * })
     * 
     */
    create<T extends StrategyExecutionCreateArgs>(args: SelectSubset<T, StrategyExecutionCreateArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StrategyExecutions.
     * @param {StrategyExecutionCreateManyArgs} args - Arguments to create many StrategyExecutions.
     * @example
     * // Create many StrategyExecutions
     * const strategyExecution = await prisma.strategyExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyExecutionCreateManyArgs>(args?: SelectSubset<T, StrategyExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrategyExecutions and returns the data saved in the database.
     * @param {StrategyExecutionCreateManyAndReturnArgs} args - Arguments to create many StrategyExecutions.
     * @example
     * // Create many StrategyExecutions
     * const strategyExecution = await prisma.strategyExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrategyExecutions and only return the `id`
     * const strategyExecutionWithIdOnly = await prisma.strategyExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StrategyExecution.
     * @param {StrategyExecutionDeleteArgs} args - Arguments to delete one StrategyExecution.
     * @example
     * // Delete one StrategyExecution
     * const StrategyExecution = await prisma.strategyExecution.delete({
     *   where: {
     *     // ... filter to delete one StrategyExecution
     *   }
     * })
     * 
     */
    delete<T extends StrategyExecutionDeleteArgs>(args: SelectSubset<T, StrategyExecutionDeleteArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StrategyExecution.
     * @param {StrategyExecutionUpdateArgs} args - Arguments to update one StrategyExecution.
     * @example
     * // Update one StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyExecutionUpdateArgs>(args: SelectSubset<T, StrategyExecutionUpdateArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StrategyExecutions.
     * @param {StrategyExecutionDeleteManyArgs} args - Arguments to filter StrategyExecutions to delete.
     * @example
     * // Delete a few StrategyExecutions
     * const { count } = await prisma.strategyExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyExecutionDeleteManyArgs>(args?: SelectSubset<T, StrategyExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrategyExecutions
     * const strategyExecution = await prisma.strategyExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyExecutionUpdateManyArgs>(args: SelectSubset<T, StrategyExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyExecutions and returns the data updated in the database.
     * @param {StrategyExecutionUpdateManyAndReturnArgs} args - Arguments to update many StrategyExecutions.
     * @example
     * // Update many StrategyExecutions
     * const strategyExecution = await prisma.strategyExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StrategyExecutions and only return the `id`
     * const strategyExecutionWithIdOnly = await prisma.strategyExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StrategyExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, StrategyExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StrategyExecution.
     * @param {StrategyExecutionUpsertArgs} args - Arguments to update or create a StrategyExecution.
     * @example
     * // Update or create a StrategyExecution
     * const strategyExecution = await prisma.strategyExecution.upsert({
     *   create: {
     *     // ... data to create a StrategyExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrategyExecution we want to update
     *   }
     * })
     */
    upsert<T extends StrategyExecutionUpsertArgs>(args: SelectSubset<T, StrategyExecutionUpsertArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StrategyExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionCountArgs} args - Arguments to filter StrategyExecutions to count.
     * @example
     * // Count the number of StrategyExecutions
     * const count = await prisma.strategyExecution.count({
     *   where: {
     *     // ... the filter for the StrategyExecutions we want to count
     *   }
     * })
    **/
    count<T extends StrategyExecutionCountArgs>(
      args?: Subset<T, StrategyExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrategyExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyExecutionAggregateArgs>(args: Subset<T, StrategyExecutionAggregateArgs>): Prisma.PrismaPromise<GetStrategyExecutionAggregateType<T>>

    /**
     * Group by StrategyExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyExecutionGroupByArgs['orderBy'] }
        : { orderBy?: StrategyExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrategyExecution model
   */
  readonly fields: StrategyExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrategyExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strategy<T extends TradingStrategyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TradingStrategyDefaultArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    results<T extends StrategyExecution$resultsArgs<ExtArgs> = {}>(args?: Subset<T, StrategyExecution$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrategyExecution model
   */
  interface StrategyExecutionFieldRefs {
    readonly id: FieldRef<"StrategyExecution", 'String'>
    readonly strategyId: FieldRef<"StrategyExecution", 'String'>
    readonly userId: FieldRef<"StrategyExecution", 'String'>
    readonly status: FieldRef<"StrategyExecution", 'String'>
    readonly startedAt: FieldRef<"StrategyExecution", 'DateTime'>
    readonly stoppedAt: FieldRef<"StrategyExecution", 'DateTime'>
    readonly runningTimeMs: FieldRef<"StrategyExecution", 'Int'>
    readonly metadata: FieldRef<"StrategyExecution", 'Json'>
    readonly createdAt: FieldRef<"StrategyExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"StrategyExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StrategyExecution findUnique
   */
  export type StrategyExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecution to fetch.
     */
    where: StrategyExecutionWhereUniqueInput
  }

  /**
   * StrategyExecution findUniqueOrThrow
   */
  export type StrategyExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecution to fetch.
     */
    where: StrategyExecutionWhereUniqueInput
  }

  /**
   * StrategyExecution findFirst
   */
  export type StrategyExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecution to fetch.
     */
    where?: StrategyExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutions to fetch.
     */
    orderBy?: StrategyExecutionOrderByWithRelationInput | StrategyExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyExecutions.
     */
    cursor?: StrategyExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyExecutions.
     */
    distinct?: StrategyExecutionScalarFieldEnum | StrategyExecutionScalarFieldEnum[]
  }

  /**
   * StrategyExecution findFirstOrThrow
   */
  export type StrategyExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecution to fetch.
     */
    where?: StrategyExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutions to fetch.
     */
    orderBy?: StrategyExecutionOrderByWithRelationInput | StrategyExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyExecutions.
     */
    cursor?: StrategyExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyExecutions.
     */
    distinct?: StrategyExecutionScalarFieldEnum | StrategyExecutionScalarFieldEnum[]
  }

  /**
   * StrategyExecution findMany
   */
  export type StrategyExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutions to fetch.
     */
    where?: StrategyExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutions to fetch.
     */
    orderBy?: StrategyExecutionOrderByWithRelationInput | StrategyExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrategyExecutions.
     */
    cursor?: StrategyExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutions.
     */
    skip?: number
    distinct?: StrategyExecutionScalarFieldEnum | StrategyExecutionScalarFieldEnum[]
  }

  /**
   * StrategyExecution create
   */
  export type StrategyExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a StrategyExecution.
     */
    data: XOR<StrategyExecutionCreateInput, StrategyExecutionUncheckedCreateInput>
  }

  /**
   * StrategyExecution createMany
   */
  export type StrategyExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrategyExecutions.
     */
    data: StrategyExecutionCreateManyInput | StrategyExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrategyExecution createManyAndReturn
   */
  export type StrategyExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many StrategyExecutions.
     */
    data: StrategyExecutionCreateManyInput | StrategyExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyExecution update
   */
  export type StrategyExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a StrategyExecution.
     */
    data: XOR<StrategyExecutionUpdateInput, StrategyExecutionUncheckedUpdateInput>
    /**
     * Choose, which StrategyExecution to update.
     */
    where: StrategyExecutionWhereUniqueInput
  }

  /**
   * StrategyExecution updateMany
   */
  export type StrategyExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrategyExecutions.
     */
    data: XOR<StrategyExecutionUpdateManyMutationInput, StrategyExecutionUncheckedUpdateManyInput>
    /**
     * Filter which StrategyExecutions to update
     */
    where?: StrategyExecutionWhereInput
    /**
     * Limit how many StrategyExecutions to update.
     */
    limit?: number
  }

  /**
   * StrategyExecution updateManyAndReturn
   */
  export type StrategyExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * The data used to update StrategyExecutions.
     */
    data: XOR<StrategyExecutionUpdateManyMutationInput, StrategyExecutionUncheckedUpdateManyInput>
    /**
     * Filter which StrategyExecutions to update
     */
    where?: StrategyExecutionWhereInput
    /**
     * Limit how many StrategyExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyExecution upsert
   */
  export type StrategyExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the StrategyExecution to update in case it exists.
     */
    where: StrategyExecutionWhereUniqueInput
    /**
     * In case the StrategyExecution found by the `where` argument doesn't exist, create a new StrategyExecution with this data.
     */
    create: XOR<StrategyExecutionCreateInput, StrategyExecutionUncheckedCreateInput>
    /**
     * In case the StrategyExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyExecutionUpdateInput, StrategyExecutionUncheckedUpdateInput>
  }

  /**
   * StrategyExecution delete
   */
  export type StrategyExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
    /**
     * Filter which StrategyExecution to delete.
     */
    where: StrategyExecutionWhereUniqueInput
  }

  /**
   * StrategyExecution deleteMany
   */
  export type StrategyExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyExecutions to delete
     */
    where?: StrategyExecutionWhereInput
    /**
     * Limit how many StrategyExecutions to delete.
     */
    limit?: number
  }

  /**
   * StrategyExecution.results
   */
  export type StrategyExecution$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    where?: StrategyExecutionResultWhereInput
    orderBy?: StrategyExecutionResultOrderByWithRelationInput | StrategyExecutionResultOrderByWithRelationInput[]
    cursor?: StrategyExecutionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrategyExecutionResultScalarFieldEnum | StrategyExecutionResultScalarFieldEnum[]
  }

  /**
   * StrategyExecution without action
   */
  export type StrategyExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecution
     */
    select?: StrategyExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecution
     */
    omit?: StrategyExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionInclude<ExtArgs> | null
  }


  /**
   * Model StrategyExecutionResult
   */

  export type AggregateStrategyExecutionResult = {
    _count: StrategyExecutionResultCountAggregateOutputType | null
    _avg: StrategyExecutionResultAvgAggregateOutputType | null
    _sum: StrategyExecutionResultSumAggregateOutputType | null
    _min: StrategyExecutionResultMinAggregateOutputType | null
    _max: StrategyExecutionResultMaxAggregateOutputType | null
  }

  export type StrategyExecutionResultAvgAggregateOutputType = {
    entryPrice: number | null
    exitPrice: number | null
    quantity: number | null
    profitLoss: number | null
    profitLossPercentage: number | null
  }

  export type StrategyExecutionResultSumAggregateOutputType = {
    entryPrice: number | null
    exitPrice: number | null
    quantity: number | null
    profitLoss: number | null
    profitLossPercentage: number | null
  }

  export type StrategyExecutionResultMinAggregateOutputType = {
    id: string | null
    executionId: string | null
    symbol: string | null
    entryTime: Date | null
    entryPrice: number | null
    exitTime: Date | null
    exitPrice: number | null
    direction: string | null
    quantity: number | null
    profitLoss: number | null
    profitLossPercentage: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyExecutionResultMaxAggregateOutputType = {
    id: string | null
    executionId: string | null
    symbol: string | null
    entryTime: Date | null
    entryPrice: number | null
    exitTime: Date | null
    exitPrice: number | null
    direction: string | null
    quantity: number | null
    profitLoss: number | null
    profitLossPercentage: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StrategyExecutionResultCountAggregateOutputType = {
    id: number
    executionId: number
    symbol: number
    entryTime: number
    entryPrice: number
    exitTime: number
    exitPrice: number
    direction: number
    quantity: number
    profitLoss: number
    profitLossPercentage: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StrategyExecutionResultAvgAggregateInputType = {
    entryPrice?: true
    exitPrice?: true
    quantity?: true
    profitLoss?: true
    profitLossPercentage?: true
  }

  export type StrategyExecutionResultSumAggregateInputType = {
    entryPrice?: true
    exitPrice?: true
    quantity?: true
    profitLoss?: true
    profitLossPercentage?: true
  }

  export type StrategyExecutionResultMinAggregateInputType = {
    id?: true
    executionId?: true
    symbol?: true
    entryTime?: true
    entryPrice?: true
    exitTime?: true
    exitPrice?: true
    direction?: true
    quantity?: true
    profitLoss?: true
    profitLossPercentage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyExecutionResultMaxAggregateInputType = {
    id?: true
    executionId?: true
    symbol?: true
    entryTime?: true
    entryPrice?: true
    exitTime?: true
    exitPrice?: true
    direction?: true
    quantity?: true
    profitLoss?: true
    profitLossPercentage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StrategyExecutionResultCountAggregateInputType = {
    id?: true
    executionId?: true
    symbol?: true
    entryTime?: true
    entryPrice?: true
    exitTime?: true
    exitPrice?: true
    direction?: true
    quantity?: true
    profitLoss?: true
    profitLossPercentage?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StrategyExecutionResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyExecutionResult to aggregate.
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutionResults to fetch.
     */
    orderBy?: StrategyExecutionResultOrderByWithRelationInput | StrategyExecutionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrategyExecutionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrategyExecutionResults
    **/
    _count?: true | StrategyExecutionResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategyExecutionResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategyExecutionResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyExecutionResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyExecutionResultMaxAggregateInputType
  }

  export type GetStrategyExecutionResultAggregateType<T extends StrategyExecutionResultAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategyExecutionResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategyExecutionResult[P]>
      : GetScalarType<T[P], AggregateStrategyExecutionResult[P]>
  }




  export type StrategyExecutionResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrategyExecutionResultWhereInput
    orderBy?: StrategyExecutionResultOrderByWithAggregationInput | StrategyExecutionResultOrderByWithAggregationInput[]
    by: StrategyExecutionResultScalarFieldEnum[] | StrategyExecutionResultScalarFieldEnum
    having?: StrategyExecutionResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyExecutionResultCountAggregateInputType | true
    _avg?: StrategyExecutionResultAvgAggregateInputType
    _sum?: StrategyExecutionResultSumAggregateInputType
    _min?: StrategyExecutionResultMinAggregateInputType
    _max?: StrategyExecutionResultMaxAggregateInputType
  }

  export type StrategyExecutionResultGroupByOutputType = {
    id: string
    executionId: string
    symbol: string
    entryTime: Date | null
    entryPrice: number | null
    exitTime: Date | null
    exitPrice: number | null
    direction: string
    quantity: number | null
    profitLoss: number | null
    profitLossPercentage: number | null
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StrategyExecutionResultCountAggregateOutputType | null
    _avg: StrategyExecutionResultAvgAggregateOutputType | null
    _sum: StrategyExecutionResultSumAggregateOutputType | null
    _min: StrategyExecutionResultMinAggregateOutputType | null
    _max: StrategyExecutionResultMaxAggregateOutputType | null
  }

  type GetStrategyExecutionResultGroupByPayload<T extends StrategyExecutionResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrategyExecutionResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyExecutionResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyExecutionResultGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyExecutionResultGroupByOutputType[P]>
        }
      >
    >


  export type StrategyExecutionResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    symbol?: boolean
    entryTime?: boolean
    entryPrice?: boolean
    exitTime?: boolean
    exitPrice?: boolean
    direction?: boolean
    quantity?: boolean
    profitLoss?: boolean
    profitLossPercentage?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecutionResult"]>

  export type StrategyExecutionResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    symbol?: boolean
    entryTime?: boolean
    entryPrice?: boolean
    exitTime?: boolean
    exitPrice?: boolean
    direction?: boolean
    quantity?: boolean
    profitLoss?: boolean
    profitLossPercentage?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecutionResult"]>

  export type StrategyExecutionResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executionId?: boolean
    symbol?: boolean
    entryTime?: boolean
    entryPrice?: boolean
    exitTime?: boolean
    exitPrice?: boolean
    direction?: boolean
    quantity?: boolean
    profitLoss?: boolean
    profitLossPercentage?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strategyExecutionResult"]>

  export type StrategyExecutionResultSelectScalar = {
    id?: boolean
    executionId?: boolean
    symbol?: boolean
    entryTime?: boolean
    entryPrice?: boolean
    exitTime?: boolean
    exitPrice?: boolean
    direction?: boolean
    quantity?: boolean
    profitLoss?: boolean
    profitLossPercentage?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StrategyExecutionResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executionId" | "symbol" | "entryTime" | "entryPrice" | "exitTime" | "exitPrice" | "direction" | "quantity" | "profitLoss" | "profitLossPercentage" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["strategyExecutionResult"]>
  export type StrategyExecutionResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }
  export type StrategyExecutionResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }
  export type StrategyExecutionResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    execution?: boolean | StrategyExecutionDefaultArgs<ExtArgs>
  }

  export type $StrategyExecutionResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrategyExecutionResult"
    objects: {
      execution: Prisma.$StrategyExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executionId: string
      symbol: string
      entryTime: Date | null
      entryPrice: number | null
      exitTime: Date | null
      exitPrice: number | null
      direction: string
      quantity: number | null
      profitLoss: number | null
      profitLossPercentage: number | null
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["strategyExecutionResult"]>
    composites: {}
  }

  type StrategyExecutionResultGetPayload<S extends boolean | null | undefined | StrategyExecutionResultDefaultArgs> = $Result.GetResult<Prisma.$StrategyExecutionResultPayload, S>

  type StrategyExecutionResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StrategyExecutionResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrategyExecutionResultCountAggregateInputType | true
    }

  export interface StrategyExecutionResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrategyExecutionResult'], meta: { name: 'StrategyExecutionResult' } }
    /**
     * Find zero or one StrategyExecutionResult that matches the filter.
     * @param {StrategyExecutionResultFindUniqueArgs} args - Arguments to find a StrategyExecutionResult
     * @example
     * // Get one StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrategyExecutionResultFindUniqueArgs>(args: SelectSubset<T, StrategyExecutionResultFindUniqueArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StrategyExecutionResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StrategyExecutionResultFindUniqueOrThrowArgs} args - Arguments to find a StrategyExecutionResult
     * @example
     * // Get one StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrategyExecutionResultFindUniqueOrThrowArgs>(args: SelectSubset<T, StrategyExecutionResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StrategyExecutionResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultFindFirstArgs} args - Arguments to find a StrategyExecutionResult
     * @example
     * // Get one StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrategyExecutionResultFindFirstArgs>(args?: SelectSubset<T, StrategyExecutionResultFindFirstArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StrategyExecutionResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultFindFirstOrThrowArgs} args - Arguments to find a StrategyExecutionResult
     * @example
     * // Get one StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrategyExecutionResultFindFirstOrThrowArgs>(args?: SelectSubset<T, StrategyExecutionResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StrategyExecutionResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrategyExecutionResults
     * const strategyExecutionResults = await prisma.strategyExecutionResult.findMany()
     * 
     * // Get first 10 StrategyExecutionResults
     * const strategyExecutionResults = await prisma.strategyExecutionResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyExecutionResultWithIdOnly = await prisma.strategyExecutionResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrategyExecutionResultFindManyArgs>(args?: SelectSubset<T, StrategyExecutionResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StrategyExecutionResult.
     * @param {StrategyExecutionResultCreateArgs} args - Arguments to create a StrategyExecutionResult.
     * @example
     * // Create one StrategyExecutionResult
     * const StrategyExecutionResult = await prisma.strategyExecutionResult.create({
     *   data: {
     *     // ... data to create a StrategyExecutionResult
     *   }
     * })
     * 
     */
    create<T extends StrategyExecutionResultCreateArgs>(args: SelectSubset<T, StrategyExecutionResultCreateArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StrategyExecutionResults.
     * @param {StrategyExecutionResultCreateManyArgs} args - Arguments to create many StrategyExecutionResults.
     * @example
     * // Create many StrategyExecutionResults
     * const strategyExecutionResult = await prisma.strategyExecutionResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrategyExecutionResultCreateManyArgs>(args?: SelectSubset<T, StrategyExecutionResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrategyExecutionResults and returns the data saved in the database.
     * @param {StrategyExecutionResultCreateManyAndReturnArgs} args - Arguments to create many StrategyExecutionResults.
     * @example
     * // Create many StrategyExecutionResults
     * const strategyExecutionResult = await prisma.strategyExecutionResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrategyExecutionResults and only return the `id`
     * const strategyExecutionResultWithIdOnly = await prisma.strategyExecutionResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrategyExecutionResultCreateManyAndReturnArgs>(args?: SelectSubset<T, StrategyExecutionResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StrategyExecutionResult.
     * @param {StrategyExecutionResultDeleteArgs} args - Arguments to delete one StrategyExecutionResult.
     * @example
     * // Delete one StrategyExecutionResult
     * const StrategyExecutionResult = await prisma.strategyExecutionResult.delete({
     *   where: {
     *     // ... filter to delete one StrategyExecutionResult
     *   }
     * })
     * 
     */
    delete<T extends StrategyExecutionResultDeleteArgs>(args: SelectSubset<T, StrategyExecutionResultDeleteArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StrategyExecutionResult.
     * @param {StrategyExecutionResultUpdateArgs} args - Arguments to update one StrategyExecutionResult.
     * @example
     * // Update one StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrategyExecutionResultUpdateArgs>(args: SelectSubset<T, StrategyExecutionResultUpdateArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StrategyExecutionResults.
     * @param {StrategyExecutionResultDeleteManyArgs} args - Arguments to filter StrategyExecutionResults to delete.
     * @example
     * // Delete a few StrategyExecutionResults
     * const { count } = await prisma.strategyExecutionResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrategyExecutionResultDeleteManyArgs>(args?: SelectSubset<T, StrategyExecutionResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyExecutionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrategyExecutionResults
     * const strategyExecutionResult = await prisma.strategyExecutionResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrategyExecutionResultUpdateManyArgs>(args: SelectSubset<T, StrategyExecutionResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyExecutionResults and returns the data updated in the database.
     * @param {StrategyExecutionResultUpdateManyAndReturnArgs} args - Arguments to update many StrategyExecutionResults.
     * @example
     * // Update many StrategyExecutionResults
     * const strategyExecutionResult = await prisma.strategyExecutionResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StrategyExecutionResults and only return the `id`
     * const strategyExecutionResultWithIdOnly = await prisma.strategyExecutionResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StrategyExecutionResultUpdateManyAndReturnArgs>(args: SelectSubset<T, StrategyExecutionResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StrategyExecutionResult.
     * @param {StrategyExecutionResultUpsertArgs} args - Arguments to update or create a StrategyExecutionResult.
     * @example
     * // Update or create a StrategyExecutionResult
     * const strategyExecutionResult = await prisma.strategyExecutionResult.upsert({
     *   create: {
     *     // ... data to create a StrategyExecutionResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrategyExecutionResult we want to update
     *   }
     * })
     */
    upsert<T extends StrategyExecutionResultUpsertArgs>(args: SelectSubset<T, StrategyExecutionResultUpsertArgs<ExtArgs>>): Prisma__StrategyExecutionResultClient<$Result.GetResult<Prisma.$StrategyExecutionResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StrategyExecutionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultCountArgs} args - Arguments to filter StrategyExecutionResults to count.
     * @example
     * // Count the number of StrategyExecutionResults
     * const count = await prisma.strategyExecutionResult.count({
     *   where: {
     *     // ... the filter for the StrategyExecutionResults we want to count
     *   }
     * })
    **/
    count<T extends StrategyExecutionResultCountArgs>(
      args?: Subset<T, StrategyExecutionResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyExecutionResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrategyExecutionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyExecutionResultAggregateArgs>(args: Subset<T, StrategyExecutionResultAggregateArgs>): Prisma.PrismaPromise<GetStrategyExecutionResultAggregateType<T>>

    /**
     * Group by StrategyExecutionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyExecutionResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyExecutionResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyExecutionResultGroupByArgs['orderBy'] }
        : { orderBy?: StrategyExecutionResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyExecutionResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyExecutionResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrategyExecutionResult model
   */
  readonly fields: StrategyExecutionResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrategyExecutionResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrategyExecutionResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    execution<T extends StrategyExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StrategyExecutionDefaultArgs<ExtArgs>>): Prisma__StrategyExecutionClient<$Result.GetResult<Prisma.$StrategyExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrategyExecutionResult model
   */
  interface StrategyExecutionResultFieldRefs {
    readonly id: FieldRef<"StrategyExecutionResult", 'String'>
    readonly executionId: FieldRef<"StrategyExecutionResult", 'String'>
    readonly symbol: FieldRef<"StrategyExecutionResult", 'String'>
    readonly entryTime: FieldRef<"StrategyExecutionResult", 'DateTime'>
    readonly entryPrice: FieldRef<"StrategyExecutionResult", 'Float'>
    readonly exitTime: FieldRef<"StrategyExecutionResult", 'DateTime'>
    readonly exitPrice: FieldRef<"StrategyExecutionResult", 'Float'>
    readonly direction: FieldRef<"StrategyExecutionResult", 'String'>
    readonly quantity: FieldRef<"StrategyExecutionResult", 'Float'>
    readonly profitLoss: FieldRef<"StrategyExecutionResult", 'Float'>
    readonly profitLossPercentage: FieldRef<"StrategyExecutionResult", 'Float'>
    readonly status: FieldRef<"StrategyExecutionResult", 'String'>
    readonly metadata: FieldRef<"StrategyExecutionResult", 'Json'>
    readonly createdAt: FieldRef<"StrategyExecutionResult", 'DateTime'>
    readonly updatedAt: FieldRef<"StrategyExecutionResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StrategyExecutionResult findUnique
   */
  export type StrategyExecutionResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutionResult to fetch.
     */
    where: StrategyExecutionResultWhereUniqueInput
  }

  /**
   * StrategyExecutionResult findUniqueOrThrow
   */
  export type StrategyExecutionResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutionResult to fetch.
     */
    where: StrategyExecutionResultWhereUniqueInput
  }

  /**
   * StrategyExecutionResult findFirst
   */
  export type StrategyExecutionResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutionResult to fetch.
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutionResults to fetch.
     */
    orderBy?: StrategyExecutionResultOrderByWithRelationInput | StrategyExecutionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyExecutionResults.
     */
    cursor?: StrategyExecutionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyExecutionResults.
     */
    distinct?: StrategyExecutionResultScalarFieldEnum | StrategyExecutionResultScalarFieldEnum[]
  }

  /**
   * StrategyExecutionResult findFirstOrThrow
   */
  export type StrategyExecutionResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutionResult to fetch.
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutionResults to fetch.
     */
    orderBy?: StrategyExecutionResultOrderByWithRelationInput | StrategyExecutionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyExecutionResults.
     */
    cursor?: StrategyExecutionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyExecutionResults.
     */
    distinct?: StrategyExecutionResultScalarFieldEnum | StrategyExecutionResultScalarFieldEnum[]
  }

  /**
   * StrategyExecutionResult findMany
   */
  export type StrategyExecutionResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter, which StrategyExecutionResults to fetch.
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyExecutionResults to fetch.
     */
    orderBy?: StrategyExecutionResultOrderByWithRelationInput | StrategyExecutionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrategyExecutionResults.
     */
    cursor?: StrategyExecutionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyExecutionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyExecutionResults.
     */
    skip?: number
    distinct?: StrategyExecutionResultScalarFieldEnum | StrategyExecutionResultScalarFieldEnum[]
  }

  /**
   * StrategyExecutionResult create
   */
  export type StrategyExecutionResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * The data needed to create a StrategyExecutionResult.
     */
    data: XOR<StrategyExecutionResultCreateInput, StrategyExecutionResultUncheckedCreateInput>
  }

  /**
   * StrategyExecutionResult createMany
   */
  export type StrategyExecutionResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrategyExecutionResults.
     */
    data: StrategyExecutionResultCreateManyInput | StrategyExecutionResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrategyExecutionResult createManyAndReturn
   */
  export type StrategyExecutionResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * The data used to create many StrategyExecutionResults.
     */
    data: StrategyExecutionResultCreateManyInput | StrategyExecutionResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyExecutionResult update
   */
  export type StrategyExecutionResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * The data needed to update a StrategyExecutionResult.
     */
    data: XOR<StrategyExecutionResultUpdateInput, StrategyExecutionResultUncheckedUpdateInput>
    /**
     * Choose, which StrategyExecutionResult to update.
     */
    where: StrategyExecutionResultWhereUniqueInput
  }

  /**
   * StrategyExecutionResult updateMany
   */
  export type StrategyExecutionResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrategyExecutionResults.
     */
    data: XOR<StrategyExecutionResultUpdateManyMutationInput, StrategyExecutionResultUncheckedUpdateManyInput>
    /**
     * Filter which StrategyExecutionResults to update
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * Limit how many StrategyExecutionResults to update.
     */
    limit?: number
  }

  /**
   * StrategyExecutionResult updateManyAndReturn
   */
  export type StrategyExecutionResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * The data used to update StrategyExecutionResults.
     */
    data: XOR<StrategyExecutionResultUpdateManyMutationInput, StrategyExecutionResultUncheckedUpdateManyInput>
    /**
     * Filter which StrategyExecutionResults to update
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * Limit how many StrategyExecutionResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrategyExecutionResult upsert
   */
  export type StrategyExecutionResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * The filter to search for the StrategyExecutionResult to update in case it exists.
     */
    where: StrategyExecutionResultWhereUniqueInput
    /**
     * In case the StrategyExecutionResult found by the `where` argument doesn't exist, create a new StrategyExecutionResult with this data.
     */
    create: XOR<StrategyExecutionResultCreateInput, StrategyExecutionResultUncheckedCreateInput>
    /**
     * In case the StrategyExecutionResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrategyExecutionResultUpdateInput, StrategyExecutionResultUncheckedUpdateInput>
  }

  /**
   * StrategyExecutionResult delete
   */
  export type StrategyExecutionResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
    /**
     * Filter which StrategyExecutionResult to delete.
     */
    where: StrategyExecutionResultWhereUniqueInput
  }

  /**
   * StrategyExecutionResult deleteMany
   */
  export type StrategyExecutionResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrategyExecutionResults to delete
     */
    where?: StrategyExecutionResultWhereInput
    /**
     * Limit how many StrategyExecutionResults to delete.
     */
    limit?: number
  }

  /**
   * StrategyExecutionResult without action
   */
  export type StrategyExecutionResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrategyExecutionResult
     */
    select?: StrategyExecutionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrategyExecutionResult
     */
    omit?: StrategyExecutionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrategyExecutionResultInclude<ExtArgs> | null
  }


  /**
   * Model MLModel
   */

  export type AggregateMLModel = {
    _count: MLModelCountAggregateOutputType | null
    _avg: MLModelAvgAggregateOutputType | null
    _sum: MLModelSumAggregateOutputType | null
    _min: MLModelMinAggregateOutputType | null
    _max: MLModelMaxAggregateOutputType | null
  }

  export type MLModelAvgAggregateOutputType = {
    accuracy: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
  }

  export type MLModelSumAggregateOutputType = {
    accuracy: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
  }

  export type MLModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    modelType: string | null
    symbol: string | null
    timeframe: string | null
    description: string | null
    status: string | null
    accuracy: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    trainedAt: Date | null
    lastUsedAt: Date | null
    trainingId: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    modelType: string | null
    symbol: string | null
    timeframe: string | null
    description: string | null
    status: string | null
    accuracy: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    trainedAt: Date | null
    lastUsedAt: Date | null
    trainingId: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLModelCountAggregateOutputType = {
    id: number
    name: number
    version: number
    modelType: number
    symbol: number
    timeframe: number
    description: number
    status: number
    accuracy: number
    precision: number
    recall: number
    f1Score: number
    trainedAt: number
    lastUsedAt: number
    trainingId: number
    location: number
    params: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MLModelAvgAggregateInputType = {
    accuracy?: true
    precision?: true
    recall?: true
    f1Score?: true
  }

  export type MLModelSumAggregateInputType = {
    accuracy?: true
    precision?: true
    recall?: true
    f1Score?: true
  }

  export type MLModelMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    modelType?: true
    symbol?: true
    timeframe?: true
    description?: true
    status?: true
    accuracy?: true
    precision?: true
    recall?: true
    f1Score?: true
    trainedAt?: true
    lastUsedAt?: true
    trainingId?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLModelMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    modelType?: true
    symbol?: true
    timeframe?: true
    description?: true
    status?: true
    accuracy?: true
    precision?: true
    recall?: true
    f1Score?: true
    trainedAt?: true
    lastUsedAt?: true
    trainingId?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLModelCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    modelType?: true
    symbol?: true
    timeframe?: true
    description?: true
    status?: true
    accuracy?: true
    precision?: true
    recall?: true
    f1Score?: true
    trainedAt?: true
    lastUsedAt?: true
    trainingId?: true
    location?: true
    params?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MLModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLModel to aggregate.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MLModels
    **/
    _count?: true | MLModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MLModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MLModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MLModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MLModelMaxAggregateInputType
  }

  export type GetMLModelAggregateType<T extends MLModelAggregateArgs> = {
        [P in keyof T & keyof AggregateMLModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMLModel[P]>
      : GetScalarType<T[P], AggregateMLModel[P]>
  }




  export type MLModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MLModelWhereInput
    orderBy?: MLModelOrderByWithAggregationInput | MLModelOrderByWithAggregationInput[]
    by: MLModelScalarFieldEnum[] | MLModelScalarFieldEnum
    having?: MLModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MLModelCountAggregateInputType | true
    _avg?: MLModelAvgAggregateInputType
    _sum?: MLModelSumAggregateInputType
    _min?: MLModelMinAggregateInputType
    _max?: MLModelMaxAggregateInputType
  }

  export type MLModelGroupByOutputType = {
    id: string
    name: string
    version: string
    modelType: string
    symbol: string | null
    timeframe: string | null
    description: string | null
    status: string
    accuracy: number | null
    precision: number | null
    recall: number | null
    f1Score: number | null
    trainedAt: Date | null
    lastUsedAt: Date | null
    trainingId: string | null
    location: string | null
    params: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MLModelCountAggregateOutputType | null
    _avg: MLModelAvgAggregateOutputType | null
    _sum: MLModelSumAggregateOutputType | null
    _min: MLModelMinAggregateOutputType | null
    _max: MLModelMaxAggregateOutputType | null
  }

  type GetMLModelGroupByPayload<T extends MLModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MLModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MLModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MLModelGroupByOutputType[P]>
            : GetScalarType<T[P], MLModelGroupByOutputType[P]>
        }
      >
    >


  export type MLModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    modelType?: boolean
    symbol?: boolean
    timeframe?: boolean
    description?: boolean
    status?: boolean
    accuracy?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    trainedAt?: boolean
    lastUsedAt?: boolean
    trainingId?: boolean
    location?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    predictions?: boolean | MLModel$predictionsArgs<ExtArgs>
    _count?: boolean | MLModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    modelType?: boolean
    symbol?: boolean
    timeframe?: boolean
    description?: boolean
    status?: boolean
    accuracy?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    trainedAt?: boolean
    lastUsedAt?: boolean
    trainingId?: boolean
    location?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    modelType?: boolean
    symbol?: boolean
    timeframe?: boolean
    description?: boolean
    status?: boolean
    accuracy?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    trainedAt?: boolean
    lastUsedAt?: boolean
    trainingId?: boolean
    location?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    modelType?: boolean
    symbol?: boolean
    timeframe?: boolean
    description?: boolean
    status?: boolean
    accuracy?: boolean
    precision?: boolean
    recall?: boolean
    f1Score?: boolean
    trainedAt?: boolean
    lastUsedAt?: boolean
    trainingId?: boolean
    location?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MLModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version" | "modelType" | "symbol" | "timeframe" | "description" | "status" | "accuracy" | "precision" | "recall" | "f1Score" | "trainedAt" | "lastUsedAt" | "trainingId" | "location" | "params" | "createdAt" | "updatedAt", ExtArgs["result"]["mLModel"]>
  export type MLModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predictions?: boolean | MLModel$predictionsArgs<ExtArgs>
    _count?: boolean | MLModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MLModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MLModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MLModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MLModel"
    objects: {
      predictions: Prisma.$MLPredictionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      modelType: string
      symbol: string | null
      timeframe: string | null
      description: string | null
      status: string
      accuracy: number | null
      precision: number | null
      recall: number | null
      f1Score: number | null
      trainedAt: Date | null
      lastUsedAt: Date | null
      trainingId: string | null
      location: string | null
      params: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mLModel"]>
    composites: {}
  }

  type MLModelGetPayload<S extends boolean | null | undefined | MLModelDefaultArgs> = $Result.GetResult<Prisma.$MLModelPayload, S>

  type MLModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MLModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MLModelCountAggregateInputType | true
    }

  export interface MLModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MLModel'], meta: { name: 'MLModel' } }
    /**
     * Find zero or one MLModel that matches the filter.
     * @param {MLModelFindUniqueArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MLModelFindUniqueArgs>(args: SelectSubset<T, MLModelFindUniqueArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MLModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MLModelFindUniqueOrThrowArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MLModelFindUniqueOrThrowArgs>(args: SelectSubset<T, MLModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindFirstArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MLModelFindFirstArgs>(args?: SelectSubset<T, MLModelFindFirstArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindFirstOrThrowArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MLModelFindFirstOrThrowArgs>(args?: SelectSubset<T, MLModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MLModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MLModels
     * const mLModels = await prisma.mLModel.findMany()
     * 
     * // Get first 10 MLModels
     * const mLModels = await prisma.mLModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MLModelFindManyArgs>(args?: SelectSubset<T, MLModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MLModel.
     * @param {MLModelCreateArgs} args - Arguments to create a MLModel.
     * @example
     * // Create one MLModel
     * const MLModel = await prisma.mLModel.create({
     *   data: {
     *     // ... data to create a MLModel
     *   }
     * })
     * 
     */
    create<T extends MLModelCreateArgs>(args: SelectSubset<T, MLModelCreateArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MLModels.
     * @param {MLModelCreateManyArgs} args - Arguments to create many MLModels.
     * @example
     * // Create many MLModels
     * const mLModel = await prisma.mLModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MLModelCreateManyArgs>(args?: SelectSubset<T, MLModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MLModels and returns the data saved in the database.
     * @param {MLModelCreateManyAndReturnArgs} args - Arguments to create many MLModels.
     * @example
     * // Create many MLModels
     * const mLModel = await prisma.mLModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MLModels and only return the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MLModelCreateManyAndReturnArgs>(args?: SelectSubset<T, MLModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MLModel.
     * @param {MLModelDeleteArgs} args - Arguments to delete one MLModel.
     * @example
     * // Delete one MLModel
     * const MLModel = await prisma.mLModel.delete({
     *   where: {
     *     // ... filter to delete one MLModel
     *   }
     * })
     * 
     */
    delete<T extends MLModelDeleteArgs>(args: SelectSubset<T, MLModelDeleteArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MLModel.
     * @param {MLModelUpdateArgs} args - Arguments to update one MLModel.
     * @example
     * // Update one MLModel
     * const mLModel = await prisma.mLModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MLModelUpdateArgs>(args: SelectSubset<T, MLModelUpdateArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MLModels.
     * @param {MLModelDeleteManyArgs} args - Arguments to filter MLModels to delete.
     * @example
     * // Delete a few MLModels
     * const { count } = await prisma.mLModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MLModelDeleteManyArgs>(args?: SelectSubset<T, MLModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MLModels
     * const mLModel = await prisma.mLModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MLModelUpdateManyArgs>(args: SelectSubset<T, MLModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLModels and returns the data updated in the database.
     * @param {MLModelUpdateManyAndReturnArgs} args - Arguments to update many MLModels.
     * @example
     * // Update many MLModels
     * const mLModel = await prisma.mLModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MLModels and only return the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MLModelUpdateManyAndReturnArgs>(args: SelectSubset<T, MLModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MLModel.
     * @param {MLModelUpsertArgs} args - Arguments to update or create a MLModel.
     * @example
     * // Update or create a MLModel
     * const mLModel = await prisma.mLModel.upsert({
     *   create: {
     *     // ... data to create a MLModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MLModel we want to update
     *   }
     * })
     */
    upsert<T extends MLModelUpsertArgs>(args: SelectSubset<T, MLModelUpsertArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MLModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelCountArgs} args - Arguments to filter MLModels to count.
     * @example
     * // Count the number of MLModels
     * const count = await prisma.mLModel.count({
     *   where: {
     *     // ... the filter for the MLModels we want to count
     *   }
     * })
    **/
    count<T extends MLModelCountArgs>(
      args?: Subset<T, MLModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MLModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MLModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MLModelAggregateArgs>(args: Subset<T, MLModelAggregateArgs>): Prisma.PrismaPromise<GetMLModelAggregateType<T>>

    /**
     * Group by MLModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MLModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MLModelGroupByArgs['orderBy'] }
        : { orderBy?: MLModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MLModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMLModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MLModel model
   */
  readonly fields: MLModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MLModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MLModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    predictions<T extends MLModel$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, MLModel$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MLModel model
   */
  interface MLModelFieldRefs {
    readonly id: FieldRef<"MLModel", 'String'>
    readonly name: FieldRef<"MLModel", 'String'>
    readonly version: FieldRef<"MLModel", 'String'>
    readonly modelType: FieldRef<"MLModel", 'String'>
    readonly symbol: FieldRef<"MLModel", 'String'>
    readonly timeframe: FieldRef<"MLModel", 'String'>
    readonly description: FieldRef<"MLModel", 'String'>
    readonly status: FieldRef<"MLModel", 'String'>
    readonly accuracy: FieldRef<"MLModel", 'Float'>
    readonly precision: FieldRef<"MLModel", 'Float'>
    readonly recall: FieldRef<"MLModel", 'Float'>
    readonly f1Score: FieldRef<"MLModel", 'Float'>
    readonly trainedAt: FieldRef<"MLModel", 'DateTime'>
    readonly lastUsedAt: FieldRef<"MLModel", 'DateTime'>
    readonly trainingId: FieldRef<"MLModel", 'String'>
    readonly location: FieldRef<"MLModel", 'String'>
    readonly params: FieldRef<"MLModel", 'Json'>
    readonly createdAt: FieldRef<"MLModel", 'DateTime'>
    readonly updatedAt: FieldRef<"MLModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MLModel findUnique
   */
  export type MLModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel findUniqueOrThrow
   */
  export type MLModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel findFirst
   */
  export type MLModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLModels.
     */
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel findFirstOrThrow
   */
  export type MLModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLModels.
     */
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel findMany
   */
  export type MLModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter, which MLModels to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel create
   */
  export type MLModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * The data needed to create a MLModel.
     */
    data: XOR<MLModelCreateInput, MLModelUncheckedCreateInput>
  }

  /**
   * MLModel createMany
   */
  export type MLModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MLModels.
     */
    data: MLModelCreateManyInput | MLModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLModel createManyAndReturn
   */
  export type MLModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data used to create many MLModels.
     */
    data: MLModelCreateManyInput | MLModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLModel update
   */
  export type MLModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * The data needed to update a MLModel.
     */
    data: XOR<MLModelUpdateInput, MLModelUncheckedUpdateInput>
    /**
     * Choose, which MLModel to update.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel updateMany
   */
  export type MLModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MLModels.
     */
    data: XOR<MLModelUpdateManyMutationInput, MLModelUncheckedUpdateManyInput>
    /**
     * Filter which MLModels to update
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to update.
     */
    limit?: number
  }

  /**
   * MLModel updateManyAndReturn
   */
  export type MLModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data used to update MLModels.
     */
    data: XOR<MLModelUpdateManyMutationInput, MLModelUncheckedUpdateManyInput>
    /**
     * Filter which MLModels to update
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to update.
     */
    limit?: number
  }

  /**
   * MLModel upsert
   */
  export type MLModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * The filter to search for the MLModel to update in case it exists.
     */
    where: MLModelWhereUniqueInput
    /**
     * In case the MLModel found by the `where` argument doesn't exist, create a new MLModel with this data.
     */
    create: XOR<MLModelCreateInput, MLModelUncheckedCreateInput>
    /**
     * In case the MLModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MLModelUpdateInput, MLModelUncheckedUpdateInput>
  }

  /**
   * MLModel delete
   */
  export type MLModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
    /**
     * Filter which MLModel to delete.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel deleteMany
   */
  export type MLModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLModels to delete
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to delete.
     */
    limit?: number
  }

  /**
   * MLModel.predictions
   */
  export type MLModel$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    where?: MLPredictionWhereInput
    orderBy?: MLPredictionOrderByWithRelationInput | MLPredictionOrderByWithRelationInput[]
    cursor?: MLPredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MLPredictionScalarFieldEnum | MLPredictionScalarFieldEnum[]
  }

  /**
   * MLModel without action
   */
  export type MLModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLModelInclude<ExtArgs> | null
  }


  /**
   * Model MLPrediction
   */

  export type AggregateMLPrediction = {
    _count: MLPredictionCountAggregateOutputType | null
    _avg: MLPredictionAvgAggregateOutputType | null
    _sum: MLPredictionSumAggregateOutputType | null
    _min: MLPredictionMinAggregateOutputType | null
    _max: MLPredictionMaxAggregateOutputType | null
  }

  export type MLPredictionAvgAggregateOutputType = {
    values: number | null
    confidenceScores: number | null
  }

  export type MLPredictionSumAggregateOutputType = {
    values: number[]
    confidenceScores: number[]
  }

  export type MLPredictionMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    symbol: string | null
    timeframe: string | null
    predictionType: string | null
    generatedAt: Date | null
    expiresAt: Date | null
    signalGenerated: boolean | null
    signalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLPredictionMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    symbol: string | null
    timeframe: string | null
    predictionType: string | null
    generatedAt: Date | null
    expiresAt: Date | null
    signalGenerated: boolean | null
    signalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLPredictionCountAggregateOutputType = {
    id: number
    modelId: number
    symbol: number
    timeframe: number
    predictionType: number
    values: number
    timestamps: number
    confidenceScores: number
    metadata: number
    generatedAt: number
    expiresAt: number
    signalGenerated: number
    signalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MLPredictionAvgAggregateInputType = {
    values?: true
    confidenceScores?: true
  }

  export type MLPredictionSumAggregateInputType = {
    values?: true
    confidenceScores?: true
  }

  export type MLPredictionMinAggregateInputType = {
    id?: true
    modelId?: true
    symbol?: true
    timeframe?: true
    predictionType?: true
    generatedAt?: true
    expiresAt?: true
    signalGenerated?: true
    signalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLPredictionMaxAggregateInputType = {
    id?: true
    modelId?: true
    symbol?: true
    timeframe?: true
    predictionType?: true
    generatedAt?: true
    expiresAt?: true
    signalGenerated?: true
    signalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLPredictionCountAggregateInputType = {
    id?: true
    modelId?: true
    symbol?: true
    timeframe?: true
    predictionType?: true
    values?: true
    timestamps?: true
    confidenceScores?: true
    metadata?: true
    generatedAt?: true
    expiresAt?: true
    signalGenerated?: true
    signalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MLPredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLPrediction to aggregate.
     */
    where?: MLPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLPredictions to fetch.
     */
    orderBy?: MLPredictionOrderByWithRelationInput | MLPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MLPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MLPredictions
    **/
    _count?: true | MLPredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MLPredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MLPredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MLPredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MLPredictionMaxAggregateInputType
  }

  export type GetMLPredictionAggregateType<T extends MLPredictionAggregateArgs> = {
        [P in keyof T & keyof AggregateMLPrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMLPrediction[P]>
      : GetScalarType<T[P], AggregateMLPrediction[P]>
  }




  export type MLPredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MLPredictionWhereInput
    orderBy?: MLPredictionOrderByWithAggregationInput | MLPredictionOrderByWithAggregationInput[]
    by: MLPredictionScalarFieldEnum[] | MLPredictionScalarFieldEnum
    having?: MLPredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MLPredictionCountAggregateInputType | true
    _avg?: MLPredictionAvgAggregateInputType
    _sum?: MLPredictionSumAggregateInputType
    _min?: MLPredictionMinAggregateInputType
    _max?: MLPredictionMaxAggregateInputType
  }

  export type MLPredictionGroupByOutputType = {
    id: string
    modelId: string
    symbol: string
    timeframe: string
    predictionType: string
    values: number[]
    timestamps: string[]
    confidenceScores: number[]
    metadata: JsonValue | null
    generatedAt: Date
    expiresAt: Date | null
    signalGenerated: boolean
    signalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MLPredictionCountAggregateOutputType | null
    _avg: MLPredictionAvgAggregateOutputType | null
    _sum: MLPredictionSumAggregateOutputType | null
    _min: MLPredictionMinAggregateOutputType | null
    _max: MLPredictionMaxAggregateOutputType | null
  }

  type GetMLPredictionGroupByPayload<T extends MLPredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MLPredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MLPredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MLPredictionGroupByOutputType[P]>
            : GetScalarType<T[P], MLPredictionGroupByOutputType[P]>
        }
      >
    >


  export type MLPredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    symbol?: boolean
    timeframe?: boolean
    predictionType?: boolean
    values?: boolean
    timestamps?: boolean
    confidenceScores?: boolean
    metadata?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    signalGenerated?: boolean
    signalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mLPrediction"]>

  export type MLPredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    symbol?: boolean
    timeframe?: boolean
    predictionType?: boolean
    values?: boolean
    timestamps?: boolean
    confidenceScores?: boolean
    metadata?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    signalGenerated?: boolean
    signalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mLPrediction"]>

  export type MLPredictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    symbol?: boolean
    timeframe?: boolean
    predictionType?: boolean
    values?: boolean
    timestamps?: boolean
    confidenceScores?: boolean
    metadata?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    signalGenerated?: boolean
    signalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mLPrediction"]>

  export type MLPredictionSelectScalar = {
    id?: boolean
    modelId?: boolean
    symbol?: boolean
    timeframe?: boolean
    predictionType?: boolean
    values?: boolean
    timestamps?: boolean
    confidenceScores?: boolean
    metadata?: boolean
    generatedAt?: boolean
    expiresAt?: boolean
    signalGenerated?: boolean
    signalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MLPredictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelId" | "symbol" | "timeframe" | "predictionType" | "values" | "timestamps" | "confidenceScores" | "metadata" | "generatedAt" | "expiresAt" | "signalGenerated" | "signalId" | "createdAt" | "updatedAt", ExtArgs["result"]["mLPrediction"]>
  export type MLPredictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }
  export type MLPredictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }
  export type MLPredictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | MLModelDefaultArgs<ExtArgs>
  }

  export type $MLPredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MLPrediction"
    objects: {
      model: Prisma.$MLModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      symbol: string
      timeframe: string
      predictionType: string
      values: number[]
      timestamps: string[]
      confidenceScores: number[]
      metadata: Prisma.JsonValue | null
      generatedAt: Date
      expiresAt: Date | null
      signalGenerated: boolean
      signalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mLPrediction"]>
    composites: {}
  }

  type MLPredictionGetPayload<S extends boolean | null | undefined | MLPredictionDefaultArgs> = $Result.GetResult<Prisma.$MLPredictionPayload, S>

  type MLPredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MLPredictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MLPredictionCountAggregateInputType | true
    }

  export interface MLPredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MLPrediction'], meta: { name: 'MLPrediction' } }
    /**
     * Find zero or one MLPrediction that matches the filter.
     * @param {MLPredictionFindUniqueArgs} args - Arguments to find a MLPrediction
     * @example
     * // Get one MLPrediction
     * const mLPrediction = await prisma.mLPrediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MLPredictionFindUniqueArgs>(args: SelectSubset<T, MLPredictionFindUniqueArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MLPrediction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MLPredictionFindUniqueOrThrowArgs} args - Arguments to find a MLPrediction
     * @example
     * // Get one MLPrediction
     * const mLPrediction = await prisma.mLPrediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MLPredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, MLPredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLPrediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionFindFirstArgs} args - Arguments to find a MLPrediction
     * @example
     * // Get one MLPrediction
     * const mLPrediction = await prisma.mLPrediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MLPredictionFindFirstArgs>(args?: SelectSubset<T, MLPredictionFindFirstArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLPrediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionFindFirstOrThrowArgs} args - Arguments to find a MLPrediction
     * @example
     * // Get one MLPrediction
     * const mLPrediction = await prisma.mLPrediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MLPredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, MLPredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MLPredictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MLPredictions
     * const mLPredictions = await prisma.mLPrediction.findMany()
     * 
     * // Get first 10 MLPredictions
     * const mLPredictions = await prisma.mLPrediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mLPredictionWithIdOnly = await prisma.mLPrediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MLPredictionFindManyArgs>(args?: SelectSubset<T, MLPredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MLPrediction.
     * @param {MLPredictionCreateArgs} args - Arguments to create a MLPrediction.
     * @example
     * // Create one MLPrediction
     * const MLPrediction = await prisma.mLPrediction.create({
     *   data: {
     *     // ... data to create a MLPrediction
     *   }
     * })
     * 
     */
    create<T extends MLPredictionCreateArgs>(args: SelectSubset<T, MLPredictionCreateArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MLPredictions.
     * @param {MLPredictionCreateManyArgs} args - Arguments to create many MLPredictions.
     * @example
     * // Create many MLPredictions
     * const mLPrediction = await prisma.mLPrediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MLPredictionCreateManyArgs>(args?: SelectSubset<T, MLPredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MLPredictions and returns the data saved in the database.
     * @param {MLPredictionCreateManyAndReturnArgs} args - Arguments to create many MLPredictions.
     * @example
     * // Create many MLPredictions
     * const mLPrediction = await prisma.mLPrediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MLPredictions and only return the `id`
     * const mLPredictionWithIdOnly = await prisma.mLPrediction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MLPredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, MLPredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MLPrediction.
     * @param {MLPredictionDeleteArgs} args - Arguments to delete one MLPrediction.
     * @example
     * // Delete one MLPrediction
     * const MLPrediction = await prisma.mLPrediction.delete({
     *   where: {
     *     // ... filter to delete one MLPrediction
     *   }
     * })
     * 
     */
    delete<T extends MLPredictionDeleteArgs>(args: SelectSubset<T, MLPredictionDeleteArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MLPrediction.
     * @param {MLPredictionUpdateArgs} args - Arguments to update one MLPrediction.
     * @example
     * // Update one MLPrediction
     * const mLPrediction = await prisma.mLPrediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MLPredictionUpdateArgs>(args: SelectSubset<T, MLPredictionUpdateArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MLPredictions.
     * @param {MLPredictionDeleteManyArgs} args - Arguments to filter MLPredictions to delete.
     * @example
     * // Delete a few MLPredictions
     * const { count } = await prisma.mLPrediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MLPredictionDeleteManyArgs>(args?: SelectSubset<T, MLPredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MLPredictions
     * const mLPrediction = await prisma.mLPrediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MLPredictionUpdateManyArgs>(args: SelectSubset<T, MLPredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLPredictions and returns the data updated in the database.
     * @param {MLPredictionUpdateManyAndReturnArgs} args - Arguments to update many MLPredictions.
     * @example
     * // Update many MLPredictions
     * const mLPrediction = await prisma.mLPrediction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MLPredictions and only return the `id`
     * const mLPredictionWithIdOnly = await prisma.mLPrediction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MLPredictionUpdateManyAndReturnArgs>(args: SelectSubset<T, MLPredictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MLPrediction.
     * @param {MLPredictionUpsertArgs} args - Arguments to update or create a MLPrediction.
     * @example
     * // Update or create a MLPrediction
     * const mLPrediction = await prisma.mLPrediction.upsert({
     *   create: {
     *     // ... data to create a MLPrediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MLPrediction we want to update
     *   }
     * })
     */
    upsert<T extends MLPredictionUpsertArgs>(args: SelectSubset<T, MLPredictionUpsertArgs<ExtArgs>>): Prisma__MLPredictionClient<$Result.GetResult<Prisma.$MLPredictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MLPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionCountArgs} args - Arguments to filter MLPredictions to count.
     * @example
     * // Count the number of MLPredictions
     * const count = await prisma.mLPrediction.count({
     *   where: {
     *     // ... the filter for the MLPredictions we want to count
     *   }
     * })
    **/
    count<T extends MLPredictionCountArgs>(
      args?: Subset<T, MLPredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MLPredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MLPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MLPredictionAggregateArgs>(args: Subset<T, MLPredictionAggregateArgs>): Prisma.PrismaPromise<GetMLPredictionAggregateType<T>>

    /**
     * Group by MLPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLPredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MLPredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MLPredictionGroupByArgs['orderBy'] }
        : { orderBy?: MLPredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MLPredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMLPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MLPrediction model
   */
  readonly fields: MLPredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MLPrediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MLPredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends MLModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MLModelDefaultArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MLPrediction model
   */
  interface MLPredictionFieldRefs {
    readonly id: FieldRef<"MLPrediction", 'String'>
    readonly modelId: FieldRef<"MLPrediction", 'String'>
    readonly symbol: FieldRef<"MLPrediction", 'String'>
    readonly timeframe: FieldRef<"MLPrediction", 'String'>
    readonly predictionType: FieldRef<"MLPrediction", 'String'>
    readonly values: FieldRef<"MLPrediction", 'Float[]'>
    readonly timestamps: FieldRef<"MLPrediction", 'String[]'>
    readonly confidenceScores: FieldRef<"MLPrediction", 'Float[]'>
    readonly metadata: FieldRef<"MLPrediction", 'Json'>
    readonly generatedAt: FieldRef<"MLPrediction", 'DateTime'>
    readonly expiresAt: FieldRef<"MLPrediction", 'DateTime'>
    readonly signalGenerated: FieldRef<"MLPrediction", 'Boolean'>
    readonly signalId: FieldRef<"MLPrediction", 'String'>
    readonly createdAt: FieldRef<"MLPrediction", 'DateTime'>
    readonly updatedAt: FieldRef<"MLPrediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MLPrediction findUnique
   */
  export type MLPredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter, which MLPrediction to fetch.
     */
    where: MLPredictionWhereUniqueInput
  }

  /**
   * MLPrediction findUniqueOrThrow
   */
  export type MLPredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter, which MLPrediction to fetch.
     */
    where: MLPredictionWhereUniqueInput
  }

  /**
   * MLPrediction findFirst
   */
  export type MLPredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter, which MLPrediction to fetch.
     */
    where?: MLPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLPredictions to fetch.
     */
    orderBy?: MLPredictionOrderByWithRelationInput | MLPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLPredictions.
     */
    cursor?: MLPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLPredictions.
     */
    distinct?: MLPredictionScalarFieldEnum | MLPredictionScalarFieldEnum[]
  }

  /**
   * MLPrediction findFirstOrThrow
   */
  export type MLPredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter, which MLPrediction to fetch.
     */
    where?: MLPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLPredictions to fetch.
     */
    orderBy?: MLPredictionOrderByWithRelationInput | MLPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLPredictions.
     */
    cursor?: MLPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLPredictions.
     */
    distinct?: MLPredictionScalarFieldEnum | MLPredictionScalarFieldEnum[]
  }

  /**
   * MLPrediction findMany
   */
  export type MLPredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter, which MLPredictions to fetch.
     */
    where?: MLPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLPredictions to fetch.
     */
    orderBy?: MLPredictionOrderByWithRelationInput | MLPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MLPredictions.
     */
    cursor?: MLPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLPredictions.
     */
    skip?: number
    distinct?: MLPredictionScalarFieldEnum | MLPredictionScalarFieldEnum[]
  }

  /**
   * MLPrediction create
   */
  export type MLPredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * The data needed to create a MLPrediction.
     */
    data: XOR<MLPredictionCreateInput, MLPredictionUncheckedCreateInput>
  }

  /**
   * MLPrediction createMany
   */
  export type MLPredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MLPredictions.
     */
    data: MLPredictionCreateManyInput | MLPredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLPrediction createManyAndReturn
   */
  export type MLPredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * The data used to create many MLPredictions.
     */
    data: MLPredictionCreateManyInput | MLPredictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MLPrediction update
   */
  export type MLPredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * The data needed to update a MLPrediction.
     */
    data: XOR<MLPredictionUpdateInput, MLPredictionUncheckedUpdateInput>
    /**
     * Choose, which MLPrediction to update.
     */
    where: MLPredictionWhereUniqueInput
  }

  /**
   * MLPrediction updateMany
   */
  export type MLPredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MLPredictions.
     */
    data: XOR<MLPredictionUpdateManyMutationInput, MLPredictionUncheckedUpdateManyInput>
    /**
     * Filter which MLPredictions to update
     */
    where?: MLPredictionWhereInput
    /**
     * Limit how many MLPredictions to update.
     */
    limit?: number
  }

  /**
   * MLPrediction updateManyAndReturn
   */
  export type MLPredictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * The data used to update MLPredictions.
     */
    data: XOR<MLPredictionUpdateManyMutationInput, MLPredictionUncheckedUpdateManyInput>
    /**
     * Filter which MLPredictions to update
     */
    where?: MLPredictionWhereInput
    /**
     * Limit how many MLPredictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MLPrediction upsert
   */
  export type MLPredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * The filter to search for the MLPrediction to update in case it exists.
     */
    where: MLPredictionWhereUniqueInput
    /**
     * In case the MLPrediction found by the `where` argument doesn't exist, create a new MLPrediction with this data.
     */
    create: XOR<MLPredictionCreateInput, MLPredictionUncheckedCreateInput>
    /**
     * In case the MLPrediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MLPredictionUpdateInput, MLPredictionUncheckedUpdateInput>
  }

  /**
   * MLPrediction delete
   */
  export type MLPredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
    /**
     * Filter which MLPrediction to delete.
     */
    where: MLPredictionWhereUniqueInput
  }

  /**
   * MLPrediction deleteMany
   */
  export type MLPredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLPredictions to delete
     */
    where?: MLPredictionWhereInput
    /**
     * Limit how many MLPredictions to delete.
     */
    limit?: number
  }

  /**
   * MLPrediction without action
   */
  export type MLPredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLPrediction
     */
    select?: MLPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLPrediction
     */
    omit?: MLPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MLPredictionInclude<ExtArgs> | null
  }


  /**
   * Model MLTrainingJob
   */

  export type AggregateMLTrainingJob = {
    _count: MLTrainingJobCountAggregateOutputType | null
    _avg: MLTrainingJobAvgAggregateOutputType | null
    _sum: MLTrainingJobSumAggregateOutputType | null
    _min: MLTrainingJobMinAggregateOutputType | null
    _max: MLTrainingJobMaxAggregateOutputType | null
  }

  export type MLTrainingJobAvgAggregateOutputType = {
    progress: number | null
  }

  export type MLTrainingJobSumAggregateOutputType = {
    progress: number | null
  }

  export type MLTrainingJobMinAggregateOutputType = {
    id: string | null
    userId: string | null
    symbol: string | null
    timeframe: string | null
    modelType: string | null
    status: string | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    resultModelId: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLTrainingJobMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    symbol: string | null
    timeframe: string | null
    modelType: string | null
    status: string | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    resultModelId: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MLTrainingJobCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    timeframe: number
    modelType: number
    status: number
    progress: number
    startedAt: number
    completedAt: number
    resultModelId: number
    errorMessage: number
    params: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MLTrainingJobAvgAggregateInputType = {
    progress?: true
  }

  export type MLTrainingJobSumAggregateInputType = {
    progress?: true
  }

  export type MLTrainingJobMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    timeframe?: true
    modelType?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    resultModelId?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLTrainingJobMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    timeframe?: true
    modelType?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    resultModelId?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MLTrainingJobCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    timeframe?: true
    modelType?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    resultModelId?: true
    errorMessage?: true
    params?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MLTrainingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLTrainingJob to aggregate.
     */
    where?: MLTrainingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLTrainingJobs to fetch.
     */
    orderBy?: MLTrainingJobOrderByWithRelationInput | MLTrainingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MLTrainingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLTrainingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLTrainingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MLTrainingJobs
    **/
    _count?: true | MLTrainingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MLTrainingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MLTrainingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MLTrainingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MLTrainingJobMaxAggregateInputType
  }

  export type GetMLTrainingJobAggregateType<T extends MLTrainingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateMLTrainingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMLTrainingJob[P]>
      : GetScalarType<T[P], AggregateMLTrainingJob[P]>
  }




  export type MLTrainingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MLTrainingJobWhereInput
    orderBy?: MLTrainingJobOrderByWithAggregationInput | MLTrainingJobOrderByWithAggregationInput[]
    by: MLTrainingJobScalarFieldEnum[] | MLTrainingJobScalarFieldEnum
    having?: MLTrainingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MLTrainingJobCountAggregateInputType | true
    _avg?: MLTrainingJobAvgAggregateInputType
    _sum?: MLTrainingJobSumAggregateInputType
    _min?: MLTrainingJobMinAggregateInputType
    _max?: MLTrainingJobMaxAggregateInputType
  }

  export type MLTrainingJobGroupByOutputType = {
    id: string
    userId: string
    symbol: string
    timeframe: string
    modelType: string
    status: string
    progress: number
    startedAt: Date | null
    completedAt: Date | null
    resultModelId: string | null
    errorMessage: string | null
    params: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MLTrainingJobCountAggregateOutputType | null
    _avg: MLTrainingJobAvgAggregateOutputType | null
    _sum: MLTrainingJobSumAggregateOutputType | null
    _min: MLTrainingJobMinAggregateOutputType | null
    _max: MLTrainingJobMaxAggregateOutputType | null
  }

  type GetMLTrainingJobGroupByPayload<T extends MLTrainingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MLTrainingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MLTrainingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MLTrainingJobGroupByOutputType[P]>
            : GetScalarType<T[P], MLTrainingJobGroupByOutputType[P]>
        }
      >
    >


  export type MLTrainingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    timeframe?: boolean
    modelType?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    resultModelId?: boolean
    errorMessage?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mLTrainingJob"]>

  export type MLTrainingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    timeframe?: boolean
    modelType?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    resultModelId?: boolean
    errorMessage?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mLTrainingJob"]>

  export type MLTrainingJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    timeframe?: boolean
    modelType?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    resultModelId?: boolean
    errorMessage?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mLTrainingJob"]>

  export type MLTrainingJobSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
    timeframe?: boolean
    modelType?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    resultModelId?: boolean
    errorMessage?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MLTrainingJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "symbol" | "timeframe" | "modelType" | "status" | "progress" | "startedAt" | "completedAt" | "resultModelId" | "errorMessage" | "params" | "createdAt" | "updatedAt", ExtArgs["result"]["mLTrainingJob"]>

  export type $MLTrainingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MLTrainingJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      symbol: string
      timeframe: string
      modelType: string
      status: string
      progress: number
      startedAt: Date | null
      completedAt: Date | null
      resultModelId: string | null
      errorMessage: string | null
      params: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mLTrainingJob"]>
    composites: {}
  }

  type MLTrainingJobGetPayload<S extends boolean | null | undefined | MLTrainingJobDefaultArgs> = $Result.GetResult<Prisma.$MLTrainingJobPayload, S>

  type MLTrainingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MLTrainingJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MLTrainingJobCountAggregateInputType | true
    }

  export interface MLTrainingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MLTrainingJob'], meta: { name: 'MLTrainingJob' } }
    /**
     * Find zero or one MLTrainingJob that matches the filter.
     * @param {MLTrainingJobFindUniqueArgs} args - Arguments to find a MLTrainingJob
     * @example
     * // Get one MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MLTrainingJobFindUniqueArgs>(args: SelectSubset<T, MLTrainingJobFindUniqueArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MLTrainingJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MLTrainingJobFindUniqueOrThrowArgs} args - Arguments to find a MLTrainingJob
     * @example
     * // Get one MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MLTrainingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, MLTrainingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLTrainingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobFindFirstArgs} args - Arguments to find a MLTrainingJob
     * @example
     * // Get one MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MLTrainingJobFindFirstArgs>(args?: SelectSubset<T, MLTrainingJobFindFirstArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLTrainingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobFindFirstOrThrowArgs} args - Arguments to find a MLTrainingJob
     * @example
     * // Get one MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MLTrainingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, MLTrainingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MLTrainingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MLTrainingJobs
     * const mLTrainingJobs = await prisma.mLTrainingJob.findMany()
     * 
     * // Get first 10 MLTrainingJobs
     * const mLTrainingJobs = await prisma.mLTrainingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mLTrainingJobWithIdOnly = await prisma.mLTrainingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MLTrainingJobFindManyArgs>(args?: SelectSubset<T, MLTrainingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MLTrainingJob.
     * @param {MLTrainingJobCreateArgs} args - Arguments to create a MLTrainingJob.
     * @example
     * // Create one MLTrainingJob
     * const MLTrainingJob = await prisma.mLTrainingJob.create({
     *   data: {
     *     // ... data to create a MLTrainingJob
     *   }
     * })
     * 
     */
    create<T extends MLTrainingJobCreateArgs>(args: SelectSubset<T, MLTrainingJobCreateArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MLTrainingJobs.
     * @param {MLTrainingJobCreateManyArgs} args - Arguments to create many MLTrainingJobs.
     * @example
     * // Create many MLTrainingJobs
     * const mLTrainingJob = await prisma.mLTrainingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MLTrainingJobCreateManyArgs>(args?: SelectSubset<T, MLTrainingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MLTrainingJobs and returns the data saved in the database.
     * @param {MLTrainingJobCreateManyAndReturnArgs} args - Arguments to create many MLTrainingJobs.
     * @example
     * // Create many MLTrainingJobs
     * const mLTrainingJob = await prisma.mLTrainingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MLTrainingJobs and only return the `id`
     * const mLTrainingJobWithIdOnly = await prisma.mLTrainingJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MLTrainingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, MLTrainingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MLTrainingJob.
     * @param {MLTrainingJobDeleteArgs} args - Arguments to delete one MLTrainingJob.
     * @example
     * // Delete one MLTrainingJob
     * const MLTrainingJob = await prisma.mLTrainingJob.delete({
     *   where: {
     *     // ... filter to delete one MLTrainingJob
     *   }
     * })
     * 
     */
    delete<T extends MLTrainingJobDeleteArgs>(args: SelectSubset<T, MLTrainingJobDeleteArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MLTrainingJob.
     * @param {MLTrainingJobUpdateArgs} args - Arguments to update one MLTrainingJob.
     * @example
     * // Update one MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MLTrainingJobUpdateArgs>(args: SelectSubset<T, MLTrainingJobUpdateArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MLTrainingJobs.
     * @param {MLTrainingJobDeleteManyArgs} args - Arguments to filter MLTrainingJobs to delete.
     * @example
     * // Delete a few MLTrainingJobs
     * const { count } = await prisma.mLTrainingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MLTrainingJobDeleteManyArgs>(args?: SelectSubset<T, MLTrainingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLTrainingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MLTrainingJobs
     * const mLTrainingJob = await prisma.mLTrainingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MLTrainingJobUpdateManyArgs>(args: SelectSubset<T, MLTrainingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLTrainingJobs and returns the data updated in the database.
     * @param {MLTrainingJobUpdateManyAndReturnArgs} args - Arguments to update many MLTrainingJobs.
     * @example
     * // Update many MLTrainingJobs
     * const mLTrainingJob = await prisma.mLTrainingJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MLTrainingJobs and only return the `id`
     * const mLTrainingJobWithIdOnly = await prisma.mLTrainingJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MLTrainingJobUpdateManyAndReturnArgs>(args: SelectSubset<T, MLTrainingJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MLTrainingJob.
     * @param {MLTrainingJobUpsertArgs} args - Arguments to update or create a MLTrainingJob.
     * @example
     * // Update or create a MLTrainingJob
     * const mLTrainingJob = await prisma.mLTrainingJob.upsert({
     *   create: {
     *     // ... data to create a MLTrainingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MLTrainingJob we want to update
     *   }
     * })
     */
    upsert<T extends MLTrainingJobUpsertArgs>(args: SelectSubset<T, MLTrainingJobUpsertArgs<ExtArgs>>): Prisma__MLTrainingJobClient<$Result.GetResult<Prisma.$MLTrainingJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MLTrainingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobCountArgs} args - Arguments to filter MLTrainingJobs to count.
     * @example
     * // Count the number of MLTrainingJobs
     * const count = await prisma.mLTrainingJob.count({
     *   where: {
     *     // ... the filter for the MLTrainingJobs we want to count
     *   }
     * })
    **/
    count<T extends MLTrainingJobCountArgs>(
      args?: Subset<T, MLTrainingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MLTrainingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MLTrainingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MLTrainingJobAggregateArgs>(args: Subset<T, MLTrainingJobAggregateArgs>): Prisma.PrismaPromise<GetMLTrainingJobAggregateType<T>>

    /**
     * Group by MLTrainingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLTrainingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MLTrainingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MLTrainingJobGroupByArgs['orderBy'] }
        : { orderBy?: MLTrainingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MLTrainingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMLTrainingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MLTrainingJob model
   */
  readonly fields: MLTrainingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MLTrainingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MLTrainingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MLTrainingJob model
   */
  interface MLTrainingJobFieldRefs {
    readonly id: FieldRef<"MLTrainingJob", 'String'>
    readonly userId: FieldRef<"MLTrainingJob", 'String'>
    readonly symbol: FieldRef<"MLTrainingJob", 'String'>
    readonly timeframe: FieldRef<"MLTrainingJob", 'String'>
    readonly modelType: FieldRef<"MLTrainingJob", 'String'>
    readonly status: FieldRef<"MLTrainingJob", 'String'>
    readonly progress: FieldRef<"MLTrainingJob", 'Float'>
    readonly startedAt: FieldRef<"MLTrainingJob", 'DateTime'>
    readonly completedAt: FieldRef<"MLTrainingJob", 'DateTime'>
    readonly resultModelId: FieldRef<"MLTrainingJob", 'String'>
    readonly errorMessage: FieldRef<"MLTrainingJob", 'String'>
    readonly params: FieldRef<"MLTrainingJob", 'Json'>
    readonly createdAt: FieldRef<"MLTrainingJob", 'DateTime'>
    readonly updatedAt: FieldRef<"MLTrainingJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MLTrainingJob findUnique
   */
  export type MLTrainingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter, which MLTrainingJob to fetch.
     */
    where: MLTrainingJobWhereUniqueInput
  }

  /**
   * MLTrainingJob findUniqueOrThrow
   */
  export type MLTrainingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter, which MLTrainingJob to fetch.
     */
    where: MLTrainingJobWhereUniqueInput
  }

  /**
   * MLTrainingJob findFirst
   */
  export type MLTrainingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter, which MLTrainingJob to fetch.
     */
    where?: MLTrainingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLTrainingJobs to fetch.
     */
    orderBy?: MLTrainingJobOrderByWithRelationInput | MLTrainingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLTrainingJobs.
     */
    cursor?: MLTrainingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLTrainingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLTrainingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLTrainingJobs.
     */
    distinct?: MLTrainingJobScalarFieldEnum | MLTrainingJobScalarFieldEnum[]
  }

  /**
   * MLTrainingJob findFirstOrThrow
   */
  export type MLTrainingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter, which MLTrainingJob to fetch.
     */
    where?: MLTrainingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLTrainingJobs to fetch.
     */
    orderBy?: MLTrainingJobOrderByWithRelationInput | MLTrainingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLTrainingJobs.
     */
    cursor?: MLTrainingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLTrainingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLTrainingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLTrainingJobs.
     */
    distinct?: MLTrainingJobScalarFieldEnum | MLTrainingJobScalarFieldEnum[]
  }

  /**
   * MLTrainingJob findMany
   */
  export type MLTrainingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter, which MLTrainingJobs to fetch.
     */
    where?: MLTrainingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLTrainingJobs to fetch.
     */
    orderBy?: MLTrainingJobOrderByWithRelationInput | MLTrainingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MLTrainingJobs.
     */
    cursor?: MLTrainingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLTrainingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLTrainingJobs.
     */
    skip?: number
    distinct?: MLTrainingJobScalarFieldEnum | MLTrainingJobScalarFieldEnum[]
  }

  /**
   * MLTrainingJob create
   */
  export type MLTrainingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * The data needed to create a MLTrainingJob.
     */
    data: XOR<MLTrainingJobCreateInput, MLTrainingJobUncheckedCreateInput>
  }

  /**
   * MLTrainingJob createMany
   */
  export type MLTrainingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MLTrainingJobs.
     */
    data: MLTrainingJobCreateManyInput | MLTrainingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLTrainingJob createManyAndReturn
   */
  export type MLTrainingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * The data used to create many MLTrainingJobs.
     */
    data: MLTrainingJobCreateManyInput | MLTrainingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLTrainingJob update
   */
  export type MLTrainingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * The data needed to update a MLTrainingJob.
     */
    data: XOR<MLTrainingJobUpdateInput, MLTrainingJobUncheckedUpdateInput>
    /**
     * Choose, which MLTrainingJob to update.
     */
    where: MLTrainingJobWhereUniqueInput
  }

  /**
   * MLTrainingJob updateMany
   */
  export type MLTrainingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MLTrainingJobs.
     */
    data: XOR<MLTrainingJobUpdateManyMutationInput, MLTrainingJobUncheckedUpdateManyInput>
    /**
     * Filter which MLTrainingJobs to update
     */
    where?: MLTrainingJobWhereInput
    /**
     * Limit how many MLTrainingJobs to update.
     */
    limit?: number
  }

  /**
   * MLTrainingJob updateManyAndReturn
   */
  export type MLTrainingJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * The data used to update MLTrainingJobs.
     */
    data: XOR<MLTrainingJobUpdateManyMutationInput, MLTrainingJobUncheckedUpdateManyInput>
    /**
     * Filter which MLTrainingJobs to update
     */
    where?: MLTrainingJobWhereInput
    /**
     * Limit how many MLTrainingJobs to update.
     */
    limit?: number
  }

  /**
   * MLTrainingJob upsert
   */
  export type MLTrainingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * The filter to search for the MLTrainingJob to update in case it exists.
     */
    where: MLTrainingJobWhereUniqueInput
    /**
     * In case the MLTrainingJob found by the `where` argument doesn't exist, create a new MLTrainingJob with this data.
     */
    create: XOR<MLTrainingJobCreateInput, MLTrainingJobUncheckedCreateInput>
    /**
     * In case the MLTrainingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MLTrainingJobUpdateInput, MLTrainingJobUncheckedUpdateInput>
  }

  /**
   * MLTrainingJob delete
   */
  export type MLTrainingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
    /**
     * Filter which MLTrainingJob to delete.
     */
    where: MLTrainingJobWhereUniqueInput
  }

  /**
   * MLTrainingJob deleteMany
   */
  export type MLTrainingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLTrainingJobs to delete
     */
    where?: MLTrainingJobWhereInput
    /**
     * Limit how many MLTrainingJobs to delete.
     */
    limit?: number
  }

  /**
   * MLTrainingJob without action
   */
  export type MLTrainingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLTrainingJob
     */
    select?: MLTrainingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLTrainingJob
     */
    omit?: MLTrainingJobOmit<ExtArgs> | null
  }


  /**
   * Model BridgeConfig
   */

  export type AggregateBridgeConfig = {
    _count: BridgeConfigCountAggregateOutputType | null
    _avg: BridgeConfigAvgAggregateOutputType | null
    _sum: BridgeConfigSumAggregateOutputType | null
    _min: BridgeConfigMinAggregateOutputType | null
    _max: BridgeConfigMaxAggregateOutputType | null
  }

  export type BridgeConfigAvgAggregateOutputType = {
    confidenceThreshold: number | null
    signalExpiryMinutes: number | null
    refreshIntervalMinutes: number | null
  }

  export type BridgeConfigSumAggregateOutputType = {
    confidenceThreshold: number | null
    signalExpiryMinutes: number | null
    refreshIntervalMinutes: number | null
  }

  export type BridgeConfigMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    mlModelId: string | null
    autoGenerateSignals: boolean | null
    confidenceThreshold: number | null
    signalExpiryMinutes: number | null
    refreshIntervalMinutes: number | null
    lastExecutedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BridgeConfigMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    mlModelId: string | null
    autoGenerateSignals: boolean | null
    confidenceThreshold: number | null
    signalExpiryMinutes: number | null
    refreshIntervalMinutes: number | null
    lastExecutedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BridgeConfigCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    isActive: number
    mlModelId: number
    autoGenerateSignals: number
    confidenceThreshold: number
    signalExpiryMinutes: number
    refreshIntervalMinutes: number
    symbols: number
    timeframes: number
    lastExecutedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BridgeConfigAvgAggregateInputType = {
    confidenceThreshold?: true
    signalExpiryMinutes?: true
    refreshIntervalMinutes?: true
  }

  export type BridgeConfigSumAggregateInputType = {
    confidenceThreshold?: true
    signalExpiryMinutes?: true
    refreshIntervalMinutes?: true
  }

  export type BridgeConfigMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    mlModelId?: true
    autoGenerateSignals?: true
    confidenceThreshold?: true
    signalExpiryMinutes?: true
    refreshIntervalMinutes?: true
    lastExecutedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BridgeConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    mlModelId?: true
    autoGenerateSignals?: true
    confidenceThreshold?: true
    signalExpiryMinutes?: true
    refreshIntervalMinutes?: true
    lastExecutedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BridgeConfigCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    mlModelId?: true
    autoGenerateSignals?: true
    confidenceThreshold?: true
    signalExpiryMinutes?: true
    refreshIntervalMinutes?: true
    symbols?: true
    timeframes?: true
    lastExecutedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BridgeConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BridgeConfig to aggregate.
     */
    where?: BridgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BridgeConfigs to fetch.
     */
    orderBy?: BridgeConfigOrderByWithRelationInput | BridgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BridgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BridgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BridgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BridgeConfigs
    **/
    _count?: true | BridgeConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BridgeConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BridgeConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BridgeConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BridgeConfigMaxAggregateInputType
  }

  export type GetBridgeConfigAggregateType<T extends BridgeConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBridgeConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBridgeConfig[P]>
      : GetScalarType<T[P], AggregateBridgeConfig[P]>
  }




  export type BridgeConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BridgeConfigWhereInput
    orderBy?: BridgeConfigOrderByWithAggregationInput | BridgeConfigOrderByWithAggregationInput[]
    by: BridgeConfigScalarFieldEnum[] | BridgeConfigScalarFieldEnum
    having?: BridgeConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BridgeConfigCountAggregateInputType | true
    _avg?: BridgeConfigAvgAggregateInputType
    _sum?: BridgeConfigSumAggregateInputType
    _min?: BridgeConfigMinAggregateInputType
    _max?: BridgeConfigMaxAggregateInputType
  }

  export type BridgeConfigGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    description: string | null
    isActive: boolean
    mlModelId: string | null
    autoGenerateSignals: boolean
    confidenceThreshold: number
    signalExpiryMinutes: number
    refreshIntervalMinutes: number
    symbols: string[]
    timeframes: string[]
    lastExecutedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BridgeConfigCountAggregateOutputType | null
    _avg: BridgeConfigAvgAggregateOutputType | null
    _sum: BridgeConfigSumAggregateOutputType | null
    _min: BridgeConfigMinAggregateOutputType | null
    _max: BridgeConfigMaxAggregateOutputType | null
  }

  type GetBridgeConfigGroupByPayload<T extends BridgeConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BridgeConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BridgeConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BridgeConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BridgeConfigGroupByOutputType[P]>
        }
      >
    >


  export type BridgeConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    mlModelId?: boolean
    autoGenerateSignals?: boolean
    confidenceThreshold?: boolean
    signalExpiryMinutes?: boolean
    refreshIntervalMinutes?: boolean
    symbols?: boolean
    timeframes?: boolean
    lastExecutedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bridgeConfig"]>

  export type BridgeConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    mlModelId?: boolean
    autoGenerateSignals?: boolean
    confidenceThreshold?: boolean
    signalExpiryMinutes?: boolean
    refreshIntervalMinutes?: boolean
    symbols?: boolean
    timeframes?: boolean
    lastExecutedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bridgeConfig"]>

  export type BridgeConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    mlModelId?: boolean
    autoGenerateSignals?: boolean
    confidenceThreshold?: boolean
    signalExpiryMinutes?: boolean
    refreshIntervalMinutes?: boolean
    symbols?: boolean
    timeframes?: boolean
    lastExecutedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bridgeConfig"]>

  export type BridgeConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    mlModelId?: boolean
    autoGenerateSignals?: boolean
    confidenceThreshold?: boolean
    signalExpiryMinutes?: boolean
    refreshIntervalMinutes?: boolean
    symbols?: boolean
    timeframes?: boolean
    lastExecutedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BridgeConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "isActive" | "mlModelId" | "autoGenerateSignals" | "confidenceThreshold" | "signalExpiryMinutes" | "refreshIntervalMinutes" | "symbols" | "timeframes" | "lastExecutedAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["bridgeConfig"]>

  export type $BridgeConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BridgeConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      description: string | null
      isActive: boolean
      mlModelId: string | null
      autoGenerateSignals: boolean
      confidenceThreshold: number
      signalExpiryMinutes: number
      refreshIntervalMinutes: number
      symbols: string[]
      timeframes: string[]
      lastExecutedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bridgeConfig"]>
    composites: {}
  }

  type BridgeConfigGetPayload<S extends boolean | null | undefined | BridgeConfigDefaultArgs> = $Result.GetResult<Prisma.$BridgeConfigPayload, S>

  type BridgeConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BridgeConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BridgeConfigCountAggregateInputType | true
    }

  export interface BridgeConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BridgeConfig'], meta: { name: 'BridgeConfig' } }
    /**
     * Find zero or one BridgeConfig that matches the filter.
     * @param {BridgeConfigFindUniqueArgs} args - Arguments to find a BridgeConfig
     * @example
     * // Get one BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BridgeConfigFindUniqueArgs>(args: SelectSubset<T, BridgeConfigFindUniqueArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BridgeConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BridgeConfigFindUniqueOrThrowArgs} args - Arguments to find a BridgeConfig
     * @example
     * // Get one BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BridgeConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BridgeConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BridgeConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigFindFirstArgs} args - Arguments to find a BridgeConfig
     * @example
     * // Get one BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BridgeConfigFindFirstArgs>(args?: SelectSubset<T, BridgeConfigFindFirstArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BridgeConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigFindFirstOrThrowArgs} args - Arguments to find a BridgeConfig
     * @example
     * // Get one BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BridgeConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BridgeConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BridgeConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BridgeConfigs
     * const bridgeConfigs = await prisma.bridgeConfig.findMany()
     * 
     * // Get first 10 BridgeConfigs
     * const bridgeConfigs = await prisma.bridgeConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bridgeConfigWithIdOnly = await prisma.bridgeConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BridgeConfigFindManyArgs>(args?: SelectSubset<T, BridgeConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BridgeConfig.
     * @param {BridgeConfigCreateArgs} args - Arguments to create a BridgeConfig.
     * @example
     * // Create one BridgeConfig
     * const BridgeConfig = await prisma.bridgeConfig.create({
     *   data: {
     *     // ... data to create a BridgeConfig
     *   }
     * })
     * 
     */
    create<T extends BridgeConfigCreateArgs>(args: SelectSubset<T, BridgeConfigCreateArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BridgeConfigs.
     * @param {BridgeConfigCreateManyArgs} args - Arguments to create many BridgeConfigs.
     * @example
     * // Create many BridgeConfigs
     * const bridgeConfig = await prisma.bridgeConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BridgeConfigCreateManyArgs>(args?: SelectSubset<T, BridgeConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BridgeConfigs and returns the data saved in the database.
     * @param {BridgeConfigCreateManyAndReturnArgs} args - Arguments to create many BridgeConfigs.
     * @example
     * // Create many BridgeConfigs
     * const bridgeConfig = await prisma.bridgeConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BridgeConfigs and only return the `id`
     * const bridgeConfigWithIdOnly = await prisma.bridgeConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BridgeConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BridgeConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BridgeConfig.
     * @param {BridgeConfigDeleteArgs} args - Arguments to delete one BridgeConfig.
     * @example
     * // Delete one BridgeConfig
     * const BridgeConfig = await prisma.bridgeConfig.delete({
     *   where: {
     *     // ... filter to delete one BridgeConfig
     *   }
     * })
     * 
     */
    delete<T extends BridgeConfigDeleteArgs>(args: SelectSubset<T, BridgeConfigDeleteArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BridgeConfig.
     * @param {BridgeConfigUpdateArgs} args - Arguments to update one BridgeConfig.
     * @example
     * // Update one BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BridgeConfigUpdateArgs>(args: SelectSubset<T, BridgeConfigUpdateArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BridgeConfigs.
     * @param {BridgeConfigDeleteManyArgs} args - Arguments to filter BridgeConfigs to delete.
     * @example
     * // Delete a few BridgeConfigs
     * const { count } = await prisma.bridgeConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BridgeConfigDeleteManyArgs>(args?: SelectSubset<T, BridgeConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BridgeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BridgeConfigs
     * const bridgeConfig = await prisma.bridgeConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BridgeConfigUpdateManyArgs>(args: SelectSubset<T, BridgeConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BridgeConfigs and returns the data updated in the database.
     * @param {BridgeConfigUpdateManyAndReturnArgs} args - Arguments to update many BridgeConfigs.
     * @example
     * // Update many BridgeConfigs
     * const bridgeConfig = await prisma.bridgeConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BridgeConfigs and only return the `id`
     * const bridgeConfigWithIdOnly = await prisma.bridgeConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BridgeConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, BridgeConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BridgeConfig.
     * @param {BridgeConfigUpsertArgs} args - Arguments to update or create a BridgeConfig.
     * @example
     * // Update or create a BridgeConfig
     * const bridgeConfig = await prisma.bridgeConfig.upsert({
     *   create: {
     *     // ... data to create a BridgeConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BridgeConfig we want to update
     *   }
     * })
     */
    upsert<T extends BridgeConfigUpsertArgs>(args: SelectSubset<T, BridgeConfigUpsertArgs<ExtArgs>>): Prisma__BridgeConfigClient<$Result.GetResult<Prisma.$BridgeConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BridgeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigCountArgs} args - Arguments to filter BridgeConfigs to count.
     * @example
     * // Count the number of BridgeConfigs
     * const count = await prisma.bridgeConfig.count({
     *   where: {
     *     // ... the filter for the BridgeConfigs we want to count
     *   }
     * })
    **/
    count<T extends BridgeConfigCountArgs>(
      args?: Subset<T, BridgeConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BridgeConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BridgeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BridgeConfigAggregateArgs>(args: Subset<T, BridgeConfigAggregateArgs>): Prisma.PrismaPromise<GetBridgeConfigAggregateType<T>>

    /**
     * Group by BridgeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BridgeConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BridgeConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BridgeConfigGroupByArgs['orderBy'] }
        : { orderBy?: BridgeConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BridgeConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBridgeConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BridgeConfig model
   */
  readonly fields: BridgeConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BridgeConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BridgeConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BridgeConfig model
   */
  interface BridgeConfigFieldRefs {
    readonly id: FieldRef<"BridgeConfig", 'String'>
    readonly userId: FieldRef<"BridgeConfig", 'String'>
    readonly name: FieldRef<"BridgeConfig", 'String'>
    readonly description: FieldRef<"BridgeConfig", 'String'>
    readonly isActive: FieldRef<"BridgeConfig", 'Boolean'>
    readonly mlModelId: FieldRef<"BridgeConfig", 'String'>
    readonly autoGenerateSignals: FieldRef<"BridgeConfig", 'Boolean'>
    readonly confidenceThreshold: FieldRef<"BridgeConfig", 'Float'>
    readonly signalExpiryMinutes: FieldRef<"BridgeConfig", 'Int'>
    readonly refreshIntervalMinutes: FieldRef<"BridgeConfig", 'Int'>
    readonly symbols: FieldRef<"BridgeConfig", 'String[]'>
    readonly timeframes: FieldRef<"BridgeConfig", 'String[]'>
    readonly lastExecutedAt: FieldRef<"BridgeConfig", 'DateTime'>
    readonly metadata: FieldRef<"BridgeConfig", 'Json'>
    readonly createdAt: FieldRef<"BridgeConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BridgeConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BridgeConfig findUnique
   */
  export type BridgeConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter, which BridgeConfig to fetch.
     */
    where: BridgeConfigWhereUniqueInput
  }

  /**
   * BridgeConfig findUniqueOrThrow
   */
  export type BridgeConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter, which BridgeConfig to fetch.
     */
    where: BridgeConfigWhereUniqueInput
  }

  /**
   * BridgeConfig findFirst
   */
  export type BridgeConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter, which BridgeConfig to fetch.
     */
    where?: BridgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BridgeConfigs to fetch.
     */
    orderBy?: BridgeConfigOrderByWithRelationInput | BridgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BridgeConfigs.
     */
    cursor?: BridgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BridgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BridgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BridgeConfigs.
     */
    distinct?: BridgeConfigScalarFieldEnum | BridgeConfigScalarFieldEnum[]
  }

  /**
   * BridgeConfig findFirstOrThrow
   */
  export type BridgeConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter, which BridgeConfig to fetch.
     */
    where?: BridgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BridgeConfigs to fetch.
     */
    orderBy?: BridgeConfigOrderByWithRelationInput | BridgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BridgeConfigs.
     */
    cursor?: BridgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BridgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BridgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BridgeConfigs.
     */
    distinct?: BridgeConfigScalarFieldEnum | BridgeConfigScalarFieldEnum[]
  }

  /**
   * BridgeConfig findMany
   */
  export type BridgeConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter, which BridgeConfigs to fetch.
     */
    where?: BridgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BridgeConfigs to fetch.
     */
    orderBy?: BridgeConfigOrderByWithRelationInput | BridgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BridgeConfigs.
     */
    cursor?: BridgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BridgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BridgeConfigs.
     */
    skip?: number
    distinct?: BridgeConfigScalarFieldEnum | BridgeConfigScalarFieldEnum[]
  }

  /**
   * BridgeConfig create
   */
  export type BridgeConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a BridgeConfig.
     */
    data: XOR<BridgeConfigCreateInput, BridgeConfigUncheckedCreateInput>
  }

  /**
   * BridgeConfig createMany
   */
  export type BridgeConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BridgeConfigs.
     */
    data: BridgeConfigCreateManyInput | BridgeConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BridgeConfig createManyAndReturn
   */
  export type BridgeConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * The data used to create many BridgeConfigs.
     */
    data: BridgeConfigCreateManyInput | BridgeConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BridgeConfig update
   */
  export type BridgeConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a BridgeConfig.
     */
    data: XOR<BridgeConfigUpdateInput, BridgeConfigUncheckedUpdateInput>
    /**
     * Choose, which BridgeConfig to update.
     */
    where: BridgeConfigWhereUniqueInput
  }

  /**
   * BridgeConfig updateMany
   */
  export type BridgeConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BridgeConfigs.
     */
    data: XOR<BridgeConfigUpdateManyMutationInput, BridgeConfigUncheckedUpdateManyInput>
    /**
     * Filter which BridgeConfigs to update
     */
    where?: BridgeConfigWhereInput
    /**
     * Limit how many BridgeConfigs to update.
     */
    limit?: number
  }

  /**
   * BridgeConfig updateManyAndReturn
   */
  export type BridgeConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * The data used to update BridgeConfigs.
     */
    data: XOR<BridgeConfigUpdateManyMutationInput, BridgeConfigUncheckedUpdateManyInput>
    /**
     * Filter which BridgeConfigs to update
     */
    where?: BridgeConfigWhereInput
    /**
     * Limit how many BridgeConfigs to update.
     */
    limit?: number
  }

  /**
   * BridgeConfig upsert
   */
  export type BridgeConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the BridgeConfig to update in case it exists.
     */
    where: BridgeConfigWhereUniqueInput
    /**
     * In case the BridgeConfig found by the `where` argument doesn't exist, create a new BridgeConfig with this data.
     */
    create: XOR<BridgeConfigCreateInput, BridgeConfigUncheckedCreateInput>
    /**
     * In case the BridgeConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BridgeConfigUpdateInput, BridgeConfigUncheckedUpdateInput>
  }

  /**
   * BridgeConfig delete
   */
  export type BridgeConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
    /**
     * Filter which BridgeConfig to delete.
     */
    where: BridgeConfigWhereUniqueInput
  }

  /**
   * BridgeConfig deleteMany
   */
  export type BridgeConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BridgeConfigs to delete
     */
    where?: BridgeConfigWhereInput
    /**
     * Limit how many BridgeConfigs to delete.
     */
    limit?: number
  }

  /**
   * BridgeConfig without action
   */
  export type BridgeConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BridgeConfig
     */
    select?: BridgeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BridgeConfig
     */
    omit?: BridgeConfigOmit<ExtArgs> | null
  }


  /**
   * Model PerformanceTest
   */

  export type AggregatePerformanceTest = {
    _count: PerformanceTestCountAggregateOutputType | null
    _avg: PerformanceTestAvgAggregateOutputType | null
    _sum: PerformanceTestSumAggregateOutputType | null
    _min: PerformanceTestMinAggregateOutputType | null
    _max: PerformanceTestMaxAggregateOutputType | null
  }

  export type PerformanceTestAvgAggregateOutputType = {
    duration: number | null
    concurrency: number | null
    rampUp: number | null
  }

  export type PerformanceTestSumAggregateOutputType = {
    duration: number | null
    concurrency: number | null
    rampUp: number | null
  }

  export type PerformanceTestMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    testType: string | null
    duration: number | null
    concurrency: number | null
    rampUp: number | null
    targetEndpoint: string | null
    modelId: string | null
    strategyId: string | null
    symbol: string | null
    timeframe: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceTestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    testType: string | null
    duration: number | null
    concurrency: number | null
    rampUp: number | null
    targetEndpoint: string | null
    modelId: string | null
    strategyId: string | null
    symbol: string | null
    timeframe: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceTestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    testType: number
    duration: number
    concurrency: number
    rampUp: number
    targetEndpoint: number
    modelId: number
    strategyId: number
    symbol: number
    timeframe: number
    options: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceTestAvgAggregateInputType = {
    duration?: true
    concurrency?: true
    rampUp?: true
  }

  export type PerformanceTestSumAggregateInputType = {
    duration?: true
    concurrency?: true
    rampUp?: true
  }

  export type PerformanceTestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    testType?: true
    duration?: true
    concurrency?: true
    rampUp?: true
    targetEndpoint?: true
    modelId?: true
    strategyId?: true
    symbol?: true
    timeframe?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceTestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    testType?: true
    duration?: true
    concurrency?: true
    rampUp?: true
    targetEndpoint?: true
    modelId?: true
    strategyId?: true
    symbol?: true
    timeframe?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceTestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    testType?: true
    duration?: true
    concurrency?: true
    rampUp?: true
    targetEndpoint?: true
    modelId?: true
    strategyId?: true
    symbol?: true
    timeframe?: true
    options?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceTest to aggregate.
     */
    where?: PerformanceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTests to fetch.
     */
    orderBy?: PerformanceTestOrderByWithRelationInput | PerformanceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceTests
    **/
    _count?: true | PerformanceTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceTestMaxAggregateInputType
  }

  export type GetPerformanceTestAggregateType<T extends PerformanceTestAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceTest[P]>
      : GetScalarType<T[P], AggregatePerformanceTest[P]>
  }




  export type PerformanceTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceTestWhereInput
    orderBy?: PerformanceTestOrderByWithAggregationInput | PerformanceTestOrderByWithAggregationInput[]
    by: PerformanceTestScalarFieldEnum[] | PerformanceTestScalarFieldEnum
    having?: PerformanceTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceTestCountAggregateInputType | true
    _avg?: PerformanceTestAvgAggregateInputType
    _sum?: PerformanceTestSumAggregateInputType
    _min?: PerformanceTestMinAggregateInputType
    _max?: PerformanceTestMaxAggregateInputType
  }

  export type PerformanceTestGroupByOutputType = {
    id: string
    name: string
    description: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp: number | null
    targetEndpoint: string | null
    modelId: string | null
    strategyId: string | null
    symbol: string | null
    timeframe: string | null
    options: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PerformanceTestCountAggregateOutputType | null
    _avg: PerformanceTestAvgAggregateOutputType | null
    _sum: PerformanceTestSumAggregateOutputType | null
    _min: PerformanceTestMinAggregateOutputType | null
    _max: PerformanceTestMaxAggregateOutputType | null
  }

  type GetPerformanceTestGroupByPayload<T extends PerformanceTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceTestGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceTestGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    testType?: boolean
    duration?: boolean
    concurrency?: boolean
    rampUp?: boolean
    targetEndpoint?: boolean
    modelId?: boolean
    strategyId?: boolean
    symbol?: boolean
    timeframe?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    results?: boolean | PerformanceTest$resultsArgs<ExtArgs>
    _count?: boolean | PerformanceTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceTest"]>

  export type PerformanceTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    testType?: boolean
    duration?: boolean
    concurrency?: boolean
    rampUp?: boolean
    targetEndpoint?: boolean
    modelId?: boolean
    strategyId?: boolean
    symbol?: boolean
    timeframe?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["performanceTest"]>

  export type PerformanceTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    testType?: boolean
    duration?: boolean
    concurrency?: boolean
    rampUp?: boolean
    targetEndpoint?: boolean
    modelId?: boolean
    strategyId?: boolean
    symbol?: boolean
    timeframe?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["performanceTest"]>

  export type PerformanceTestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    testType?: boolean
    duration?: boolean
    concurrency?: boolean
    rampUp?: boolean
    targetEndpoint?: boolean
    modelId?: boolean
    strategyId?: boolean
    symbol?: boolean
    timeframe?: boolean
    options?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "testType" | "duration" | "concurrency" | "rampUp" | "targetEndpoint" | "modelId" | "strategyId" | "symbol" | "timeframe" | "options" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceTest"]>
  export type PerformanceTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | PerformanceTest$resultsArgs<ExtArgs>
    _count?: boolean | PerformanceTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PerformanceTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PerformanceTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PerformanceTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceTest"
    objects: {
      results: Prisma.$PerformanceTestResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      testType: string
      duration: number
      concurrency: number
      rampUp: number | null
      targetEndpoint: string | null
      modelId: string | null
      strategyId: string | null
      symbol: string | null
      timeframe: string | null
      options: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceTest"]>
    composites: {}
  }

  type PerformanceTestGetPayload<S extends boolean | null | undefined | PerformanceTestDefaultArgs> = $Result.GetResult<Prisma.$PerformanceTestPayload, S>

  type PerformanceTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceTestCountAggregateInputType | true
    }

  export interface PerformanceTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceTest'], meta: { name: 'PerformanceTest' } }
    /**
     * Find zero or one PerformanceTest that matches the filter.
     * @param {PerformanceTestFindUniqueArgs} args - Arguments to find a PerformanceTest
     * @example
     * // Get one PerformanceTest
     * const performanceTest = await prisma.performanceTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceTestFindUniqueArgs>(args: SelectSubset<T, PerformanceTestFindUniqueArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceTestFindUniqueOrThrowArgs} args - Arguments to find a PerformanceTest
     * @example
     * // Get one PerformanceTest
     * const performanceTest = await prisma.performanceTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceTestFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestFindFirstArgs} args - Arguments to find a PerformanceTest
     * @example
     * // Get one PerformanceTest
     * const performanceTest = await prisma.performanceTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceTestFindFirstArgs>(args?: SelectSubset<T, PerformanceTestFindFirstArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestFindFirstOrThrowArgs} args - Arguments to find a PerformanceTest
     * @example
     * // Get one PerformanceTest
     * const performanceTest = await prisma.performanceTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceTestFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceTests
     * const performanceTests = await prisma.performanceTest.findMany()
     * 
     * // Get first 10 PerformanceTests
     * const performanceTests = await prisma.performanceTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceTestWithIdOnly = await prisma.performanceTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceTestFindManyArgs>(args?: SelectSubset<T, PerformanceTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceTest.
     * @param {PerformanceTestCreateArgs} args - Arguments to create a PerformanceTest.
     * @example
     * // Create one PerformanceTest
     * const PerformanceTest = await prisma.performanceTest.create({
     *   data: {
     *     // ... data to create a PerformanceTest
     *   }
     * })
     * 
     */
    create<T extends PerformanceTestCreateArgs>(args: SelectSubset<T, PerformanceTestCreateArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceTests.
     * @param {PerformanceTestCreateManyArgs} args - Arguments to create many PerformanceTests.
     * @example
     * // Create many PerformanceTests
     * const performanceTest = await prisma.performanceTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceTestCreateManyArgs>(args?: SelectSubset<T, PerformanceTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceTests and returns the data saved in the database.
     * @param {PerformanceTestCreateManyAndReturnArgs} args - Arguments to create many PerformanceTests.
     * @example
     * // Create many PerformanceTests
     * const performanceTest = await prisma.performanceTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceTests and only return the `id`
     * const performanceTestWithIdOnly = await prisma.performanceTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceTestCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceTest.
     * @param {PerformanceTestDeleteArgs} args - Arguments to delete one PerformanceTest.
     * @example
     * // Delete one PerformanceTest
     * const PerformanceTest = await prisma.performanceTest.delete({
     *   where: {
     *     // ... filter to delete one PerformanceTest
     *   }
     * })
     * 
     */
    delete<T extends PerformanceTestDeleteArgs>(args: SelectSubset<T, PerformanceTestDeleteArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceTest.
     * @param {PerformanceTestUpdateArgs} args - Arguments to update one PerformanceTest.
     * @example
     * // Update one PerformanceTest
     * const performanceTest = await prisma.performanceTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceTestUpdateArgs>(args: SelectSubset<T, PerformanceTestUpdateArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceTests.
     * @param {PerformanceTestDeleteManyArgs} args - Arguments to filter PerformanceTests to delete.
     * @example
     * // Delete a few PerformanceTests
     * const { count } = await prisma.performanceTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceTestDeleteManyArgs>(args?: SelectSubset<T, PerformanceTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceTests
     * const performanceTest = await prisma.performanceTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceTestUpdateManyArgs>(args: SelectSubset<T, PerformanceTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceTests and returns the data updated in the database.
     * @param {PerformanceTestUpdateManyAndReturnArgs} args - Arguments to update many PerformanceTests.
     * @example
     * // Update many PerformanceTests
     * const performanceTest = await prisma.performanceTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceTests and only return the `id`
     * const performanceTestWithIdOnly = await prisma.performanceTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceTestUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceTest.
     * @param {PerformanceTestUpsertArgs} args - Arguments to update or create a PerformanceTest.
     * @example
     * // Update or create a PerformanceTest
     * const performanceTest = await prisma.performanceTest.upsert({
     *   create: {
     *     // ... data to create a PerformanceTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceTest we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceTestUpsertArgs>(args: SelectSubset<T, PerformanceTestUpsertArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestCountArgs} args - Arguments to filter PerformanceTests to count.
     * @example
     * // Count the number of PerformanceTests
     * const count = await prisma.performanceTest.count({
     *   where: {
     *     // ... the filter for the PerformanceTests we want to count
     *   }
     * })
    **/
    count<T extends PerformanceTestCountArgs>(
      args?: Subset<T, PerformanceTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceTestAggregateArgs>(args: Subset<T, PerformanceTestAggregateArgs>): Prisma.PrismaPromise<GetPerformanceTestAggregateType<T>>

    /**
     * Group by PerformanceTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceTestGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceTest model
   */
  readonly fields: PerformanceTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends PerformanceTest$resultsArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceTest$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceTest model
   */
  interface PerformanceTestFieldRefs {
    readonly id: FieldRef<"PerformanceTest", 'String'>
    readonly name: FieldRef<"PerformanceTest", 'String'>
    readonly description: FieldRef<"PerformanceTest", 'String'>
    readonly testType: FieldRef<"PerformanceTest", 'String'>
    readonly duration: FieldRef<"PerformanceTest", 'Int'>
    readonly concurrency: FieldRef<"PerformanceTest", 'Int'>
    readonly rampUp: FieldRef<"PerformanceTest", 'Int'>
    readonly targetEndpoint: FieldRef<"PerformanceTest", 'String'>
    readonly modelId: FieldRef<"PerformanceTest", 'String'>
    readonly strategyId: FieldRef<"PerformanceTest", 'String'>
    readonly symbol: FieldRef<"PerformanceTest", 'String'>
    readonly timeframe: FieldRef<"PerformanceTest", 'String'>
    readonly options: FieldRef<"PerformanceTest", 'Json'>
    readonly createdAt: FieldRef<"PerformanceTest", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceTest findUnique
   */
  export type PerformanceTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTest to fetch.
     */
    where: PerformanceTestWhereUniqueInput
  }

  /**
   * PerformanceTest findUniqueOrThrow
   */
  export type PerformanceTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTest to fetch.
     */
    where: PerformanceTestWhereUniqueInput
  }

  /**
   * PerformanceTest findFirst
   */
  export type PerformanceTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTest to fetch.
     */
    where?: PerformanceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTests to fetch.
     */
    orderBy?: PerformanceTestOrderByWithRelationInput | PerformanceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceTests.
     */
    cursor?: PerformanceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceTests.
     */
    distinct?: PerformanceTestScalarFieldEnum | PerformanceTestScalarFieldEnum[]
  }

  /**
   * PerformanceTest findFirstOrThrow
   */
  export type PerformanceTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTest to fetch.
     */
    where?: PerformanceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTests to fetch.
     */
    orderBy?: PerformanceTestOrderByWithRelationInput | PerformanceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceTests.
     */
    cursor?: PerformanceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceTests.
     */
    distinct?: PerformanceTestScalarFieldEnum | PerformanceTestScalarFieldEnum[]
  }

  /**
   * PerformanceTest findMany
   */
  export type PerformanceTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTests to fetch.
     */
    where?: PerformanceTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTests to fetch.
     */
    orderBy?: PerformanceTestOrderByWithRelationInput | PerformanceTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceTests.
     */
    cursor?: PerformanceTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTests.
     */
    skip?: number
    distinct?: PerformanceTestScalarFieldEnum | PerformanceTestScalarFieldEnum[]
  }

  /**
   * PerformanceTest create
   */
  export type PerformanceTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceTest.
     */
    data: XOR<PerformanceTestCreateInput, PerformanceTestUncheckedCreateInput>
  }

  /**
   * PerformanceTest createMany
   */
  export type PerformanceTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceTests.
     */
    data: PerformanceTestCreateManyInput | PerformanceTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceTest createManyAndReturn
   */
  export type PerformanceTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceTests.
     */
    data: PerformanceTestCreateManyInput | PerformanceTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceTest update
   */
  export type PerformanceTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceTest.
     */
    data: XOR<PerformanceTestUpdateInput, PerformanceTestUncheckedUpdateInput>
    /**
     * Choose, which PerformanceTest to update.
     */
    where: PerformanceTestWhereUniqueInput
  }

  /**
   * PerformanceTest updateMany
   */
  export type PerformanceTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceTests.
     */
    data: XOR<PerformanceTestUpdateManyMutationInput, PerformanceTestUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceTests to update
     */
    where?: PerformanceTestWhereInput
    /**
     * Limit how many PerformanceTests to update.
     */
    limit?: number
  }

  /**
   * PerformanceTest updateManyAndReturn
   */
  export type PerformanceTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceTests.
     */
    data: XOR<PerformanceTestUpdateManyMutationInput, PerformanceTestUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceTests to update
     */
    where?: PerformanceTestWhereInput
    /**
     * Limit how many PerformanceTests to update.
     */
    limit?: number
  }

  /**
   * PerformanceTest upsert
   */
  export type PerformanceTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceTest to update in case it exists.
     */
    where: PerformanceTestWhereUniqueInput
    /**
     * In case the PerformanceTest found by the `where` argument doesn't exist, create a new PerformanceTest with this data.
     */
    create: XOR<PerformanceTestCreateInput, PerformanceTestUncheckedCreateInput>
    /**
     * In case the PerformanceTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceTestUpdateInput, PerformanceTestUncheckedUpdateInput>
  }

  /**
   * PerformanceTest delete
   */
  export type PerformanceTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
    /**
     * Filter which PerformanceTest to delete.
     */
    where: PerformanceTestWhereUniqueInput
  }

  /**
   * PerformanceTest deleteMany
   */
  export type PerformanceTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceTests to delete
     */
    where?: PerformanceTestWhereInput
    /**
     * Limit how many PerformanceTests to delete.
     */
    limit?: number
  }

  /**
   * PerformanceTest.results
   */
  export type PerformanceTest$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    where?: PerformanceTestResultWhereInput
    orderBy?: PerformanceTestResultOrderByWithRelationInput | PerformanceTestResultOrderByWithRelationInput[]
    cursor?: PerformanceTestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceTestResultScalarFieldEnum | PerformanceTestResultScalarFieldEnum[]
  }

  /**
   * PerformanceTest without action
   */
  export type PerformanceTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTest
     */
    select?: PerformanceTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTest
     */
    omit?: PerformanceTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceTestResult
   */

  export type AggregatePerformanceTestResult = {
    _count: PerformanceTestResultCountAggregateOutputType | null
    _avg: PerformanceTestResultAvgAggregateOutputType | null
    _sum: PerformanceTestResultSumAggregateOutputType | null
    _min: PerformanceTestResultMinAggregateOutputType | null
    _max: PerformanceTestResultMaxAggregateOutputType | null
  }

  export type PerformanceTestResultAvgAggregateOutputType = {
    duration: number | null
  }

  export type PerformanceTestResultSumAggregateOutputType = {
    duration: number | null
  }

  export type PerformanceTestResultMinAggregateOutputType = {
    id: string | null
    testId: string | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceTestResultMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceTestResultCountAggregateOutputType = {
    id: number
    testId: number
    status: number
    startTime: number
    endTime: number
    duration: number
    metrics: number
    errors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceTestResultAvgAggregateInputType = {
    duration?: true
  }

  export type PerformanceTestResultSumAggregateInputType = {
    duration?: true
  }

  export type PerformanceTestResultMinAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceTestResultMaxAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceTestResultCountAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    metrics?: true
    errors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceTestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceTestResult to aggregate.
     */
    where?: PerformanceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTestResults to fetch.
     */
    orderBy?: PerformanceTestResultOrderByWithRelationInput | PerformanceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceTestResults
    **/
    _count?: true | PerformanceTestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceTestResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceTestResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceTestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceTestResultMaxAggregateInputType
  }

  export type GetPerformanceTestResultAggregateType<T extends PerformanceTestResultAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceTestResult[P]>
      : GetScalarType<T[P], AggregatePerformanceTestResult[P]>
  }




  export type PerformanceTestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceTestResultWhereInput
    orderBy?: PerformanceTestResultOrderByWithAggregationInput | PerformanceTestResultOrderByWithAggregationInput[]
    by: PerformanceTestResultScalarFieldEnum[] | PerformanceTestResultScalarFieldEnum
    having?: PerformanceTestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceTestResultCountAggregateInputType | true
    _avg?: PerformanceTestResultAvgAggregateInputType
    _sum?: PerformanceTestResultSumAggregateInputType
    _min?: PerformanceTestResultMinAggregateInputType
    _max?: PerformanceTestResultMaxAggregateInputType
  }

  export type PerformanceTestResultGroupByOutputType = {
    id: string
    testId: string
    status: string
    startTime: Date
    endTime: Date | null
    duration: number | null
    metrics: JsonValue
    errors: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PerformanceTestResultCountAggregateOutputType | null
    _avg: PerformanceTestResultAvgAggregateOutputType | null
    _sum: PerformanceTestResultSumAggregateOutputType | null
    _min: PerformanceTestResultMinAggregateOutputType | null
    _max: PerformanceTestResultMaxAggregateOutputType | null
  }

  type GetPerformanceTestResultGroupByPayload<T extends PerformanceTestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceTestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceTestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceTestResultGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceTestResultGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceTestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    metrics?: boolean
    errors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
    recommendations?: boolean | PerformanceTestResult$recommendationsArgs<ExtArgs>
    _count?: boolean | PerformanceTestResultCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceTestResult"]>

  export type PerformanceTestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    metrics?: boolean
    errors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceTestResult"]>

  export type PerformanceTestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    metrics?: boolean
    errors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceTestResult"]>

  export type PerformanceTestResultSelectScalar = {
    id?: boolean
    testId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    metrics?: boolean
    errors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceTestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "status" | "startTime" | "endTime" | "duration" | "metrics" | "errors" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceTestResult"]>
  export type PerformanceTestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
    recommendations?: boolean | PerformanceTestResult$recommendationsArgs<ExtArgs>
    _count?: boolean | PerformanceTestResultCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PerformanceTestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
  }
  export type PerformanceTestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | PerformanceTestDefaultArgs<ExtArgs>
  }

  export type $PerformanceTestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceTestResult"
    objects: {
      test: Prisma.$PerformanceTestPayload<ExtArgs>
      recommendations: Prisma.$OptimizationRecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      status: string
      startTime: Date
      endTime: Date | null
      duration: number | null
      metrics: Prisma.JsonValue
      errors: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceTestResult"]>
    composites: {}
  }

  type PerformanceTestResultGetPayload<S extends boolean | null | undefined | PerformanceTestResultDefaultArgs> = $Result.GetResult<Prisma.$PerformanceTestResultPayload, S>

  type PerformanceTestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceTestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceTestResultCountAggregateInputType | true
    }

  export interface PerformanceTestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceTestResult'], meta: { name: 'PerformanceTestResult' } }
    /**
     * Find zero or one PerformanceTestResult that matches the filter.
     * @param {PerformanceTestResultFindUniqueArgs} args - Arguments to find a PerformanceTestResult
     * @example
     * // Get one PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceTestResultFindUniqueArgs>(args: SelectSubset<T, PerformanceTestResultFindUniqueArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceTestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceTestResultFindUniqueOrThrowArgs} args - Arguments to find a PerformanceTestResult
     * @example
     * // Get one PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceTestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceTestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceTestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultFindFirstArgs} args - Arguments to find a PerformanceTestResult
     * @example
     * // Get one PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceTestResultFindFirstArgs>(args?: SelectSubset<T, PerformanceTestResultFindFirstArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceTestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultFindFirstOrThrowArgs} args - Arguments to find a PerformanceTestResult
     * @example
     * // Get one PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceTestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceTestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceTestResults
     * const performanceTestResults = await prisma.performanceTestResult.findMany()
     * 
     * // Get first 10 PerformanceTestResults
     * const performanceTestResults = await prisma.performanceTestResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceTestResultWithIdOnly = await prisma.performanceTestResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceTestResultFindManyArgs>(args?: SelectSubset<T, PerformanceTestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceTestResult.
     * @param {PerformanceTestResultCreateArgs} args - Arguments to create a PerformanceTestResult.
     * @example
     * // Create one PerformanceTestResult
     * const PerformanceTestResult = await prisma.performanceTestResult.create({
     *   data: {
     *     // ... data to create a PerformanceTestResult
     *   }
     * })
     * 
     */
    create<T extends PerformanceTestResultCreateArgs>(args: SelectSubset<T, PerformanceTestResultCreateArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceTestResults.
     * @param {PerformanceTestResultCreateManyArgs} args - Arguments to create many PerformanceTestResults.
     * @example
     * // Create many PerformanceTestResults
     * const performanceTestResult = await prisma.performanceTestResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceTestResultCreateManyArgs>(args?: SelectSubset<T, PerformanceTestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceTestResults and returns the data saved in the database.
     * @param {PerformanceTestResultCreateManyAndReturnArgs} args - Arguments to create many PerformanceTestResults.
     * @example
     * // Create many PerformanceTestResults
     * const performanceTestResult = await prisma.performanceTestResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceTestResults and only return the `id`
     * const performanceTestResultWithIdOnly = await prisma.performanceTestResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceTestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceTestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceTestResult.
     * @param {PerformanceTestResultDeleteArgs} args - Arguments to delete one PerformanceTestResult.
     * @example
     * // Delete one PerformanceTestResult
     * const PerformanceTestResult = await prisma.performanceTestResult.delete({
     *   where: {
     *     // ... filter to delete one PerformanceTestResult
     *   }
     * })
     * 
     */
    delete<T extends PerformanceTestResultDeleteArgs>(args: SelectSubset<T, PerformanceTestResultDeleteArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceTestResult.
     * @param {PerformanceTestResultUpdateArgs} args - Arguments to update one PerformanceTestResult.
     * @example
     * // Update one PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceTestResultUpdateArgs>(args: SelectSubset<T, PerformanceTestResultUpdateArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceTestResults.
     * @param {PerformanceTestResultDeleteManyArgs} args - Arguments to filter PerformanceTestResults to delete.
     * @example
     * // Delete a few PerformanceTestResults
     * const { count } = await prisma.performanceTestResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceTestResultDeleteManyArgs>(args?: SelectSubset<T, PerformanceTestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceTestResults
     * const performanceTestResult = await prisma.performanceTestResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceTestResultUpdateManyArgs>(args: SelectSubset<T, PerformanceTestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceTestResults and returns the data updated in the database.
     * @param {PerformanceTestResultUpdateManyAndReturnArgs} args - Arguments to update many PerformanceTestResults.
     * @example
     * // Update many PerformanceTestResults
     * const performanceTestResult = await prisma.performanceTestResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceTestResults and only return the `id`
     * const performanceTestResultWithIdOnly = await prisma.performanceTestResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceTestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceTestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceTestResult.
     * @param {PerformanceTestResultUpsertArgs} args - Arguments to update or create a PerformanceTestResult.
     * @example
     * // Update or create a PerformanceTestResult
     * const performanceTestResult = await prisma.performanceTestResult.upsert({
     *   create: {
     *     // ... data to create a PerformanceTestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceTestResult we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceTestResultUpsertArgs>(args: SelectSubset<T, PerformanceTestResultUpsertArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultCountArgs} args - Arguments to filter PerformanceTestResults to count.
     * @example
     * // Count the number of PerformanceTestResults
     * const count = await prisma.performanceTestResult.count({
     *   where: {
     *     // ... the filter for the PerformanceTestResults we want to count
     *   }
     * })
    **/
    count<T extends PerformanceTestResultCountArgs>(
      args?: Subset<T, PerformanceTestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceTestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceTestResultAggregateArgs>(args: Subset<T, PerformanceTestResultAggregateArgs>): Prisma.PrismaPromise<GetPerformanceTestResultAggregateType<T>>

    /**
     * Group by PerformanceTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceTestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceTestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceTestResultGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceTestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceTestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceTestResult model
   */
  readonly fields: PerformanceTestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceTestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceTestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends PerformanceTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceTestDefaultArgs<ExtArgs>>): Prisma__PerformanceTestClient<$Result.GetResult<Prisma.$PerformanceTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recommendations<T extends PerformanceTestResult$recommendationsArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceTestResult$recommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceTestResult model
   */
  interface PerformanceTestResultFieldRefs {
    readonly id: FieldRef<"PerformanceTestResult", 'String'>
    readonly testId: FieldRef<"PerformanceTestResult", 'String'>
    readonly status: FieldRef<"PerformanceTestResult", 'String'>
    readonly startTime: FieldRef<"PerformanceTestResult", 'DateTime'>
    readonly endTime: FieldRef<"PerformanceTestResult", 'DateTime'>
    readonly duration: FieldRef<"PerformanceTestResult", 'Int'>
    readonly metrics: FieldRef<"PerformanceTestResult", 'Json'>
    readonly errors: FieldRef<"PerformanceTestResult", 'Json'>
    readonly createdAt: FieldRef<"PerformanceTestResult", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceTestResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceTestResult findUnique
   */
  export type PerformanceTestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTestResult to fetch.
     */
    where: PerformanceTestResultWhereUniqueInput
  }

  /**
   * PerformanceTestResult findUniqueOrThrow
   */
  export type PerformanceTestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTestResult to fetch.
     */
    where: PerformanceTestResultWhereUniqueInput
  }

  /**
   * PerformanceTestResult findFirst
   */
  export type PerformanceTestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTestResult to fetch.
     */
    where?: PerformanceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTestResults to fetch.
     */
    orderBy?: PerformanceTestResultOrderByWithRelationInput | PerformanceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceTestResults.
     */
    cursor?: PerformanceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceTestResults.
     */
    distinct?: PerformanceTestResultScalarFieldEnum | PerformanceTestResultScalarFieldEnum[]
  }

  /**
   * PerformanceTestResult findFirstOrThrow
   */
  export type PerformanceTestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTestResult to fetch.
     */
    where?: PerformanceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTestResults to fetch.
     */
    orderBy?: PerformanceTestResultOrderByWithRelationInput | PerformanceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceTestResults.
     */
    cursor?: PerformanceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceTestResults.
     */
    distinct?: PerformanceTestResultScalarFieldEnum | PerformanceTestResultScalarFieldEnum[]
  }

  /**
   * PerformanceTestResult findMany
   */
  export type PerformanceTestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceTestResults to fetch.
     */
    where?: PerformanceTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceTestResults to fetch.
     */
    orderBy?: PerformanceTestResultOrderByWithRelationInput | PerformanceTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceTestResults.
     */
    cursor?: PerformanceTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceTestResults.
     */
    skip?: number
    distinct?: PerformanceTestResultScalarFieldEnum | PerformanceTestResultScalarFieldEnum[]
  }

  /**
   * PerformanceTestResult create
   */
  export type PerformanceTestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceTestResult.
     */
    data: XOR<PerformanceTestResultCreateInput, PerformanceTestResultUncheckedCreateInput>
  }

  /**
   * PerformanceTestResult createMany
   */
  export type PerformanceTestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceTestResults.
     */
    data: PerformanceTestResultCreateManyInput | PerformanceTestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceTestResult createManyAndReturn
   */
  export type PerformanceTestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceTestResults.
     */
    data: PerformanceTestResultCreateManyInput | PerformanceTestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceTestResult update
   */
  export type PerformanceTestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceTestResult.
     */
    data: XOR<PerformanceTestResultUpdateInput, PerformanceTestResultUncheckedUpdateInput>
    /**
     * Choose, which PerformanceTestResult to update.
     */
    where: PerformanceTestResultWhereUniqueInput
  }

  /**
   * PerformanceTestResult updateMany
   */
  export type PerformanceTestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceTestResults.
     */
    data: XOR<PerformanceTestResultUpdateManyMutationInput, PerformanceTestResultUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceTestResults to update
     */
    where?: PerformanceTestResultWhereInput
    /**
     * Limit how many PerformanceTestResults to update.
     */
    limit?: number
  }

  /**
   * PerformanceTestResult updateManyAndReturn
   */
  export type PerformanceTestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceTestResults.
     */
    data: XOR<PerformanceTestResultUpdateManyMutationInput, PerformanceTestResultUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceTestResults to update
     */
    where?: PerformanceTestResultWhereInput
    /**
     * Limit how many PerformanceTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceTestResult upsert
   */
  export type PerformanceTestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceTestResult to update in case it exists.
     */
    where: PerformanceTestResultWhereUniqueInput
    /**
     * In case the PerformanceTestResult found by the `where` argument doesn't exist, create a new PerformanceTestResult with this data.
     */
    create: XOR<PerformanceTestResultCreateInput, PerformanceTestResultUncheckedCreateInput>
    /**
     * In case the PerformanceTestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceTestResultUpdateInput, PerformanceTestResultUncheckedUpdateInput>
  }

  /**
   * PerformanceTestResult delete
   */
  export type PerformanceTestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
    /**
     * Filter which PerformanceTestResult to delete.
     */
    where: PerformanceTestResultWhereUniqueInput
  }

  /**
   * PerformanceTestResult deleteMany
   */
  export type PerformanceTestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceTestResults to delete
     */
    where?: PerformanceTestResultWhereInput
    /**
     * Limit how many PerformanceTestResults to delete.
     */
    limit?: number
  }

  /**
   * PerformanceTestResult.recommendations
   */
  export type PerformanceTestResult$recommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    where?: OptimizationRecommendationWhereInput
    orderBy?: OptimizationRecommendationOrderByWithRelationInput | OptimizationRecommendationOrderByWithRelationInput[]
    cursor?: OptimizationRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptimizationRecommendationScalarFieldEnum | OptimizationRecommendationScalarFieldEnum[]
  }

  /**
   * PerformanceTestResult without action
   */
  export type PerformanceTestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceTestResult
     */
    select?: PerformanceTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceTestResult
     */
    omit?: PerformanceTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceTestResultInclude<ExtArgs> | null
  }


  /**
   * Model OptimizationRecommendation
   */

  export type AggregateOptimizationRecommendation = {
    _count: OptimizationRecommendationCountAggregateOutputType | null
    _min: OptimizationRecommendationMinAggregateOutputType | null
    _max: OptimizationRecommendationMaxAggregateOutputType | null
  }

  export type OptimizationRecommendationMinAggregateOutputType = {
    id: string | null
    testResultId: string | null
    category: string | null
    impact: string | null
    description: string | null
    implementation: string | null
    estimatedImprovement: string | null
    createdAt: Date | null
  }

  export type OptimizationRecommendationMaxAggregateOutputType = {
    id: string | null
    testResultId: string | null
    category: string | null
    impact: string | null
    description: string | null
    implementation: string | null
    estimatedImprovement: string | null
    createdAt: Date | null
  }

  export type OptimizationRecommendationCountAggregateOutputType = {
    id: number
    testResultId: number
    category: number
    impact: number
    description: number
    implementation: number
    estimatedImprovement: number
    createdAt: number
    _all: number
  }


  export type OptimizationRecommendationMinAggregateInputType = {
    id?: true
    testResultId?: true
    category?: true
    impact?: true
    description?: true
    implementation?: true
    estimatedImprovement?: true
    createdAt?: true
  }

  export type OptimizationRecommendationMaxAggregateInputType = {
    id?: true
    testResultId?: true
    category?: true
    impact?: true
    description?: true
    implementation?: true
    estimatedImprovement?: true
    createdAt?: true
  }

  export type OptimizationRecommendationCountAggregateInputType = {
    id?: true
    testResultId?: true
    category?: true
    impact?: true
    description?: true
    implementation?: true
    estimatedImprovement?: true
    createdAt?: true
    _all?: true
  }

  export type OptimizationRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRecommendation to aggregate.
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecommendations to fetch.
     */
    orderBy?: OptimizationRecommendationOrderByWithRelationInput | OptimizationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptimizationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptimizationRecommendations
    **/
    _count?: true | OptimizationRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptimizationRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptimizationRecommendationMaxAggregateInputType
  }

  export type GetOptimizationRecommendationAggregateType<T extends OptimizationRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateOptimizationRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptimizationRecommendation[P]>
      : GetScalarType<T[P], AggregateOptimizationRecommendation[P]>
  }




  export type OptimizationRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptimizationRecommendationWhereInput
    orderBy?: OptimizationRecommendationOrderByWithAggregationInput | OptimizationRecommendationOrderByWithAggregationInput[]
    by: OptimizationRecommendationScalarFieldEnum[] | OptimizationRecommendationScalarFieldEnum
    having?: OptimizationRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptimizationRecommendationCountAggregateInputType | true
    _min?: OptimizationRecommendationMinAggregateInputType
    _max?: OptimizationRecommendationMaxAggregateInputType
  }

  export type OptimizationRecommendationGroupByOutputType = {
    id: string
    testResultId: string
    category: string
    impact: string
    description: string
    implementation: string | null
    estimatedImprovement: string | null
    createdAt: Date
    _count: OptimizationRecommendationCountAggregateOutputType | null
    _min: OptimizationRecommendationMinAggregateOutputType | null
    _max: OptimizationRecommendationMaxAggregateOutputType | null
  }

  type GetOptimizationRecommendationGroupByPayload<T extends OptimizationRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptimizationRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptimizationRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptimizationRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], OptimizationRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type OptimizationRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    category?: boolean
    impact?: boolean
    description?: boolean
    implementation?: boolean
    estimatedImprovement?: boolean
    createdAt?: boolean
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRecommendation"]>

  export type OptimizationRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    category?: boolean
    impact?: boolean
    description?: boolean
    implementation?: boolean
    estimatedImprovement?: boolean
    createdAt?: boolean
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRecommendation"]>

  export type OptimizationRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testResultId?: boolean
    category?: boolean
    impact?: boolean
    description?: boolean
    implementation?: boolean
    estimatedImprovement?: boolean
    createdAt?: boolean
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRecommendation"]>

  export type OptimizationRecommendationSelectScalar = {
    id?: boolean
    testResultId?: boolean
    category?: boolean
    impact?: boolean
    description?: boolean
    implementation?: boolean
    estimatedImprovement?: boolean
    createdAt?: boolean
  }

  export type OptimizationRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testResultId" | "category" | "impact" | "description" | "implementation" | "estimatedImprovement" | "createdAt", ExtArgs["result"]["optimizationRecommendation"]>
  export type OptimizationRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }
  export type OptimizationRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }
  export type OptimizationRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResult?: boolean | PerformanceTestResultDefaultArgs<ExtArgs>
  }

  export type $OptimizationRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptimizationRecommendation"
    objects: {
      testResult: Prisma.$PerformanceTestResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testResultId: string
      category: string
      impact: string
      description: string
      implementation: string | null
      estimatedImprovement: string | null
      createdAt: Date
    }, ExtArgs["result"]["optimizationRecommendation"]>
    composites: {}
  }

  type OptimizationRecommendationGetPayload<S extends boolean | null | undefined | OptimizationRecommendationDefaultArgs> = $Result.GetResult<Prisma.$OptimizationRecommendationPayload, S>

  type OptimizationRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptimizationRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptimizationRecommendationCountAggregateInputType | true
    }

  export interface OptimizationRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptimizationRecommendation'], meta: { name: 'OptimizationRecommendation' } }
    /**
     * Find zero or one OptimizationRecommendation that matches the filter.
     * @param {OptimizationRecommendationFindUniqueArgs} args - Arguments to find a OptimizationRecommendation
     * @example
     * // Get one OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptimizationRecommendationFindUniqueArgs>(args: SelectSubset<T, OptimizationRecommendationFindUniqueArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OptimizationRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptimizationRecommendationFindUniqueOrThrowArgs} args - Arguments to find a OptimizationRecommendation
     * @example
     * // Get one OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptimizationRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, OptimizationRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptimizationRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationFindFirstArgs} args - Arguments to find a OptimizationRecommendation
     * @example
     * // Get one OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptimizationRecommendationFindFirstArgs>(args?: SelectSubset<T, OptimizationRecommendationFindFirstArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OptimizationRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationFindFirstOrThrowArgs} args - Arguments to find a OptimizationRecommendation
     * @example
     * // Get one OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptimizationRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, OptimizationRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OptimizationRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptimizationRecommendations
     * const optimizationRecommendations = await prisma.optimizationRecommendation.findMany()
     * 
     * // Get first 10 OptimizationRecommendations
     * const optimizationRecommendations = await prisma.optimizationRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optimizationRecommendationWithIdOnly = await prisma.optimizationRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptimizationRecommendationFindManyArgs>(args?: SelectSubset<T, OptimizationRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OptimizationRecommendation.
     * @param {OptimizationRecommendationCreateArgs} args - Arguments to create a OptimizationRecommendation.
     * @example
     * // Create one OptimizationRecommendation
     * const OptimizationRecommendation = await prisma.optimizationRecommendation.create({
     *   data: {
     *     // ... data to create a OptimizationRecommendation
     *   }
     * })
     * 
     */
    create<T extends OptimizationRecommendationCreateArgs>(args: SelectSubset<T, OptimizationRecommendationCreateArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OptimizationRecommendations.
     * @param {OptimizationRecommendationCreateManyArgs} args - Arguments to create many OptimizationRecommendations.
     * @example
     * // Create many OptimizationRecommendations
     * const optimizationRecommendation = await prisma.optimizationRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptimizationRecommendationCreateManyArgs>(args?: SelectSubset<T, OptimizationRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OptimizationRecommendations and returns the data saved in the database.
     * @param {OptimizationRecommendationCreateManyAndReturnArgs} args - Arguments to create many OptimizationRecommendations.
     * @example
     * // Create many OptimizationRecommendations
     * const optimizationRecommendation = await prisma.optimizationRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OptimizationRecommendations and only return the `id`
     * const optimizationRecommendationWithIdOnly = await prisma.optimizationRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptimizationRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, OptimizationRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OptimizationRecommendation.
     * @param {OptimizationRecommendationDeleteArgs} args - Arguments to delete one OptimizationRecommendation.
     * @example
     * // Delete one OptimizationRecommendation
     * const OptimizationRecommendation = await prisma.optimizationRecommendation.delete({
     *   where: {
     *     // ... filter to delete one OptimizationRecommendation
     *   }
     * })
     * 
     */
    delete<T extends OptimizationRecommendationDeleteArgs>(args: SelectSubset<T, OptimizationRecommendationDeleteArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OptimizationRecommendation.
     * @param {OptimizationRecommendationUpdateArgs} args - Arguments to update one OptimizationRecommendation.
     * @example
     * // Update one OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptimizationRecommendationUpdateArgs>(args: SelectSubset<T, OptimizationRecommendationUpdateArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OptimizationRecommendations.
     * @param {OptimizationRecommendationDeleteManyArgs} args - Arguments to filter OptimizationRecommendations to delete.
     * @example
     * // Delete a few OptimizationRecommendations
     * const { count } = await prisma.optimizationRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptimizationRecommendationDeleteManyArgs>(args?: SelectSubset<T, OptimizationRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptimizationRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptimizationRecommendations
     * const optimizationRecommendation = await prisma.optimizationRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptimizationRecommendationUpdateManyArgs>(args: SelectSubset<T, OptimizationRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptimizationRecommendations and returns the data updated in the database.
     * @param {OptimizationRecommendationUpdateManyAndReturnArgs} args - Arguments to update many OptimizationRecommendations.
     * @example
     * // Update many OptimizationRecommendations
     * const optimizationRecommendation = await prisma.optimizationRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OptimizationRecommendations and only return the `id`
     * const optimizationRecommendationWithIdOnly = await prisma.optimizationRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptimizationRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, OptimizationRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OptimizationRecommendation.
     * @param {OptimizationRecommendationUpsertArgs} args - Arguments to update or create a OptimizationRecommendation.
     * @example
     * // Update or create a OptimizationRecommendation
     * const optimizationRecommendation = await prisma.optimizationRecommendation.upsert({
     *   create: {
     *     // ... data to create a OptimizationRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptimizationRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends OptimizationRecommendationUpsertArgs>(args: SelectSubset<T, OptimizationRecommendationUpsertArgs<ExtArgs>>): Prisma__OptimizationRecommendationClient<$Result.GetResult<Prisma.$OptimizationRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OptimizationRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationCountArgs} args - Arguments to filter OptimizationRecommendations to count.
     * @example
     * // Count the number of OptimizationRecommendations
     * const count = await prisma.optimizationRecommendation.count({
     *   where: {
     *     // ... the filter for the OptimizationRecommendations we want to count
     *   }
     * })
    **/
    count<T extends OptimizationRecommendationCountArgs>(
      args?: Subset<T, OptimizationRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptimizationRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptimizationRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptimizationRecommendationAggregateArgs>(args: Subset<T, OptimizationRecommendationAggregateArgs>): Prisma.PrismaPromise<GetOptimizationRecommendationAggregateType<T>>

    /**
     * Group by OptimizationRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptimizationRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptimizationRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: OptimizationRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptimizationRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptimizationRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptimizationRecommendation model
   */
  readonly fields: OptimizationRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptimizationRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptimizationRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testResult<T extends PerformanceTestResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceTestResultDefaultArgs<ExtArgs>>): Prisma__PerformanceTestResultClient<$Result.GetResult<Prisma.$PerformanceTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptimizationRecommendation model
   */
  interface OptimizationRecommendationFieldRefs {
    readonly id: FieldRef<"OptimizationRecommendation", 'String'>
    readonly testResultId: FieldRef<"OptimizationRecommendation", 'String'>
    readonly category: FieldRef<"OptimizationRecommendation", 'String'>
    readonly impact: FieldRef<"OptimizationRecommendation", 'String'>
    readonly description: FieldRef<"OptimizationRecommendation", 'String'>
    readonly implementation: FieldRef<"OptimizationRecommendation", 'String'>
    readonly estimatedImprovement: FieldRef<"OptimizationRecommendation", 'String'>
    readonly createdAt: FieldRef<"OptimizationRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OptimizationRecommendation findUnique
   */
  export type OptimizationRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecommendation to fetch.
     */
    where: OptimizationRecommendationWhereUniqueInput
  }

  /**
   * OptimizationRecommendation findUniqueOrThrow
   */
  export type OptimizationRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecommendation to fetch.
     */
    where: OptimizationRecommendationWhereUniqueInput
  }

  /**
   * OptimizationRecommendation findFirst
   */
  export type OptimizationRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecommendation to fetch.
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecommendations to fetch.
     */
    orderBy?: OptimizationRecommendationOrderByWithRelationInput | OptimizationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRecommendations.
     */
    cursor?: OptimizationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRecommendations.
     */
    distinct?: OptimizationRecommendationScalarFieldEnum | OptimizationRecommendationScalarFieldEnum[]
  }

  /**
   * OptimizationRecommendation findFirstOrThrow
   */
  export type OptimizationRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecommendation to fetch.
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecommendations to fetch.
     */
    orderBy?: OptimizationRecommendationOrderByWithRelationInput | OptimizationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRecommendations.
     */
    cursor?: OptimizationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRecommendations.
     */
    distinct?: OptimizationRecommendationScalarFieldEnum | OptimizationRecommendationScalarFieldEnum[]
  }

  /**
   * OptimizationRecommendation findMany
   */
  export type OptimizationRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecommendations to fetch.
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecommendations to fetch.
     */
    orderBy?: OptimizationRecommendationOrderByWithRelationInput | OptimizationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptimizationRecommendations.
     */
    cursor?: OptimizationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecommendations.
     */
    skip?: number
    distinct?: OptimizationRecommendationScalarFieldEnum | OptimizationRecommendationScalarFieldEnum[]
  }

  /**
   * OptimizationRecommendation create
   */
  export type OptimizationRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a OptimizationRecommendation.
     */
    data: XOR<OptimizationRecommendationCreateInput, OptimizationRecommendationUncheckedCreateInput>
  }

  /**
   * OptimizationRecommendation createMany
   */
  export type OptimizationRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptimizationRecommendations.
     */
    data: OptimizationRecommendationCreateManyInput | OptimizationRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OptimizationRecommendation createManyAndReturn
   */
  export type OptimizationRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many OptimizationRecommendations.
     */
    data: OptimizationRecommendationCreateManyInput | OptimizationRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptimizationRecommendation update
   */
  export type OptimizationRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a OptimizationRecommendation.
     */
    data: XOR<OptimizationRecommendationUpdateInput, OptimizationRecommendationUncheckedUpdateInput>
    /**
     * Choose, which OptimizationRecommendation to update.
     */
    where: OptimizationRecommendationWhereUniqueInput
  }

  /**
   * OptimizationRecommendation updateMany
   */
  export type OptimizationRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptimizationRecommendations.
     */
    data: XOR<OptimizationRecommendationUpdateManyMutationInput, OptimizationRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which OptimizationRecommendations to update
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * Limit how many OptimizationRecommendations to update.
     */
    limit?: number
  }

  /**
   * OptimizationRecommendation updateManyAndReturn
   */
  export type OptimizationRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update OptimizationRecommendations.
     */
    data: XOR<OptimizationRecommendationUpdateManyMutationInput, OptimizationRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which OptimizationRecommendations to update
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * Limit how many OptimizationRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OptimizationRecommendation upsert
   */
  export type OptimizationRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the OptimizationRecommendation to update in case it exists.
     */
    where: OptimizationRecommendationWhereUniqueInput
    /**
     * In case the OptimizationRecommendation found by the `where` argument doesn't exist, create a new OptimizationRecommendation with this data.
     */
    create: XOR<OptimizationRecommendationCreateInput, OptimizationRecommendationUncheckedCreateInput>
    /**
     * In case the OptimizationRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptimizationRecommendationUpdateInput, OptimizationRecommendationUncheckedUpdateInput>
  }

  /**
   * OptimizationRecommendation delete
   */
  export type OptimizationRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
    /**
     * Filter which OptimizationRecommendation to delete.
     */
    where: OptimizationRecommendationWhereUniqueInput
  }

  /**
   * OptimizationRecommendation deleteMany
   */
  export type OptimizationRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRecommendations to delete
     */
    where?: OptimizationRecommendationWhereInput
    /**
     * Limit how many OptimizationRecommendations to delete.
     */
    limit?: number
  }

  /**
   * OptimizationRecommendation without action
   */
  export type OptimizationRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecommendation
     */
    select?: OptimizationRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OptimizationRecommendation
     */
    omit?: OptimizationRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptimizationRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model ABTest
   */

  export type AggregateABTest = {
    _count: ABTestCountAggregateOutputType | null
    _avg: ABTestAvgAggregateOutputType | null
    _sum: ABTestSumAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  export type ABTestAvgAggregateOutputType = {
    targetImprovement: number | null
  }

  export type ABTestSumAggregateOutputType = {
    targetImprovement: number | null
  }

  export type ABTestMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    variantA: string | null
    variantB: string | null
    type: string | null
    metric: string | null
    targetImprovement: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    variantA: string | null
    variantB: string | null
    type: string | null
    metric: string | null
    targetImprovement: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    variantA: number
    variantB: number
    type: number
    metric: number
    targetImprovement: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ABTestAvgAggregateInputType = {
    targetImprovement?: true
  }

  export type ABTestSumAggregateInputType = {
    targetImprovement?: true
  }

  export type ABTestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    variantA?: true
    variantB?: true
    type?: true
    metric?: true
    targetImprovement?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    variantA?: true
    variantB?: true
    type?: true
    metric?: true
    targetImprovement?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    variantA?: true
    variantB?: true
    type?: true
    metric?: true
    targetImprovement?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ABTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTest to aggregate.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABTests
    **/
    _count?: true | ABTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ABTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ABTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABTestMaxAggregateInputType
  }

  export type GetABTestAggregateType<T extends ABTestAggregateArgs> = {
        [P in keyof T & keyof AggregateABTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABTest[P]>
      : GetScalarType<T[P], AggregateABTest[P]>
  }




  export type ABTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestWhereInput
    orderBy?: ABTestOrderByWithAggregationInput | ABTestOrderByWithAggregationInput[]
    by: ABTestScalarFieldEnum[] | ABTestScalarFieldEnum
    having?: ABTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABTestCountAggregateInputType | true
    _avg?: ABTestAvgAggregateInputType
    _sum?: ABTestSumAggregateInputType
    _min?: ABTestMinAggregateInputType
    _max?: ABTestMaxAggregateInputType
  }

  export type ABTestGroupByOutputType = {
    id: string
    name: string
    description: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ABTestCountAggregateOutputType | null
    _avg: ABTestAvgAggregateOutputType | null
    _sum: ABTestSumAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  type GetABTestGroupByPayload<T extends ABTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABTestGroupByOutputType[P]>
            : GetScalarType<T[P], ABTestGroupByOutputType[P]>
        }
      >
    >


  export type ABTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    variantA?: boolean
    variantB?: boolean
    type?: boolean
    metric?: boolean
    targetImprovement?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    results?: boolean | ABTest$resultsArgs<ExtArgs>
    _count?: boolean | ABTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    variantA?: boolean
    variantB?: boolean
    type?: boolean
    metric?: boolean
    targetImprovement?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    variantA?: boolean
    variantB?: boolean
    type?: boolean
    metric?: boolean
    targetImprovement?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    variantA?: boolean
    variantB?: boolean
    type?: boolean
    metric?: boolean
    targetImprovement?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ABTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "variantA" | "variantB" | "type" | "metric" | "targetImprovement" | "status" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["aBTest"]>
  export type ABTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | ABTest$resultsArgs<ExtArgs>
    _count?: boolean | ABTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ABTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ABTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ABTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ABTest"
    objects: {
      results: Prisma.$ABTestResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      variantA: string
      variantB: string
      type: string
      metric: string
      targetImprovement: number
      status: string
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aBTest"]>
    composites: {}
  }

  type ABTestGetPayload<S extends boolean | null | undefined | ABTestDefaultArgs> = $Result.GetResult<Prisma.$ABTestPayload, S>

  type ABTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ABTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ABTestCountAggregateInputType | true
    }

  export interface ABTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABTest'], meta: { name: 'ABTest' } }
    /**
     * Find zero or one ABTest that matches the filter.
     * @param {ABTestFindUniqueArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ABTestFindUniqueArgs>(args: SelectSubset<T, ABTestFindUniqueArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ABTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ABTestFindUniqueOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ABTestFindUniqueOrThrowArgs>(args: SelectSubset<T, ABTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ABTestFindFirstArgs>(args?: SelectSubset<T, ABTestFindFirstArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ABTestFindFirstOrThrowArgs>(args?: SelectSubset<T, ABTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ABTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABTests
     * const aBTests = await prisma.aBTest.findMany()
     * 
     * // Get first 10 ABTests
     * const aBTests = await prisma.aBTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ABTestFindManyArgs>(args?: SelectSubset<T, ABTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ABTest.
     * @param {ABTestCreateArgs} args - Arguments to create a ABTest.
     * @example
     * // Create one ABTest
     * const ABTest = await prisma.aBTest.create({
     *   data: {
     *     // ... data to create a ABTest
     *   }
     * })
     * 
     */
    create<T extends ABTestCreateArgs>(args: SelectSubset<T, ABTestCreateArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ABTests.
     * @param {ABTestCreateManyArgs} args - Arguments to create many ABTests.
     * @example
     * // Create many ABTests
     * const aBTest = await prisma.aBTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ABTestCreateManyArgs>(args?: SelectSubset<T, ABTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ABTests and returns the data saved in the database.
     * @param {ABTestCreateManyAndReturnArgs} args - Arguments to create many ABTests.
     * @example
     * // Create many ABTests
     * const aBTest = await prisma.aBTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ABTests and only return the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ABTestCreateManyAndReturnArgs>(args?: SelectSubset<T, ABTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ABTest.
     * @param {ABTestDeleteArgs} args - Arguments to delete one ABTest.
     * @example
     * // Delete one ABTest
     * const ABTest = await prisma.aBTest.delete({
     *   where: {
     *     // ... filter to delete one ABTest
     *   }
     * })
     * 
     */
    delete<T extends ABTestDeleteArgs>(args: SelectSubset<T, ABTestDeleteArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ABTest.
     * @param {ABTestUpdateArgs} args - Arguments to update one ABTest.
     * @example
     * // Update one ABTest
     * const aBTest = await prisma.aBTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ABTestUpdateArgs>(args: SelectSubset<T, ABTestUpdateArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ABTests.
     * @param {ABTestDeleteManyArgs} args - Arguments to filter ABTests to delete.
     * @example
     * // Delete a few ABTests
     * const { count } = await prisma.aBTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ABTestDeleteManyArgs>(args?: SelectSubset<T, ABTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABTests
     * const aBTest = await prisma.aBTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ABTestUpdateManyArgs>(args: SelectSubset<T, ABTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTests and returns the data updated in the database.
     * @param {ABTestUpdateManyAndReturnArgs} args - Arguments to update many ABTests.
     * @example
     * // Update many ABTests
     * const aBTest = await prisma.aBTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ABTests and only return the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ABTestUpdateManyAndReturnArgs>(args: SelectSubset<T, ABTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ABTest.
     * @param {ABTestUpsertArgs} args - Arguments to update or create a ABTest.
     * @example
     * // Update or create a ABTest
     * const aBTest = await prisma.aBTest.upsert({
     *   create: {
     *     // ... data to create a ABTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABTest we want to update
     *   }
     * })
     */
    upsert<T extends ABTestUpsertArgs>(args: SelectSubset<T, ABTestUpsertArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestCountArgs} args - Arguments to filter ABTests to count.
     * @example
     * // Count the number of ABTests
     * const count = await prisma.aBTest.count({
     *   where: {
     *     // ... the filter for the ABTests we want to count
     *   }
     * })
    **/
    count<T extends ABTestCountArgs>(
      args?: Subset<T, ABTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABTestAggregateArgs>(args: Subset<T, ABTestAggregateArgs>): Prisma.PrismaPromise<GetABTestAggregateType<T>>

    /**
     * Group by ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABTestGroupByArgs['orderBy'] }
        : { orderBy?: ABTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABTest model
   */
  readonly fields: ABTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ABTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends ABTest$resultsArgs<ExtArgs> = {}>(args?: Subset<T, ABTest$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ABTest model
   */
  interface ABTestFieldRefs {
    readonly id: FieldRef<"ABTest", 'String'>
    readonly name: FieldRef<"ABTest", 'String'>
    readonly description: FieldRef<"ABTest", 'String'>
    readonly variantA: FieldRef<"ABTest", 'String'>
    readonly variantB: FieldRef<"ABTest", 'String'>
    readonly type: FieldRef<"ABTest", 'String'>
    readonly metric: FieldRef<"ABTest", 'String'>
    readonly targetImprovement: FieldRef<"ABTest", 'Float'>
    readonly status: FieldRef<"ABTest", 'String'>
    readonly startDate: FieldRef<"ABTest", 'DateTime'>
    readonly endDate: FieldRef<"ABTest", 'DateTime'>
    readonly createdAt: FieldRef<"ABTest", 'DateTime'>
    readonly updatedAt: FieldRef<"ABTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ABTest findUnique
   */
  export type ABTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest findUniqueOrThrow
   */
  export type ABTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest findFirst
   */
  export type ABTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest findFirstOrThrow
   */
  export type ABTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest findMany
   */
  export type ABTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTests to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest create
   */
  export type ABTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The data needed to create a ABTest.
     */
    data: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
  }

  /**
   * ABTest createMany
   */
  export type ABTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABTests.
     */
    data: ABTestCreateManyInput | ABTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABTest createManyAndReturn
   */
  export type ABTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * The data used to create many ABTests.
     */
    data: ABTestCreateManyInput | ABTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABTest update
   */
  export type ABTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The data needed to update a ABTest.
     */
    data: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
    /**
     * Choose, which ABTest to update.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest updateMany
   */
  export type ABTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABTests.
     */
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyInput>
    /**
     * Filter which ABTests to update
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to update.
     */
    limit?: number
  }

  /**
   * ABTest updateManyAndReturn
   */
  export type ABTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * The data used to update ABTests.
     */
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyInput>
    /**
     * Filter which ABTests to update
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to update.
     */
    limit?: number
  }

  /**
   * ABTest upsert
   */
  export type ABTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The filter to search for the ABTest to update in case it exists.
     */
    where: ABTestWhereUniqueInput
    /**
     * In case the ABTest found by the `where` argument doesn't exist, create a new ABTest with this data.
     */
    create: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
    /**
     * In case the ABTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
  }

  /**
   * ABTest delete
   */
  export type ABTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter which ABTest to delete.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest deleteMany
   */
  export type ABTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTests to delete
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to delete.
     */
    limit?: number
  }

  /**
   * ABTest.results
   */
  export type ABTest$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    where?: ABTestResultWhereInput
    orderBy?: ABTestResultOrderByWithRelationInput | ABTestResultOrderByWithRelationInput[]
    cursor?: ABTestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ABTestResultScalarFieldEnum | ABTestResultScalarFieldEnum[]
  }

  /**
   * ABTest without action
   */
  export type ABTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
  }


  /**
   * Model ABTestResult
   */

  export type AggregateABTestResult = {
    _count: ABTestResultCountAggregateOutputType | null
    _avg: ABTestResultAvgAggregateOutputType | null
    _sum: ABTestResultSumAggregateOutputType | null
    _min: ABTestResultMinAggregateOutputType | null
    _max: ABTestResultMaxAggregateOutputType | null
  }

  export type ABTestResultAvgAggregateOutputType = {
    improvement: number | null
    confidenceLevel: number | null
  }

  export type ABTestResultSumAggregateOutputType = {
    improvement: number | null
    confidenceLevel: number | null
  }

  export type ABTestResultMinAggregateOutputType = {
    id: string | null
    testId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    winner: string | null
    improvement: number | null
    confidenceLevel: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestResultMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    winner: string | null
    improvement: number | null
    confidenceLevel: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestResultCountAggregateOutputType = {
    id: number
    testId: number
    status: number
    startDate: number
    endDate: number
    variantAMetrics: number
    variantBMetrics: number
    winner: number
    improvement: number
    confidenceLevel: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ABTestResultAvgAggregateInputType = {
    improvement?: true
    confidenceLevel?: true
  }

  export type ABTestResultSumAggregateInputType = {
    improvement?: true
    confidenceLevel?: true
  }

  export type ABTestResultMinAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startDate?: true
    endDate?: true
    winner?: true
    improvement?: true
    confidenceLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestResultMaxAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startDate?: true
    endDate?: true
    winner?: true
    improvement?: true
    confidenceLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestResultCountAggregateInputType = {
    id?: true
    testId?: true
    status?: true
    startDate?: true
    endDate?: true
    variantAMetrics?: true
    variantBMetrics?: true
    winner?: true
    improvement?: true
    confidenceLevel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ABTestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTestResult to aggregate.
     */
    where?: ABTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestResults to fetch.
     */
    orderBy?: ABTestResultOrderByWithRelationInput | ABTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABTestResults
    **/
    _count?: true | ABTestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ABTestResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ABTestResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABTestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABTestResultMaxAggregateInputType
  }

  export type GetABTestResultAggregateType<T extends ABTestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateABTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABTestResult[P]>
      : GetScalarType<T[P], AggregateABTestResult[P]>
  }




  export type ABTestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestResultWhereInput
    orderBy?: ABTestResultOrderByWithAggregationInput | ABTestResultOrderByWithAggregationInput[]
    by: ABTestResultScalarFieldEnum[] | ABTestResultScalarFieldEnum
    having?: ABTestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABTestResultCountAggregateInputType | true
    _avg?: ABTestResultAvgAggregateInputType
    _sum?: ABTestResultSumAggregateInputType
    _min?: ABTestResultMinAggregateInputType
    _max?: ABTestResultMaxAggregateInputType
  }

  export type ABTestResultGroupByOutputType = {
    id: string
    testId: string
    status: string
    startDate: Date
    endDate: Date | null
    variantAMetrics: JsonValue
    variantBMetrics: JsonValue
    winner: string | null
    improvement: number | null
    confidenceLevel: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ABTestResultCountAggregateOutputType | null
    _avg: ABTestResultAvgAggregateOutputType | null
    _sum: ABTestResultSumAggregateOutputType | null
    _min: ABTestResultMinAggregateOutputType | null
    _max: ABTestResultMaxAggregateOutputType | null
  }

  type GetABTestResultGroupByPayload<T extends ABTestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABTestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABTestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABTestResultGroupByOutputType[P]>
            : GetScalarType<T[P], ABTestResultGroupByOutputType[P]>
        }
      >
    >


  export type ABTestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    variantAMetrics?: boolean
    variantBMetrics?: boolean
    winner?: boolean
    improvement?: boolean
    confidenceLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTestResult"]>

  export type ABTestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    variantAMetrics?: boolean
    variantBMetrics?: boolean
    winner?: boolean
    improvement?: boolean
    confidenceLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTestResult"]>

  export type ABTestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    variantAMetrics?: boolean
    variantBMetrics?: boolean
    winner?: boolean
    improvement?: boolean
    confidenceLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTestResult"]>

  export type ABTestResultSelectScalar = {
    id?: boolean
    testId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    variantAMetrics?: boolean
    variantBMetrics?: boolean
    winner?: boolean
    improvement?: boolean
    confidenceLevel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ABTestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "status" | "startDate" | "endDate" | "variantAMetrics" | "variantBMetrics" | "winner" | "improvement" | "confidenceLevel" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["aBTestResult"]>
  export type ABTestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }
  export type ABTestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }
  export type ABTestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | ABTestDefaultArgs<ExtArgs>
  }

  export type $ABTestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ABTestResult"
    objects: {
      test: Prisma.$ABTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      status: string
      startDate: Date
      endDate: Date | null
      variantAMetrics: Prisma.JsonValue
      variantBMetrics: Prisma.JsonValue
      winner: string | null
      improvement: number | null
      confidenceLevel: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aBTestResult"]>
    composites: {}
  }

  type ABTestResultGetPayload<S extends boolean | null | undefined | ABTestResultDefaultArgs> = $Result.GetResult<Prisma.$ABTestResultPayload, S>

  type ABTestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ABTestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ABTestResultCountAggregateInputType | true
    }

  export interface ABTestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABTestResult'], meta: { name: 'ABTestResult' } }
    /**
     * Find zero or one ABTestResult that matches the filter.
     * @param {ABTestResultFindUniqueArgs} args - Arguments to find a ABTestResult
     * @example
     * // Get one ABTestResult
     * const aBTestResult = await prisma.aBTestResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ABTestResultFindUniqueArgs>(args: SelectSubset<T, ABTestResultFindUniqueArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ABTestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ABTestResultFindUniqueOrThrowArgs} args - Arguments to find a ABTestResult
     * @example
     * // Get one ABTestResult
     * const aBTestResult = await prisma.aBTestResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ABTestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ABTestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultFindFirstArgs} args - Arguments to find a ABTestResult
     * @example
     * // Get one ABTestResult
     * const aBTestResult = await prisma.aBTestResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ABTestResultFindFirstArgs>(args?: SelectSubset<T, ABTestResultFindFirstArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultFindFirstOrThrowArgs} args - Arguments to find a ABTestResult
     * @example
     * // Get one ABTestResult
     * const aBTestResult = await prisma.aBTestResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ABTestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ABTestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ABTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABTestResults
     * const aBTestResults = await prisma.aBTestResult.findMany()
     * 
     * // Get first 10 ABTestResults
     * const aBTestResults = await prisma.aBTestResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBTestResultWithIdOnly = await prisma.aBTestResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ABTestResultFindManyArgs>(args?: SelectSubset<T, ABTestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ABTestResult.
     * @param {ABTestResultCreateArgs} args - Arguments to create a ABTestResult.
     * @example
     * // Create one ABTestResult
     * const ABTestResult = await prisma.aBTestResult.create({
     *   data: {
     *     // ... data to create a ABTestResult
     *   }
     * })
     * 
     */
    create<T extends ABTestResultCreateArgs>(args: SelectSubset<T, ABTestResultCreateArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ABTestResults.
     * @param {ABTestResultCreateManyArgs} args - Arguments to create many ABTestResults.
     * @example
     * // Create many ABTestResults
     * const aBTestResult = await prisma.aBTestResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ABTestResultCreateManyArgs>(args?: SelectSubset<T, ABTestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ABTestResults and returns the data saved in the database.
     * @param {ABTestResultCreateManyAndReturnArgs} args - Arguments to create many ABTestResults.
     * @example
     * // Create many ABTestResults
     * const aBTestResult = await prisma.aBTestResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ABTestResults and only return the `id`
     * const aBTestResultWithIdOnly = await prisma.aBTestResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ABTestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ABTestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ABTestResult.
     * @param {ABTestResultDeleteArgs} args - Arguments to delete one ABTestResult.
     * @example
     * // Delete one ABTestResult
     * const ABTestResult = await prisma.aBTestResult.delete({
     *   where: {
     *     // ... filter to delete one ABTestResult
     *   }
     * })
     * 
     */
    delete<T extends ABTestResultDeleteArgs>(args: SelectSubset<T, ABTestResultDeleteArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ABTestResult.
     * @param {ABTestResultUpdateArgs} args - Arguments to update one ABTestResult.
     * @example
     * // Update one ABTestResult
     * const aBTestResult = await prisma.aBTestResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ABTestResultUpdateArgs>(args: SelectSubset<T, ABTestResultUpdateArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ABTestResults.
     * @param {ABTestResultDeleteManyArgs} args - Arguments to filter ABTestResults to delete.
     * @example
     * // Delete a few ABTestResults
     * const { count } = await prisma.aBTestResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ABTestResultDeleteManyArgs>(args?: SelectSubset<T, ABTestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABTestResults
     * const aBTestResult = await prisma.aBTestResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ABTestResultUpdateManyArgs>(args: SelectSubset<T, ABTestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTestResults and returns the data updated in the database.
     * @param {ABTestResultUpdateManyAndReturnArgs} args - Arguments to update many ABTestResults.
     * @example
     * // Update many ABTestResults
     * const aBTestResult = await prisma.aBTestResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ABTestResults and only return the `id`
     * const aBTestResultWithIdOnly = await prisma.aBTestResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ABTestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ABTestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ABTestResult.
     * @param {ABTestResultUpsertArgs} args - Arguments to update or create a ABTestResult.
     * @example
     * // Update or create a ABTestResult
     * const aBTestResult = await prisma.aBTestResult.upsert({
     *   create: {
     *     // ... data to create a ABTestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABTestResult we want to update
     *   }
     * })
     */
    upsert<T extends ABTestResultUpsertArgs>(args: SelectSubset<T, ABTestResultUpsertArgs<ExtArgs>>): Prisma__ABTestResultClient<$Result.GetResult<Prisma.$ABTestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ABTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultCountArgs} args - Arguments to filter ABTestResults to count.
     * @example
     * // Count the number of ABTestResults
     * const count = await prisma.aBTestResult.count({
     *   where: {
     *     // ... the filter for the ABTestResults we want to count
     *   }
     * })
    **/
    count<T extends ABTestResultCountArgs>(
      args?: Subset<T, ABTestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABTestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABTestResultAggregateArgs>(args: Subset<T, ABTestResultAggregateArgs>): Prisma.PrismaPromise<GetABTestResultAggregateType<T>>

    /**
     * Group by ABTestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABTestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABTestResultGroupByArgs['orderBy'] }
        : { orderBy?: ABTestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABTestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABTestResult model
   */
  readonly fields: ABTestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABTestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ABTestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends ABTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ABTestDefaultArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ABTestResult model
   */
  interface ABTestResultFieldRefs {
    readonly id: FieldRef<"ABTestResult", 'String'>
    readonly testId: FieldRef<"ABTestResult", 'String'>
    readonly status: FieldRef<"ABTestResult", 'String'>
    readonly startDate: FieldRef<"ABTestResult", 'DateTime'>
    readonly endDate: FieldRef<"ABTestResult", 'DateTime'>
    readonly variantAMetrics: FieldRef<"ABTestResult", 'Json'>
    readonly variantBMetrics: FieldRef<"ABTestResult", 'Json'>
    readonly winner: FieldRef<"ABTestResult", 'String'>
    readonly improvement: FieldRef<"ABTestResult", 'Float'>
    readonly confidenceLevel: FieldRef<"ABTestResult", 'Float'>
    readonly notes: FieldRef<"ABTestResult", 'String'>
    readonly createdAt: FieldRef<"ABTestResult", 'DateTime'>
    readonly updatedAt: FieldRef<"ABTestResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ABTestResult findUnique
   */
  export type ABTestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ABTestResult to fetch.
     */
    where: ABTestResultWhereUniqueInput
  }

  /**
   * ABTestResult findUniqueOrThrow
   */
  export type ABTestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ABTestResult to fetch.
     */
    where: ABTestResultWhereUniqueInput
  }

  /**
   * ABTestResult findFirst
   */
  export type ABTestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ABTestResult to fetch.
     */
    where?: ABTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestResults to fetch.
     */
    orderBy?: ABTestResultOrderByWithRelationInput | ABTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTestResults.
     */
    cursor?: ABTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTestResults.
     */
    distinct?: ABTestResultScalarFieldEnum | ABTestResultScalarFieldEnum[]
  }

  /**
   * ABTestResult findFirstOrThrow
   */
  export type ABTestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ABTestResult to fetch.
     */
    where?: ABTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestResults to fetch.
     */
    orderBy?: ABTestResultOrderByWithRelationInput | ABTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTestResults.
     */
    cursor?: ABTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTestResults.
     */
    distinct?: ABTestResultScalarFieldEnum | ABTestResultScalarFieldEnum[]
  }

  /**
   * ABTestResult findMany
   */
  export type ABTestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter, which ABTestResults to fetch.
     */
    where?: ABTestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestResults to fetch.
     */
    orderBy?: ABTestResultOrderByWithRelationInput | ABTestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABTestResults.
     */
    cursor?: ABTestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestResults.
     */
    skip?: number
    distinct?: ABTestResultScalarFieldEnum | ABTestResultScalarFieldEnum[]
  }

  /**
   * ABTestResult create
   */
  export type ABTestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ABTestResult.
     */
    data: XOR<ABTestResultCreateInput, ABTestResultUncheckedCreateInput>
  }

  /**
   * ABTestResult createMany
   */
  export type ABTestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABTestResults.
     */
    data: ABTestResultCreateManyInput | ABTestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABTestResult createManyAndReturn
   */
  export type ABTestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * The data used to create many ABTestResults.
     */
    data: ABTestResultCreateManyInput | ABTestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABTestResult update
   */
  export type ABTestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ABTestResult.
     */
    data: XOR<ABTestResultUpdateInput, ABTestResultUncheckedUpdateInput>
    /**
     * Choose, which ABTestResult to update.
     */
    where: ABTestResultWhereUniqueInput
  }

  /**
   * ABTestResult updateMany
   */
  export type ABTestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABTestResults.
     */
    data: XOR<ABTestResultUpdateManyMutationInput, ABTestResultUncheckedUpdateManyInput>
    /**
     * Filter which ABTestResults to update
     */
    where?: ABTestResultWhereInput
    /**
     * Limit how many ABTestResults to update.
     */
    limit?: number
  }

  /**
   * ABTestResult updateManyAndReturn
   */
  export type ABTestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * The data used to update ABTestResults.
     */
    data: XOR<ABTestResultUpdateManyMutationInput, ABTestResultUncheckedUpdateManyInput>
    /**
     * Filter which ABTestResults to update
     */
    where?: ABTestResultWhereInput
    /**
     * Limit how many ABTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABTestResult upsert
   */
  export type ABTestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ABTestResult to update in case it exists.
     */
    where: ABTestResultWhereUniqueInput
    /**
     * In case the ABTestResult found by the `where` argument doesn't exist, create a new ABTestResult with this data.
     */
    create: XOR<ABTestResultCreateInput, ABTestResultUncheckedCreateInput>
    /**
     * In case the ABTestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABTestResultUpdateInput, ABTestResultUncheckedUpdateInput>
  }

  /**
   * ABTestResult delete
   */
  export type ABTestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
    /**
     * Filter which ABTestResult to delete.
     */
    where: ABTestResultWhereUniqueInput
  }

  /**
   * ABTestResult deleteMany
   */
  export type ABTestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTestResults to delete
     */
    where?: ABTestResultWhereInput
    /**
     * Limit how many ABTestResults to delete.
     */
    limit?: number
  }

  /**
   * ABTestResult without action
   */
  export type ABTestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestResult
     */
    select?: ABTestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestResult
     */
    omit?: ABTestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestResultInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    value: number | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    system: string | null
    component: string | null
    metric: string | null
    value: number | null
    unit: string | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    system: string | null
    component: string | null
    metric: string | null
    value: number | null
    unit: string | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    timestamp: number
    system: number
    component: number
    metric: number
    value: number
    unit: number
    tags: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    value?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    value?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    timestamp?: true
    system?: true
    component?: true
    metric?: true
    value?: true
    unit?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    timestamp?: true
    system?: true
    component?: true
    metric?: true
    value?: true
    unit?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    timestamp?: true
    system?: true
    component?: true
    metric?: true
    value?: true
    unit?: true
    tags?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: string
    timestamp: Date
    system: string
    component: string
    metric: string
    value: number
    unit: string
    tags: JsonValue | null
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    system?: boolean
    component?: boolean
    metric?: boolean
    value?: boolean
    unit?: boolean
    tags?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    system?: boolean
    component?: boolean
    metric?: boolean
    value?: boolean
    unit?: boolean
    tags?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    system?: boolean
    component?: boolean
    metric?: boolean
    value?: boolean
    unit?: boolean
    tags?: boolean
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectScalar = {
    id?: boolean
    timestamp?: boolean
    system?: boolean
    component?: boolean
    metric?: boolean
    value?: boolean
    unit?: boolean
    tags?: boolean
  }

  export type PerformanceMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "system" | "component" | "metric" | "value" | "unit" | "tags", ExtArgs["result"]["performanceMetric"]>

  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      system: string
      component: string
      metric: string
      value: number
      unit: string
      tags: Prisma.JsonValue | null
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }

  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricFindManyArgs>(args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricCreateArgs>(args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceMetrics.
     * @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceMetrics and returns the data saved in the database.
     * @param {PerformanceMetricCreateManyAndReturnArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricDeleteArgs>(args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricUpdateArgs>(args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics and returns the data updated in the database.
     * @param {PerformanceMetricUpdateManyAndReturnArgs} args - Arguments to update many PerformanceMetrics.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricUpsertArgs>(args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetric model
   */
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'String'>
    readonly timestamp: FieldRef<"PerformanceMetric", 'DateTime'>
    readonly system: FieldRef<"PerformanceMetric", 'String'>
    readonly component: FieldRef<"PerformanceMetric", 'String'>
    readonly metric: FieldRef<"PerformanceMetric", 'String'>
    readonly value: FieldRef<"PerformanceMetric", 'Float'>
    readonly unit: FieldRef<"PerformanceMetric", 'String'>
    readonly tags: FieldRef<"PerformanceMetric", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }

  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetric createManyAndReturn
   */
  export type PerformanceMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric updateManyAndReturn
   */
  export type PerformanceMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }

  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to delete.
     */
    limit?: number
  }

  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    stopPrice: number | null
    avgFillPrice: number | null
    filledQuantity: number | null
    remainingQuantity: number | null
    fee: number | null
  }

  export type OrderSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    stopPrice: number | null
    avgFillPrice: number | null
    filledQuantity: number | null
    remainingQuantity: number | null
    fee: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    status: string | null
    symbol: string | null
    type: string | null
    side: string | null
    quantity: number | null
    price: number | null
    stopPrice: number | null
    avgFillPrice: number | null
    filledQuantity: number | null
    remainingQuantity: number | null
    fee: number | null
    feeCurrency: string | null
    clientOrderId: string | null
    exchangeOrderId: string | null
    source: string | null
    exchangeId: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    userId: string | null
    positionId: string | null
    strategyId: string | null
    botId: string | null
    signalId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    status: string | null
    symbol: string | null
    type: string | null
    side: string | null
    quantity: number | null
    price: number | null
    stopPrice: number | null
    avgFillPrice: number | null
    filledQuantity: number | null
    remainingQuantity: number | null
    fee: number | null
    feeCurrency: string | null
    clientOrderId: string | null
    exchangeOrderId: string | null
    source: string | null
    exchangeId: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    userId: string | null
    positionId: string | null
    strategyId: string | null
    botId: string | null
    signalId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    status: number
    symbol: number
    type: number
    side: number
    quantity: number
    price: number
    stopPrice: number
    avgFillPrice: number
    filledQuantity: number
    remainingQuantity: number
    fee: number
    feeCurrency: number
    clientOrderId: number
    exchangeOrderId: number
    source: number
    exchangeId: number
    submittedAt: number
    updatedAt: number
    completedAt: number
    errorCode: number
    errorMessage: number
    errorDetails: number
    raw: number
    userId: number
    positionId: number
    strategyId: number
    botId: number
    signalId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    quantity?: true
    price?: true
    stopPrice?: true
    avgFillPrice?: true
    filledQuantity?: true
    remainingQuantity?: true
    fee?: true
  }

  export type OrderSumAggregateInputType = {
    quantity?: true
    price?: true
    stopPrice?: true
    avgFillPrice?: true
    filledQuantity?: true
    remainingQuantity?: true
    fee?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    symbol?: true
    type?: true
    side?: true
    quantity?: true
    price?: true
    stopPrice?: true
    avgFillPrice?: true
    filledQuantity?: true
    remainingQuantity?: true
    fee?: true
    feeCurrency?: true
    clientOrderId?: true
    exchangeOrderId?: true
    source?: true
    exchangeId?: true
    submittedAt?: true
    updatedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    userId?: true
    positionId?: true
    strategyId?: true
    botId?: true
    signalId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    symbol?: true
    type?: true
    side?: true
    quantity?: true
    price?: true
    stopPrice?: true
    avgFillPrice?: true
    filledQuantity?: true
    remainingQuantity?: true
    fee?: true
    feeCurrency?: true
    clientOrderId?: true
    exchangeOrderId?: true
    source?: true
    exchangeId?: true
    submittedAt?: true
    updatedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    userId?: true
    positionId?: true
    strategyId?: true
    botId?: true
    signalId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    status?: true
    symbol?: true
    type?: true
    side?: true
    quantity?: true
    price?: true
    stopPrice?: true
    avgFillPrice?: true
    filledQuantity?: true
    remainingQuantity?: true
    fee?: true
    feeCurrency?: true
    clientOrderId?: true
    exchangeOrderId?: true
    source?: true
    exchangeId?: true
    submittedAt?: true
    updatedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    errorDetails?: true
    raw?: true
    userId?: true
    positionId?: true
    strategyId?: true
    botId?: true
    signalId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price: number | null
    stopPrice: number | null
    avgFillPrice: number | null
    filledQuantity: number
    remainingQuantity: number
    fee: number | null
    feeCurrency: string | null
    clientOrderId: string | null
    exchangeOrderId: string | null
    source: string
    exchangeId: string
    submittedAt: Date
    updatedAt: Date
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    errorDetails: JsonValue | null
    raw: JsonValue | null
    userId: string
    positionId: string | null
    strategyId: string | null
    botId: string | null
    signalId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    symbol?: boolean
    type?: boolean
    side?: boolean
    quantity?: boolean
    price?: boolean
    stopPrice?: boolean
    avgFillPrice?: boolean
    filledQuantity?: boolean
    remainingQuantity?: boolean
    fee?: boolean
    feeCurrency?: boolean
    clientOrderId?: boolean
    exchangeOrderId?: boolean
    source?: boolean
    exchangeId?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    raw?: boolean
    userId?: boolean
    positionId?: boolean
    strategyId?: boolean
    botId?: boolean
    signalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
    auditTrails?: boolean | Order$auditTrailsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    symbol?: boolean
    type?: boolean
    side?: boolean
    quantity?: boolean
    price?: boolean
    stopPrice?: boolean
    avgFillPrice?: boolean
    filledQuantity?: boolean
    remainingQuantity?: boolean
    fee?: boolean
    feeCurrency?: boolean
    clientOrderId?: boolean
    exchangeOrderId?: boolean
    source?: boolean
    exchangeId?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    raw?: boolean
    userId?: boolean
    positionId?: boolean
    strategyId?: boolean
    botId?: boolean
    signalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    symbol?: boolean
    type?: boolean
    side?: boolean
    quantity?: boolean
    price?: boolean
    stopPrice?: boolean
    avgFillPrice?: boolean
    filledQuantity?: boolean
    remainingQuantity?: boolean
    fee?: boolean
    feeCurrency?: boolean
    clientOrderId?: boolean
    exchangeOrderId?: boolean
    source?: boolean
    exchangeId?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    raw?: boolean
    userId?: boolean
    positionId?: boolean
    strategyId?: boolean
    botId?: boolean
    signalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    status?: boolean
    symbol?: boolean
    type?: boolean
    side?: boolean
    quantity?: boolean
    price?: boolean
    stopPrice?: boolean
    avgFillPrice?: boolean
    filledQuantity?: boolean
    remainingQuantity?: boolean
    fee?: boolean
    feeCurrency?: boolean
    clientOrderId?: boolean
    exchangeOrderId?: boolean
    source?: boolean
    exchangeId?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    raw?: boolean
    userId?: boolean
    positionId?: boolean
    strategyId?: boolean
    botId?: boolean
    signalId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "symbol" | "type" | "side" | "quantity" | "price" | "stopPrice" | "avgFillPrice" | "filledQuantity" | "remainingQuantity" | "fee" | "feeCurrency" | "clientOrderId" | "exchangeOrderId" | "source" | "exchangeId" | "submittedAt" | "updatedAt" | "completedAt" | "errorCode" | "errorMessage" | "errorDetails" | "raw" | "userId" | "positionId" | "strategyId" | "botId" | "signalId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
    auditTrails?: boolean | Order$auditTrailsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Order$positionArgs<ExtArgs>
    strategy?: boolean | Order$strategyArgs<ExtArgs>
    bot?: boolean | Order$botArgs<ExtArgs>
    signal?: boolean | Order$signalArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      position: Prisma.$PositionPayload<ExtArgs> | null
      strategy: Prisma.$TradingStrategyPayload<ExtArgs> | null
      bot: Prisma.$BotPayload<ExtArgs> | null
      signal: Prisma.$TradingSignalPayload<ExtArgs> | null
      auditTrails: Prisma.$AuditTrailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      symbol: string
      type: string
      side: string
      quantity: number
      price: number | null
      stopPrice: number | null
      avgFillPrice: number | null
      filledQuantity: number
      remainingQuantity: number
      fee: number | null
      feeCurrency: string | null
      clientOrderId: string | null
      exchangeOrderId: string | null
      source: string
      exchangeId: string
      submittedAt: Date
      updatedAt: Date
      completedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      errorDetails: Prisma.JsonValue | null
      raw: Prisma.JsonValue | null
      userId: string
      positionId: string | null
      strategyId: string | null
      botId: string | null
      signalId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends Order$positionArgs<ExtArgs> = {}>(args?: Subset<T, Order$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    strategy<T extends Order$strategyArgs<ExtArgs> = {}>(args?: Subset<T, Order$strategyArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bot<T extends Order$botArgs<ExtArgs> = {}>(args?: Subset<T, Order$botArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    signal<T extends Order$signalArgs<ExtArgs> = {}>(args?: Subset<T, Order$signalArgs<ExtArgs>>): Prisma__TradingSignalClient<$Result.GetResult<Prisma.$TradingSignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditTrails<T extends Order$auditTrailsArgs<ExtArgs> = {}>(args?: Subset<T, Order$auditTrailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly symbol: FieldRef<"Order", 'String'>
    readonly type: FieldRef<"Order", 'String'>
    readonly side: FieldRef<"Order", 'String'>
    readonly quantity: FieldRef<"Order", 'Float'>
    readonly price: FieldRef<"Order", 'Float'>
    readonly stopPrice: FieldRef<"Order", 'Float'>
    readonly avgFillPrice: FieldRef<"Order", 'Float'>
    readonly filledQuantity: FieldRef<"Order", 'Float'>
    readonly remainingQuantity: FieldRef<"Order", 'Float'>
    readonly fee: FieldRef<"Order", 'Float'>
    readonly feeCurrency: FieldRef<"Order", 'String'>
    readonly clientOrderId: FieldRef<"Order", 'String'>
    readonly exchangeOrderId: FieldRef<"Order", 'String'>
    readonly source: FieldRef<"Order", 'String'>
    readonly exchangeId: FieldRef<"Order", 'String'>
    readonly submittedAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
    readonly errorCode: FieldRef<"Order", 'String'>
    readonly errorMessage: FieldRef<"Order", 'String'>
    readonly errorDetails: FieldRef<"Order", 'Json'>
    readonly raw: FieldRef<"Order", 'Json'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly positionId: FieldRef<"Order", 'String'>
    readonly strategyId: FieldRef<"Order", 'String'>
    readonly botId: FieldRef<"Order", 'String'>
    readonly signalId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.position
   */
  export type Order$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * Order.strategy
   */
  export type Order$strategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    where?: TradingStrategyWhereInput
  }

  /**
   * Order.bot
   */
  export type Order$botArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
  }

  /**
   * Order.signal
   */
  export type Order$signalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingSignal
     */
    select?: TradingSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingSignal
     */
    omit?: TradingSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingSignalInclude<ExtArgs> | null
    where?: TradingSignalWhereInput
  }

  /**
   * Order.auditTrails
   */
  export type Order$auditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    cursor?: AuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model DecisionLog
   */

  export type AggregateDecisionLog = {
    _count: DecisionLogCountAggregateOutputType | null
    _min: DecisionLogMinAggregateOutputType | null
    _max: DecisionLogMaxAggregateOutputType | null
  }

  export type DecisionLogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    source: string | null
    actionType: string | null
    decision: string | null
    reasonDetails: string | null
    userId: string | null
    botId: string | null
    strategyId: string | null
    symbol: string | null
    orderId: string | null
    positionId: string | null
    importance: string | null
    auditTrailId: string | null
  }

  export type DecisionLogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    source: string | null
    actionType: string | null
    decision: string | null
    reasonDetails: string | null
    userId: string | null
    botId: string | null
    strategyId: string | null
    symbol: string | null
    orderId: string | null
    positionId: string | null
    importance: string | null
    auditTrailId: string | null
  }

  export type DecisionLogCountAggregateOutputType = {
    id: number
    timestamp: number
    source: number
    actionType: number
    decision: number
    reasonDetails: number
    userId: number
    botId: number
    strategyId: number
    symbol: number
    orderId: number
    positionId: number
    importance: number
    metadata: number
    tags: number
    auditTrailId: number
    _all: number
  }


  export type DecisionLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    source?: true
    actionType?: true
    decision?: true
    reasonDetails?: true
    userId?: true
    botId?: true
    strategyId?: true
    symbol?: true
    orderId?: true
    positionId?: true
    importance?: true
    auditTrailId?: true
  }

  export type DecisionLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    source?: true
    actionType?: true
    decision?: true
    reasonDetails?: true
    userId?: true
    botId?: true
    strategyId?: true
    symbol?: true
    orderId?: true
    positionId?: true
    importance?: true
    auditTrailId?: true
  }

  export type DecisionLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    source?: true
    actionType?: true
    decision?: true
    reasonDetails?: true
    userId?: true
    botId?: true
    strategyId?: true
    symbol?: true
    orderId?: true
    positionId?: true
    importance?: true
    metadata?: true
    tags?: true
    auditTrailId?: true
    _all?: true
  }

  export type DecisionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionLog to aggregate.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DecisionLogs
    **/
    _count?: true | DecisionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionLogMaxAggregateInputType
  }

  export type GetDecisionLogAggregateType<T extends DecisionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDecisionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecisionLog[P]>
      : GetScalarType<T[P], AggregateDecisionLog[P]>
  }




  export type DecisionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithAggregationInput | DecisionLogOrderByWithAggregationInput[]
    by: DecisionLogScalarFieldEnum[] | DecisionLogScalarFieldEnum
    having?: DecisionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionLogCountAggregateInputType | true
    _min?: DecisionLogMinAggregateInputType
    _max?: DecisionLogMaxAggregateInputType
  }

  export type DecisionLogGroupByOutputType = {
    id: string
    timestamp: Date
    source: string
    actionType: string
    decision: string
    reasonDetails: string | null
    userId: string | null
    botId: string | null
    strategyId: string | null
    symbol: string | null
    orderId: string | null
    positionId: string | null
    importance: string
    metadata: JsonValue
    tags: string[]
    auditTrailId: string | null
    _count: DecisionLogCountAggregateOutputType | null
    _min: DecisionLogMinAggregateOutputType | null
    _max: DecisionLogMaxAggregateOutputType | null
  }

  type GetDecisionLogGroupByPayload<T extends DecisionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionLogGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionLogGroupByOutputType[P]>
        }
      >
    >


  export type DecisionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    source?: boolean
    actionType?: boolean
    decision?: boolean
    reasonDetails?: boolean
    userId?: boolean
    botId?: boolean
    strategyId?: boolean
    symbol?: boolean
    orderId?: boolean
    positionId?: boolean
    importance?: boolean
    metadata?: boolean
    tags?: boolean
    auditTrailId?: boolean
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }, ExtArgs["result"]["decisionLog"]>

  export type DecisionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    source?: boolean
    actionType?: boolean
    decision?: boolean
    reasonDetails?: boolean
    userId?: boolean
    botId?: boolean
    strategyId?: boolean
    symbol?: boolean
    orderId?: boolean
    positionId?: boolean
    importance?: boolean
    metadata?: boolean
    tags?: boolean
    auditTrailId?: boolean
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }, ExtArgs["result"]["decisionLog"]>

  export type DecisionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    source?: boolean
    actionType?: boolean
    decision?: boolean
    reasonDetails?: boolean
    userId?: boolean
    botId?: boolean
    strategyId?: boolean
    symbol?: boolean
    orderId?: boolean
    positionId?: boolean
    importance?: boolean
    metadata?: boolean
    tags?: boolean
    auditTrailId?: boolean
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }, ExtArgs["result"]["decisionLog"]>

  export type DecisionLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    source?: boolean
    actionType?: boolean
    decision?: boolean
    reasonDetails?: boolean
    userId?: boolean
    botId?: boolean
    strategyId?: boolean
    symbol?: boolean
    orderId?: boolean
    positionId?: boolean
    importance?: boolean
    metadata?: boolean
    tags?: boolean
    auditTrailId?: boolean
  }

  export type DecisionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "source" | "actionType" | "decision" | "reasonDetails" | "userId" | "botId" | "strategyId" | "symbol" | "orderId" | "positionId" | "importance" | "metadata" | "tags" | "auditTrailId", ExtArgs["result"]["decisionLog"]>
  export type DecisionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }
  export type DecisionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }
  export type DecisionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DecisionLog$userArgs<ExtArgs>
    bot?: boolean | DecisionLog$botArgs<ExtArgs>
    strategy?: boolean | DecisionLog$strategyArgs<ExtArgs>
    auditTrail?: boolean | DecisionLog$auditTrailArgs<ExtArgs>
  }

  export type $DecisionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DecisionLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      bot: Prisma.$BotPayload<ExtArgs> | null
      strategy: Prisma.$TradingStrategyPayload<ExtArgs> | null
      auditTrail: Prisma.$AuditTrailPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      source: string
      actionType: string
      decision: string
      reasonDetails: string | null
      userId: string | null
      botId: string | null
      strategyId: string | null
      symbol: string | null
      orderId: string | null
      positionId: string | null
      importance: string
      metadata: Prisma.JsonValue
      tags: string[]
      auditTrailId: string | null
    }, ExtArgs["result"]["decisionLog"]>
    composites: {}
  }

  type DecisionLogGetPayload<S extends boolean | null | undefined | DecisionLogDefaultArgs> = $Result.GetResult<Prisma.$DecisionLogPayload, S>

  type DecisionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DecisionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DecisionLogCountAggregateInputType | true
    }

  export interface DecisionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DecisionLog'], meta: { name: 'DecisionLog' } }
    /**
     * Find zero or one DecisionLog that matches the filter.
     * @param {DecisionLogFindUniqueArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecisionLogFindUniqueArgs>(args: SelectSubset<T, DecisionLogFindUniqueArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DecisionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DecisionLogFindUniqueOrThrowArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecisionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DecisionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindFirstArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecisionLogFindFirstArgs>(args?: SelectSubset<T, DecisionLogFindFirstArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DecisionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindFirstOrThrowArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecisionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DecisionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DecisionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DecisionLogs
     * const decisionLogs = await prisma.decisionLog.findMany()
     * 
     * // Get first 10 DecisionLogs
     * const decisionLogs = await prisma.decisionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionLogWithIdOnly = await prisma.decisionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecisionLogFindManyArgs>(args?: SelectSubset<T, DecisionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DecisionLog.
     * @param {DecisionLogCreateArgs} args - Arguments to create a DecisionLog.
     * @example
     * // Create one DecisionLog
     * const DecisionLog = await prisma.decisionLog.create({
     *   data: {
     *     // ... data to create a DecisionLog
     *   }
     * })
     * 
     */
    create<T extends DecisionLogCreateArgs>(args: SelectSubset<T, DecisionLogCreateArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DecisionLogs.
     * @param {DecisionLogCreateManyArgs} args - Arguments to create many DecisionLogs.
     * @example
     * // Create many DecisionLogs
     * const decisionLog = await prisma.decisionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecisionLogCreateManyArgs>(args?: SelectSubset<T, DecisionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DecisionLogs and returns the data saved in the database.
     * @param {DecisionLogCreateManyAndReturnArgs} args - Arguments to create many DecisionLogs.
     * @example
     * // Create many DecisionLogs
     * const decisionLog = await prisma.decisionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DecisionLogs and only return the `id`
     * const decisionLogWithIdOnly = await prisma.decisionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecisionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DecisionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DecisionLog.
     * @param {DecisionLogDeleteArgs} args - Arguments to delete one DecisionLog.
     * @example
     * // Delete one DecisionLog
     * const DecisionLog = await prisma.decisionLog.delete({
     *   where: {
     *     // ... filter to delete one DecisionLog
     *   }
     * })
     * 
     */
    delete<T extends DecisionLogDeleteArgs>(args: SelectSubset<T, DecisionLogDeleteArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DecisionLog.
     * @param {DecisionLogUpdateArgs} args - Arguments to update one DecisionLog.
     * @example
     * // Update one DecisionLog
     * const decisionLog = await prisma.decisionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecisionLogUpdateArgs>(args: SelectSubset<T, DecisionLogUpdateArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DecisionLogs.
     * @param {DecisionLogDeleteManyArgs} args - Arguments to filter DecisionLogs to delete.
     * @example
     * // Delete a few DecisionLogs
     * const { count } = await prisma.decisionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecisionLogDeleteManyArgs>(args?: SelectSubset<T, DecisionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DecisionLogs
     * const decisionLog = await prisma.decisionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecisionLogUpdateManyArgs>(args: SelectSubset<T, DecisionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionLogs and returns the data updated in the database.
     * @param {DecisionLogUpdateManyAndReturnArgs} args - Arguments to update many DecisionLogs.
     * @example
     * // Update many DecisionLogs
     * const decisionLog = await prisma.decisionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DecisionLogs and only return the `id`
     * const decisionLogWithIdOnly = await prisma.decisionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DecisionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DecisionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DecisionLog.
     * @param {DecisionLogUpsertArgs} args - Arguments to update or create a DecisionLog.
     * @example
     * // Update or create a DecisionLog
     * const decisionLog = await prisma.decisionLog.upsert({
     *   create: {
     *     // ... data to create a DecisionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DecisionLog we want to update
     *   }
     * })
     */
    upsert<T extends DecisionLogUpsertArgs>(args: SelectSubset<T, DecisionLogUpsertArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DecisionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogCountArgs} args - Arguments to filter DecisionLogs to count.
     * @example
     * // Count the number of DecisionLogs
     * const count = await prisma.decisionLog.count({
     *   where: {
     *     // ... the filter for the DecisionLogs we want to count
     *   }
     * })
    **/
    count<T extends DecisionLogCountArgs>(
      args?: Subset<T, DecisionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DecisionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionLogAggregateArgs>(args: Subset<T, DecisionLogAggregateArgs>): Prisma.PrismaPromise<GetDecisionLogAggregateType<T>>

    /**
     * Group by DecisionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecisionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecisionLogGroupByArgs['orderBy'] }
        : { orderBy?: DecisionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecisionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DecisionLog model
   */
  readonly fields: DecisionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DecisionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecisionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends DecisionLog$userArgs<ExtArgs> = {}>(args?: Subset<T, DecisionLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bot<T extends DecisionLog$botArgs<ExtArgs> = {}>(args?: Subset<T, DecisionLog$botArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    strategy<T extends DecisionLog$strategyArgs<ExtArgs> = {}>(args?: Subset<T, DecisionLog$strategyArgs<ExtArgs>>): Prisma__TradingStrategyClient<$Result.GetResult<Prisma.$TradingStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditTrail<T extends DecisionLog$auditTrailArgs<ExtArgs> = {}>(args?: Subset<T, DecisionLog$auditTrailArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DecisionLog model
   */
  interface DecisionLogFieldRefs {
    readonly id: FieldRef<"DecisionLog", 'String'>
    readonly timestamp: FieldRef<"DecisionLog", 'DateTime'>
    readonly source: FieldRef<"DecisionLog", 'String'>
    readonly actionType: FieldRef<"DecisionLog", 'String'>
    readonly decision: FieldRef<"DecisionLog", 'String'>
    readonly reasonDetails: FieldRef<"DecisionLog", 'String'>
    readonly userId: FieldRef<"DecisionLog", 'String'>
    readonly botId: FieldRef<"DecisionLog", 'String'>
    readonly strategyId: FieldRef<"DecisionLog", 'String'>
    readonly symbol: FieldRef<"DecisionLog", 'String'>
    readonly orderId: FieldRef<"DecisionLog", 'String'>
    readonly positionId: FieldRef<"DecisionLog", 'String'>
    readonly importance: FieldRef<"DecisionLog", 'String'>
    readonly metadata: FieldRef<"DecisionLog", 'Json'>
    readonly tags: FieldRef<"DecisionLog", 'String[]'>
    readonly auditTrailId: FieldRef<"DecisionLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DecisionLog findUnique
   */
  export type DecisionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog findUniqueOrThrow
   */
  export type DecisionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog findFirst
   */
  export type DecisionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionLogs.
     */
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog findFirstOrThrow
   */
  export type DecisionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionLogs.
     */
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog findMany
   */
  export type DecisionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLogs to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog create
   */
  export type DecisionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DecisionLog.
     */
    data: XOR<DecisionLogCreateInput, DecisionLogUncheckedCreateInput>
  }

  /**
   * DecisionLog createMany
   */
  export type DecisionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DecisionLogs.
     */
    data: DecisionLogCreateManyInput | DecisionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DecisionLog createManyAndReturn
   */
  export type DecisionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * The data used to create many DecisionLogs.
     */
    data: DecisionLogCreateManyInput | DecisionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionLog update
   */
  export type DecisionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DecisionLog.
     */
    data: XOR<DecisionLogUpdateInput, DecisionLogUncheckedUpdateInput>
    /**
     * Choose, which DecisionLog to update.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog updateMany
   */
  export type DecisionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DecisionLogs.
     */
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyInput>
    /**
     * Filter which DecisionLogs to update
     */
    where?: DecisionLogWhereInput
    /**
     * Limit how many DecisionLogs to update.
     */
    limit?: number
  }

  /**
   * DecisionLog updateManyAndReturn
   */
  export type DecisionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * The data used to update DecisionLogs.
     */
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyInput>
    /**
     * Filter which DecisionLogs to update
     */
    where?: DecisionLogWhereInput
    /**
     * Limit how many DecisionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionLog upsert
   */
  export type DecisionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DecisionLog to update in case it exists.
     */
    where: DecisionLogWhereUniqueInput
    /**
     * In case the DecisionLog found by the `where` argument doesn't exist, create a new DecisionLog with this data.
     */
    create: XOR<DecisionLogCreateInput, DecisionLogUncheckedCreateInput>
    /**
     * In case the DecisionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecisionLogUpdateInput, DecisionLogUncheckedUpdateInput>
  }

  /**
   * DecisionLog delete
   */
  export type DecisionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter which DecisionLog to delete.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog deleteMany
   */
  export type DecisionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionLogs to delete
     */
    where?: DecisionLogWhereInput
    /**
     * Limit how many DecisionLogs to delete.
     */
    limit?: number
  }

  /**
   * DecisionLog.user
   */
  export type DecisionLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DecisionLog.bot
   */
  export type DecisionLog$botArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
  }

  /**
   * DecisionLog.strategy
   */
  export type DecisionLog$strategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradingStrategy
     */
    select?: TradingStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradingStrategy
     */
    omit?: TradingStrategyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradingStrategyInclude<ExtArgs> | null
    where?: TradingStrategyWhereInput
  }

  /**
   * DecisionLog.auditTrail
   */
  export type DecisionLog$auditTrailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
  }

  /**
   * DecisionLog without action
   */
  export type DecisionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditTrail
   */

  export type AggregateAuditTrail = {
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  export type AuditTrailMinAggregateOutputType = {
    id: string | null
    trailType: string | null
    entityId: string | null
    entityType: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    summary: string | null
    userId: string | null
    orderId: string | null
  }

  export type AuditTrailMaxAggregateOutputType = {
    id: string | null
    trailType: string | null
    entityId: string | null
    entityType: string | null
    startTime: Date | null
    endTime: Date | null
    status: string | null
    summary: string | null
    userId: string | null
    orderId: string | null
  }

  export type AuditTrailCountAggregateOutputType = {
    id: number
    trailType: number
    entityId: number
    entityType: number
    startTime: number
    endTime: number
    status: number
    summary: number
    userId: number
    orderId: number
    tags: number
    metadata: number
    _all: number
  }


  export type AuditTrailMinAggregateInputType = {
    id?: true
    trailType?: true
    entityId?: true
    entityType?: true
    startTime?: true
    endTime?: true
    status?: true
    summary?: true
    userId?: true
    orderId?: true
  }

  export type AuditTrailMaxAggregateInputType = {
    id?: true
    trailType?: true
    entityId?: true
    entityType?: true
    startTime?: true
    endTime?: true
    status?: true
    summary?: true
    userId?: true
    orderId?: true
  }

  export type AuditTrailCountAggregateInputType = {
    id?: true
    trailType?: true
    entityId?: true
    entityType?: true
    startTime?: true
    endTime?: true
    status?: true
    summary?: true
    userId?: true
    orderId?: true
    tags?: true
    metadata?: true
    _all?: true
  }

  export type AuditTrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrail to aggregate.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditTrails
    **/
    _count?: true | AuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditTrailMaxAggregateInputType
  }

  export type GetAuditTrailAggregateType<T extends AuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditTrail[P]>
      : GetScalarType<T[P], AggregateAuditTrail[P]>
  }




  export type AuditTrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithAggregationInput | AuditTrailOrderByWithAggregationInput[]
    by: AuditTrailScalarFieldEnum[] | AuditTrailScalarFieldEnum
    having?: AuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditTrailCountAggregateInputType | true
    _min?: AuditTrailMinAggregateInputType
    _max?: AuditTrailMaxAggregateInputType
  }

  export type AuditTrailGroupByOutputType = {
    id: string
    trailType: string
    entityId: string
    entityType: string
    startTime: Date
    endTime: Date | null
    status: string
    summary: string | null
    userId: string | null
    orderId: string | null
    tags: string[]
    metadata: JsonValue | null
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  type GetAuditTrailGroupByPayload<T extends AuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type AuditTrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trailType?: boolean
    entityId?: boolean
    entityType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    summary?: boolean
    userId?: boolean
    orderId?: boolean
    tags?: boolean
    metadata?: boolean
    events?: boolean | AuditTrail$eventsArgs<ExtArgs>
    decisionLogs?: boolean | AuditTrail$decisionLogsArgs<ExtArgs>
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
    _count?: boolean | AuditTrailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trailType?: boolean
    entityId?: boolean
    entityType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    summary?: boolean
    userId?: boolean
    orderId?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trailType?: boolean
    entityId?: boolean
    entityType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    summary?: boolean
    userId?: boolean
    orderId?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectScalar = {
    id?: boolean
    trailType?: boolean
    entityId?: boolean
    entityType?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    summary?: boolean
    userId?: boolean
    orderId?: boolean
    tags?: boolean
    metadata?: boolean
  }

  export type AuditTrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trailType" | "entityId" | "entityType" | "startTime" | "endTime" | "status" | "summary" | "userId" | "orderId" | "tags" | "metadata", ExtArgs["result"]["auditTrail"]>
  export type AuditTrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | AuditTrail$eventsArgs<ExtArgs>
    decisionLogs?: boolean | AuditTrail$decisionLogsArgs<ExtArgs>
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
    _count?: boolean | AuditTrailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditTrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
  }
  export type AuditTrailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AuditTrail$orderArgs<ExtArgs>
  }

  export type $AuditTrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditTrail"
    objects: {
      events: Prisma.$AuditEventPayload<ExtArgs>[]
      decisionLogs: Prisma.$DecisionLogPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trailType: string
      entityId: string
      entityType: string
      startTime: Date
      endTime: Date | null
      status: string
      summary: string | null
      userId: string | null
      orderId: string | null
      tags: string[]
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["auditTrail"]>
    composites: {}
  }

  type AuditTrailGetPayload<S extends boolean | null | undefined | AuditTrailDefaultArgs> = $Result.GetResult<Prisma.$AuditTrailPayload, S>

  type AuditTrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditTrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditTrailCountAggregateInputType | true
    }

  export interface AuditTrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditTrail'], meta: { name: 'AuditTrail' } }
    /**
     * Find zero or one AuditTrail that matches the filter.
     * @param {AuditTrailFindUniqueArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditTrailFindUniqueArgs>(args: SelectSubset<T, AuditTrailFindUniqueArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditTrail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditTrailFindUniqueOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditTrailFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditTrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditTrailFindFirstArgs>(args?: SelectSubset<T, AuditTrailFindFirstArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditTrailFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditTrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany()
     * 
     * // Get first 10 AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditTrailFindManyArgs>(args?: SelectSubset<T, AuditTrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditTrail.
     * @param {AuditTrailCreateArgs} args - Arguments to create a AuditTrail.
     * @example
     * // Create one AuditTrail
     * const AuditTrail = await prisma.auditTrail.create({
     *   data: {
     *     // ... data to create a AuditTrail
     *   }
     * })
     * 
     */
    create<T extends AuditTrailCreateArgs>(args: SelectSubset<T, AuditTrailCreateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditTrails.
     * @param {AuditTrailCreateManyArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditTrailCreateManyArgs>(args?: SelectSubset<T, AuditTrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditTrails and returns the data saved in the database.
     * @param {AuditTrailCreateManyAndReturnArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditTrails and only return the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditTrailCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditTrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditTrail.
     * @param {AuditTrailDeleteArgs} args - Arguments to delete one AuditTrail.
     * @example
     * // Delete one AuditTrail
     * const AuditTrail = await prisma.auditTrail.delete({
     *   where: {
     *     // ... filter to delete one AuditTrail
     *   }
     * })
     * 
     */
    delete<T extends AuditTrailDeleteArgs>(args: SelectSubset<T, AuditTrailDeleteArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditTrail.
     * @param {AuditTrailUpdateArgs} args - Arguments to update one AuditTrail.
     * @example
     * // Update one AuditTrail
     * const auditTrail = await prisma.auditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditTrailUpdateArgs>(args: SelectSubset<T, AuditTrailUpdateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditTrails.
     * @param {AuditTrailDeleteManyArgs} args - Arguments to filter AuditTrails to delete.
     * @example
     * // Delete a few AuditTrails
     * const { count } = await prisma.auditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditTrailDeleteManyArgs>(args?: SelectSubset<T, AuditTrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditTrailUpdateManyArgs>(args: SelectSubset<T, AuditTrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails and returns the data updated in the database.
     * @param {AuditTrailUpdateManyAndReturnArgs} args - Arguments to update many AuditTrails.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditTrails and only return the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditTrailUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditTrailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditTrail.
     * @param {AuditTrailUpsertArgs} args - Arguments to update or create a AuditTrail.
     * @example
     * // Update or create a AuditTrail
     * const auditTrail = await prisma.auditTrail.upsert({
     *   create: {
     *     // ... data to create a AuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditTrail we want to update
     *   }
     * })
     */
    upsert<T extends AuditTrailUpsertArgs>(args: SelectSubset<T, AuditTrailUpsertArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailCountArgs} args - Arguments to filter AuditTrails to count.
     * @example
     * // Count the number of AuditTrails
     * const count = await prisma.auditTrail.count({
     *   where: {
     *     // ... the filter for the AuditTrails we want to count
     *   }
     * })
    **/
    count<T extends AuditTrailCountArgs>(
      args?: Subset<T, AuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditTrailAggregateArgs>(args: Subset<T, AuditTrailAggregateArgs>): Prisma.PrismaPromise<GetAuditTrailAggregateType<T>>

    /**
     * Group by AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: AuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditTrail model
   */
  readonly fields: AuditTrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditTrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends AuditTrail$eventsArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrail$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decisionLogs<T extends AuditTrail$decisionLogsArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrail$decisionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends AuditTrail$orderArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrail$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditTrail model
   */
  interface AuditTrailFieldRefs {
    readonly id: FieldRef<"AuditTrail", 'String'>
    readonly trailType: FieldRef<"AuditTrail", 'String'>
    readonly entityId: FieldRef<"AuditTrail", 'String'>
    readonly entityType: FieldRef<"AuditTrail", 'String'>
    readonly startTime: FieldRef<"AuditTrail", 'DateTime'>
    readonly endTime: FieldRef<"AuditTrail", 'DateTime'>
    readonly status: FieldRef<"AuditTrail", 'String'>
    readonly summary: FieldRef<"AuditTrail", 'String'>
    readonly userId: FieldRef<"AuditTrail", 'String'>
    readonly orderId: FieldRef<"AuditTrail", 'String'>
    readonly tags: FieldRef<"AuditTrail", 'String[]'>
    readonly metadata: FieldRef<"AuditTrail", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AuditTrail findUnique
   */
  export type AuditTrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findUniqueOrThrow
   */
  export type AuditTrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findFirst
   */
  export type AuditTrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findFirstOrThrow
   */
  export type AuditTrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findMany
   */
  export type AuditTrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrails to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail create
   */
  export type AuditTrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditTrail.
     */
    data: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
  }

  /**
   * AuditTrail createMany
   */
  export type AuditTrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditTrail createManyAndReturn
   */
  export type AuditTrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditTrail update
   */
  export type AuditTrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditTrail.
     */
    data: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
    /**
     * Choose, which AuditTrail to update.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail updateMany
   */
  export type AuditTrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to update.
     */
    limit?: number
  }

  /**
   * AuditTrail updateManyAndReturn
   */
  export type AuditTrailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditTrail upsert
   */
  export type AuditTrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditTrail to update in case it exists.
     */
    where: AuditTrailWhereUniqueInput
    /**
     * In case the AuditTrail found by the `where` argument doesn't exist, create a new AuditTrail with this data.
     */
    create: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
    /**
     * In case the AuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
  }

  /**
   * AuditTrail delete
   */
  export type AuditTrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter which AuditTrail to delete.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail deleteMany
   */
  export type AuditTrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrails to delete
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to delete.
     */
    limit?: number
  }

  /**
   * AuditTrail.events
   */
  export type AuditTrail$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditTrail.decisionLogs
   */
  export type AuditTrail$decisionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DecisionLog
     */
    omit?: DecisionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * AuditTrail.order
   */
  export type AuditTrail$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * AuditTrail without action
   */
  export type AuditTrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: string | null
    auditTrailId: string | null
    timestamp: Date | null
    eventType: string | null
    component: string | null
    action: string | null
    status: string | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: string | null
    auditTrailId: string | null
    timestamp: Date | null
    eventType: string | null
    component: string | null
    action: string | null
    status: string | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    auditTrailId: number
    timestamp: number
    eventType: number
    component: number
    action: number
    status: number
    details: number
    dataBefore: number
    dataAfter: number
    metadata: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    auditTrailId?: true
    timestamp?: true
    eventType?: true
    component?: true
    action?: true
    status?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    auditTrailId?: true
    timestamp?: true
    eventType?: true
    component?: true
    action?: true
    status?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    auditTrailId?: true
    timestamp?: true
    eventType?: true
    component?: true
    action?: true
    status?: true
    details?: true
    dataBefore?: true
    dataAfter?: true
    metadata?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: string
    auditTrailId: string
    timestamp: Date
    eventType: string
    component: string
    action: string
    status: string
    details: JsonValue | null
    dataBefore: JsonValue | null
    dataAfter: JsonValue | null
    metadata: JsonValue | null
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditTrailId?: boolean
    timestamp?: boolean
    eventType?: boolean
    component?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    dataBefore?: boolean
    dataAfter?: boolean
    metadata?: boolean
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditTrailId?: boolean
    timestamp?: boolean
    eventType?: boolean
    component?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    dataBefore?: boolean
    dataAfter?: boolean
    metadata?: boolean
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditTrailId?: boolean
    timestamp?: boolean
    eventType?: boolean
    component?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    dataBefore?: boolean
    dataAfter?: boolean
    metadata?: boolean
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    auditTrailId?: boolean
    timestamp?: boolean
    eventType?: boolean
    component?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    dataBefore?: boolean
    dataAfter?: boolean
    metadata?: boolean
  }

  export type AuditEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditTrailId" | "timestamp" | "eventType" | "component" | "action" | "status" | "details" | "dataBefore" | "dataAfter" | "metadata", ExtArgs["result"]["auditEvent"]>
  export type AuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }
  export type AuditEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }
  export type AuditEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditTrail?: boolean | AuditTrailDefaultArgs<ExtArgs>
  }

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {
      auditTrail: Prisma.$AuditTrailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditTrailId: string
      timestamp: Date
      eventType: string
      component: string
      action: string
      status: string
      details: Prisma.JsonValue | null
      dataBefore: Prisma.JsonValue | null
      dataAfter: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents and returns the data updated in the database.
     * @param {AuditEventUpdateManyAndReturnArgs} args - Arguments to update many AuditEvents.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditTrail<T extends AuditTrailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrailDefaultArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'String'>
    readonly auditTrailId: FieldRef<"AuditEvent", 'String'>
    readonly timestamp: FieldRef<"AuditEvent", 'DateTime'>
    readonly eventType: FieldRef<"AuditEvent", 'String'>
    readonly component: FieldRef<"AuditEvent", 'String'>
    readonly action: FieldRef<"AuditEvent", 'String'>
    readonly status: FieldRef<"AuditEvent", 'String'>
    readonly details: FieldRef<"AuditEvent", 'Json'>
    readonly dataBefore: FieldRef<"AuditEvent", 'Json'>
    readonly dataAfter: FieldRef<"AuditEvent", 'Json'>
    readonly metadata: FieldRef<"AuditEvent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
  }

  /**
   * AuditEvent updateManyAndReturn
   */
  export type AuditEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to delete.
     */
    limit?: number
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    details: JsonValue
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "details" | "ipAddress" | "userAgent" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      details: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    isVerified: 'isVerified',
    verificationToken: 'verificationToken',
    verificationTokenExpiry: 'verificationTokenExpiry',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    lastLoginAt: 'lastLoginAt',
    oauthProvider: 'oauthProvider',
    oauthId: 'oauthId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceId: 'deviceId',
    isValid: 'isValid',
    expiresAt: 'expiresAt',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rememberMe: 'rememberMe',
    metadata: 'metadata'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    encryptedData: 'encryptedData',
    userId: 'userId',
    name: 'name',
    scopes: 'scopes',
    expiry: 'expiry',
    environment: 'environment',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt',
    isRevoked: 'isRevoked',
    revokedAt: 'revokedAt',
    revokedBy: 'revokedBy',
    revokedReason: 'revokedReason',
    ipRestrictions: 'ipRestrictions',
    hashedSecret: 'hashedSecret',
    usageCount: 'usageCount',
    isDefault: 'isDefault',
    rateLimits: 'rateLimits',
    metadata: 'metadata'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const TradeLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    instrument: 'instrument',
    amount: 'amount',
    price: 'price',
    timestamp: 'timestamp',
    orderId: 'orderId',
    type: 'type',
    status: 'status'
  };

  export type TradeLogScalarFieldEnum = (typeof TradeLogScalarFieldEnum)[keyof typeof TradeLogScalarFieldEnum]


  export const BotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    symbol: 'symbol',
    strategy: 'strategy',
    timeframe: 'timeframe',
    parameters: 'parameters',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotScalarFieldEnum = (typeof BotScalarFieldEnum)[keyof typeof BotScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    botId: 'botId',
    symbol: 'symbol',
    side: 'side',
    entryPrice: 'entryPrice',
    currentPrice: 'currentPrice',
    amount: 'amount',
    leverage: 'leverage',
    takeProfitPrice: 'takeProfitPrice',
    stopLossPrice: 'stopLossPrice',
    status: 'status',
    pnl: 'pnl',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    metadata: 'metadata'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    recordedAt: 'recordedAt',
    tags: 'tags'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const TradingSignalScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    type: 'type',
    direction: 'direction',
    strength: 'strength',
    timeframe: 'timeframe',
    price: 'price',
    targetPrice: 'targetPrice',
    stopLoss: 'stopLoss',
    confidenceScore: 'confidenceScore',
    expectedReturn: 'expectedReturn',
    expectedRisk: 'expectedRisk',
    riskRewardRatio: 'riskRewardRatio',
    generatedAt: 'generatedAt',
    expiresAt: 'expiresAt',
    source: 'source',
    metadata: 'metadata',
    predictionValues: 'predictionValues',
    validatedAt: 'validatedAt',
    validationStatus: 'validationStatus',
    validationReason: 'validationReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradingSignalScalarFieldEnum = (typeof TradingSignalScalarFieldEnum)[keyof typeof TradingSignalScalarFieldEnum]


  export const RiskSettingsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    botId: 'botId',
    isActive: 'isActive',
    positionSizingMethod: 'positionSizingMethod',
    riskPercentage: 'riskPercentage',
    maxPositionSize: 'maxPositionSize',
    kellyFraction: 'kellyFraction',
    winRate: 'winRate',
    customSizingParams: 'customSizingParams',
    stopLossType: 'stopLossType',
    stopLossValue: 'stopLossValue',
    trailingCallback: 'trailingCallback',
    trailingStep: 'trailingStep',
    timeLimit: 'timeLimit',
    stopLossLevels: 'stopLossLevels',
    takeProfitType: 'takeProfitType',
    takeProfitValue: 'takeProfitValue',
    trailingActivation: 'trailingActivation',
    takeProfitLevels: 'takeProfitLevels',
    maxRiskPerTrade: 'maxRiskPerTrade',
    maxRiskPerSymbol: 'maxRiskPerSymbol',
    maxRiskPerDirection: 'maxRiskPerDirection',
    maxTotalRisk: 'maxTotalRisk',
    maxDrawdown: 'maxDrawdown',
    maxPositions: 'maxPositions',
    maxDailyLoss: 'maxDailyLoss',
    cooldownPeriod: 'cooldownPeriod',
    volatilityLookback: 'volatilityLookback',
    circuitBreakerEnabled: 'circuitBreakerEnabled',
    maxDailyLossBreaker: 'maxDailyLossBreaker',
    maxDrawdownBreaker: 'maxDrawdownBreaker',
    volatilityMultiplier: 'volatilityMultiplier',
    consecutiveLossesBreaker: 'consecutiveLossesBreaker',
    tradingPause: 'tradingPause',
    marketWideEnabled: 'marketWideEnabled',
    enableManualOverride: 'enableManualOverride',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskSettingsScalarFieldEnum = (typeof RiskSettingsScalarFieldEnum)[keyof typeof RiskSettingsScalarFieldEnum]


  export const RiskAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    level: 'level',
    message: 'message',
    details: 'details',
    timestamp: 'timestamp',
    acknowledged: 'acknowledged',
    resolvedAt: 'resolvedAt'
  };

  export type RiskAlertScalarFieldEnum = (typeof RiskAlertScalarFieldEnum)[keyof typeof RiskAlertScalarFieldEnum]


  export const CircuitBreakerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    botId: 'botId',
    type: 'type',
    isGlobal: 'isGlobal',
    isActive: 'isActive',
    threshold: 'threshold',
    recoveryThreshold: 'recoveryThreshold',
    cooldownMinutes: 'cooldownMinutes',
    action: 'action',
    lastTriggered: 'lastTriggered',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CircuitBreakerScalarFieldEnum = (typeof CircuitBreakerScalarFieldEnum)[keyof typeof CircuitBreakerScalarFieldEnum]


  export const TradingStrategyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    timeHorizon: 'timeHorizon',
    symbols: 'symbols',
    entryRules: 'entryRules',
    exitRules: 'exitRules',
    positionSizing: 'positionSizing',
    riskManagement: 'riskManagement',
    userId: 'userId',
    isPublic: 'isPublic',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradingStrategyScalarFieldEnum = (typeof TradingStrategyScalarFieldEnum)[keyof typeof TradingStrategyScalarFieldEnum]


  export const StrategyExecutionScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    userId: 'userId',
    status: 'status',
    startedAt: 'startedAt',
    stoppedAt: 'stoppedAt',
    runningTimeMs: 'runningTimeMs',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StrategyExecutionScalarFieldEnum = (typeof StrategyExecutionScalarFieldEnum)[keyof typeof StrategyExecutionScalarFieldEnum]


  export const StrategyExecutionResultScalarFieldEnum: {
    id: 'id',
    executionId: 'executionId',
    symbol: 'symbol',
    entryTime: 'entryTime',
    entryPrice: 'entryPrice',
    exitTime: 'exitTime',
    exitPrice: 'exitPrice',
    direction: 'direction',
    quantity: 'quantity',
    profitLoss: 'profitLoss',
    profitLossPercentage: 'profitLossPercentage',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StrategyExecutionResultScalarFieldEnum = (typeof StrategyExecutionResultScalarFieldEnum)[keyof typeof StrategyExecutionResultScalarFieldEnum]


  export const MLModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    modelType: 'modelType',
    symbol: 'symbol',
    timeframe: 'timeframe',
    description: 'description',
    status: 'status',
    accuracy: 'accuracy',
    precision: 'precision',
    recall: 'recall',
    f1Score: 'f1Score',
    trainedAt: 'trainedAt',
    lastUsedAt: 'lastUsedAt',
    trainingId: 'trainingId',
    location: 'location',
    params: 'params',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MLModelScalarFieldEnum = (typeof MLModelScalarFieldEnum)[keyof typeof MLModelScalarFieldEnum]


  export const MLPredictionScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    symbol: 'symbol',
    timeframe: 'timeframe',
    predictionType: 'predictionType',
    values: 'values',
    timestamps: 'timestamps',
    confidenceScores: 'confidenceScores',
    metadata: 'metadata',
    generatedAt: 'generatedAt',
    expiresAt: 'expiresAt',
    signalGenerated: 'signalGenerated',
    signalId: 'signalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MLPredictionScalarFieldEnum = (typeof MLPredictionScalarFieldEnum)[keyof typeof MLPredictionScalarFieldEnum]


  export const MLTrainingJobScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol',
    timeframe: 'timeframe',
    modelType: 'modelType',
    status: 'status',
    progress: 'progress',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    resultModelId: 'resultModelId',
    errorMessage: 'errorMessage',
    params: 'params',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MLTrainingJobScalarFieldEnum = (typeof MLTrainingJobScalarFieldEnum)[keyof typeof MLTrainingJobScalarFieldEnum]


  export const BridgeConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    mlModelId: 'mlModelId',
    autoGenerateSignals: 'autoGenerateSignals',
    confidenceThreshold: 'confidenceThreshold',
    signalExpiryMinutes: 'signalExpiryMinutes',
    refreshIntervalMinutes: 'refreshIntervalMinutes',
    symbols: 'symbols',
    timeframes: 'timeframes',
    lastExecutedAt: 'lastExecutedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BridgeConfigScalarFieldEnum = (typeof BridgeConfigScalarFieldEnum)[keyof typeof BridgeConfigScalarFieldEnum]


  export const PerformanceTestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    testType: 'testType',
    duration: 'duration',
    concurrency: 'concurrency',
    rampUp: 'rampUp',
    targetEndpoint: 'targetEndpoint',
    modelId: 'modelId',
    strategyId: 'strategyId',
    symbol: 'symbol',
    timeframe: 'timeframe',
    options: 'options',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceTestScalarFieldEnum = (typeof PerformanceTestScalarFieldEnum)[keyof typeof PerformanceTestScalarFieldEnum]


  export const PerformanceTestResultScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    metrics: 'metrics',
    errors: 'errors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceTestResultScalarFieldEnum = (typeof PerformanceTestResultScalarFieldEnum)[keyof typeof PerformanceTestResultScalarFieldEnum]


  export const OptimizationRecommendationScalarFieldEnum: {
    id: 'id',
    testResultId: 'testResultId',
    category: 'category',
    impact: 'impact',
    description: 'description',
    implementation: 'implementation',
    estimatedImprovement: 'estimatedImprovement',
    createdAt: 'createdAt'
  };

  export type OptimizationRecommendationScalarFieldEnum = (typeof OptimizationRecommendationScalarFieldEnum)[keyof typeof OptimizationRecommendationScalarFieldEnum]


  export const ABTestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    variantA: 'variantA',
    variantB: 'variantB',
    type: 'type',
    metric: 'metric',
    targetImprovement: 'targetImprovement',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ABTestScalarFieldEnum = (typeof ABTestScalarFieldEnum)[keyof typeof ABTestScalarFieldEnum]


  export const ABTestResultScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    variantAMetrics: 'variantAMetrics',
    variantBMetrics: 'variantBMetrics',
    winner: 'winner',
    improvement: 'improvement',
    confidenceLevel: 'confidenceLevel',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ABTestResultScalarFieldEnum = (typeof ABTestResultScalarFieldEnum)[keyof typeof ABTestResultScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    system: 'system',
    component: 'component',
    metric: 'metric',
    value: 'value',
    unit: 'unit',
    tags: 'tags'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    symbol: 'symbol',
    type: 'type',
    side: 'side',
    quantity: 'quantity',
    price: 'price',
    stopPrice: 'stopPrice',
    avgFillPrice: 'avgFillPrice',
    filledQuantity: 'filledQuantity',
    remainingQuantity: 'remainingQuantity',
    fee: 'fee',
    feeCurrency: 'feeCurrency',
    clientOrderId: 'clientOrderId',
    exchangeOrderId: 'exchangeOrderId',
    source: 'source',
    exchangeId: 'exchangeId',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    errorDetails: 'errorDetails',
    raw: 'raw',
    userId: 'userId',
    positionId: 'positionId',
    strategyId: 'strategyId',
    botId: 'botId',
    signalId: 'signalId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const DecisionLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    source: 'source',
    actionType: 'actionType',
    decision: 'decision',
    reasonDetails: 'reasonDetails',
    userId: 'userId',
    botId: 'botId',
    strategyId: 'strategyId',
    symbol: 'symbol',
    orderId: 'orderId',
    positionId: 'positionId',
    importance: 'importance',
    metadata: 'metadata',
    tags: 'tags',
    auditTrailId: 'auditTrailId'
  };

  export type DecisionLogScalarFieldEnum = (typeof DecisionLogScalarFieldEnum)[keyof typeof DecisionLogScalarFieldEnum]


  export const AuditTrailScalarFieldEnum: {
    id: 'id',
    trailType: 'trailType',
    entityId: 'entityId',
    entityType: 'entityType',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    summary: 'summary',
    userId: 'userId',
    orderId: 'orderId',
    tags: 'tags',
    metadata: 'metadata'
  };

  export type AuditTrailScalarFieldEnum = (typeof AuditTrailScalarFieldEnum)[keyof typeof AuditTrailScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    auditTrailId: 'auditTrailId',
    timestamp: 'timestamp',
    eventType: 'eventType',
    component: 'component',
    action: 'action',
    status: 'status',
    details: 'details',
    dataBefore: 'dataBefore',
    dataAfter: 'dataAfter',
    metadata: 'metadata'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    oauthProvider?: StringNullableFilter<"User"> | string | null
    oauthId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
    tradeLogs?: TradeLogListRelationFilter
    bots?: BotListRelationFilter
    positions?: PositionListRelationFilter
    sessions?: SessionListRelationFilter
    riskSettings?: RiskSettingsListRelationFilter
    riskAlerts?: RiskAlertListRelationFilter
    orders?: OrderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiry?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    tradeLogs?: TradeLogOrderByRelationAggregateInput
    bots?: BotOrderByRelationAggregateInput
    positions?: PositionOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    riskSettings?: RiskSettingsOrderByRelationAggregateInput
    riskAlerts?: RiskAlertOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    decisionLogs?: DecisionLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    oauthProvider?: StringNullableFilter<"User"> | string | null
    oauthId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
    tradeLogs?: TradeLogListRelationFilter
    bots?: BotListRelationFilter
    positions?: PositionListRelationFilter
    sessions?: SessionListRelationFilter
    riskSettings?: RiskSettingsListRelationFilter
    riskAlerts?: RiskAlertListRelationFilter
    orders?: OrderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiry?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    oauthProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    oauthId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceId?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    rememberMe?: BoolFilter<"Session"> | boolean
    metadata?: JsonNullableFilter<"Session">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    isValid?: SortOrder
    expiresAt?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rememberMe?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceId?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    rememberMe?: BoolFilter<"Session"> | boolean
    metadata?: JsonNullableFilter<"Session">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    isValid?: SortOrder
    expiresAt?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rememberMe?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isValid?: BoolWithAggregatesFilter<"Session"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    rememberMe?: BoolWithAggregatesFilter<"Session"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Session">
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    encryptedData?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    scopes?: StringFilter<"ApiKey"> | string
    expiry?: DateTimeFilter<"ApiKey"> | Date | string
    environment?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isRevoked?: BoolFilter<"ApiKey"> | boolean
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedBy?: StringNullableFilter<"ApiKey"> | string | null
    revokedReason?: StringNullableFilter<"ApiKey"> | string | null
    ipRestrictions?: StringNullableFilter<"ApiKey"> | string | null
    hashedSecret?: StringNullableFilter<"ApiKey"> | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    isDefault?: BoolFilter<"ApiKey"> | boolean
    rateLimits?: JsonNullableFilter<"ApiKey">
    metadata?: JsonNullableFilter<"ApiKey">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    encryptedData?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    scopes?: SortOrder
    expiry?: SortOrder
    environment?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    ipRestrictions?: SortOrderInput | SortOrder
    hashedSecret?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    isDefault?: SortOrder
    rateLimits?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    encryptedData?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    scopes?: StringFilter<"ApiKey"> | string
    expiry?: DateTimeFilter<"ApiKey"> | Date | string
    environment?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isRevoked?: BoolFilter<"ApiKey"> | boolean
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedBy?: StringNullableFilter<"ApiKey"> | string | null
    revokedReason?: StringNullableFilter<"ApiKey"> | string | null
    ipRestrictions?: StringNullableFilter<"ApiKey"> | string | null
    hashedSecret?: StringNullableFilter<"ApiKey"> | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    isDefault?: BoolFilter<"ApiKey"> | boolean
    rateLimits?: JsonNullableFilter<"ApiKey">
    metadata?: JsonNullableFilter<"ApiKey">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    encryptedData?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    scopes?: SortOrder
    expiry?: SortOrder
    environment?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    ipRestrictions?: SortOrderInput | SortOrder
    hashedSecret?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    isDefault?: SortOrder
    rateLimits?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    encryptedData?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    scopes?: StringWithAggregatesFilter<"ApiKey"> | string
    expiry?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    environment?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    isRevoked?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    revokedBy?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    revokedReason?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    ipRestrictions?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    hashedSecret?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    usageCount?: IntWithAggregatesFilter<"ApiKey"> | number
    isDefault?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    rateLimits?: JsonNullableWithAggregatesFilter<"ApiKey">
    metadata?: JsonNullableWithAggregatesFilter<"ApiKey">
  }

  export type TradeLogWhereInput = {
    AND?: TradeLogWhereInput | TradeLogWhereInput[]
    OR?: TradeLogWhereInput[]
    NOT?: TradeLogWhereInput | TradeLogWhereInput[]
    id?: StringFilter<"TradeLog"> | string
    userId?: StringFilter<"TradeLog"> | string
    instrument?: StringFilter<"TradeLog"> | string
    amount?: FloatFilter<"TradeLog"> | number
    price?: FloatFilter<"TradeLog"> | number
    timestamp?: DateTimeFilter<"TradeLog"> | Date | string
    orderId?: StringNullableFilter<"TradeLog"> | string | null
    type?: StringFilter<"TradeLog"> | string
    status?: StringFilter<"TradeLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TradeLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrument?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    orderId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TradeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradeLogWhereInput | TradeLogWhereInput[]
    OR?: TradeLogWhereInput[]
    NOT?: TradeLogWhereInput | TradeLogWhereInput[]
    userId?: StringFilter<"TradeLog"> | string
    instrument?: StringFilter<"TradeLog"> | string
    amount?: FloatFilter<"TradeLog"> | number
    price?: FloatFilter<"TradeLog"> | number
    timestamp?: DateTimeFilter<"TradeLog"> | Date | string
    orderId?: StringNullableFilter<"TradeLog"> | string | null
    type?: StringFilter<"TradeLog"> | string
    status?: StringFilter<"TradeLog"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TradeLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrument?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    orderId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    _count?: TradeLogCountOrderByAggregateInput
    _avg?: TradeLogAvgOrderByAggregateInput
    _max?: TradeLogMaxOrderByAggregateInput
    _min?: TradeLogMinOrderByAggregateInput
    _sum?: TradeLogSumOrderByAggregateInput
  }

  export type TradeLogScalarWhereWithAggregatesInput = {
    AND?: TradeLogScalarWhereWithAggregatesInput | TradeLogScalarWhereWithAggregatesInput[]
    OR?: TradeLogScalarWhereWithAggregatesInput[]
    NOT?: TradeLogScalarWhereWithAggregatesInput | TradeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeLog"> | string
    userId?: StringWithAggregatesFilter<"TradeLog"> | string
    instrument?: StringWithAggregatesFilter<"TradeLog"> | string
    amount?: FloatWithAggregatesFilter<"TradeLog"> | number
    price?: FloatWithAggregatesFilter<"TradeLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"TradeLog"> | Date | string
    orderId?: StringNullableWithAggregatesFilter<"TradeLog"> | string | null
    type?: StringWithAggregatesFilter<"TradeLog"> | string
    status?: StringWithAggregatesFilter<"TradeLog"> | string
  }

  export type BotWhereInput = {
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    id?: StringFilter<"Bot"> | string
    userId?: StringFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    symbol?: StringFilter<"Bot"> | string
    strategy?: StringFilter<"Bot"> | string
    timeframe?: StringFilter<"Bot"> | string
    parameters?: JsonFilter<"Bot">
    isActive?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    positions?: PositionListRelationFilter
    riskSettings?: RiskSettingsListRelationFilter
    orders?: OrderListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }

  export type BotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    strategy?: SortOrder
    timeframe?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    positions?: PositionOrderByRelationAggregateInput
    riskSettings?: RiskSettingsOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    decisionLogs?: DecisionLogOrderByRelationAggregateInput
  }

  export type BotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    userId?: StringFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    symbol?: StringFilter<"Bot"> | string
    strategy?: StringFilter<"Bot"> | string
    timeframe?: StringFilter<"Bot"> | string
    parameters?: JsonFilter<"Bot">
    isActive?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    positions?: PositionListRelationFilter
    riskSettings?: RiskSettingsListRelationFilter
    orders?: OrderListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }, "id">

  export type BotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    strategy?: SortOrder
    timeframe?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotCountOrderByAggregateInput
    _max?: BotMaxOrderByAggregateInput
    _min?: BotMinOrderByAggregateInput
  }

  export type BotScalarWhereWithAggregatesInput = {
    AND?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    OR?: BotScalarWhereWithAggregatesInput[]
    NOT?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bot"> | string
    userId?: StringWithAggregatesFilter<"Bot"> | string
    name?: StringWithAggregatesFilter<"Bot"> | string
    symbol?: StringWithAggregatesFilter<"Bot"> | string
    strategy?: StringWithAggregatesFilter<"Bot"> | string
    timeframe?: StringWithAggregatesFilter<"Bot"> | string
    parameters?: JsonWithAggregatesFilter<"Bot">
    isActive?: BoolWithAggregatesFilter<"Bot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    userId?: StringFilter<"Position"> | string
    botId?: StringNullableFilter<"Position"> | string | null
    symbol?: StringFilter<"Position"> | string
    side?: StringFilter<"Position"> | string
    entryPrice?: FloatFilter<"Position"> | number
    currentPrice?: FloatNullableFilter<"Position"> | number | null
    amount?: FloatFilter<"Position"> | number
    leverage?: FloatFilter<"Position"> | number
    takeProfitPrice?: FloatNullableFilter<"Position"> | number | null
    stopLossPrice?: FloatNullableFilter<"Position"> | number | null
    status?: StringFilter<"Position"> | string
    pnl?: FloatNullableFilter<"Position"> | number | null
    openedAt?: DateTimeFilter<"Position"> | Date | string
    closedAt?: DateTimeNullableFilter<"Position"> | Date | string | null
    metadata?: JsonNullableFilter<"Position">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    orders?: OrderListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    symbol?: SortOrder
    side?: SortOrder
    entryPrice?: SortOrder
    currentPrice?: SortOrderInput | SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrderInput | SortOrder
    stopLossPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    pnl?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    bot?: BotOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    userId?: StringFilter<"Position"> | string
    botId?: StringNullableFilter<"Position"> | string | null
    symbol?: StringFilter<"Position"> | string
    side?: StringFilter<"Position"> | string
    entryPrice?: FloatFilter<"Position"> | number
    currentPrice?: FloatNullableFilter<"Position"> | number | null
    amount?: FloatFilter<"Position"> | number
    leverage?: FloatFilter<"Position"> | number
    takeProfitPrice?: FloatNullableFilter<"Position"> | number | null
    stopLossPrice?: FloatNullableFilter<"Position"> | number | null
    status?: StringFilter<"Position"> | string
    pnl?: FloatNullableFilter<"Position"> | number | null
    openedAt?: DateTimeFilter<"Position"> | Date | string
    closedAt?: DateTimeNullableFilter<"Position"> | Date | string | null
    metadata?: JsonNullableFilter<"Position">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    orders?: OrderListRelationFilter
  }, "id">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    symbol?: SortOrder
    side?: SortOrder
    entryPrice?: SortOrder
    currentPrice?: SortOrderInput | SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrderInput | SortOrder
    stopLossPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    pnl?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    userId?: StringWithAggregatesFilter<"Position"> | string
    botId?: StringNullableWithAggregatesFilter<"Position"> | string | null
    symbol?: StringWithAggregatesFilter<"Position"> | string
    side?: StringWithAggregatesFilter<"Position"> | string
    entryPrice?: FloatWithAggregatesFilter<"Position"> | number
    currentPrice?: FloatNullableWithAggregatesFilter<"Position"> | number | null
    amount?: FloatWithAggregatesFilter<"Position"> | number
    leverage?: FloatWithAggregatesFilter<"Position"> | number
    takeProfitPrice?: FloatNullableWithAggregatesFilter<"Position"> | number | null
    stopLossPrice?: FloatNullableWithAggregatesFilter<"Position"> | number | null
    status?: StringWithAggregatesFilter<"Position"> | string
    pnl?: FloatNullableWithAggregatesFilter<"Position"> | number | null
    openedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Position"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Position">
  }

  export type MetricWhereInput = {
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    id?: StringFilter<"Metric"> | string
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    recordedAt?: DateTimeFilter<"Metric"> | Date | string
    tags?: JsonNullableFilter<"Metric">
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    recordedAt?: SortOrder
    tags?: SortOrderInput | SortOrder
  }

  export type MetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    name?: StringFilter<"Metric"> | string
    value?: FloatFilter<"Metric"> | number
    recordedAt?: DateTimeFilter<"Metric"> | Date | string
    tags?: JsonNullableFilter<"Metric">
  }, "id">

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    recordedAt?: SortOrder
    tags?: SortOrderInput | SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    OR?: MetricScalarWhereWithAggregatesInput[]
    NOT?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Metric"> | string
    name?: StringWithAggregatesFilter<"Metric"> | string
    value?: FloatWithAggregatesFilter<"Metric"> | number
    recordedAt?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    tags?: JsonNullableWithAggregatesFilter<"Metric">
  }

  export type TradingSignalWhereInput = {
    AND?: TradingSignalWhereInput | TradingSignalWhereInput[]
    OR?: TradingSignalWhereInput[]
    NOT?: TradingSignalWhereInput | TradingSignalWhereInput[]
    id?: StringFilter<"TradingSignal"> | string
    symbol?: StringFilter<"TradingSignal"> | string
    type?: StringFilter<"TradingSignal"> | string
    direction?: StringFilter<"TradingSignal"> | string
    strength?: StringFilter<"TradingSignal"> | string
    timeframe?: StringFilter<"TradingSignal"> | string
    price?: FloatFilter<"TradingSignal"> | number
    targetPrice?: FloatNullableFilter<"TradingSignal"> | number | null
    stopLoss?: FloatNullableFilter<"TradingSignal"> | number | null
    confidenceScore?: IntFilter<"TradingSignal"> | number
    expectedReturn?: FloatFilter<"TradingSignal"> | number
    expectedRisk?: FloatFilter<"TradingSignal"> | number
    riskRewardRatio?: FloatFilter<"TradingSignal"> | number
    generatedAt?: DateTimeFilter<"TradingSignal"> | Date | string
    expiresAt?: DateTimeNullableFilter<"TradingSignal"> | Date | string | null
    source?: StringFilter<"TradingSignal"> | string
    metadata?: JsonFilter<"TradingSignal">
    predictionValues?: JsonFilter<"TradingSignal">
    validatedAt?: DateTimeNullableFilter<"TradingSignal"> | Date | string | null
    validationStatus?: BoolFilter<"TradingSignal"> | boolean
    validationReason?: StringNullableFilter<"TradingSignal"> | string | null
    createdAt?: DateTimeFilter<"TradingSignal"> | Date | string
    updatedAt?: DateTimeFilter<"TradingSignal"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type TradingSignalOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    strength?: SortOrder
    timeframe?: SortOrder
    price?: SortOrder
    targetPrice?: SortOrderInput | SortOrder
    stopLoss?: SortOrderInput | SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    source?: SortOrder
    metadata?: SortOrder
    predictionValues?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validationStatus?: SortOrder
    validationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type TradingSignalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradingSignalWhereInput | TradingSignalWhereInput[]
    OR?: TradingSignalWhereInput[]
    NOT?: TradingSignalWhereInput | TradingSignalWhereInput[]
    symbol?: StringFilter<"TradingSignal"> | string
    type?: StringFilter<"TradingSignal"> | string
    direction?: StringFilter<"TradingSignal"> | string
    strength?: StringFilter<"TradingSignal"> | string
    timeframe?: StringFilter<"TradingSignal"> | string
    price?: FloatFilter<"TradingSignal"> | number
    targetPrice?: FloatNullableFilter<"TradingSignal"> | number | null
    stopLoss?: FloatNullableFilter<"TradingSignal"> | number | null
    confidenceScore?: IntFilter<"TradingSignal"> | number
    expectedReturn?: FloatFilter<"TradingSignal"> | number
    expectedRisk?: FloatFilter<"TradingSignal"> | number
    riskRewardRatio?: FloatFilter<"TradingSignal"> | number
    generatedAt?: DateTimeFilter<"TradingSignal"> | Date | string
    expiresAt?: DateTimeNullableFilter<"TradingSignal"> | Date | string | null
    source?: StringFilter<"TradingSignal"> | string
    metadata?: JsonFilter<"TradingSignal">
    predictionValues?: JsonFilter<"TradingSignal">
    validatedAt?: DateTimeNullableFilter<"TradingSignal"> | Date | string | null
    validationStatus?: BoolFilter<"TradingSignal"> | boolean
    validationReason?: StringNullableFilter<"TradingSignal"> | string | null
    createdAt?: DateTimeFilter<"TradingSignal"> | Date | string
    updatedAt?: DateTimeFilter<"TradingSignal"> | Date | string
    orders?: OrderListRelationFilter
  }, "id">

  export type TradingSignalOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    strength?: SortOrder
    timeframe?: SortOrder
    price?: SortOrder
    targetPrice?: SortOrderInput | SortOrder
    stopLoss?: SortOrderInput | SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    source?: SortOrder
    metadata?: SortOrder
    predictionValues?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validationStatus?: SortOrder
    validationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradingSignalCountOrderByAggregateInput
    _avg?: TradingSignalAvgOrderByAggregateInput
    _max?: TradingSignalMaxOrderByAggregateInput
    _min?: TradingSignalMinOrderByAggregateInput
    _sum?: TradingSignalSumOrderByAggregateInput
  }

  export type TradingSignalScalarWhereWithAggregatesInput = {
    AND?: TradingSignalScalarWhereWithAggregatesInput | TradingSignalScalarWhereWithAggregatesInput[]
    OR?: TradingSignalScalarWhereWithAggregatesInput[]
    NOT?: TradingSignalScalarWhereWithAggregatesInput | TradingSignalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradingSignal"> | string
    symbol?: StringWithAggregatesFilter<"TradingSignal"> | string
    type?: StringWithAggregatesFilter<"TradingSignal"> | string
    direction?: StringWithAggregatesFilter<"TradingSignal"> | string
    strength?: StringWithAggregatesFilter<"TradingSignal"> | string
    timeframe?: StringWithAggregatesFilter<"TradingSignal"> | string
    price?: FloatWithAggregatesFilter<"TradingSignal"> | number
    targetPrice?: FloatNullableWithAggregatesFilter<"TradingSignal"> | number | null
    stopLoss?: FloatNullableWithAggregatesFilter<"TradingSignal"> | number | null
    confidenceScore?: IntWithAggregatesFilter<"TradingSignal"> | number
    expectedReturn?: FloatWithAggregatesFilter<"TradingSignal"> | number
    expectedRisk?: FloatWithAggregatesFilter<"TradingSignal"> | number
    riskRewardRatio?: FloatWithAggregatesFilter<"TradingSignal"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"TradingSignal"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TradingSignal"> | Date | string | null
    source?: StringWithAggregatesFilter<"TradingSignal"> | string
    metadata?: JsonWithAggregatesFilter<"TradingSignal">
    predictionValues?: JsonWithAggregatesFilter<"TradingSignal">
    validatedAt?: DateTimeNullableWithAggregatesFilter<"TradingSignal"> | Date | string | null
    validationStatus?: BoolWithAggregatesFilter<"TradingSignal"> | boolean
    validationReason?: StringNullableWithAggregatesFilter<"TradingSignal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TradingSignal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradingSignal"> | Date | string
  }

  export type RiskSettingsWhereInput = {
    AND?: RiskSettingsWhereInput | RiskSettingsWhereInput[]
    OR?: RiskSettingsWhereInput[]
    NOT?: RiskSettingsWhereInput | RiskSettingsWhereInput[]
    id?: StringFilter<"RiskSettings"> | string
    name?: StringFilter<"RiskSettings"> | string
    description?: StringNullableFilter<"RiskSettings"> | string | null
    userId?: StringFilter<"RiskSettings"> | string
    botId?: StringNullableFilter<"RiskSettings"> | string | null
    isActive?: BoolFilter<"RiskSettings"> | boolean
    positionSizingMethod?: StringFilter<"RiskSettings"> | string
    riskPercentage?: FloatFilter<"RiskSettings"> | number
    maxPositionSize?: FloatFilter<"RiskSettings"> | number
    kellyFraction?: FloatNullableFilter<"RiskSettings"> | number | null
    winRate?: FloatNullableFilter<"RiskSettings"> | number | null
    customSizingParams?: JsonNullableFilter<"RiskSettings">
    stopLossType?: StringFilter<"RiskSettings"> | string
    stopLossValue?: FloatFilter<"RiskSettings"> | number
    trailingCallback?: FloatNullableFilter<"RiskSettings"> | number | null
    trailingStep?: FloatNullableFilter<"RiskSettings"> | number | null
    timeLimit?: IntNullableFilter<"RiskSettings"> | number | null
    stopLossLevels?: JsonNullableFilter<"RiskSettings">
    takeProfitType?: StringFilter<"RiskSettings"> | string
    takeProfitValue?: FloatFilter<"RiskSettings"> | number
    trailingActivation?: FloatNullableFilter<"RiskSettings"> | number | null
    takeProfitLevels?: JsonNullableFilter<"RiskSettings">
    maxRiskPerTrade?: FloatFilter<"RiskSettings"> | number
    maxRiskPerSymbol?: FloatFilter<"RiskSettings"> | number
    maxRiskPerDirection?: FloatFilter<"RiskSettings"> | number
    maxTotalRisk?: FloatFilter<"RiskSettings"> | number
    maxDrawdown?: FloatFilter<"RiskSettings"> | number
    maxPositions?: IntFilter<"RiskSettings"> | number
    maxDailyLoss?: FloatFilter<"RiskSettings"> | number
    cooldownPeriod?: IntFilter<"RiskSettings"> | number
    volatilityLookback?: IntFilter<"RiskSettings"> | number
    circuitBreakerEnabled?: BoolFilter<"RiskSettings"> | boolean
    maxDailyLossBreaker?: FloatFilter<"RiskSettings"> | number
    maxDrawdownBreaker?: FloatFilter<"RiskSettings"> | number
    volatilityMultiplier?: FloatFilter<"RiskSettings"> | number
    consecutiveLossesBreaker?: IntFilter<"RiskSettings"> | number
    tradingPause?: IntFilter<"RiskSettings"> | number
    marketWideEnabled?: BoolFilter<"RiskSettings"> | boolean
    enableManualOverride?: BoolFilter<"RiskSettings"> | boolean
    createdAt?: DateTimeFilter<"RiskSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RiskSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
  }

  export type RiskSettingsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    positionSizingMethod?: SortOrder
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrderInput | SortOrder
    winRate?: SortOrderInput | SortOrder
    customSizingParams?: SortOrderInput | SortOrder
    stopLossType?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrderInput | SortOrder
    trailingStep?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    stopLossLevels?: SortOrderInput | SortOrder
    takeProfitType?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrderInput | SortOrder
    takeProfitLevels?: SortOrderInput | SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    circuitBreakerEnabled?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
    marketWideEnabled?: SortOrder
    enableManualOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bot?: BotOrderByWithRelationInput
  }

  export type RiskSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskSettingsWhereInput | RiskSettingsWhereInput[]
    OR?: RiskSettingsWhereInput[]
    NOT?: RiskSettingsWhereInput | RiskSettingsWhereInput[]
    name?: StringFilter<"RiskSettings"> | string
    description?: StringNullableFilter<"RiskSettings"> | string | null
    userId?: StringFilter<"RiskSettings"> | string
    botId?: StringNullableFilter<"RiskSettings"> | string | null
    isActive?: BoolFilter<"RiskSettings"> | boolean
    positionSizingMethod?: StringFilter<"RiskSettings"> | string
    riskPercentage?: FloatFilter<"RiskSettings"> | number
    maxPositionSize?: FloatFilter<"RiskSettings"> | number
    kellyFraction?: FloatNullableFilter<"RiskSettings"> | number | null
    winRate?: FloatNullableFilter<"RiskSettings"> | number | null
    customSizingParams?: JsonNullableFilter<"RiskSettings">
    stopLossType?: StringFilter<"RiskSettings"> | string
    stopLossValue?: FloatFilter<"RiskSettings"> | number
    trailingCallback?: FloatNullableFilter<"RiskSettings"> | number | null
    trailingStep?: FloatNullableFilter<"RiskSettings"> | number | null
    timeLimit?: IntNullableFilter<"RiskSettings"> | number | null
    stopLossLevels?: JsonNullableFilter<"RiskSettings">
    takeProfitType?: StringFilter<"RiskSettings"> | string
    takeProfitValue?: FloatFilter<"RiskSettings"> | number
    trailingActivation?: FloatNullableFilter<"RiskSettings"> | number | null
    takeProfitLevels?: JsonNullableFilter<"RiskSettings">
    maxRiskPerTrade?: FloatFilter<"RiskSettings"> | number
    maxRiskPerSymbol?: FloatFilter<"RiskSettings"> | number
    maxRiskPerDirection?: FloatFilter<"RiskSettings"> | number
    maxTotalRisk?: FloatFilter<"RiskSettings"> | number
    maxDrawdown?: FloatFilter<"RiskSettings"> | number
    maxPositions?: IntFilter<"RiskSettings"> | number
    maxDailyLoss?: FloatFilter<"RiskSettings"> | number
    cooldownPeriod?: IntFilter<"RiskSettings"> | number
    volatilityLookback?: IntFilter<"RiskSettings"> | number
    circuitBreakerEnabled?: BoolFilter<"RiskSettings"> | boolean
    maxDailyLossBreaker?: FloatFilter<"RiskSettings"> | number
    maxDrawdownBreaker?: FloatFilter<"RiskSettings"> | number
    volatilityMultiplier?: FloatFilter<"RiskSettings"> | number
    consecutiveLossesBreaker?: IntFilter<"RiskSettings"> | number
    tradingPause?: IntFilter<"RiskSettings"> | number
    marketWideEnabled?: BoolFilter<"RiskSettings"> | boolean
    enableManualOverride?: BoolFilter<"RiskSettings"> | boolean
    createdAt?: DateTimeFilter<"RiskSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RiskSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
  }, "id">

  export type RiskSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    positionSizingMethod?: SortOrder
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrderInput | SortOrder
    winRate?: SortOrderInput | SortOrder
    customSizingParams?: SortOrderInput | SortOrder
    stopLossType?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrderInput | SortOrder
    trailingStep?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    stopLossLevels?: SortOrderInput | SortOrder
    takeProfitType?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrderInput | SortOrder
    takeProfitLevels?: SortOrderInput | SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    circuitBreakerEnabled?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
    marketWideEnabled?: SortOrder
    enableManualOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskSettingsCountOrderByAggregateInput
    _avg?: RiskSettingsAvgOrderByAggregateInput
    _max?: RiskSettingsMaxOrderByAggregateInput
    _min?: RiskSettingsMinOrderByAggregateInput
    _sum?: RiskSettingsSumOrderByAggregateInput
  }

  export type RiskSettingsScalarWhereWithAggregatesInput = {
    AND?: RiskSettingsScalarWhereWithAggregatesInput | RiskSettingsScalarWhereWithAggregatesInput[]
    OR?: RiskSettingsScalarWhereWithAggregatesInput[]
    NOT?: RiskSettingsScalarWhereWithAggregatesInput | RiskSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskSettings"> | string
    name?: StringWithAggregatesFilter<"RiskSettings"> | string
    description?: StringNullableWithAggregatesFilter<"RiskSettings"> | string | null
    userId?: StringWithAggregatesFilter<"RiskSettings"> | string
    botId?: StringNullableWithAggregatesFilter<"RiskSettings"> | string | null
    isActive?: BoolWithAggregatesFilter<"RiskSettings"> | boolean
    positionSizingMethod?: StringWithAggregatesFilter<"RiskSettings"> | string
    riskPercentage?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxPositionSize?: FloatWithAggregatesFilter<"RiskSettings"> | number
    kellyFraction?: FloatNullableWithAggregatesFilter<"RiskSettings"> | number | null
    winRate?: FloatNullableWithAggregatesFilter<"RiskSettings"> | number | null
    customSizingParams?: JsonNullableWithAggregatesFilter<"RiskSettings">
    stopLossType?: StringWithAggregatesFilter<"RiskSettings"> | string
    stopLossValue?: FloatWithAggregatesFilter<"RiskSettings"> | number
    trailingCallback?: FloatNullableWithAggregatesFilter<"RiskSettings"> | number | null
    trailingStep?: FloatNullableWithAggregatesFilter<"RiskSettings"> | number | null
    timeLimit?: IntNullableWithAggregatesFilter<"RiskSettings"> | number | null
    stopLossLevels?: JsonNullableWithAggregatesFilter<"RiskSettings">
    takeProfitType?: StringWithAggregatesFilter<"RiskSettings"> | string
    takeProfitValue?: FloatWithAggregatesFilter<"RiskSettings"> | number
    trailingActivation?: FloatNullableWithAggregatesFilter<"RiskSettings"> | number | null
    takeProfitLevels?: JsonNullableWithAggregatesFilter<"RiskSettings">
    maxRiskPerTrade?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxRiskPerSymbol?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxRiskPerDirection?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxTotalRisk?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxDrawdown?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxPositions?: IntWithAggregatesFilter<"RiskSettings"> | number
    maxDailyLoss?: FloatWithAggregatesFilter<"RiskSettings"> | number
    cooldownPeriod?: IntWithAggregatesFilter<"RiskSettings"> | number
    volatilityLookback?: IntWithAggregatesFilter<"RiskSettings"> | number
    circuitBreakerEnabled?: BoolWithAggregatesFilter<"RiskSettings"> | boolean
    maxDailyLossBreaker?: FloatWithAggregatesFilter<"RiskSettings"> | number
    maxDrawdownBreaker?: FloatWithAggregatesFilter<"RiskSettings"> | number
    volatilityMultiplier?: FloatWithAggregatesFilter<"RiskSettings"> | number
    consecutiveLossesBreaker?: IntWithAggregatesFilter<"RiskSettings"> | number
    tradingPause?: IntWithAggregatesFilter<"RiskSettings"> | number
    marketWideEnabled?: BoolWithAggregatesFilter<"RiskSettings"> | boolean
    enableManualOverride?: BoolWithAggregatesFilter<"RiskSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskSettings"> | Date | string
  }

  export type RiskAlertWhereInput = {
    AND?: RiskAlertWhereInput | RiskAlertWhereInput[]
    OR?: RiskAlertWhereInput[]
    NOT?: RiskAlertWhereInput | RiskAlertWhereInput[]
    id?: StringFilter<"RiskAlert"> | string
    userId?: StringFilter<"RiskAlert"> | string
    type?: StringFilter<"RiskAlert"> | string
    level?: StringFilter<"RiskAlert"> | string
    message?: StringFilter<"RiskAlert"> | string
    details?: JsonFilter<"RiskAlert">
    timestamp?: DateTimeFilter<"RiskAlert"> | Date | string
    acknowledged?: BoolFilter<"RiskAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"RiskAlert"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RiskAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RiskAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskAlertWhereInput | RiskAlertWhereInput[]
    OR?: RiskAlertWhereInput[]
    NOT?: RiskAlertWhereInput | RiskAlertWhereInput[]
    userId?: StringFilter<"RiskAlert"> | string
    type?: StringFilter<"RiskAlert"> | string
    level?: StringFilter<"RiskAlert"> | string
    message?: StringFilter<"RiskAlert"> | string
    details?: JsonFilter<"RiskAlert">
    timestamp?: DateTimeFilter<"RiskAlert"> | Date | string
    acknowledged?: BoolFilter<"RiskAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"RiskAlert"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RiskAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: RiskAlertCountOrderByAggregateInput
    _max?: RiskAlertMaxOrderByAggregateInput
    _min?: RiskAlertMinOrderByAggregateInput
  }

  export type RiskAlertScalarWhereWithAggregatesInput = {
    AND?: RiskAlertScalarWhereWithAggregatesInput | RiskAlertScalarWhereWithAggregatesInput[]
    OR?: RiskAlertScalarWhereWithAggregatesInput[]
    NOT?: RiskAlertScalarWhereWithAggregatesInput | RiskAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAlert"> | string
    userId?: StringWithAggregatesFilter<"RiskAlert"> | string
    type?: StringWithAggregatesFilter<"RiskAlert"> | string
    level?: StringWithAggregatesFilter<"RiskAlert"> | string
    message?: StringWithAggregatesFilter<"RiskAlert"> | string
    details?: JsonWithAggregatesFilter<"RiskAlert">
    timestamp?: DateTimeWithAggregatesFilter<"RiskAlert"> | Date | string
    acknowledged?: BoolWithAggregatesFilter<"RiskAlert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"RiskAlert"> | Date | string | null
  }

  export type CircuitBreakerWhereInput = {
    AND?: CircuitBreakerWhereInput | CircuitBreakerWhereInput[]
    OR?: CircuitBreakerWhereInput[]
    NOT?: CircuitBreakerWhereInput | CircuitBreakerWhereInput[]
    id?: StringFilter<"CircuitBreaker"> | string
    name?: StringFilter<"CircuitBreaker"> | string
    description?: StringNullableFilter<"CircuitBreaker"> | string | null
    userId?: StringFilter<"CircuitBreaker"> | string
    botId?: StringNullableFilter<"CircuitBreaker"> | string | null
    type?: StringFilter<"CircuitBreaker"> | string
    isGlobal?: BoolFilter<"CircuitBreaker"> | boolean
    isActive?: BoolFilter<"CircuitBreaker"> | boolean
    threshold?: FloatFilter<"CircuitBreaker"> | number
    recoveryThreshold?: FloatNullableFilter<"CircuitBreaker"> | number | null
    cooldownMinutes?: IntFilter<"CircuitBreaker"> | number
    action?: StringFilter<"CircuitBreaker"> | string
    lastTriggered?: DateTimeNullableFilter<"CircuitBreaker"> | Date | string | null
    status?: StringFilter<"CircuitBreaker"> | string
    metadata?: JsonNullableFilter<"CircuitBreaker">
    createdAt?: DateTimeFilter<"CircuitBreaker"> | Date | string
    updatedAt?: DateTimeFilter<"CircuitBreaker"> | Date | string
  }

  export type CircuitBreakerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    type?: SortOrder
    isGlobal?: SortOrder
    isActive?: SortOrder
    threshold?: SortOrder
    recoveryThreshold?: SortOrderInput | SortOrder
    cooldownMinutes?: SortOrder
    action?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CircuitBreakerWhereInput | CircuitBreakerWhereInput[]
    OR?: CircuitBreakerWhereInput[]
    NOT?: CircuitBreakerWhereInput | CircuitBreakerWhereInput[]
    name?: StringFilter<"CircuitBreaker"> | string
    description?: StringNullableFilter<"CircuitBreaker"> | string | null
    userId?: StringFilter<"CircuitBreaker"> | string
    botId?: StringNullableFilter<"CircuitBreaker"> | string | null
    type?: StringFilter<"CircuitBreaker"> | string
    isGlobal?: BoolFilter<"CircuitBreaker"> | boolean
    isActive?: BoolFilter<"CircuitBreaker"> | boolean
    threshold?: FloatFilter<"CircuitBreaker"> | number
    recoveryThreshold?: FloatNullableFilter<"CircuitBreaker"> | number | null
    cooldownMinutes?: IntFilter<"CircuitBreaker"> | number
    action?: StringFilter<"CircuitBreaker"> | string
    lastTriggered?: DateTimeNullableFilter<"CircuitBreaker"> | Date | string | null
    status?: StringFilter<"CircuitBreaker"> | string
    metadata?: JsonNullableFilter<"CircuitBreaker">
    createdAt?: DateTimeFilter<"CircuitBreaker"> | Date | string
    updatedAt?: DateTimeFilter<"CircuitBreaker"> | Date | string
  }, "id">

  export type CircuitBreakerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    botId?: SortOrderInput | SortOrder
    type?: SortOrder
    isGlobal?: SortOrder
    isActive?: SortOrder
    threshold?: SortOrder
    recoveryThreshold?: SortOrderInput | SortOrder
    cooldownMinutes?: SortOrder
    action?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CircuitBreakerCountOrderByAggregateInput
    _avg?: CircuitBreakerAvgOrderByAggregateInput
    _max?: CircuitBreakerMaxOrderByAggregateInput
    _min?: CircuitBreakerMinOrderByAggregateInput
    _sum?: CircuitBreakerSumOrderByAggregateInput
  }

  export type CircuitBreakerScalarWhereWithAggregatesInput = {
    AND?: CircuitBreakerScalarWhereWithAggregatesInput | CircuitBreakerScalarWhereWithAggregatesInput[]
    OR?: CircuitBreakerScalarWhereWithAggregatesInput[]
    NOT?: CircuitBreakerScalarWhereWithAggregatesInput | CircuitBreakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    name?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    description?: StringNullableWithAggregatesFilter<"CircuitBreaker"> | string | null
    userId?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    botId?: StringNullableWithAggregatesFilter<"CircuitBreaker"> | string | null
    type?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    isGlobal?: BoolWithAggregatesFilter<"CircuitBreaker"> | boolean
    isActive?: BoolWithAggregatesFilter<"CircuitBreaker"> | boolean
    threshold?: FloatWithAggregatesFilter<"CircuitBreaker"> | number
    recoveryThreshold?: FloatNullableWithAggregatesFilter<"CircuitBreaker"> | number | null
    cooldownMinutes?: IntWithAggregatesFilter<"CircuitBreaker"> | number
    action?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"CircuitBreaker"> | Date | string | null
    status?: StringWithAggregatesFilter<"CircuitBreaker"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CircuitBreaker">
    createdAt?: DateTimeWithAggregatesFilter<"CircuitBreaker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CircuitBreaker"> | Date | string
  }

  export type TradingStrategyWhereInput = {
    AND?: TradingStrategyWhereInput | TradingStrategyWhereInput[]
    OR?: TradingStrategyWhereInput[]
    NOT?: TradingStrategyWhereInput | TradingStrategyWhereInput[]
    id?: StringFilter<"TradingStrategy"> | string
    name?: StringFilter<"TradingStrategy"> | string
    description?: StringNullableFilter<"TradingStrategy"> | string | null
    type?: StringFilter<"TradingStrategy"> | string
    timeHorizon?: StringFilter<"TradingStrategy"> | string
    symbols?: StringNullableListFilter<"TradingStrategy">
    entryRules?: JsonFilter<"TradingStrategy">
    exitRules?: JsonFilter<"TradingStrategy">
    positionSizing?: JsonFilter<"TradingStrategy">
    riskManagement?: JsonFilter<"TradingStrategy">
    userId?: StringFilter<"TradingStrategy"> | string
    isPublic?: BoolFilter<"TradingStrategy"> | boolean
    isActive?: BoolFilter<"TradingStrategy"> | boolean
    metadata?: JsonNullableFilter<"TradingStrategy">
    createdAt?: DateTimeFilter<"TradingStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"TradingStrategy"> | Date | string
    executions?: StrategyExecutionListRelationFilter
    orders?: OrderListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }

  export type TradingStrategyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    timeHorizon?: SortOrder
    symbols?: SortOrder
    entryRules?: SortOrder
    exitRules?: SortOrder
    positionSizing?: SortOrder
    riskManagement?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    executions?: StrategyExecutionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    decisionLogs?: DecisionLogOrderByRelationAggregateInput
  }

  export type TradingStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradingStrategyWhereInput | TradingStrategyWhereInput[]
    OR?: TradingStrategyWhereInput[]
    NOT?: TradingStrategyWhereInput | TradingStrategyWhereInput[]
    name?: StringFilter<"TradingStrategy"> | string
    description?: StringNullableFilter<"TradingStrategy"> | string | null
    type?: StringFilter<"TradingStrategy"> | string
    timeHorizon?: StringFilter<"TradingStrategy"> | string
    symbols?: StringNullableListFilter<"TradingStrategy">
    entryRules?: JsonFilter<"TradingStrategy">
    exitRules?: JsonFilter<"TradingStrategy">
    positionSizing?: JsonFilter<"TradingStrategy">
    riskManagement?: JsonFilter<"TradingStrategy">
    userId?: StringFilter<"TradingStrategy"> | string
    isPublic?: BoolFilter<"TradingStrategy"> | boolean
    isActive?: BoolFilter<"TradingStrategy"> | boolean
    metadata?: JsonNullableFilter<"TradingStrategy">
    createdAt?: DateTimeFilter<"TradingStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"TradingStrategy"> | Date | string
    executions?: StrategyExecutionListRelationFilter
    orders?: OrderListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
  }, "id">

  export type TradingStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    timeHorizon?: SortOrder
    symbols?: SortOrder
    entryRules?: SortOrder
    exitRules?: SortOrder
    positionSizing?: SortOrder
    riskManagement?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradingStrategyCountOrderByAggregateInput
    _max?: TradingStrategyMaxOrderByAggregateInput
    _min?: TradingStrategyMinOrderByAggregateInput
  }

  export type TradingStrategyScalarWhereWithAggregatesInput = {
    AND?: TradingStrategyScalarWhereWithAggregatesInput | TradingStrategyScalarWhereWithAggregatesInput[]
    OR?: TradingStrategyScalarWhereWithAggregatesInput[]
    NOT?: TradingStrategyScalarWhereWithAggregatesInput | TradingStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradingStrategy"> | string
    name?: StringWithAggregatesFilter<"TradingStrategy"> | string
    description?: StringNullableWithAggregatesFilter<"TradingStrategy"> | string | null
    type?: StringWithAggregatesFilter<"TradingStrategy"> | string
    timeHorizon?: StringWithAggregatesFilter<"TradingStrategy"> | string
    symbols?: StringNullableListFilter<"TradingStrategy">
    entryRules?: JsonWithAggregatesFilter<"TradingStrategy">
    exitRules?: JsonWithAggregatesFilter<"TradingStrategy">
    positionSizing?: JsonWithAggregatesFilter<"TradingStrategy">
    riskManagement?: JsonWithAggregatesFilter<"TradingStrategy">
    userId?: StringWithAggregatesFilter<"TradingStrategy"> | string
    isPublic?: BoolWithAggregatesFilter<"TradingStrategy"> | boolean
    isActive?: BoolWithAggregatesFilter<"TradingStrategy"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"TradingStrategy">
    createdAt?: DateTimeWithAggregatesFilter<"TradingStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradingStrategy"> | Date | string
  }

  export type StrategyExecutionWhereInput = {
    AND?: StrategyExecutionWhereInput | StrategyExecutionWhereInput[]
    OR?: StrategyExecutionWhereInput[]
    NOT?: StrategyExecutionWhereInput | StrategyExecutionWhereInput[]
    id?: StringFilter<"StrategyExecution"> | string
    strategyId?: StringFilter<"StrategyExecution"> | string
    userId?: StringFilter<"StrategyExecution"> | string
    status?: StringFilter<"StrategyExecution"> | string
    startedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    stoppedAt?: DateTimeNullableFilter<"StrategyExecution"> | Date | string | null
    runningTimeMs?: IntNullableFilter<"StrategyExecution"> | number | null
    metadata?: JsonNullableFilter<"StrategyExecution">
    createdAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    strategy?: XOR<TradingStrategyScalarRelationFilter, TradingStrategyWhereInput>
    results?: StrategyExecutionResultListRelationFilter
  }

  export type StrategyExecutionOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    runningTimeMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    strategy?: TradingStrategyOrderByWithRelationInput
    results?: StrategyExecutionResultOrderByRelationAggregateInput
  }

  export type StrategyExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrategyExecutionWhereInput | StrategyExecutionWhereInput[]
    OR?: StrategyExecutionWhereInput[]
    NOT?: StrategyExecutionWhereInput | StrategyExecutionWhereInput[]
    strategyId?: StringFilter<"StrategyExecution"> | string
    userId?: StringFilter<"StrategyExecution"> | string
    status?: StringFilter<"StrategyExecution"> | string
    startedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    stoppedAt?: DateTimeNullableFilter<"StrategyExecution"> | Date | string | null
    runningTimeMs?: IntNullableFilter<"StrategyExecution"> | number | null
    metadata?: JsonNullableFilter<"StrategyExecution">
    createdAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    strategy?: XOR<TradingStrategyScalarRelationFilter, TradingStrategyWhereInput>
    results?: StrategyExecutionResultListRelationFilter
  }, "id">

  export type StrategyExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrderInput | SortOrder
    runningTimeMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StrategyExecutionCountOrderByAggregateInput
    _avg?: StrategyExecutionAvgOrderByAggregateInput
    _max?: StrategyExecutionMaxOrderByAggregateInput
    _min?: StrategyExecutionMinOrderByAggregateInput
    _sum?: StrategyExecutionSumOrderByAggregateInput
  }

  export type StrategyExecutionScalarWhereWithAggregatesInput = {
    AND?: StrategyExecutionScalarWhereWithAggregatesInput | StrategyExecutionScalarWhereWithAggregatesInput[]
    OR?: StrategyExecutionScalarWhereWithAggregatesInput[]
    NOT?: StrategyExecutionScalarWhereWithAggregatesInput | StrategyExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrategyExecution"> | string
    strategyId?: StringWithAggregatesFilter<"StrategyExecution"> | string
    userId?: StringWithAggregatesFilter<"StrategyExecution"> | string
    status?: StringWithAggregatesFilter<"StrategyExecution"> | string
    startedAt?: DateTimeWithAggregatesFilter<"StrategyExecution"> | Date | string
    stoppedAt?: DateTimeNullableWithAggregatesFilter<"StrategyExecution"> | Date | string | null
    runningTimeMs?: IntNullableWithAggregatesFilter<"StrategyExecution"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"StrategyExecution">
    createdAt?: DateTimeWithAggregatesFilter<"StrategyExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StrategyExecution"> | Date | string
  }

  export type StrategyExecutionResultWhereInput = {
    AND?: StrategyExecutionResultWhereInput | StrategyExecutionResultWhereInput[]
    OR?: StrategyExecutionResultWhereInput[]
    NOT?: StrategyExecutionResultWhereInput | StrategyExecutionResultWhereInput[]
    id?: StringFilter<"StrategyExecutionResult"> | string
    executionId?: StringFilter<"StrategyExecutionResult"> | string
    symbol?: StringFilter<"StrategyExecutionResult"> | string
    entryTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    entryPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    exitTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    exitPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    direction?: StringFilter<"StrategyExecutionResult"> | string
    quantity?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLoss?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLossPercentage?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    status?: StringFilter<"StrategyExecutionResult"> | string
    metadata?: JsonNullableFilter<"StrategyExecutionResult">
    createdAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
    execution?: XOR<StrategyExecutionScalarRelationFilter, StrategyExecutionWhereInput>
  }

  export type StrategyExecutionResultOrderByWithRelationInput = {
    id?: SortOrder
    executionId?: SortOrder
    symbol?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    entryPrice?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    exitPrice?: SortOrderInput | SortOrder
    direction?: SortOrder
    quantity?: SortOrderInput | SortOrder
    profitLoss?: SortOrderInput | SortOrder
    profitLossPercentage?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    execution?: StrategyExecutionOrderByWithRelationInput
  }

  export type StrategyExecutionResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrategyExecutionResultWhereInput | StrategyExecutionResultWhereInput[]
    OR?: StrategyExecutionResultWhereInput[]
    NOT?: StrategyExecutionResultWhereInput | StrategyExecutionResultWhereInput[]
    executionId?: StringFilter<"StrategyExecutionResult"> | string
    symbol?: StringFilter<"StrategyExecutionResult"> | string
    entryTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    entryPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    exitTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    exitPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    direction?: StringFilter<"StrategyExecutionResult"> | string
    quantity?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLoss?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLossPercentage?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    status?: StringFilter<"StrategyExecutionResult"> | string
    metadata?: JsonNullableFilter<"StrategyExecutionResult">
    createdAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
    execution?: XOR<StrategyExecutionScalarRelationFilter, StrategyExecutionWhereInput>
  }, "id">

  export type StrategyExecutionResultOrderByWithAggregationInput = {
    id?: SortOrder
    executionId?: SortOrder
    symbol?: SortOrder
    entryTime?: SortOrderInput | SortOrder
    entryPrice?: SortOrderInput | SortOrder
    exitTime?: SortOrderInput | SortOrder
    exitPrice?: SortOrderInput | SortOrder
    direction?: SortOrder
    quantity?: SortOrderInput | SortOrder
    profitLoss?: SortOrderInput | SortOrder
    profitLossPercentage?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StrategyExecutionResultCountOrderByAggregateInput
    _avg?: StrategyExecutionResultAvgOrderByAggregateInput
    _max?: StrategyExecutionResultMaxOrderByAggregateInput
    _min?: StrategyExecutionResultMinOrderByAggregateInput
    _sum?: StrategyExecutionResultSumOrderByAggregateInput
  }

  export type StrategyExecutionResultScalarWhereWithAggregatesInput = {
    AND?: StrategyExecutionResultScalarWhereWithAggregatesInput | StrategyExecutionResultScalarWhereWithAggregatesInput[]
    OR?: StrategyExecutionResultScalarWhereWithAggregatesInput[]
    NOT?: StrategyExecutionResultScalarWhereWithAggregatesInput | StrategyExecutionResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrategyExecutionResult"> | string
    executionId?: StringWithAggregatesFilter<"StrategyExecutionResult"> | string
    symbol?: StringWithAggregatesFilter<"StrategyExecutionResult"> | string
    entryTime?: DateTimeNullableWithAggregatesFilter<"StrategyExecutionResult"> | Date | string | null
    entryPrice?: FloatNullableWithAggregatesFilter<"StrategyExecutionResult"> | number | null
    exitTime?: DateTimeNullableWithAggregatesFilter<"StrategyExecutionResult"> | Date | string | null
    exitPrice?: FloatNullableWithAggregatesFilter<"StrategyExecutionResult"> | number | null
    direction?: StringWithAggregatesFilter<"StrategyExecutionResult"> | string
    quantity?: FloatNullableWithAggregatesFilter<"StrategyExecutionResult"> | number | null
    profitLoss?: FloatNullableWithAggregatesFilter<"StrategyExecutionResult"> | number | null
    profitLossPercentage?: FloatNullableWithAggregatesFilter<"StrategyExecutionResult"> | number | null
    status?: StringWithAggregatesFilter<"StrategyExecutionResult"> | string
    metadata?: JsonNullableWithAggregatesFilter<"StrategyExecutionResult">
    createdAt?: DateTimeWithAggregatesFilter<"StrategyExecutionResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StrategyExecutionResult"> | Date | string
  }

  export type MLModelWhereInput = {
    AND?: MLModelWhereInput | MLModelWhereInput[]
    OR?: MLModelWhereInput[]
    NOT?: MLModelWhereInput | MLModelWhereInput[]
    id?: StringFilter<"MLModel"> | string
    name?: StringFilter<"MLModel"> | string
    version?: StringFilter<"MLModel"> | string
    modelType?: StringFilter<"MLModel"> | string
    symbol?: StringNullableFilter<"MLModel"> | string | null
    timeframe?: StringNullableFilter<"MLModel"> | string | null
    description?: StringNullableFilter<"MLModel"> | string | null
    status?: StringFilter<"MLModel"> | string
    accuracy?: FloatNullableFilter<"MLModel"> | number | null
    precision?: FloatNullableFilter<"MLModel"> | number | null
    recall?: FloatNullableFilter<"MLModel"> | number | null
    f1Score?: FloatNullableFilter<"MLModel"> | number | null
    trainedAt?: DateTimeNullableFilter<"MLModel"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"MLModel"> | Date | string | null
    trainingId?: StringNullableFilter<"MLModel"> | string | null
    location?: StringNullableFilter<"MLModel"> | string | null
    params?: JsonNullableFilter<"MLModel">
    createdAt?: DateTimeFilter<"MLModel"> | Date | string
    updatedAt?: DateTimeFilter<"MLModel"> | Date | string
    predictions?: MLPredictionListRelationFilter
  }

  export type MLModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    modelType?: SortOrder
    symbol?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1Score?: SortOrderInput | SortOrder
    trainedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    trainingId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    predictions?: MLPredictionOrderByRelationAggregateInput
  }

  export type MLModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_version?: MLModelNameVersionCompoundUniqueInput
    AND?: MLModelWhereInput | MLModelWhereInput[]
    OR?: MLModelWhereInput[]
    NOT?: MLModelWhereInput | MLModelWhereInput[]
    name?: StringFilter<"MLModel"> | string
    version?: StringFilter<"MLModel"> | string
    modelType?: StringFilter<"MLModel"> | string
    symbol?: StringNullableFilter<"MLModel"> | string | null
    timeframe?: StringNullableFilter<"MLModel"> | string | null
    description?: StringNullableFilter<"MLModel"> | string | null
    status?: StringFilter<"MLModel"> | string
    accuracy?: FloatNullableFilter<"MLModel"> | number | null
    precision?: FloatNullableFilter<"MLModel"> | number | null
    recall?: FloatNullableFilter<"MLModel"> | number | null
    f1Score?: FloatNullableFilter<"MLModel"> | number | null
    trainedAt?: DateTimeNullableFilter<"MLModel"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"MLModel"> | Date | string | null
    trainingId?: StringNullableFilter<"MLModel"> | string | null
    location?: StringNullableFilter<"MLModel"> | string | null
    params?: JsonNullableFilter<"MLModel">
    createdAt?: DateTimeFilter<"MLModel"> | Date | string
    updatedAt?: DateTimeFilter<"MLModel"> | Date | string
    predictions?: MLPredictionListRelationFilter
  }, "id" | "name_version">

  export type MLModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    modelType?: SortOrder
    symbol?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    recall?: SortOrderInput | SortOrder
    f1Score?: SortOrderInput | SortOrder
    trainedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    trainingId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MLModelCountOrderByAggregateInput
    _avg?: MLModelAvgOrderByAggregateInput
    _max?: MLModelMaxOrderByAggregateInput
    _min?: MLModelMinOrderByAggregateInput
    _sum?: MLModelSumOrderByAggregateInput
  }

  export type MLModelScalarWhereWithAggregatesInput = {
    AND?: MLModelScalarWhereWithAggregatesInput | MLModelScalarWhereWithAggregatesInput[]
    OR?: MLModelScalarWhereWithAggregatesInput[]
    NOT?: MLModelScalarWhereWithAggregatesInput | MLModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MLModel"> | string
    name?: StringWithAggregatesFilter<"MLModel"> | string
    version?: StringWithAggregatesFilter<"MLModel"> | string
    modelType?: StringWithAggregatesFilter<"MLModel"> | string
    symbol?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    timeframe?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    description?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    status?: StringWithAggregatesFilter<"MLModel"> | string
    accuracy?: FloatNullableWithAggregatesFilter<"MLModel"> | number | null
    precision?: FloatNullableWithAggregatesFilter<"MLModel"> | number | null
    recall?: FloatNullableWithAggregatesFilter<"MLModel"> | number | null
    f1Score?: FloatNullableWithAggregatesFilter<"MLModel"> | number | null
    trainedAt?: DateTimeNullableWithAggregatesFilter<"MLModel"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"MLModel"> | Date | string | null
    trainingId?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    location?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    params?: JsonNullableWithAggregatesFilter<"MLModel">
    createdAt?: DateTimeWithAggregatesFilter<"MLModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MLModel"> | Date | string
  }

  export type MLPredictionWhereInput = {
    AND?: MLPredictionWhereInput | MLPredictionWhereInput[]
    OR?: MLPredictionWhereInput[]
    NOT?: MLPredictionWhereInput | MLPredictionWhereInput[]
    id?: StringFilter<"MLPrediction"> | string
    modelId?: StringFilter<"MLPrediction"> | string
    symbol?: StringFilter<"MLPrediction"> | string
    timeframe?: StringFilter<"MLPrediction"> | string
    predictionType?: StringFilter<"MLPrediction"> | string
    values?: FloatNullableListFilter<"MLPrediction">
    timestamps?: StringNullableListFilter<"MLPrediction">
    confidenceScores?: FloatNullableListFilter<"MLPrediction">
    metadata?: JsonNullableFilter<"MLPrediction">
    generatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MLPrediction"> | Date | string | null
    signalGenerated?: BoolFilter<"MLPrediction"> | boolean
    signalId?: StringNullableFilter<"MLPrediction"> | string | null
    createdAt?: DateTimeFilter<"MLPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
    model?: XOR<MLModelScalarRelationFilter, MLModelWhereInput>
  }

  export type MLPredictionOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    predictionType?: SortOrder
    values?: SortOrder
    timestamps?: SortOrder
    confidenceScores?: SortOrder
    metadata?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    signalGenerated?: SortOrder
    signalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: MLModelOrderByWithRelationInput
  }

  export type MLPredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MLPredictionWhereInput | MLPredictionWhereInput[]
    OR?: MLPredictionWhereInput[]
    NOT?: MLPredictionWhereInput | MLPredictionWhereInput[]
    modelId?: StringFilter<"MLPrediction"> | string
    symbol?: StringFilter<"MLPrediction"> | string
    timeframe?: StringFilter<"MLPrediction"> | string
    predictionType?: StringFilter<"MLPrediction"> | string
    values?: FloatNullableListFilter<"MLPrediction">
    timestamps?: StringNullableListFilter<"MLPrediction">
    confidenceScores?: FloatNullableListFilter<"MLPrediction">
    metadata?: JsonNullableFilter<"MLPrediction">
    generatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MLPrediction"> | Date | string | null
    signalGenerated?: BoolFilter<"MLPrediction"> | boolean
    signalId?: StringNullableFilter<"MLPrediction"> | string | null
    createdAt?: DateTimeFilter<"MLPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
    model?: XOR<MLModelScalarRelationFilter, MLModelWhereInput>
  }, "id">

  export type MLPredictionOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    predictionType?: SortOrder
    values?: SortOrder
    timestamps?: SortOrder
    confidenceScores?: SortOrder
    metadata?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    signalGenerated?: SortOrder
    signalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MLPredictionCountOrderByAggregateInput
    _avg?: MLPredictionAvgOrderByAggregateInput
    _max?: MLPredictionMaxOrderByAggregateInput
    _min?: MLPredictionMinOrderByAggregateInput
    _sum?: MLPredictionSumOrderByAggregateInput
  }

  export type MLPredictionScalarWhereWithAggregatesInput = {
    AND?: MLPredictionScalarWhereWithAggregatesInput | MLPredictionScalarWhereWithAggregatesInput[]
    OR?: MLPredictionScalarWhereWithAggregatesInput[]
    NOT?: MLPredictionScalarWhereWithAggregatesInput | MLPredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MLPrediction"> | string
    modelId?: StringWithAggregatesFilter<"MLPrediction"> | string
    symbol?: StringWithAggregatesFilter<"MLPrediction"> | string
    timeframe?: StringWithAggregatesFilter<"MLPrediction"> | string
    predictionType?: StringWithAggregatesFilter<"MLPrediction"> | string
    values?: FloatNullableListFilter<"MLPrediction">
    timestamps?: StringNullableListFilter<"MLPrediction">
    confidenceScores?: FloatNullableListFilter<"MLPrediction">
    metadata?: JsonNullableWithAggregatesFilter<"MLPrediction">
    generatedAt?: DateTimeWithAggregatesFilter<"MLPrediction"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"MLPrediction"> | Date | string | null
    signalGenerated?: BoolWithAggregatesFilter<"MLPrediction"> | boolean
    signalId?: StringNullableWithAggregatesFilter<"MLPrediction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MLPrediction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MLPrediction"> | Date | string
  }

  export type MLTrainingJobWhereInput = {
    AND?: MLTrainingJobWhereInput | MLTrainingJobWhereInput[]
    OR?: MLTrainingJobWhereInput[]
    NOT?: MLTrainingJobWhereInput | MLTrainingJobWhereInput[]
    id?: StringFilter<"MLTrainingJob"> | string
    userId?: StringFilter<"MLTrainingJob"> | string
    symbol?: StringFilter<"MLTrainingJob"> | string
    timeframe?: StringFilter<"MLTrainingJob"> | string
    modelType?: StringFilter<"MLTrainingJob"> | string
    status?: StringFilter<"MLTrainingJob"> | string
    progress?: FloatFilter<"MLTrainingJob"> | number
    startedAt?: DateTimeNullableFilter<"MLTrainingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"MLTrainingJob"> | Date | string | null
    resultModelId?: StringNullableFilter<"MLTrainingJob"> | string | null
    errorMessage?: StringNullableFilter<"MLTrainingJob"> | string | null
    params?: JsonNullableFilter<"MLTrainingJob">
    createdAt?: DateTimeFilter<"MLTrainingJob"> | Date | string
    updatedAt?: DateTimeFilter<"MLTrainingJob"> | Date | string
  }

  export type MLTrainingJobOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    modelType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    resultModelId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLTrainingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MLTrainingJobWhereInput | MLTrainingJobWhereInput[]
    OR?: MLTrainingJobWhereInput[]
    NOT?: MLTrainingJobWhereInput | MLTrainingJobWhereInput[]
    userId?: StringFilter<"MLTrainingJob"> | string
    symbol?: StringFilter<"MLTrainingJob"> | string
    timeframe?: StringFilter<"MLTrainingJob"> | string
    modelType?: StringFilter<"MLTrainingJob"> | string
    status?: StringFilter<"MLTrainingJob"> | string
    progress?: FloatFilter<"MLTrainingJob"> | number
    startedAt?: DateTimeNullableFilter<"MLTrainingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"MLTrainingJob"> | Date | string | null
    resultModelId?: StringNullableFilter<"MLTrainingJob"> | string | null
    errorMessage?: StringNullableFilter<"MLTrainingJob"> | string | null
    params?: JsonNullableFilter<"MLTrainingJob">
    createdAt?: DateTimeFilter<"MLTrainingJob"> | Date | string
    updatedAt?: DateTimeFilter<"MLTrainingJob"> | Date | string
  }, "id">

  export type MLTrainingJobOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    modelType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    resultModelId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MLTrainingJobCountOrderByAggregateInput
    _avg?: MLTrainingJobAvgOrderByAggregateInput
    _max?: MLTrainingJobMaxOrderByAggregateInput
    _min?: MLTrainingJobMinOrderByAggregateInput
    _sum?: MLTrainingJobSumOrderByAggregateInput
  }

  export type MLTrainingJobScalarWhereWithAggregatesInput = {
    AND?: MLTrainingJobScalarWhereWithAggregatesInput | MLTrainingJobScalarWhereWithAggregatesInput[]
    OR?: MLTrainingJobScalarWhereWithAggregatesInput[]
    NOT?: MLTrainingJobScalarWhereWithAggregatesInput | MLTrainingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    userId?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    symbol?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    timeframe?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    modelType?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    status?: StringWithAggregatesFilter<"MLTrainingJob"> | string
    progress?: FloatWithAggregatesFilter<"MLTrainingJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"MLTrainingJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"MLTrainingJob"> | Date | string | null
    resultModelId?: StringNullableWithAggregatesFilter<"MLTrainingJob"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"MLTrainingJob"> | string | null
    params?: JsonNullableWithAggregatesFilter<"MLTrainingJob">
    createdAt?: DateTimeWithAggregatesFilter<"MLTrainingJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MLTrainingJob"> | Date | string
  }

  export type BridgeConfigWhereInput = {
    AND?: BridgeConfigWhereInput | BridgeConfigWhereInput[]
    OR?: BridgeConfigWhereInput[]
    NOT?: BridgeConfigWhereInput | BridgeConfigWhereInput[]
    id?: StringFilter<"BridgeConfig"> | string
    userId?: StringNullableFilter<"BridgeConfig"> | string | null
    name?: StringFilter<"BridgeConfig"> | string
    description?: StringNullableFilter<"BridgeConfig"> | string | null
    isActive?: BoolFilter<"BridgeConfig"> | boolean
    mlModelId?: StringNullableFilter<"BridgeConfig"> | string | null
    autoGenerateSignals?: BoolFilter<"BridgeConfig"> | boolean
    confidenceThreshold?: FloatFilter<"BridgeConfig"> | number
    signalExpiryMinutes?: IntFilter<"BridgeConfig"> | number
    refreshIntervalMinutes?: IntFilter<"BridgeConfig"> | number
    symbols?: StringNullableListFilter<"BridgeConfig">
    timeframes?: StringNullableListFilter<"BridgeConfig">
    lastExecutedAt?: DateTimeNullableFilter<"BridgeConfig"> | Date | string | null
    metadata?: JsonNullableFilter<"BridgeConfig">
    createdAt?: DateTimeFilter<"BridgeConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BridgeConfig"> | Date | string
  }

  export type BridgeConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    mlModelId?: SortOrderInput | SortOrder
    autoGenerateSignals?: SortOrder
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
    symbols?: SortOrder
    timeframes?: SortOrder
    lastExecutedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BridgeConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: BridgeConfigUserIdNameCompoundUniqueInput
    AND?: BridgeConfigWhereInput | BridgeConfigWhereInput[]
    OR?: BridgeConfigWhereInput[]
    NOT?: BridgeConfigWhereInput | BridgeConfigWhereInput[]
    userId?: StringNullableFilter<"BridgeConfig"> | string | null
    name?: StringFilter<"BridgeConfig"> | string
    description?: StringNullableFilter<"BridgeConfig"> | string | null
    isActive?: BoolFilter<"BridgeConfig"> | boolean
    mlModelId?: StringNullableFilter<"BridgeConfig"> | string | null
    autoGenerateSignals?: BoolFilter<"BridgeConfig"> | boolean
    confidenceThreshold?: FloatFilter<"BridgeConfig"> | number
    signalExpiryMinutes?: IntFilter<"BridgeConfig"> | number
    refreshIntervalMinutes?: IntFilter<"BridgeConfig"> | number
    symbols?: StringNullableListFilter<"BridgeConfig">
    timeframes?: StringNullableListFilter<"BridgeConfig">
    lastExecutedAt?: DateTimeNullableFilter<"BridgeConfig"> | Date | string | null
    metadata?: JsonNullableFilter<"BridgeConfig">
    createdAt?: DateTimeFilter<"BridgeConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BridgeConfig"> | Date | string
  }, "id" | "userId_name">

  export type BridgeConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    mlModelId?: SortOrderInput | SortOrder
    autoGenerateSignals?: SortOrder
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
    symbols?: SortOrder
    timeframes?: SortOrder
    lastExecutedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BridgeConfigCountOrderByAggregateInput
    _avg?: BridgeConfigAvgOrderByAggregateInput
    _max?: BridgeConfigMaxOrderByAggregateInput
    _min?: BridgeConfigMinOrderByAggregateInput
    _sum?: BridgeConfigSumOrderByAggregateInput
  }

  export type BridgeConfigScalarWhereWithAggregatesInput = {
    AND?: BridgeConfigScalarWhereWithAggregatesInput | BridgeConfigScalarWhereWithAggregatesInput[]
    OR?: BridgeConfigScalarWhereWithAggregatesInput[]
    NOT?: BridgeConfigScalarWhereWithAggregatesInput | BridgeConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BridgeConfig"> | string
    userId?: StringNullableWithAggregatesFilter<"BridgeConfig"> | string | null
    name?: StringWithAggregatesFilter<"BridgeConfig"> | string
    description?: StringNullableWithAggregatesFilter<"BridgeConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"BridgeConfig"> | boolean
    mlModelId?: StringNullableWithAggregatesFilter<"BridgeConfig"> | string | null
    autoGenerateSignals?: BoolWithAggregatesFilter<"BridgeConfig"> | boolean
    confidenceThreshold?: FloatWithAggregatesFilter<"BridgeConfig"> | number
    signalExpiryMinutes?: IntWithAggregatesFilter<"BridgeConfig"> | number
    refreshIntervalMinutes?: IntWithAggregatesFilter<"BridgeConfig"> | number
    symbols?: StringNullableListFilter<"BridgeConfig">
    timeframes?: StringNullableListFilter<"BridgeConfig">
    lastExecutedAt?: DateTimeNullableWithAggregatesFilter<"BridgeConfig"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BridgeConfig">
    createdAt?: DateTimeWithAggregatesFilter<"BridgeConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BridgeConfig"> | Date | string
  }

  export type PerformanceTestWhereInput = {
    AND?: PerformanceTestWhereInput | PerformanceTestWhereInput[]
    OR?: PerformanceTestWhereInput[]
    NOT?: PerformanceTestWhereInput | PerformanceTestWhereInput[]
    id?: StringFilter<"PerformanceTest"> | string
    name?: StringFilter<"PerformanceTest"> | string
    description?: StringNullableFilter<"PerformanceTest"> | string | null
    testType?: StringFilter<"PerformanceTest"> | string
    duration?: IntFilter<"PerformanceTest"> | number
    concurrency?: IntFilter<"PerformanceTest"> | number
    rampUp?: IntNullableFilter<"PerformanceTest"> | number | null
    targetEndpoint?: StringNullableFilter<"PerformanceTest"> | string | null
    modelId?: StringNullableFilter<"PerformanceTest"> | string | null
    strategyId?: StringNullableFilter<"PerformanceTest"> | string | null
    symbol?: StringNullableFilter<"PerformanceTest"> | string | null
    timeframe?: StringNullableFilter<"PerformanceTest"> | string | null
    options?: JsonNullableFilter<"PerformanceTest">
    createdAt?: DateTimeFilter<"PerformanceTest"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceTest"> | Date | string
    results?: PerformanceTestResultListRelationFilter
  }

  export type PerformanceTestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    testType?: SortOrder
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrderInput | SortOrder
    targetEndpoint?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    results?: PerformanceTestResultOrderByRelationAggregateInput
  }

  export type PerformanceTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceTestWhereInput | PerformanceTestWhereInput[]
    OR?: PerformanceTestWhereInput[]
    NOT?: PerformanceTestWhereInput | PerformanceTestWhereInput[]
    name?: StringFilter<"PerformanceTest"> | string
    description?: StringNullableFilter<"PerformanceTest"> | string | null
    testType?: StringFilter<"PerformanceTest"> | string
    duration?: IntFilter<"PerformanceTest"> | number
    concurrency?: IntFilter<"PerformanceTest"> | number
    rampUp?: IntNullableFilter<"PerformanceTest"> | number | null
    targetEndpoint?: StringNullableFilter<"PerformanceTest"> | string | null
    modelId?: StringNullableFilter<"PerformanceTest"> | string | null
    strategyId?: StringNullableFilter<"PerformanceTest"> | string | null
    symbol?: StringNullableFilter<"PerformanceTest"> | string | null
    timeframe?: StringNullableFilter<"PerformanceTest"> | string | null
    options?: JsonNullableFilter<"PerformanceTest">
    createdAt?: DateTimeFilter<"PerformanceTest"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceTest"> | Date | string
    results?: PerformanceTestResultListRelationFilter
  }, "id">

  export type PerformanceTestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    testType?: SortOrder
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrderInput | SortOrder
    targetEndpoint?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceTestCountOrderByAggregateInput
    _avg?: PerformanceTestAvgOrderByAggregateInput
    _max?: PerformanceTestMaxOrderByAggregateInput
    _min?: PerformanceTestMinOrderByAggregateInput
    _sum?: PerformanceTestSumOrderByAggregateInput
  }

  export type PerformanceTestScalarWhereWithAggregatesInput = {
    AND?: PerformanceTestScalarWhereWithAggregatesInput | PerformanceTestScalarWhereWithAggregatesInput[]
    OR?: PerformanceTestScalarWhereWithAggregatesInput[]
    NOT?: PerformanceTestScalarWhereWithAggregatesInput | PerformanceTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceTest"> | string
    name?: StringWithAggregatesFilter<"PerformanceTest"> | string
    description?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    testType?: StringWithAggregatesFilter<"PerformanceTest"> | string
    duration?: IntWithAggregatesFilter<"PerformanceTest"> | number
    concurrency?: IntWithAggregatesFilter<"PerformanceTest"> | number
    rampUp?: IntNullableWithAggregatesFilter<"PerformanceTest"> | number | null
    targetEndpoint?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    modelId?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    strategyId?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    timeframe?: StringNullableWithAggregatesFilter<"PerformanceTest"> | string | null
    options?: JsonNullableWithAggregatesFilter<"PerformanceTest">
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceTest"> | Date | string
  }

  export type PerformanceTestResultWhereInput = {
    AND?: PerformanceTestResultWhereInput | PerformanceTestResultWhereInput[]
    OR?: PerformanceTestResultWhereInput[]
    NOT?: PerformanceTestResultWhereInput | PerformanceTestResultWhereInput[]
    id?: StringFilter<"PerformanceTestResult"> | string
    testId?: StringFilter<"PerformanceTestResult"> | string
    status?: StringFilter<"PerformanceTestResult"> | string
    startTime?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    endTime?: DateTimeNullableFilter<"PerformanceTestResult"> | Date | string | null
    duration?: IntNullableFilter<"PerformanceTestResult"> | number | null
    metrics?: JsonFilter<"PerformanceTestResult">
    errors?: JsonNullableFilter<"PerformanceTestResult">
    createdAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    test?: XOR<PerformanceTestScalarRelationFilter, PerformanceTestWhereInput>
    recommendations?: OptimizationRecommendationListRelationFilter
  }

  export type PerformanceTestResultOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metrics?: SortOrder
    errors?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    test?: PerformanceTestOrderByWithRelationInput
    recommendations?: OptimizationRecommendationOrderByRelationAggregateInput
  }

  export type PerformanceTestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceTestResultWhereInput | PerformanceTestResultWhereInput[]
    OR?: PerformanceTestResultWhereInput[]
    NOT?: PerformanceTestResultWhereInput | PerformanceTestResultWhereInput[]
    testId?: StringFilter<"PerformanceTestResult"> | string
    status?: StringFilter<"PerformanceTestResult"> | string
    startTime?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    endTime?: DateTimeNullableFilter<"PerformanceTestResult"> | Date | string | null
    duration?: IntNullableFilter<"PerformanceTestResult"> | number | null
    metrics?: JsonFilter<"PerformanceTestResult">
    errors?: JsonNullableFilter<"PerformanceTestResult">
    createdAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    test?: XOR<PerformanceTestScalarRelationFilter, PerformanceTestWhereInput>
    recommendations?: OptimizationRecommendationListRelationFilter
  }, "id">

  export type PerformanceTestResultOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metrics?: SortOrder
    errors?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceTestResultCountOrderByAggregateInput
    _avg?: PerformanceTestResultAvgOrderByAggregateInput
    _max?: PerformanceTestResultMaxOrderByAggregateInput
    _min?: PerformanceTestResultMinOrderByAggregateInput
    _sum?: PerformanceTestResultSumOrderByAggregateInput
  }

  export type PerformanceTestResultScalarWhereWithAggregatesInput = {
    AND?: PerformanceTestResultScalarWhereWithAggregatesInput | PerformanceTestResultScalarWhereWithAggregatesInput[]
    OR?: PerformanceTestResultScalarWhereWithAggregatesInput[]
    NOT?: PerformanceTestResultScalarWhereWithAggregatesInput | PerformanceTestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceTestResult"> | string
    testId?: StringWithAggregatesFilter<"PerformanceTestResult"> | string
    status?: StringWithAggregatesFilter<"PerformanceTestResult"> | string
    startTime?: DateTimeWithAggregatesFilter<"PerformanceTestResult"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"PerformanceTestResult"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"PerformanceTestResult"> | number | null
    metrics?: JsonWithAggregatesFilter<"PerformanceTestResult">
    errors?: JsonNullableWithAggregatesFilter<"PerformanceTestResult">
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceTestResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceTestResult"> | Date | string
  }

  export type OptimizationRecommendationWhereInput = {
    AND?: OptimizationRecommendationWhereInput | OptimizationRecommendationWhereInput[]
    OR?: OptimizationRecommendationWhereInput[]
    NOT?: OptimizationRecommendationWhereInput | OptimizationRecommendationWhereInput[]
    id?: StringFilter<"OptimizationRecommendation"> | string
    testResultId?: StringFilter<"OptimizationRecommendation"> | string
    category?: StringFilter<"OptimizationRecommendation"> | string
    impact?: StringFilter<"OptimizationRecommendation"> | string
    description?: StringFilter<"OptimizationRecommendation"> | string
    implementation?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    estimatedImprovement?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    createdAt?: DateTimeFilter<"OptimizationRecommendation"> | Date | string
    testResult?: XOR<PerformanceTestResultScalarRelationFilter, PerformanceTestResultWhereInput>
  }

  export type OptimizationRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    testResultId?: SortOrder
    category?: SortOrder
    impact?: SortOrder
    description?: SortOrder
    implementation?: SortOrderInput | SortOrder
    estimatedImprovement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    testResult?: PerformanceTestResultOrderByWithRelationInput
  }

  export type OptimizationRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OptimizationRecommendationWhereInput | OptimizationRecommendationWhereInput[]
    OR?: OptimizationRecommendationWhereInput[]
    NOT?: OptimizationRecommendationWhereInput | OptimizationRecommendationWhereInput[]
    testResultId?: StringFilter<"OptimizationRecommendation"> | string
    category?: StringFilter<"OptimizationRecommendation"> | string
    impact?: StringFilter<"OptimizationRecommendation"> | string
    description?: StringFilter<"OptimizationRecommendation"> | string
    implementation?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    estimatedImprovement?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    createdAt?: DateTimeFilter<"OptimizationRecommendation"> | Date | string
    testResult?: XOR<PerformanceTestResultScalarRelationFilter, PerformanceTestResultWhereInput>
  }, "id">

  export type OptimizationRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    testResultId?: SortOrder
    category?: SortOrder
    impact?: SortOrder
    description?: SortOrder
    implementation?: SortOrderInput | SortOrder
    estimatedImprovement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OptimizationRecommendationCountOrderByAggregateInput
    _max?: OptimizationRecommendationMaxOrderByAggregateInput
    _min?: OptimizationRecommendationMinOrderByAggregateInput
  }

  export type OptimizationRecommendationScalarWhereWithAggregatesInput = {
    AND?: OptimizationRecommendationScalarWhereWithAggregatesInput | OptimizationRecommendationScalarWhereWithAggregatesInput[]
    OR?: OptimizationRecommendationScalarWhereWithAggregatesInput[]
    NOT?: OptimizationRecommendationScalarWhereWithAggregatesInput | OptimizationRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptimizationRecommendation"> | string
    testResultId?: StringWithAggregatesFilter<"OptimizationRecommendation"> | string
    category?: StringWithAggregatesFilter<"OptimizationRecommendation"> | string
    impact?: StringWithAggregatesFilter<"OptimizationRecommendation"> | string
    description?: StringWithAggregatesFilter<"OptimizationRecommendation"> | string
    implementation?: StringNullableWithAggregatesFilter<"OptimizationRecommendation"> | string | null
    estimatedImprovement?: StringNullableWithAggregatesFilter<"OptimizationRecommendation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OptimizationRecommendation"> | Date | string
  }

  export type ABTestWhereInput = {
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    id?: StringFilter<"ABTest"> | string
    name?: StringFilter<"ABTest"> | string
    description?: StringNullableFilter<"ABTest"> | string | null
    variantA?: StringFilter<"ABTest"> | string
    variantB?: StringFilter<"ABTest"> | string
    type?: StringFilter<"ABTest"> | string
    metric?: StringFilter<"ABTest"> | string
    targetImprovement?: FloatFilter<"ABTest"> | number
    status?: StringFilter<"ABTest"> | string
    startDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    createdAt?: DateTimeFilter<"ABTest"> | Date | string
    updatedAt?: DateTimeFilter<"ABTest"> | Date | string
    results?: ABTestResultListRelationFilter
  }

  export type ABTestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    variantA?: SortOrder
    variantB?: SortOrder
    type?: SortOrder
    metric?: SortOrder
    targetImprovement?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    results?: ABTestResultOrderByRelationAggregateInput
  }

  export type ABTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    name?: StringFilter<"ABTest"> | string
    description?: StringNullableFilter<"ABTest"> | string | null
    variantA?: StringFilter<"ABTest"> | string
    variantB?: StringFilter<"ABTest"> | string
    type?: StringFilter<"ABTest"> | string
    metric?: StringFilter<"ABTest"> | string
    targetImprovement?: FloatFilter<"ABTest"> | number
    status?: StringFilter<"ABTest"> | string
    startDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    createdAt?: DateTimeFilter<"ABTest"> | Date | string
    updatedAt?: DateTimeFilter<"ABTest"> | Date | string
    results?: ABTestResultListRelationFilter
  }, "id">

  export type ABTestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    variantA?: SortOrder
    variantB?: SortOrder
    type?: SortOrder
    metric?: SortOrder
    targetImprovement?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ABTestCountOrderByAggregateInput
    _avg?: ABTestAvgOrderByAggregateInput
    _max?: ABTestMaxOrderByAggregateInput
    _min?: ABTestMinOrderByAggregateInput
    _sum?: ABTestSumOrderByAggregateInput
  }

  export type ABTestScalarWhereWithAggregatesInput = {
    AND?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    OR?: ABTestScalarWhereWithAggregatesInput[]
    NOT?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABTest"> | string
    name?: StringWithAggregatesFilter<"ABTest"> | string
    description?: StringNullableWithAggregatesFilter<"ABTest"> | string | null
    variantA?: StringWithAggregatesFilter<"ABTest"> | string
    variantB?: StringWithAggregatesFilter<"ABTest"> | string
    type?: StringWithAggregatesFilter<"ABTest"> | string
    metric?: StringWithAggregatesFilter<"ABTest"> | string
    targetImprovement?: FloatWithAggregatesFilter<"ABTest"> | number
    status?: StringWithAggregatesFilter<"ABTest"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ABTest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ABTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ABTest"> | Date | string
  }

  export type ABTestResultWhereInput = {
    AND?: ABTestResultWhereInput | ABTestResultWhereInput[]
    OR?: ABTestResultWhereInput[]
    NOT?: ABTestResultWhereInput | ABTestResultWhereInput[]
    id?: StringFilter<"ABTestResult"> | string
    testId?: StringFilter<"ABTestResult"> | string
    status?: StringFilter<"ABTestResult"> | string
    startDate?: DateTimeFilter<"ABTestResult"> | Date | string
    endDate?: DateTimeNullableFilter<"ABTestResult"> | Date | string | null
    variantAMetrics?: JsonFilter<"ABTestResult">
    variantBMetrics?: JsonFilter<"ABTestResult">
    winner?: StringNullableFilter<"ABTestResult"> | string | null
    improvement?: FloatNullableFilter<"ABTestResult"> | number | null
    confidenceLevel?: FloatNullableFilter<"ABTestResult"> | number | null
    notes?: StringNullableFilter<"ABTestResult"> | string | null
    createdAt?: DateTimeFilter<"ABTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"ABTestResult"> | Date | string
    test?: XOR<ABTestScalarRelationFilter, ABTestWhereInput>
  }

  export type ABTestResultOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    variantAMetrics?: SortOrder
    variantBMetrics?: SortOrder
    winner?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    test?: ABTestOrderByWithRelationInput
  }

  export type ABTestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABTestResultWhereInput | ABTestResultWhereInput[]
    OR?: ABTestResultWhereInput[]
    NOT?: ABTestResultWhereInput | ABTestResultWhereInput[]
    testId?: StringFilter<"ABTestResult"> | string
    status?: StringFilter<"ABTestResult"> | string
    startDate?: DateTimeFilter<"ABTestResult"> | Date | string
    endDate?: DateTimeNullableFilter<"ABTestResult"> | Date | string | null
    variantAMetrics?: JsonFilter<"ABTestResult">
    variantBMetrics?: JsonFilter<"ABTestResult">
    winner?: StringNullableFilter<"ABTestResult"> | string | null
    improvement?: FloatNullableFilter<"ABTestResult"> | number | null
    confidenceLevel?: FloatNullableFilter<"ABTestResult"> | number | null
    notes?: StringNullableFilter<"ABTestResult"> | string | null
    createdAt?: DateTimeFilter<"ABTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"ABTestResult"> | Date | string
    test?: XOR<ABTestScalarRelationFilter, ABTestWhereInput>
  }, "id">

  export type ABTestResultOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    variantAMetrics?: SortOrder
    variantBMetrics?: SortOrder
    winner?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ABTestResultCountOrderByAggregateInput
    _avg?: ABTestResultAvgOrderByAggregateInput
    _max?: ABTestResultMaxOrderByAggregateInput
    _min?: ABTestResultMinOrderByAggregateInput
    _sum?: ABTestResultSumOrderByAggregateInput
  }

  export type ABTestResultScalarWhereWithAggregatesInput = {
    AND?: ABTestResultScalarWhereWithAggregatesInput | ABTestResultScalarWhereWithAggregatesInput[]
    OR?: ABTestResultScalarWhereWithAggregatesInput[]
    NOT?: ABTestResultScalarWhereWithAggregatesInput | ABTestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABTestResult"> | string
    testId?: StringWithAggregatesFilter<"ABTestResult"> | string
    status?: StringWithAggregatesFilter<"ABTestResult"> | string
    startDate?: DateTimeWithAggregatesFilter<"ABTestResult"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ABTestResult"> | Date | string | null
    variantAMetrics?: JsonWithAggregatesFilter<"ABTestResult">
    variantBMetrics?: JsonWithAggregatesFilter<"ABTestResult">
    winner?: StringNullableWithAggregatesFilter<"ABTestResult"> | string | null
    improvement?: FloatNullableWithAggregatesFilter<"ABTestResult"> | number | null
    confidenceLevel?: FloatNullableWithAggregatesFilter<"ABTestResult"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ABTestResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ABTestResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ABTestResult"> | Date | string
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: StringFilter<"PerformanceMetric"> | string
    timestamp?: DateTimeFilter<"PerformanceMetric"> | Date | string
    system?: StringFilter<"PerformanceMetric"> | string
    component?: StringFilter<"PerformanceMetric"> | string
    metric?: StringFilter<"PerformanceMetric"> | string
    value?: FloatFilter<"PerformanceMetric"> | number
    unit?: StringFilter<"PerformanceMetric"> | string
    tags?: JsonNullableFilter<"PerformanceMetric">
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    system?: SortOrder
    component?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    tags?: SortOrderInput | SortOrder
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    timestamp?: DateTimeFilter<"PerformanceMetric"> | Date | string
    system?: StringFilter<"PerformanceMetric"> | string
    component?: StringFilter<"PerformanceMetric"> | string
    metric?: StringFilter<"PerformanceMetric"> | string
    value?: FloatFilter<"PerformanceMetric"> | number
    unit?: StringFilter<"PerformanceMetric"> | string
    tags?: JsonNullableFilter<"PerformanceMetric">
  }, "id">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    system?: SortOrder
    component?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    tags?: SortOrderInput | SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    timestamp?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
    system?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    component?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    metric?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    value?: FloatWithAggregatesFilter<"PerformanceMetric"> | number
    unit?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    tags?: JsonNullableWithAggregatesFilter<"PerformanceMetric">
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    symbol?: StringFilter<"Order"> | string
    type?: StringFilter<"Order"> | string
    side?: StringFilter<"Order"> | string
    quantity?: FloatFilter<"Order"> | number
    price?: FloatNullableFilter<"Order"> | number | null
    stopPrice?: FloatNullableFilter<"Order"> | number | null
    avgFillPrice?: FloatNullableFilter<"Order"> | number | null
    filledQuantity?: FloatFilter<"Order"> | number
    remainingQuantity?: FloatFilter<"Order"> | number
    fee?: FloatNullableFilter<"Order"> | number | null
    feeCurrency?: StringNullableFilter<"Order"> | string | null
    clientOrderId?: StringNullableFilter<"Order"> | string | null
    exchangeOrderId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    exchangeId?: StringFilter<"Order"> | string
    submittedAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    errorCode?: StringNullableFilter<"Order"> | string | null
    errorMessage?: StringNullableFilter<"Order"> | string | null
    errorDetails?: JsonNullableFilter<"Order">
    raw?: JsonNullableFilter<"Order">
    userId?: StringFilter<"Order"> | string
    positionId?: StringNullableFilter<"Order"> | string | null
    strategyId?: StringNullableFilter<"Order"> | string | null
    botId?: StringNullableFilter<"Order"> | string | null
    signalId?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    strategy?: XOR<TradingStrategyNullableScalarRelationFilter, TradingStrategyWhereInput> | null
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    signal?: XOR<TradingSignalNullableScalarRelationFilter, TradingSignalWhereInput> | null
    auditTrails?: AuditTrailListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    side?: SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    stopPrice?: SortOrderInput | SortOrder
    avgFillPrice?: SortOrderInput | SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrderInput | SortOrder
    feeCurrency?: SortOrderInput | SortOrder
    clientOrderId?: SortOrderInput | SortOrder
    exchangeOrderId?: SortOrderInput | SortOrder
    source?: SortOrder
    exchangeId?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    userId?: SortOrder
    positionId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    signalId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    strategy?: TradingStrategyOrderByWithRelationInput
    bot?: BotOrderByWithRelationInput
    signal?: TradingSignalOrderByWithRelationInput
    auditTrails?: AuditTrailOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: StringFilter<"Order"> | string
    symbol?: StringFilter<"Order"> | string
    type?: StringFilter<"Order"> | string
    side?: StringFilter<"Order"> | string
    quantity?: FloatFilter<"Order"> | number
    price?: FloatNullableFilter<"Order"> | number | null
    stopPrice?: FloatNullableFilter<"Order"> | number | null
    avgFillPrice?: FloatNullableFilter<"Order"> | number | null
    filledQuantity?: FloatFilter<"Order"> | number
    remainingQuantity?: FloatFilter<"Order"> | number
    fee?: FloatNullableFilter<"Order"> | number | null
    feeCurrency?: StringNullableFilter<"Order"> | string | null
    clientOrderId?: StringNullableFilter<"Order"> | string | null
    exchangeOrderId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    exchangeId?: StringFilter<"Order"> | string
    submittedAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    errorCode?: StringNullableFilter<"Order"> | string | null
    errorMessage?: StringNullableFilter<"Order"> | string | null
    errorDetails?: JsonNullableFilter<"Order">
    raw?: JsonNullableFilter<"Order">
    userId?: StringFilter<"Order"> | string
    positionId?: StringNullableFilter<"Order"> | string | null
    strategyId?: StringNullableFilter<"Order"> | string | null
    botId?: StringNullableFilter<"Order"> | string | null
    signalId?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    strategy?: XOR<TradingStrategyNullableScalarRelationFilter, TradingStrategyWhereInput> | null
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    signal?: XOR<TradingSignalNullableScalarRelationFilter, TradingSignalWhereInput> | null
    auditTrails?: AuditTrailListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    side?: SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    stopPrice?: SortOrderInput | SortOrder
    avgFillPrice?: SortOrderInput | SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrderInput | SortOrder
    feeCurrency?: SortOrderInput | SortOrder
    clientOrderId?: SortOrderInput | SortOrder
    exchangeOrderId?: SortOrderInput | SortOrder
    source?: SortOrder
    exchangeId?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    userId?: SortOrder
    positionId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    signalId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    symbol?: StringWithAggregatesFilter<"Order"> | string
    type?: StringWithAggregatesFilter<"Order"> | string
    side?: StringWithAggregatesFilter<"Order"> | string
    quantity?: FloatWithAggregatesFilter<"Order"> | number
    price?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    stopPrice?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    avgFillPrice?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    filledQuantity?: FloatWithAggregatesFilter<"Order"> | number
    remainingQuantity?: FloatWithAggregatesFilter<"Order"> | number
    fee?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    feeCurrency?: StringNullableWithAggregatesFilter<"Order"> | string | null
    clientOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    exchangeOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    source?: StringWithAggregatesFilter<"Order"> | string
    exchangeId?: StringWithAggregatesFilter<"Order"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Order"> | string | null
    errorDetails?: JsonNullableWithAggregatesFilter<"Order">
    raw?: JsonNullableWithAggregatesFilter<"Order">
    userId?: StringWithAggregatesFilter<"Order"> | string
    positionId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    strategyId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    botId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    signalId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type DecisionLogWhereInput = {
    AND?: DecisionLogWhereInput | DecisionLogWhereInput[]
    OR?: DecisionLogWhereInput[]
    NOT?: DecisionLogWhereInput | DecisionLogWhereInput[]
    id?: StringFilter<"DecisionLog"> | string
    timestamp?: DateTimeFilter<"DecisionLog"> | Date | string
    source?: StringFilter<"DecisionLog"> | string
    actionType?: StringFilter<"DecisionLog"> | string
    decision?: StringFilter<"DecisionLog"> | string
    reasonDetails?: StringNullableFilter<"DecisionLog"> | string | null
    userId?: StringNullableFilter<"DecisionLog"> | string | null
    botId?: StringNullableFilter<"DecisionLog"> | string | null
    strategyId?: StringNullableFilter<"DecisionLog"> | string | null
    symbol?: StringNullableFilter<"DecisionLog"> | string | null
    orderId?: StringNullableFilter<"DecisionLog"> | string | null
    positionId?: StringNullableFilter<"DecisionLog"> | string | null
    importance?: StringFilter<"DecisionLog"> | string
    metadata?: JsonFilter<"DecisionLog">
    tags?: StringNullableListFilter<"DecisionLog">
    auditTrailId?: StringNullableFilter<"DecisionLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    strategy?: XOR<TradingStrategyNullableScalarRelationFilter, TradingStrategyWhereInput> | null
    auditTrail?: XOR<AuditTrailNullableScalarRelationFilter, AuditTrailWhereInput> | null
  }

  export type DecisionLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    actionType?: SortOrder
    decision?: SortOrder
    reasonDetails?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    importance?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    auditTrailId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    bot?: BotOrderByWithRelationInput
    strategy?: TradingStrategyOrderByWithRelationInput
    auditTrail?: AuditTrailOrderByWithRelationInput
  }

  export type DecisionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DecisionLogWhereInput | DecisionLogWhereInput[]
    OR?: DecisionLogWhereInput[]
    NOT?: DecisionLogWhereInput | DecisionLogWhereInput[]
    timestamp?: DateTimeFilter<"DecisionLog"> | Date | string
    source?: StringFilter<"DecisionLog"> | string
    actionType?: StringFilter<"DecisionLog"> | string
    decision?: StringFilter<"DecisionLog"> | string
    reasonDetails?: StringNullableFilter<"DecisionLog"> | string | null
    userId?: StringNullableFilter<"DecisionLog"> | string | null
    botId?: StringNullableFilter<"DecisionLog"> | string | null
    strategyId?: StringNullableFilter<"DecisionLog"> | string | null
    symbol?: StringNullableFilter<"DecisionLog"> | string | null
    orderId?: StringNullableFilter<"DecisionLog"> | string | null
    positionId?: StringNullableFilter<"DecisionLog"> | string | null
    importance?: StringFilter<"DecisionLog"> | string
    metadata?: JsonFilter<"DecisionLog">
    tags?: StringNullableListFilter<"DecisionLog">
    auditTrailId?: StringNullableFilter<"DecisionLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bot?: XOR<BotNullableScalarRelationFilter, BotWhereInput> | null
    strategy?: XOR<TradingStrategyNullableScalarRelationFilter, TradingStrategyWhereInput> | null
    auditTrail?: XOR<AuditTrailNullableScalarRelationFilter, AuditTrailWhereInput> | null
  }, "id">

  export type DecisionLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    actionType?: SortOrder
    decision?: SortOrder
    reasonDetails?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    strategyId?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    importance?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    auditTrailId?: SortOrderInput | SortOrder
    _count?: DecisionLogCountOrderByAggregateInput
    _max?: DecisionLogMaxOrderByAggregateInput
    _min?: DecisionLogMinOrderByAggregateInput
  }

  export type DecisionLogScalarWhereWithAggregatesInput = {
    AND?: DecisionLogScalarWhereWithAggregatesInput | DecisionLogScalarWhereWithAggregatesInput[]
    OR?: DecisionLogScalarWhereWithAggregatesInput[]
    NOT?: DecisionLogScalarWhereWithAggregatesInput | DecisionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DecisionLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DecisionLog"> | Date | string
    source?: StringWithAggregatesFilter<"DecisionLog"> | string
    actionType?: StringWithAggregatesFilter<"DecisionLog"> | string
    decision?: StringWithAggregatesFilter<"DecisionLog"> | string
    reasonDetails?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    botId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    strategyId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
    importance?: StringWithAggregatesFilter<"DecisionLog"> | string
    metadata?: JsonWithAggregatesFilter<"DecisionLog">
    tags?: StringNullableListFilter<"DecisionLog">
    auditTrailId?: StringNullableWithAggregatesFilter<"DecisionLog"> | string | null
  }

  export type AuditTrailWhereInput = {
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    trailType?: StringFilter<"AuditTrail"> | string
    entityId?: StringFilter<"AuditTrail"> | string
    entityType?: StringFilter<"AuditTrail"> | string
    startTime?: DateTimeFilter<"AuditTrail"> | Date | string
    endTime?: DateTimeNullableFilter<"AuditTrail"> | Date | string | null
    status?: StringFilter<"AuditTrail"> | string
    summary?: StringNullableFilter<"AuditTrail"> | string | null
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    orderId?: StringNullableFilter<"AuditTrail"> | string | null
    tags?: StringNullableListFilter<"AuditTrail">
    metadata?: JsonNullableFilter<"AuditTrail">
    events?: AuditEventListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type AuditTrailOrderByWithRelationInput = {
    id?: SortOrder
    trailType?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    events?: AuditEventOrderByRelationAggregateInput
    decisionLogs?: DecisionLogOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
  }

  export type AuditTrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    trailType?: StringFilter<"AuditTrail"> | string
    entityId?: StringFilter<"AuditTrail"> | string
    entityType?: StringFilter<"AuditTrail"> | string
    startTime?: DateTimeFilter<"AuditTrail"> | Date | string
    endTime?: DateTimeNullableFilter<"AuditTrail"> | Date | string | null
    status?: StringFilter<"AuditTrail"> | string
    summary?: StringNullableFilter<"AuditTrail"> | string | null
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    orderId?: StringNullableFilter<"AuditTrail"> | string | null
    tags?: StringNullableListFilter<"AuditTrail">
    metadata?: JsonNullableFilter<"AuditTrail">
    events?: AuditEventListRelationFilter
    decisionLogs?: DecisionLogListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type AuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    trailType?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: AuditTrailCountOrderByAggregateInput
    _max?: AuditTrailMaxOrderByAggregateInput
    _min?: AuditTrailMinOrderByAggregateInput
  }

  export type AuditTrailScalarWhereWithAggregatesInput = {
    AND?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    OR?: AuditTrailScalarWhereWithAggregatesInput[]
    NOT?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditTrail"> | string
    trailType?: StringWithAggregatesFilter<"AuditTrail"> | string
    entityId?: StringWithAggregatesFilter<"AuditTrail"> | string
    entityType?: StringWithAggregatesFilter<"AuditTrail"> | string
    startTime?: DateTimeWithAggregatesFilter<"AuditTrail"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"AuditTrail"> | Date | string | null
    status?: StringWithAggregatesFilter<"AuditTrail"> | string
    summary?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    tags?: StringNullableListFilter<"AuditTrail">
    metadata?: JsonNullableWithAggregatesFilter<"AuditTrail">
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    auditTrailId?: StringFilter<"AuditEvent"> | string
    timestamp?: DateTimeFilter<"AuditEvent"> | Date | string
    eventType?: StringFilter<"AuditEvent"> | string
    component?: StringFilter<"AuditEvent"> | string
    action?: StringFilter<"AuditEvent"> | string
    status?: StringFilter<"AuditEvent"> | string
    details?: JsonNullableFilter<"AuditEvent">
    dataBefore?: JsonNullableFilter<"AuditEvent">
    dataAfter?: JsonNullableFilter<"AuditEvent">
    metadata?: JsonNullableFilter<"AuditEvent">
    auditTrail?: XOR<AuditTrailScalarRelationFilter, AuditTrailWhereInput>
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    auditTrailId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    component?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    dataBefore?: SortOrderInput | SortOrder
    dataAfter?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    auditTrail?: AuditTrailOrderByWithRelationInput
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    auditTrailId?: StringFilter<"AuditEvent"> | string
    timestamp?: DateTimeFilter<"AuditEvent"> | Date | string
    eventType?: StringFilter<"AuditEvent"> | string
    component?: StringFilter<"AuditEvent"> | string
    action?: StringFilter<"AuditEvent"> | string
    status?: StringFilter<"AuditEvent"> | string
    details?: JsonNullableFilter<"AuditEvent">
    dataBefore?: JsonNullableFilter<"AuditEvent">
    dataAfter?: JsonNullableFilter<"AuditEvent">
    metadata?: JsonNullableFilter<"AuditEvent">
    auditTrail?: XOR<AuditTrailScalarRelationFilter, AuditTrailWhereInput>
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    auditTrailId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    component?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    dataBefore?: SortOrderInput | SortOrder
    dataAfter?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditEvent"> | string
    auditTrailId?: StringWithAggregatesFilter<"AuditEvent"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
    eventType?: StringWithAggregatesFilter<"AuditEvent"> | string
    component?: StringWithAggregatesFilter<"AuditEvent"> | string
    action?: StringWithAggregatesFilter<"AuditEvent"> | string
    status?: StringWithAggregatesFilter<"AuditEvent"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditEvent">
    dataBefore?: JsonNullableWithAggregatesFilter<"AuditEvent">
    dataAfter?: JsonNullableWithAggregatesFilter<"AuditEvent">
    metadata?: JsonNullableWithAggregatesFilter<"AuditEvent">
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyCreateInput = {
    id?: string
    key: string
    encryptedData: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    key: string
    encryptedData: string
    userId: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    key: string
    encryptedData: string
    userId: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TradeLogCreateInput = {
    id?: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
    user: UserCreateNestedOneWithoutTradeLogsInput
  }

  export type TradeLogUncheckedCreateInput = {
    id?: string
    userId: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
  }

  export type TradeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTradeLogsNestedInput
  }

  export type TradeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TradeLogCreateManyInput = {
    id?: string
    userId: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
  }

  export type TradeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TradeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BotCreateInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBotsInput
    positions?: PositionCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutBotInput
    orders?: OrderCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionUncheckedCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutBotInput
    orders?: OrderUncheckedCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBotsNestedInput
    positions?: PositionUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutBotNestedInput
    orders?: OrderUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUncheckedUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutBotNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type BotCreateManyInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPositionsInput
    bot?: BotCreateNestedOneWithoutPositionsInput
    orders?: OrderCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    userId: string
    botId?: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPositionsNestedInput
    bot?: BotUpdateOneWithoutPositionsNestedInput
    orders?: OrderUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    userId: string
    botId?: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateInput = {
    id?: string
    name: string
    value: number
    recordedAt?: Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUncheckedCreateInput = {
    id?: string
    name: string
    value: number
    recordedAt?: Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricCreateManyInput = {
    id?: string
    name: string
    value: number
    recordedAt?: Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TradingSignalCreateInput = {
    id?: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice?: number | null
    stopLoss?: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date | string
    expiresAt?: Date | string | null
    source: string
    metadata: JsonNullValueInput | InputJsonValue
    predictionValues: JsonNullValueInput | InputJsonValue
    validatedAt?: Date | string | null
    validationStatus?: boolean
    validationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutSignalInput
  }

  export type TradingSignalUncheckedCreateInput = {
    id?: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice?: number | null
    stopLoss?: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date | string
    expiresAt?: Date | string | null
    source: string
    metadata: JsonNullValueInput | InputJsonValue
    predictionValues: JsonNullValueInput | InputJsonValue
    validatedAt?: Date | string | null
    validationStatus?: boolean
    validationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutSignalInput
  }

  export type TradingSignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutSignalNestedInput
  }

  export type TradingSignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutSignalNestedInput
  }

  export type TradingSignalCreateManyInput = {
    id?: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice?: number | null
    stopLoss?: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date | string
    expiresAt?: Date | string | null
    source: string
    metadata: JsonNullValueInput | InputJsonValue
    predictionValues: JsonNullValueInput | InputJsonValue
    validatedAt?: Date | string | null
    validationStatus?: boolean
    validationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradingSignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradingSignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskSettingsCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRiskSettingsInput
    bot?: BotCreateNestedOneWithoutRiskSettingsInput
  }

  export type RiskSettingsUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    botId?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRiskSettingsNestedInput
    bot?: BotUpdateOneWithoutRiskSettingsNestedInput
  }

  export type RiskSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskSettingsCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    botId?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAlertCreateInput = {
    id?: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRiskAlertsInput
  }

  export type RiskAlertUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
  }

  export type RiskAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRiskAlertsNestedInput
  }

  export type RiskAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskAlertCreateManyInput = {
    id?: string
    userId: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
  }

  export type RiskAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CircuitBreakerCreateInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    botId?: string | null
    type: string
    isGlobal?: boolean
    isActive?: boolean
    threshold: number
    recoveryThreshold?: number | null
    cooldownMinutes?: number
    action: string
    lastTriggered?: Date | string | null
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    botId?: string | null
    type: string
    isGlobal?: boolean
    isActive?: boolean
    threshold: number
    recoveryThreshold?: number | null
    cooldownMinutes?: number
    action: string
    lastTriggered?: Date | string | null
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    threshold?: FloatFieldUpdateOperationsInput | number
    recoveryThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    threshold?: FloatFieldUpdateOperationsInput | number
    recoveryThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    botId?: string | null
    type: string
    isGlobal?: boolean
    isActive?: boolean
    threshold: number
    recoveryThreshold?: number | null
    cooldownMinutes?: number
    action: string
    lastTriggered?: Date | string | null
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircuitBreakerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    threshold?: FloatFieldUpdateOperationsInput | number
    recoveryThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircuitBreakerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    threshold?: FloatFieldUpdateOperationsInput | number
    recoveryThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradingStrategyCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionCreateNestedManyWithoutStrategyInput
    orders?: OrderCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionUncheckedCreateNestedManyWithoutStrategyInput
    orders?: OrderUncheckedCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUpdateManyWithoutStrategyNestedInput
    orders?: OrderUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutStrategyNestedInput
  }

  export type TradingStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUncheckedUpdateManyWithoutStrategyNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type TradingStrategyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradingStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradingStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionCreateInput = {
    id?: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: TradingStrategyCreateNestedOneWithoutExecutionsInput
    results?: StrategyExecutionResultCreateNestedManyWithoutExecutionInput
  }

  export type StrategyExecutionUncheckedCreateInput = {
    id?: string
    strategyId: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: StrategyExecutionResultUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type StrategyExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: TradingStrategyUpdateOneRequiredWithoutExecutionsNestedInput
    results?: StrategyExecutionResultUpdateManyWithoutExecutionNestedInput
  }

  export type StrategyExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: StrategyExecutionResultUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type StrategyExecutionCreateManyInput = {
    id?: string
    strategyId: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionResultCreateInput = {
    id?: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    execution: StrategyExecutionCreateNestedOneWithoutResultsInput
  }

  export type StrategyExecutionResultUncheckedCreateInput = {
    id?: string
    executionId: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    execution?: StrategyExecutionUpdateOneRequiredWithoutResultsNestedInput
  }

  export type StrategyExecutionResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionResultCreateManyInput = {
    id?: string
    executionId: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelCreateInput = {
    id?: string
    name: string
    version: string
    modelType: string
    symbol?: string | null
    timeframe?: string | null
    description?: string | null
    status?: string
    accuracy?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    trainedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    trainingId?: string | null
    location?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: MLPredictionCreateNestedManyWithoutModelInput
  }

  export type MLModelUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    modelType: string
    symbol?: string | null
    timeframe?: string | null
    description?: string | null
    status?: string
    accuracy?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    trainedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    trainingId?: string | null
    location?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: MLPredictionUncheckedCreateNestedManyWithoutModelInput
  }

  export type MLModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: MLPredictionUpdateManyWithoutModelNestedInput
  }

  export type MLModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: MLPredictionUncheckedUpdateManyWithoutModelNestedInput
  }

  export type MLModelCreateManyInput = {
    id?: string
    name: string
    version: string
    modelType: string
    symbol?: string | null
    timeframe?: string | null
    description?: string | null
    status?: string
    accuracy?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    trainedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    trainingId?: string | null
    location?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionCreateInput = {
    id?: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    model: MLModelCreateNestedOneWithoutPredictionsInput
  }

  export type MLPredictionUncheckedCreateInput = {
    id?: string
    modelId: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLPredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: MLModelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type MLPredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionCreateManyInput = {
    id?: string
    modelId: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLPredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLTrainingJobCreateInput = {
    id?: string
    userId: string
    symbol: string
    timeframe: string
    modelType: string
    status?: string
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    resultModelId?: string | null
    errorMessage?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLTrainingJobUncheckedCreateInput = {
    id?: string
    userId: string
    symbol: string
    timeframe: string
    modelType: string
    status?: string
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    resultModelId?: string | null
    errorMessage?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLTrainingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultModelId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLTrainingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultModelId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLTrainingJobCreateManyInput = {
    id?: string
    userId: string
    symbol: string
    timeframe: string
    modelType: string
    status?: string
    progress?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    resultModelId?: string | null
    errorMessage?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLTrainingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultModelId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLTrainingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultModelId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BridgeConfigCreateInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    isActive?: boolean
    mlModelId?: string | null
    autoGenerateSignals?: boolean
    confidenceThreshold?: number
    signalExpiryMinutes?: number
    refreshIntervalMinutes?: number
    symbols?: BridgeConfigCreatesymbolsInput | string[]
    timeframes?: BridgeConfigCreatetimeframesInput | string[]
    lastExecutedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BridgeConfigUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    isActive?: boolean
    mlModelId?: string | null
    autoGenerateSignals?: boolean
    confidenceThreshold?: number
    signalExpiryMinutes?: number
    refreshIntervalMinutes?: number
    symbols?: BridgeConfigCreatesymbolsInput | string[]
    timeframes?: BridgeConfigCreatetimeframesInput | string[]
    lastExecutedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BridgeConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mlModelId?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateSignals?: BoolFieldUpdateOperationsInput | boolean
    confidenceThreshold?: FloatFieldUpdateOperationsInput | number
    signalExpiryMinutes?: IntFieldUpdateOperationsInput | number
    refreshIntervalMinutes?: IntFieldUpdateOperationsInput | number
    symbols?: BridgeConfigUpdatesymbolsInput | string[]
    timeframes?: BridgeConfigUpdatetimeframesInput | string[]
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BridgeConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mlModelId?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateSignals?: BoolFieldUpdateOperationsInput | boolean
    confidenceThreshold?: FloatFieldUpdateOperationsInput | number
    signalExpiryMinutes?: IntFieldUpdateOperationsInput | number
    refreshIntervalMinutes?: IntFieldUpdateOperationsInput | number
    symbols?: BridgeConfigUpdatesymbolsInput | string[]
    timeframes?: BridgeConfigUpdatetimeframesInput | string[]
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BridgeConfigCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    isActive?: boolean
    mlModelId?: string | null
    autoGenerateSignals?: boolean
    confidenceThreshold?: number
    signalExpiryMinutes?: number
    refreshIntervalMinutes?: number
    symbols?: BridgeConfigCreatesymbolsInput | string[]
    timeframes?: BridgeConfigCreatetimeframesInput | string[]
    lastExecutedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BridgeConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mlModelId?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateSignals?: BoolFieldUpdateOperationsInput | boolean
    confidenceThreshold?: FloatFieldUpdateOperationsInput | number
    signalExpiryMinutes?: IntFieldUpdateOperationsInput | number
    refreshIntervalMinutes?: IntFieldUpdateOperationsInput | number
    symbols?: BridgeConfigUpdatesymbolsInput | string[]
    timeframes?: BridgeConfigUpdatetimeframesInput | string[]
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BridgeConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mlModelId?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateSignals?: BoolFieldUpdateOperationsInput | boolean
    confidenceThreshold?: FloatFieldUpdateOperationsInput | number
    signalExpiryMinutes?: IntFieldUpdateOperationsInput | number
    refreshIntervalMinutes?: IntFieldUpdateOperationsInput | number
    symbols?: BridgeConfigUpdatesymbolsInput | string[]
    timeframes?: BridgeConfigUpdatetimeframesInput | string[]
    lastExecutedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestCreateInput = {
    id?: string
    name: string
    description?: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp?: number | null
    targetEndpoint?: string | null
    modelId?: string | null
    strategyId?: string | null
    symbol?: string | null
    timeframe?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: PerformanceTestResultCreateNestedManyWithoutTestInput
  }

  export type PerformanceTestUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp?: number | null
    targetEndpoint?: string | null
    modelId?: string | null
    strategyId?: string | null
    symbol?: string | null
    timeframe?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: PerformanceTestResultUncheckedCreateNestedManyWithoutTestInput
  }

  export type PerformanceTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: PerformanceTestResultUpdateManyWithoutTestNestedInput
  }

  export type PerformanceTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: PerformanceTestResultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type PerformanceTestCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp?: number | null
    targetEndpoint?: string | null
    modelId?: string | null
    strategyId?: string | null
    symbol?: string | null
    timeframe?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestResultCreateInput = {
    id?: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    test: PerformanceTestCreateNestedOneWithoutResultsInput
    recommendations?: OptimizationRecommendationCreateNestedManyWithoutTestResultInput
  }

  export type PerformanceTestResultUncheckedCreateInput = {
    id?: string
    testId: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendations?: OptimizationRecommendationUncheckedCreateNestedManyWithoutTestResultInput
  }

  export type PerformanceTestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: PerformanceTestUpdateOneRequiredWithoutResultsNestedInput
    recommendations?: OptimizationRecommendationUpdateManyWithoutTestResultNestedInput
  }

  export type PerformanceTestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendations?: OptimizationRecommendationUncheckedUpdateManyWithoutTestResultNestedInput
  }

  export type PerformanceTestResultCreateManyInput = {
    id?: string
    testId: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationCreateInput = {
    id?: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
    testResult: PerformanceTestResultCreateNestedOneWithoutRecommendationsInput
  }

  export type OptimizationRecommendationUncheckedCreateInput = {
    id?: string
    testResultId: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
  }

  export type OptimizationRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testResult?: PerformanceTestResultUpdateOneRequiredWithoutRecommendationsNestedInput
  }

  export type OptimizationRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testResultId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationCreateManyInput = {
    id?: string
    testResultId: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
  }

  export type OptimizationRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testResultId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestCreateInput = {
    id?: string
    name: string
    description?: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ABTestResultCreateNestedManyWithoutTestInput
  }

  export type ABTestUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ABTestResultUncheckedCreateNestedManyWithoutTestInput
  }

  export type ABTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ABTestResultUpdateManyWithoutTestNestedInput
  }

  export type ABTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ABTestResultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type ABTestCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultCreateInput = {
    id?: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    test: ABTestCreateNestedOneWithoutResultsInput
  }

  export type ABTestResultUncheckedCreateInput = {
    id?: string
    testId: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: ABTestUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ABTestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultCreateManyInput = {
    id?: string
    testId: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricCreateInput = {
    id?: string
    timestamp?: Date | string
    system: string
    component: string
    metric: string
    value: number
    unit: string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    system: string
    component: string
    metric: string
    value: number
    unit: string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    system?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    system?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricCreateManyInput = {
    id?: string
    timestamp?: Date | string
    system: string
    component: string
    metric: string
    value: number
    unit: string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    system?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    system?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderCreateInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    position?: PositionCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    position?: PositionUpdateOneWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogCreateInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    user?: UserCreateNestedOneWithoutDecisionLogsInput
    bot?: BotCreateNestedOneWithoutDecisionLogsInput
    strategy?: TradingStrategyCreateNestedOneWithoutDecisionLogsInput
    auditTrail?: AuditTrailCreateNestedOneWithoutDecisionLogsInput
  }

  export type DecisionLogUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type DecisionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    user?: UserUpdateOneWithoutDecisionLogsNestedInput
    bot?: BotUpdateOneWithoutDecisionLogsNestedInput
    strategy?: TradingStrategyUpdateOneWithoutDecisionLogsNestedInput
    auditTrail?: AuditTrailUpdateOneWithoutDecisionLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogCreateManyInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type DecisionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
  }

  export type DecisionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailCreateInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventCreateNestedManyWithoutAuditTrailInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutAuditTrailInput
    order?: OrderCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    orderId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedCreateNestedManyWithoutAuditTrailInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutAuditTrailInput
  }

  export type AuditTrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUpdateManyWithoutAuditTrailNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutAuditTrailNestedInput
    order?: OrderUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedUpdateManyWithoutAuditTrailNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutAuditTrailNestedInput
  }

  export type AuditTrailCreateManyInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    orderId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditTrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditTrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventCreateInput = {
    id?: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    auditTrail: AuditTrailCreateNestedOneWithoutEventsInput
  }

  export type AuditEventUncheckedCreateInput = {
    id?: string
    auditTrailId: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    auditTrail?: AuditTrailUpdateOneRequiredWithoutEventsNestedInput
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditTrailId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventCreateManyInput = {
    id?: string
    auditTrailId: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditTrailId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type TradeLogListRelationFilter = {
    every?: TradeLogWhereInput
    some?: TradeLogWhereInput
    none?: TradeLogWhereInput
  }

  export type BotListRelationFilter = {
    every?: BotWhereInput
    some?: BotWhereInput
    none?: BotWhereInput
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type RiskSettingsListRelationFilter = {
    every?: RiskSettingsWhereInput
    some?: RiskSettingsWhereInput
    none?: RiskSettingsWhereInput
  }

  export type RiskAlertListRelationFilter = {
    every?: RiskAlertWhereInput
    some?: RiskAlertWhereInput
    none?: RiskAlertWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DecisionLogListRelationFilter = {
    every?: DecisionLogWhereInput
    some?: DecisionLogWhereInput
    none?: DecisionLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DecisionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiry?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    isValid?: SortOrder
    expiresAt?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rememberMe?: SortOrder
    metadata?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    isValid?: SortOrder
    expiresAt?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rememberMe?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    isValid?: SortOrder
    expiresAt?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rememberMe?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    encryptedData?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    scopes?: SortOrder
    expiry?: SortOrder
    environment?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    ipRestrictions?: SortOrder
    hashedSecret?: SortOrder
    usageCount?: SortOrder
    isDefault?: SortOrder
    rateLimits?: SortOrder
    metadata?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    encryptedData?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    scopes?: SortOrder
    expiry?: SortOrder
    environment?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    ipRestrictions?: SortOrder
    hashedSecret?: SortOrder
    usageCount?: SortOrder
    isDefault?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    encryptedData?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    scopes?: SortOrder
    expiry?: SortOrder
    environment?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    ipRestrictions?: SortOrder
    hashedSecret?: SortOrder
    usageCount?: SortOrder
    isDefault?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TradeLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrument?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TradeLogAvgOrderByAggregateInput = {
    amount?: SortOrder
    price?: SortOrder
  }

  export type TradeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrument?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TradeLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrument?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type TradeLogSumOrderByAggregateInput = {
    amount?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    strategy?: SortOrder
    timeframe?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    strategy?: SortOrder
    timeframe?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    strategy?: SortOrder
    timeframe?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BotNullableScalarRelationFilter = {
    is?: BotWhereInput | null
    isNot?: BotWhereInput | null
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    symbol?: SortOrder
    side?: SortOrder
    entryPrice?: SortOrder
    currentPrice?: SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrder
    stopLossPrice?: SortOrder
    status?: SortOrder
    pnl?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    metadata?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    entryPrice?: SortOrder
    currentPrice?: SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrder
    stopLossPrice?: SortOrder
    pnl?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    symbol?: SortOrder
    side?: SortOrder
    entryPrice?: SortOrder
    currentPrice?: SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrder
    stopLossPrice?: SortOrder
    status?: SortOrder
    pnl?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    symbol?: SortOrder
    side?: SortOrder
    entryPrice?: SortOrder
    currentPrice?: SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrder
    stopLossPrice?: SortOrder
    status?: SortOrder
    pnl?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    entryPrice?: SortOrder
    currentPrice?: SortOrder
    amount?: SortOrder
    leverage?: SortOrder
    takeProfitPrice?: SortOrder
    stopLossPrice?: SortOrder
    pnl?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    recordedAt?: SortOrder
    tags?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    recordedAt?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    recordedAt?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TradingSignalCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    strength?: SortOrder
    timeframe?: SortOrder
    price?: SortOrder
    targetPrice?: SortOrder
    stopLoss?: SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    predictionValues?: SortOrder
    validatedAt?: SortOrder
    validationStatus?: SortOrder
    validationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingSignalAvgOrderByAggregateInput = {
    price?: SortOrder
    targetPrice?: SortOrder
    stopLoss?: SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
  }

  export type TradingSignalMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    strength?: SortOrder
    timeframe?: SortOrder
    price?: SortOrder
    targetPrice?: SortOrder
    stopLoss?: SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    validatedAt?: SortOrder
    validationStatus?: SortOrder
    validationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingSignalMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    strength?: SortOrder
    timeframe?: SortOrder
    price?: SortOrder
    targetPrice?: SortOrder
    stopLoss?: SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    validatedAt?: SortOrder
    validationStatus?: SortOrder
    validationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingSignalSumOrderByAggregateInput = {
    price?: SortOrder
    targetPrice?: SortOrder
    stopLoss?: SortOrder
    confidenceScore?: SortOrder
    expectedReturn?: SortOrder
    expectedRisk?: SortOrder
    riskRewardRatio?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RiskSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    isActive?: SortOrder
    positionSizingMethod?: SortOrder
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrder
    winRate?: SortOrder
    customSizingParams?: SortOrder
    stopLossType?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrder
    trailingStep?: SortOrder
    timeLimit?: SortOrder
    stopLossLevels?: SortOrder
    takeProfitType?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrder
    takeProfitLevels?: SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    circuitBreakerEnabled?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
    marketWideEnabled?: SortOrder
    enableManualOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskSettingsAvgOrderByAggregateInput = {
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrder
    winRate?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrder
    trailingStep?: SortOrder
    timeLimit?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
  }

  export type RiskSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    isActive?: SortOrder
    positionSizingMethod?: SortOrder
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrder
    winRate?: SortOrder
    stopLossType?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrder
    trailingStep?: SortOrder
    timeLimit?: SortOrder
    takeProfitType?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    circuitBreakerEnabled?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
    marketWideEnabled?: SortOrder
    enableManualOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    isActive?: SortOrder
    positionSizingMethod?: SortOrder
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrder
    winRate?: SortOrder
    stopLossType?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrder
    trailingStep?: SortOrder
    timeLimit?: SortOrder
    takeProfitType?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    circuitBreakerEnabled?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
    marketWideEnabled?: SortOrder
    enableManualOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskSettingsSumOrderByAggregateInput = {
    riskPercentage?: SortOrder
    maxPositionSize?: SortOrder
    kellyFraction?: SortOrder
    winRate?: SortOrder
    stopLossValue?: SortOrder
    trailingCallback?: SortOrder
    trailingStep?: SortOrder
    timeLimit?: SortOrder
    takeProfitValue?: SortOrder
    trailingActivation?: SortOrder
    maxRiskPerTrade?: SortOrder
    maxRiskPerSymbol?: SortOrder
    maxRiskPerDirection?: SortOrder
    maxTotalRisk?: SortOrder
    maxDrawdown?: SortOrder
    maxPositions?: SortOrder
    maxDailyLoss?: SortOrder
    cooldownPeriod?: SortOrder
    volatilityLookback?: SortOrder
    maxDailyLossBreaker?: SortOrder
    maxDrawdownBreaker?: SortOrder
    volatilityMultiplier?: SortOrder
    consecutiveLossesBreaker?: SortOrder
    tradingPause?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RiskAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    resolvedAt?: SortOrder
  }

  export type RiskAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    resolvedAt?: SortOrder
  }

  export type RiskAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    acknowledged?: SortOrder
    resolvedAt?: SortOrder
  }

  export type CircuitBreakerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    type?: SortOrder
    isGlobal?: SortOrder
    isActive?: SortOrder
    threshold?: SortOrder
    recoveryThreshold?: SortOrder
    cooldownMinutes?: SortOrder
    action?: SortOrder
    lastTriggered?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerAvgOrderByAggregateInput = {
    threshold?: SortOrder
    recoveryThreshold?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type CircuitBreakerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    type?: SortOrder
    isGlobal?: SortOrder
    isActive?: SortOrder
    threshold?: SortOrder
    recoveryThreshold?: SortOrder
    cooldownMinutes?: SortOrder
    action?: SortOrder
    lastTriggered?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    type?: SortOrder
    isGlobal?: SortOrder
    isActive?: SortOrder
    threshold?: SortOrder
    recoveryThreshold?: SortOrder
    cooldownMinutes?: SortOrder
    action?: SortOrder
    lastTriggered?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircuitBreakerSumOrderByAggregateInput = {
    threshold?: SortOrder
    recoveryThreshold?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StrategyExecutionListRelationFilter = {
    every?: StrategyExecutionWhereInput
    some?: StrategyExecutionWhereInput
    none?: StrategyExecutionWhereInput
  }

  export type StrategyExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradingStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    timeHorizon?: SortOrder
    symbols?: SortOrder
    entryRules?: SortOrder
    exitRules?: SortOrder
    positionSizing?: SortOrder
    riskManagement?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    timeHorizon?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    timeHorizon?: SortOrder
    userId?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradingStrategyScalarRelationFilter = {
    is?: TradingStrategyWhereInput
    isNot?: TradingStrategyWhereInput
  }

  export type StrategyExecutionResultListRelationFilter = {
    every?: StrategyExecutionResultWhereInput
    some?: StrategyExecutionResultWhereInput
    none?: StrategyExecutionResultWhereInput
  }

  export type StrategyExecutionResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrategyExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    runningTimeMs?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionAvgOrderByAggregateInput = {
    runningTimeMs?: SortOrder
  }

  export type StrategyExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    runningTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    stoppedAt?: SortOrder
    runningTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionSumOrderByAggregateInput = {
    runningTimeMs?: SortOrder
  }

  export type StrategyExecutionScalarRelationFilter = {
    is?: StrategyExecutionWhereInput
    isNot?: StrategyExecutionWhereInput
  }

  export type StrategyExecutionResultCountOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    symbol?: SortOrder
    entryTime?: SortOrder
    entryPrice?: SortOrder
    exitTime?: SortOrder
    exitPrice?: SortOrder
    direction?: SortOrder
    quantity?: SortOrder
    profitLoss?: SortOrder
    profitLossPercentage?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionResultAvgOrderByAggregateInput = {
    entryPrice?: SortOrder
    exitPrice?: SortOrder
    quantity?: SortOrder
    profitLoss?: SortOrder
    profitLossPercentage?: SortOrder
  }

  export type StrategyExecutionResultMaxOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    symbol?: SortOrder
    entryTime?: SortOrder
    entryPrice?: SortOrder
    exitTime?: SortOrder
    exitPrice?: SortOrder
    direction?: SortOrder
    quantity?: SortOrder
    profitLoss?: SortOrder
    profitLossPercentage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionResultMinOrderByAggregateInput = {
    id?: SortOrder
    executionId?: SortOrder
    symbol?: SortOrder
    entryTime?: SortOrder
    entryPrice?: SortOrder
    exitTime?: SortOrder
    exitPrice?: SortOrder
    direction?: SortOrder
    quantity?: SortOrder
    profitLoss?: SortOrder
    profitLossPercentage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StrategyExecutionResultSumOrderByAggregateInput = {
    entryPrice?: SortOrder
    exitPrice?: SortOrder
    quantity?: SortOrder
    profitLoss?: SortOrder
    profitLossPercentage?: SortOrder
  }

  export type MLPredictionListRelationFilter = {
    every?: MLPredictionWhereInput
    some?: MLPredictionWhereInput
    none?: MLPredictionWhereInput
  }

  export type MLPredictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MLModelNameVersionCompoundUniqueInput = {
    name: string
    version: string
  }

  export type MLModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    modelType?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    description?: SortOrder
    status?: SortOrder
    accuracy?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    trainedAt?: SortOrder
    lastUsedAt?: SortOrder
    trainingId?: SortOrder
    location?: SortOrder
    params?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLModelAvgOrderByAggregateInput = {
    accuracy?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
  }

  export type MLModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    modelType?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    description?: SortOrder
    status?: SortOrder
    accuracy?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    trainedAt?: SortOrder
    lastUsedAt?: SortOrder
    trainingId?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    modelType?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    description?: SortOrder
    status?: SortOrder
    accuracy?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
    trainedAt?: SortOrder
    lastUsedAt?: SortOrder
    trainingId?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLModelSumOrderByAggregateInput = {
    accuracy?: SortOrder
    precision?: SortOrder
    recall?: SortOrder
    f1Score?: SortOrder
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MLModelScalarRelationFilter = {
    is?: MLModelWhereInput
    isNot?: MLModelWhereInput
  }

  export type MLPredictionCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    predictionType?: SortOrder
    values?: SortOrder
    timestamps?: SortOrder
    confidenceScores?: SortOrder
    metadata?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    signalGenerated?: SortOrder
    signalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLPredictionAvgOrderByAggregateInput = {
    values?: SortOrder
    confidenceScores?: SortOrder
  }

  export type MLPredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    predictionType?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    signalGenerated?: SortOrder
    signalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLPredictionMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    predictionType?: SortOrder
    generatedAt?: SortOrder
    expiresAt?: SortOrder
    signalGenerated?: SortOrder
    signalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLPredictionSumOrderByAggregateInput = {
    values?: SortOrder
    confidenceScores?: SortOrder
  }

  export type MLTrainingJobCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    modelType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    resultModelId?: SortOrder
    errorMessage?: SortOrder
    params?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLTrainingJobAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type MLTrainingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    modelType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    resultModelId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLTrainingJobMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    modelType?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    resultModelId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MLTrainingJobSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type BridgeConfigUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type BridgeConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    mlModelId?: SortOrder
    autoGenerateSignals?: SortOrder
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
    symbols?: SortOrder
    timeframes?: SortOrder
    lastExecutedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BridgeConfigAvgOrderByAggregateInput = {
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
  }

  export type BridgeConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    mlModelId?: SortOrder
    autoGenerateSignals?: SortOrder
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
    lastExecutedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BridgeConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    mlModelId?: SortOrder
    autoGenerateSignals?: SortOrder
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
    lastExecutedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BridgeConfigSumOrderByAggregateInput = {
    confidenceThreshold?: SortOrder
    signalExpiryMinutes?: SortOrder
    refreshIntervalMinutes?: SortOrder
  }

  export type PerformanceTestResultListRelationFilter = {
    every?: PerformanceTestResultWhereInput
    some?: PerformanceTestResultWhereInput
    none?: PerformanceTestResultWhereInput
  }

  export type PerformanceTestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceTestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    testType?: SortOrder
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrder
    targetEndpoint?: SortOrder
    modelId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestAvgOrderByAggregateInput = {
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrder
  }

  export type PerformanceTestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    testType?: SortOrder
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrder
    targetEndpoint?: SortOrder
    modelId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    testType?: SortOrder
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrder
    targetEndpoint?: SortOrder
    modelId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    timeframe?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestSumOrderByAggregateInput = {
    duration?: SortOrder
    concurrency?: SortOrder
    rampUp?: SortOrder
  }

  export type PerformanceTestScalarRelationFilter = {
    is?: PerformanceTestWhereInput
    isNot?: PerformanceTestWhereInput
  }

  export type OptimizationRecommendationListRelationFilter = {
    every?: OptimizationRecommendationWhereInput
    some?: OptimizationRecommendationWhereInput
    none?: OptimizationRecommendationWhereInput
  }

  export type OptimizationRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceTestResultCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    metrics?: SortOrder
    errors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestResultAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PerformanceTestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestResultMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceTestResultSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PerformanceTestResultScalarRelationFilter = {
    is?: PerformanceTestResultWhereInput
    isNot?: PerformanceTestResultWhereInput
  }

  export type OptimizationRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    category?: SortOrder
    impact?: SortOrder
    description?: SortOrder
    implementation?: SortOrder
    estimatedImprovement?: SortOrder
    createdAt?: SortOrder
  }

  export type OptimizationRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    category?: SortOrder
    impact?: SortOrder
    description?: SortOrder
    implementation?: SortOrder
    estimatedImprovement?: SortOrder
    createdAt?: SortOrder
  }

  export type OptimizationRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    testResultId?: SortOrder
    category?: SortOrder
    impact?: SortOrder
    description?: SortOrder
    implementation?: SortOrder
    estimatedImprovement?: SortOrder
    createdAt?: SortOrder
  }

  export type ABTestResultListRelationFilter = {
    every?: ABTestResultWhereInput
    some?: ABTestResultWhereInput
    none?: ABTestResultWhereInput
  }

  export type ABTestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ABTestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    variantA?: SortOrder
    variantB?: SortOrder
    type?: SortOrder
    metric?: SortOrder
    targetImprovement?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestAvgOrderByAggregateInput = {
    targetImprovement?: SortOrder
  }

  export type ABTestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    variantA?: SortOrder
    variantB?: SortOrder
    type?: SortOrder
    metric?: SortOrder
    targetImprovement?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    variantA?: SortOrder
    variantB?: SortOrder
    type?: SortOrder
    metric?: SortOrder
    targetImprovement?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestSumOrderByAggregateInput = {
    targetImprovement?: SortOrder
  }

  export type ABTestScalarRelationFilter = {
    is?: ABTestWhereInput
    isNot?: ABTestWhereInput
  }

  export type ABTestResultCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    variantAMetrics?: SortOrder
    variantBMetrics?: SortOrder
    winner?: SortOrder
    improvement?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestResultAvgOrderByAggregateInput = {
    improvement?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type ABTestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    winner?: SortOrder
    improvement?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestResultMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    winner?: SortOrder
    improvement?: SortOrder
    confidenceLevel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestResultSumOrderByAggregateInput = {
    improvement?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    system?: SortOrder
    component?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    tags?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    system?: SortOrder
    component?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    system?: SortOrder
    component?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PositionNullableScalarRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type TradingStrategyNullableScalarRelationFilter = {
    is?: TradingStrategyWhereInput | null
    isNot?: TradingStrategyWhereInput | null
  }

  export type TradingSignalNullableScalarRelationFilter = {
    is?: TradingSignalWhereInput | null
    isNot?: TradingSignalWhereInput | null
  }

  export type AuditTrailListRelationFilter = {
    every?: AuditTrailWhereInput
    some?: AuditTrailWhereInput
    none?: AuditTrailWhereInput
  }

  export type AuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    side?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    stopPrice?: SortOrder
    avgFillPrice?: SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrder
    feeCurrency?: SortOrder
    clientOrderId?: SortOrder
    exchangeOrderId?: SortOrder
    source?: SortOrder
    exchangeId?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    errorDetails?: SortOrder
    raw?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    strategyId?: SortOrder
    botId?: SortOrder
    signalId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    stopPrice?: SortOrder
    avgFillPrice?: SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    side?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    stopPrice?: SortOrder
    avgFillPrice?: SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrder
    feeCurrency?: SortOrder
    clientOrderId?: SortOrder
    exchangeOrderId?: SortOrder
    source?: SortOrder
    exchangeId?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    strategyId?: SortOrder
    botId?: SortOrder
    signalId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    side?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    stopPrice?: SortOrder
    avgFillPrice?: SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrder
    feeCurrency?: SortOrder
    clientOrderId?: SortOrder
    exchangeOrderId?: SortOrder
    source?: SortOrder
    exchangeId?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    userId?: SortOrder
    positionId?: SortOrder
    strategyId?: SortOrder
    botId?: SortOrder
    signalId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    stopPrice?: SortOrder
    avgFillPrice?: SortOrder
    filledQuantity?: SortOrder
    remainingQuantity?: SortOrder
    fee?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditTrailNullableScalarRelationFilter = {
    is?: AuditTrailWhereInput | null
    isNot?: AuditTrailWhereInput | null
  }

  export type DecisionLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    actionType?: SortOrder
    decision?: SortOrder
    reasonDetails?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    orderId?: SortOrder
    positionId?: SortOrder
    importance?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    auditTrailId?: SortOrder
  }

  export type DecisionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    actionType?: SortOrder
    decision?: SortOrder
    reasonDetails?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    orderId?: SortOrder
    positionId?: SortOrder
    importance?: SortOrder
    auditTrailId?: SortOrder
  }

  export type DecisionLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    source?: SortOrder
    actionType?: SortOrder
    decision?: SortOrder
    reasonDetails?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    strategyId?: SortOrder
    symbol?: SortOrder
    orderId?: SortOrder
    positionId?: SortOrder
    importance?: SortOrder
    auditTrailId?: SortOrder
  }

  export type AuditEventListRelationFilter = {
    every?: AuditEventWhereInput
    some?: AuditEventWhereInput
    none?: AuditEventWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type AuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    trailType?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
  }

  export type AuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    trailType?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type AuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    trailType?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
  }

  export type AuditTrailScalarRelationFilter = {
    is?: AuditTrailWhereInput
    isNot?: AuditTrailWhereInput
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    auditTrailId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    component?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrder
    dataBefore?: SortOrder
    dataAfter?: SortOrder
    metadata?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    auditTrailId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    component?: SortOrder
    action?: SortOrder
    status?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    auditTrailId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    component?: SortOrder
    action?: SortOrder
    status?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type TradeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput> | TradeLogCreateWithoutUserInput[] | TradeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeLogCreateOrConnectWithoutUserInput | TradeLogCreateOrConnectWithoutUserInput[]
    createMany?: TradeLogCreateManyUserInputEnvelope
    connect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
  }

  export type BotCreateNestedManyWithoutUserInput = {
    create?: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput> | BotCreateWithoutUserInput[] | BotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BotCreateOrConnectWithoutUserInput | BotCreateOrConnectWithoutUserInput[]
    createMany?: BotCreateManyUserInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type PositionCreateNestedManyWithoutUserInput = {
    create?: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput> | PositionCreateWithoutUserInput[] | PositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutUserInput | PositionCreateOrConnectWithoutUserInput[]
    createMany?: PositionCreateManyUserInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RiskSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput> | RiskSettingsCreateWithoutUserInput[] | RiskSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutUserInput | RiskSettingsCreateOrConnectWithoutUserInput[]
    createMany?: RiskSettingsCreateManyUserInputEnvelope
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
  }

  export type RiskAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput> | RiskAlertCreateWithoutUserInput[] | RiskAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskAlertCreateOrConnectWithoutUserInput | RiskAlertCreateOrConnectWithoutUserInput[]
    createMany?: RiskAlertCreateManyUserInputEnvelope
    connect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DecisionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput> | DecisionLogCreateWithoutUserInput[] | DecisionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutUserInput | DecisionLogCreateOrConnectWithoutUserInput[]
    createMany?: DecisionLogCreateManyUserInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type TradeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput> | TradeLogCreateWithoutUserInput[] | TradeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeLogCreateOrConnectWithoutUserInput | TradeLogCreateOrConnectWithoutUserInput[]
    createMany?: TradeLogCreateManyUserInputEnvelope
    connect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput> | BotCreateWithoutUserInput[] | BotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BotCreateOrConnectWithoutUserInput | BotCreateOrConnectWithoutUserInput[]
    createMany?: BotCreateManyUserInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type PositionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput> | PositionCreateWithoutUserInput[] | PositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutUserInput | PositionCreateOrConnectWithoutUserInput[]
    createMany?: PositionCreateManyUserInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RiskSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput> | RiskSettingsCreateWithoutUserInput[] | RiskSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutUserInput | RiskSettingsCreateOrConnectWithoutUserInput[]
    createMany?: RiskSettingsCreateManyUserInputEnvelope
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
  }

  export type RiskAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput> | RiskAlertCreateWithoutUserInput[] | RiskAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskAlertCreateOrConnectWithoutUserInput | RiskAlertCreateOrConnectWithoutUserInput[]
    createMany?: RiskAlertCreateManyUserInputEnvelope
    connect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput> | DecisionLogCreateWithoutUserInput[] | DecisionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutUserInput | DecisionLogCreateOrConnectWithoutUserInput[]
    createMany?: DecisionLogCreateManyUserInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type TradeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput> | TradeLogCreateWithoutUserInput[] | TradeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeLogCreateOrConnectWithoutUserInput | TradeLogCreateOrConnectWithoutUserInput[]
    upsert?: TradeLogUpsertWithWhereUniqueWithoutUserInput | TradeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeLogCreateManyUserInputEnvelope
    set?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    disconnect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    delete?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    connect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    update?: TradeLogUpdateWithWhereUniqueWithoutUserInput | TradeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeLogUpdateManyWithWhereWithoutUserInput | TradeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeLogScalarWhereInput | TradeLogScalarWhereInput[]
  }

  export type BotUpdateManyWithoutUserNestedInput = {
    create?: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput> | BotCreateWithoutUserInput[] | BotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BotCreateOrConnectWithoutUserInput | BotCreateOrConnectWithoutUserInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutUserInput | BotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BotCreateManyUserInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutUserInput | BotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BotUpdateManyWithWhereWithoutUserInput | BotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type PositionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput> | PositionCreateWithoutUserInput[] | PositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutUserInput | PositionCreateOrConnectWithoutUserInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutUserInput | PositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PositionCreateManyUserInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutUserInput | PositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutUserInput | PositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RiskSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput> | RiskSettingsCreateWithoutUserInput[] | RiskSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutUserInput | RiskSettingsCreateOrConnectWithoutUserInput[]
    upsert?: RiskSettingsUpsertWithWhereUniqueWithoutUserInput | RiskSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RiskSettingsCreateManyUserInputEnvelope
    set?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    disconnect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    delete?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    update?: RiskSettingsUpdateWithWhereUniqueWithoutUserInput | RiskSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RiskSettingsUpdateManyWithWhereWithoutUserInput | RiskSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
  }

  export type RiskAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput> | RiskAlertCreateWithoutUserInput[] | RiskAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskAlertCreateOrConnectWithoutUserInput | RiskAlertCreateOrConnectWithoutUserInput[]
    upsert?: RiskAlertUpsertWithWhereUniqueWithoutUserInput | RiskAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RiskAlertCreateManyUserInputEnvelope
    set?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    disconnect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    delete?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    connect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    update?: RiskAlertUpdateWithWhereUniqueWithoutUserInput | RiskAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RiskAlertUpdateManyWithWhereWithoutUserInput | RiskAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RiskAlertScalarWhereInput | RiskAlertScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DecisionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput> | DecisionLogCreateWithoutUserInput[] | DecisionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutUserInput | DecisionLogCreateOrConnectWithoutUserInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutUserInput | DecisionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DecisionLogCreateManyUserInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutUserInput | DecisionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutUserInput | DecisionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type TradeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput> | TradeLogCreateWithoutUserInput[] | TradeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeLogCreateOrConnectWithoutUserInput | TradeLogCreateOrConnectWithoutUserInput[]
    upsert?: TradeLogUpsertWithWhereUniqueWithoutUserInput | TradeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeLogCreateManyUserInputEnvelope
    set?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    disconnect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    delete?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    connect?: TradeLogWhereUniqueInput | TradeLogWhereUniqueInput[]
    update?: TradeLogUpdateWithWhereUniqueWithoutUserInput | TradeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeLogUpdateManyWithWhereWithoutUserInput | TradeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeLogScalarWhereInput | TradeLogScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput> | BotCreateWithoutUserInput[] | BotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BotCreateOrConnectWithoutUserInput | BotCreateOrConnectWithoutUserInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutUserInput | BotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BotCreateManyUserInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutUserInput | BotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BotUpdateManyWithWhereWithoutUserInput | BotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type PositionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput> | PositionCreateWithoutUserInput[] | PositionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutUserInput | PositionCreateOrConnectWithoutUserInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutUserInput | PositionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PositionCreateManyUserInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutUserInput | PositionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutUserInput | PositionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RiskSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput> | RiskSettingsCreateWithoutUserInput[] | RiskSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutUserInput | RiskSettingsCreateOrConnectWithoutUserInput[]
    upsert?: RiskSettingsUpsertWithWhereUniqueWithoutUserInput | RiskSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RiskSettingsCreateManyUserInputEnvelope
    set?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    disconnect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    delete?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    update?: RiskSettingsUpdateWithWhereUniqueWithoutUserInput | RiskSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RiskSettingsUpdateManyWithWhereWithoutUserInput | RiskSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
  }

  export type RiskAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput> | RiskAlertCreateWithoutUserInput[] | RiskAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RiskAlertCreateOrConnectWithoutUserInput | RiskAlertCreateOrConnectWithoutUserInput[]
    upsert?: RiskAlertUpsertWithWhereUniqueWithoutUserInput | RiskAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RiskAlertCreateManyUserInputEnvelope
    set?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    disconnect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    delete?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    connect?: RiskAlertWhereUniqueInput | RiskAlertWhereUniqueInput[]
    update?: RiskAlertUpdateWithWhereUniqueWithoutUserInput | RiskAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RiskAlertUpdateManyWithWhereWithoutUserInput | RiskAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RiskAlertScalarWhereInput | RiskAlertScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput> | DecisionLogCreateWithoutUserInput[] | DecisionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutUserInput | DecisionLogCreateOrConnectWithoutUserInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutUserInput | DecisionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DecisionLogCreateManyUserInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutUserInput | DecisionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutUserInput | DecisionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutTradeLogsInput = {
    create?: XOR<UserCreateWithoutTradeLogsInput, UserUncheckedCreateWithoutTradeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTradeLogsNestedInput = {
    create?: XOR<UserCreateWithoutTradeLogsInput, UserUncheckedCreateWithoutTradeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeLogsInput
    upsert?: UserUpsertWithoutTradeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradeLogsInput, UserUpdateWithoutTradeLogsInput>, UserUncheckedUpdateWithoutTradeLogsInput>
  }

  export type UserCreateNestedOneWithoutBotsInput = {
    create?: XOR<UserCreateWithoutBotsInput, UserUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotsInput
    connect?: UserWhereUniqueInput
  }

  export type PositionCreateNestedManyWithoutBotInput = {
    create?: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput> | PositionCreateWithoutBotInput[] | PositionUncheckedCreateWithoutBotInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutBotInput | PositionCreateOrConnectWithoutBotInput[]
    createMany?: PositionCreateManyBotInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type RiskSettingsCreateNestedManyWithoutBotInput = {
    create?: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput> | RiskSettingsCreateWithoutBotInput[] | RiskSettingsUncheckedCreateWithoutBotInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutBotInput | RiskSettingsCreateOrConnectWithoutBotInput[]
    createMany?: RiskSettingsCreateManyBotInputEnvelope
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutBotInput = {
    create?: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput> | OrderCreateWithoutBotInput[] | OrderUncheckedCreateWithoutBotInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBotInput | OrderCreateOrConnectWithoutBotInput[]
    createMany?: OrderCreateManyBotInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DecisionLogCreateNestedManyWithoutBotInput = {
    create?: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput> | DecisionLogCreateWithoutBotInput[] | DecisionLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutBotInput | DecisionLogCreateOrConnectWithoutBotInput[]
    createMany?: DecisionLogCreateManyBotInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type PositionUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput> | PositionCreateWithoutBotInput[] | PositionUncheckedCreateWithoutBotInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutBotInput | PositionCreateOrConnectWithoutBotInput[]
    createMany?: PositionCreateManyBotInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type RiskSettingsUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput> | RiskSettingsCreateWithoutBotInput[] | RiskSettingsUncheckedCreateWithoutBotInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutBotInput | RiskSettingsCreateOrConnectWithoutBotInput[]
    createMany?: RiskSettingsCreateManyBotInputEnvelope
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput> | OrderCreateWithoutBotInput[] | OrderUncheckedCreateWithoutBotInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBotInput | OrderCreateOrConnectWithoutBotInput[]
    createMany?: OrderCreateManyBotInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput> | DecisionLogCreateWithoutBotInput[] | DecisionLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutBotInput | DecisionLogCreateOrConnectWithoutBotInput[]
    createMany?: DecisionLogCreateManyBotInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBotsNestedInput = {
    create?: XOR<UserCreateWithoutBotsInput, UserUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotsInput
    upsert?: UserUpsertWithoutBotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBotsInput, UserUpdateWithoutBotsInput>, UserUncheckedUpdateWithoutBotsInput>
  }

  export type PositionUpdateManyWithoutBotNestedInput = {
    create?: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput> | PositionCreateWithoutBotInput[] | PositionUncheckedCreateWithoutBotInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutBotInput | PositionCreateOrConnectWithoutBotInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutBotInput | PositionUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: PositionCreateManyBotInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutBotInput | PositionUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutBotInput | PositionUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type RiskSettingsUpdateManyWithoutBotNestedInput = {
    create?: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput> | RiskSettingsCreateWithoutBotInput[] | RiskSettingsUncheckedCreateWithoutBotInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutBotInput | RiskSettingsCreateOrConnectWithoutBotInput[]
    upsert?: RiskSettingsUpsertWithWhereUniqueWithoutBotInput | RiskSettingsUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: RiskSettingsCreateManyBotInputEnvelope
    set?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    disconnect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    delete?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    update?: RiskSettingsUpdateWithWhereUniqueWithoutBotInput | RiskSettingsUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: RiskSettingsUpdateManyWithWhereWithoutBotInput | RiskSettingsUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutBotNestedInput = {
    create?: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput> | OrderCreateWithoutBotInput[] | OrderUncheckedCreateWithoutBotInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBotInput | OrderCreateOrConnectWithoutBotInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBotInput | OrderUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: OrderCreateManyBotInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBotInput | OrderUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBotInput | OrderUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DecisionLogUpdateManyWithoutBotNestedInput = {
    create?: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput> | DecisionLogCreateWithoutBotInput[] | DecisionLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutBotInput | DecisionLogCreateOrConnectWithoutBotInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutBotInput | DecisionLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: DecisionLogCreateManyBotInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutBotInput | DecisionLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutBotInput | DecisionLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type PositionUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput> | PositionCreateWithoutBotInput[] | PositionUncheckedCreateWithoutBotInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutBotInput | PositionCreateOrConnectWithoutBotInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutBotInput | PositionUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: PositionCreateManyBotInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutBotInput | PositionUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutBotInput | PositionUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type RiskSettingsUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput> | RiskSettingsCreateWithoutBotInput[] | RiskSettingsUncheckedCreateWithoutBotInput[]
    connectOrCreate?: RiskSettingsCreateOrConnectWithoutBotInput | RiskSettingsCreateOrConnectWithoutBotInput[]
    upsert?: RiskSettingsUpsertWithWhereUniqueWithoutBotInput | RiskSettingsUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: RiskSettingsCreateManyBotInputEnvelope
    set?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    disconnect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    delete?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    connect?: RiskSettingsWhereUniqueInput | RiskSettingsWhereUniqueInput[]
    update?: RiskSettingsUpdateWithWhereUniqueWithoutBotInput | RiskSettingsUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: RiskSettingsUpdateManyWithWhereWithoutBotInput | RiskSettingsUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput> | OrderCreateWithoutBotInput[] | OrderUncheckedCreateWithoutBotInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBotInput | OrderCreateOrConnectWithoutBotInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBotInput | OrderUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: OrderCreateManyBotInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBotInput | OrderUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBotInput | OrderUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput> | DecisionLogCreateWithoutBotInput[] | DecisionLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutBotInput | DecisionLogCreateOrConnectWithoutBotInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutBotInput | DecisionLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: DecisionLogCreateManyBotInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutBotInput | DecisionLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutBotInput | DecisionLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPositionsInput = {
    create?: XOR<UserCreateWithoutPositionsInput, UserUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPositionsInput
    connect?: UserWhereUniqueInput
  }

  export type BotCreateNestedOneWithoutPositionsInput = {
    create?: XOR<BotCreateWithoutPositionsInput, BotUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: BotCreateOrConnectWithoutPositionsInput
    connect?: BotWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutPositionInput = {
    create?: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput> | OrderCreateWithoutPositionInput[] | OrderUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPositionInput | OrderCreateOrConnectWithoutPositionInput[]
    createMany?: OrderCreateManyPositionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput> | OrderCreateWithoutPositionInput[] | OrderUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPositionInput | OrderCreateOrConnectWithoutPositionInput[]
    createMany?: OrderCreateManyPositionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPositionsNestedInput = {
    create?: XOR<UserCreateWithoutPositionsInput, UserUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPositionsInput
    upsert?: UserUpsertWithoutPositionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPositionsInput, UserUpdateWithoutPositionsInput>, UserUncheckedUpdateWithoutPositionsInput>
  }

  export type BotUpdateOneWithoutPositionsNestedInput = {
    create?: XOR<BotCreateWithoutPositionsInput, BotUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: BotCreateOrConnectWithoutPositionsInput
    upsert?: BotUpsertWithoutPositionsInput
    disconnect?: BotWhereInput | boolean
    delete?: BotWhereInput | boolean
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutPositionsInput, BotUpdateWithoutPositionsInput>, BotUncheckedUpdateWithoutPositionsInput>
  }

  export type OrderUpdateManyWithoutPositionNestedInput = {
    create?: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput> | OrderCreateWithoutPositionInput[] | OrderUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPositionInput | OrderCreateOrConnectWithoutPositionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPositionInput | OrderUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: OrderCreateManyPositionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPositionInput | OrderUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPositionInput | OrderUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput> | OrderCreateWithoutPositionInput[] | OrderUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPositionInput | OrderCreateOrConnectWithoutPositionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPositionInput | OrderUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: OrderCreateManyPositionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPositionInput | OrderUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPositionInput | OrderUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutSignalInput = {
    create?: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput> | OrderCreateWithoutSignalInput[] | OrderUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSignalInput | OrderCreateOrConnectWithoutSignalInput[]
    createMany?: OrderCreateManySignalInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSignalInput = {
    create?: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput> | OrderCreateWithoutSignalInput[] | OrderUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSignalInput | OrderCreateOrConnectWithoutSignalInput[]
    createMany?: OrderCreateManySignalInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutSignalNestedInput = {
    create?: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput> | OrderCreateWithoutSignalInput[] | OrderUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSignalInput | OrderCreateOrConnectWithoutSignalInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSignalInput | OrderUpsertWithWhereUniqueWithoutSignalInput[]
    createMany?: OrderCreateManySignalInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSignalInput | OrderUpdateWithWhereUniqueWithoutSignalInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSignalInput | OrderUpdateManyWithWhereWithoutSignalInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSignalNestedInput = {
    create?: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput> | OrderCreateWithoutSignalInput[] | OrderUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSignalInput | OrderCreateOrConnectWithoutSignalInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSignalInput | OrderUpsertWithWhereUniqueWithoutSignalInput[]
    createMany?: OrderCreateManySignalInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSignalInput | OrderUpdateWithWhereUniqueWithoutSignalInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSignalInput | OrderUpdateManyWithWhereWithoutSignalInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRiskSettingsInput = {
    create?: XOR<UserCreateWithoutRiskSettingsInput, UserUncheckedCreateWithoutRiskSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type BotCreateNestedOneWithoutRiskSettingsInput = {
    create?: XOR<BotCreateWithoutRiskSettingsInput, BotUncheckedCreateWithoutRiskSettingsInput>
    connectOrCreate?: BotCreateOrConnectWithoutRiskSettingsInput
    connect?: BotWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutRiskSettingsNestedInput = {
    create?: XOR<UserCreateWithoutRiskSettingsInput, UserUncheckedCreateWithoutRiskSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskSettingsInput
    upsert?: UserUpsertWithoutRiskSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRiskSettingsInput, UserUpdateWithoutRiskSettingsInput>, UserUncheckedUpdateWithoutRiskSettingsInput>
  }

  export type BotUpdateOneWithoutRiskSettingsNestedInput = {
    create?: XOR<BotCreateWithoutRiskSettingsInput, BotUncheckedCreateWithoutRiskSettingsInput>
    connectOrCreate?: BotCreateOrConnectWithoutRiskSettingsInput
    upsert?: BotUpsertWithoutRiskSettingsInput
    disconnect?: BotWhereInput | boolean
    delete?: BotWhereInput | boolean
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutRiskSettingsInput, BotUpdateWithoutRiskSettingsInput>, BotUncheckedUpdateWithoutRiskSettingsInput>
  }

  export type UserCreateNestedOneWithoutRiskAlertsInput = {
    create?: XOR<UserCreateWithoutRiskAlertsInput, UserUncheckedCreateWithoutRiskAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRiskAlertsNestedInput = {
    create?: XOR<UserCreateWithoutRiskAlertsInput, UserUncheckedCreateWithoutRiskAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskAlertsInput
    upsert?: UserUpsertWithoutRiskAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRiskAlertsInput, UserUpdateWithoutRiskAlertsInput>, UserUncheckedUpdateWithoutRiskAlertsInput>
  }

  export type TradingStrategyCreatesymbolsInput = {
    set: string[]
  }

  export type StrategyExecutionCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput> | StrategyExecutionCreateWithoutStrategyInput[] | StrategyExecutionUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutStrategyInput | StrategyExecutionCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyExecutionCreateManyStrategyInputEnvelope
    connect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutStrategyInput = {
    create?: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput> | OrderCreateWithoutStrategyInput[] | OrderUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStrategyInput | OrderCreateOrConnectWithoutStrategyInput[]
    createMany?: OrderCreateManyStrategyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DecisionLogCreateNestedManyWithoutStrategyInput = {
    create?: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput> | DecisionLogCreateWithoutStrategyInput[] | DecisionLogUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutStrategyInput | DecisionLogCreateOrConnectWithoutStrategyInput[]
    createMany?: DecisionLogCreateManyStrategyInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type StrategyExecutionUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput> | StrategyExecutionCreateWithoutStrategyInput[] | StrategyExecutionUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutStrategyInput | StrategyExecutionCreateOrConnectWithoutStrategyInput[]
    createMany?: StrategyExecutionCreateManyStrategyInputEnvelope
    connect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput> | OrderCreateWithoutStrategyInput[] | OrderUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStrategyInput | OrderCreateOrConnectWithoutStrategyInput[]
    createMany?: OrderCreateManyStrategyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput> | DecisionLogCreateWithoutStrategyInput[] | DecisionLogUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutStrategyInput | DecisionLogCreateOrConnectWithoutStrategyInput[]
    createMany?: DecisionLogCreateManyStrategyInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type TradingStrategyUpdatesymbolsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StrategyExecutionUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput> | StrategyExecutionCreateWithoutStrategyInput[] | StrategyExecutionUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutStrategyInput | StrategyExecutionCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyExecutionUpsertWithWhereUniqueWithoutStrategyInput | StrategyExecutionUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyExecutionCreateManyStrategyInputEnvelope
    set?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    disconnect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    delete?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    connect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    update?: StrategyExecutionUpdateWithWhereUniqueWithoutStrategyInput | StrategyExecutionUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyExecutionUpdateManyWithWhereWithoutStrategyInput | StrategyExecutionUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyExecutionScalarWhereInput | StrategyExecutionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput> | OrderCreateWithoutStrategyInput[] | OrderUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStrategyInput | OrderCreateOrConnectWithoutStrategyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStrategyInput | OrderUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: OrderCreateManyStrategyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStrategyInput | OrderUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStrategyInput | OrderUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DecisionLogUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput> | DecisionLogCreateWithoutStrategyInput[] | DecisionLogUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutStrategyInput | DecisionLogCreateOrConnectWithoutStrategyInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutStrategyInput | DecisionLogUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: DecisionLogCreateManyStrategyInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutStrategyInput | DecisionLogUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutStrategyInput | DecisionLogUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type StrategyExecutionUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput> | StrategyExecutionCreateWithoutStrategyInput[] | StrategyExecutionUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutStrategyInput | StrategyExecutionCreateOrConnectWithoutStrategyInput[]
    upsert?: StrategyExecutionUpsertWithWhereUniqueWithoutStrategyInput | StrategyExecutionUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: StrategyExecutionCreateManyStrategyInputEnvelope
    set?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    disconnect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    delete?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    connect?: StrategyExecutionWhereUniqueInput | StrategyExecutionWhereUniqueInput[]
    update?: StrategyExecutionUpdateWithWhereUniqueWithoutStrategyInput | StrategyExecutionUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: StrategyExecutionUpdateManyWithWhereWithoutStrategyInput | StrategyExecutionUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: StrategyExecutionScalarWhereInput | StrategyExecutionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput> | OrderCreateWithoutStrategyInput[] | OrderUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStrategyInput | OrderCreateOrConnectWithoutStrategyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStrategyInput | OrderUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: OrderCreateManyStrategyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStrategyInput | OrderUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStrategyInput | OrderUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput> | DecisionLogCreateWithoutStrategyInput[] | DecisionLogUncheckedCreateWithoutStrategyInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutStrategyInput | DecisionLogCreateOrConnectWithoutStrategyInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutStrategyInput | DecisionLogUpsertWithWhereUniqueWithoutStrategyInput[]
    createMany?: DecisionLogCreateManyStrategyInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutStrategyInput | DecisionLogUpdateWithWhereUniqueWithoutStrategyInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutStrategyInput | DecisionLogUpdateManyWithWhereWithoutStrategyInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type TradingStrategyCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TradingStrategyCreateWithoutExecutionsInput, TradingStrategyUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutExecutionsInput
    connect?: TradingStrategyWhereUniqueInput
  }

  export type StrategyExecutionResultCreateNestedManyWithoutExecutionInput = {
    create?: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput> | StrategyExecutionResultCreateWithoutExecutionInput[] | StrategyExecutionResultUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: StrategyExecutionResultCreateOrConnectWithoutExecutionInput | StrategyExecutionResultCreateOrConnectWithoutExecutionInput[]
    createMany?: StrategyExecutionResultCreateManyExecutionInputEnvelope
    connect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
  }

  export type StrategyExecutionResultUncheckedCreateNestedManyWithoutExecutionInput = {
    create?: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput> | StrategyExecutionResultCreateWithoutExecutionInput[] | StrategyExecutionResultUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: StrategyExecutionResultCreateOrConnectWithoutExecutionInput | StrategyExecutionResultCreateOrConnectWithoutExecutionInput[]
    createMany?: StrategyExecutionResultCreateManyExecutionInputEnvelope
    connect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
  }

  export type TradingStrategyUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TradingStrategyCreateWithoutExecutionsInput, TradingStrategyUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutExecutionsInput
    upsert?: TradingStrategyUpsertWithoutExecutionsInput
    connect?: TradingStrategyWhereUniqueInput
    update?: XOR<XOR<TradingStrategyUpdateToOneWithWhereWithoutExecutionsInput, TradingStrategyUpdateWithoutExecutionsInput>, TradingStrategyUncheckedUpdateWithoutExecutionsInput>
  }

  export type StrategyExecutionResultUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput> | StrategyExecutionResultCreateWithoutExecutionInput[] | StrategyExecutionResultUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: StrategyExecutionResultCreateOrConnectWithoutExecutionInput | StrategyExecutionResultCreateOrConnectWithoutExecutionInput[]
    upsert?: StrategyExecutionResultUpsertWithWhereUniqueWithoutExecutionInput | StrategyExecutionResultUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: StrategyExecutionResultCreateManyExecutionInputEnvelope
    set?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    disconnect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    delete?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    connect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    update?: StrategyExecutionResultUpdateWithWhereUniqueWithoutExecutionInput | StrategyExecutionResultUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: StrategyExecutionResultUpdateManyWithWhereWithoutExecutionInput | StrategyExecutionResultUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: StrategyExecutionResultScalarWhereInput | StrategyExecutionResultScalarWhereInput[]
  }

  export type StrategyExecutionResultUncheckedUpdateManyWithoutExecutionNestedInput = {
    create?: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput> | StrategyExecutionResultCreateWithoutExecutionInput[] | StrategyExecutionResultUncheckedCreateWithoutExecutionInput[]
    connectOrCreate?: StrategyExecutionResultCreateOrConnectWithoutExecutionInput | StrategyExecutionResultCreateOrConnectWithoutExecutionInput[]
    upsert?: StrategyExecutionResultUpsertWithWhereUniqueWithoutExecutionInput | StrategyExecutionResultUpsertWithWhereUniqueWithoutExecutionInput[]
    createMany?: StrategyExecutionResultCreateManyExecutionInputEnvelope
    set?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    disconnect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    delete?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    connect?: StrategyExecutionResultWhereUniqueInput | StrategyExecutionResultWhereUniqueInput[]
    update?: StrategyExecutionResultUpdateWithWhereUniqueWithoutExecutionInput | StrategyExecutionResultUpdateWithWhereUniqueWithoutExecutionInput[]
    updateMany?: StrategyExecutionResultUpdateManyWithWhereWithoutExecutionInput | StrategyExecutionResultUpdateManyWithWhereWithoutExecutionInput[]
    deleteMany?: StrategyExecutionResultScalarWhereInput | StrategyExecutionResultScalarWhereInput[]
  }

  export type StrategyExecutionCreateNestedOneWithoutResultsInput = {
    create?: XOR<StrategyExecutionCreateWithoutResultsInput, StrategyExecutionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutResultsInput
    connect?: StrategyExecutionWhereUniqueInput
  }

  export type StrategyExecutionUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<StrategyExecutionCreateWithoutResultsInput, StrategyExecutionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: StrategyExecutionCreateOrConnectWithoutResultsInput
    upsert?: StrategyExecutionUpsertWithoutResultsInput
    connect?: StrategyExecutionWhereUniqueInput
    update?: XOR<XOR<StrategyExecutionUpdateToOneWithWhereWithoutResultsInput, StrategyExecutionUpdateWithoutResultsInput>, StrategyExecutionUncheckedUpdateWithoutResultsInput>
  }

  export type MLPredictionCreateNestedManyWithoutModelInput = {
    create?: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput> | MLPredictionCreateWithoutModelInput[] | MLPredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: MLPredictionCreateOrConnectWithoutModelInput | MLPredictionCreateOrConnectWithoutModelInput[]
    createMany?: MLPredictionCreateManyModelInputEnvelope
    connect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
  }

  export type MLPredictionUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput> | MLPredictionCreateWithoutModelInput[] | MLPredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: MLPredictionCreateOrConnectWithoutModelInput | MLPredictionCreateOrConnectWithoutModelInput[]
    createMany?: MLPredictionCreateManyModelInputEnvelope
    connect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
  }

  export type MLPredictionUpdateManyWithoutModelNestedInput = {
    create?: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput> | MLPredictionCreateWithoutModelInput[] | MLPredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: MLPredictionCreateOrConnectWithoutModelInput | MLPredictionCreateOrConnectWithoutModelInput[]
    upsert?: MLPredictionUpsertWithWhereUniqueWithoutModelInput | MLPredictionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: MLPredictionCreateManyModelInputEnvelope
    set?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    disconnect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    delete?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    connect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    update?: MLPredictionUpdateWithWhereUniqueWithoutModelInput | MLPredictionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: MLPredictionUpdateManyWithWhereWithoutModelInput | MLPredictionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: MLPredictionScalarWhereInput | MLPredictionScalarWhereInput[]
  }

  export type MLPredictionUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput> | MLPredictionCreateWithoutModelInput[] | MLPredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: MLPredictionCreateOrConnectWithoutModelInput | MLPredictionCreateOrConnectWithoutModelInput[]
    upsert?: MLPredictionUpsertWithWhereUniqueWithoutModelInput | MLPredictionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: MLPredictionCreateManyModelInputEnvelope
    set?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    disconnect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    delete?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    connect?: MLPredictionWhereUniqueInput | MLPredictionWhereUniqueInput[]
    update?: MLPredictionUpdateWithWhereUniqueWithoutModelInput | MLPredictionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: MLPredictionUpdateManyWithWhereWithoutModelInput | MLPredictionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: MLPredictionScalarWhereInput | MLPredictionScalarWhereInput[]
  }

  export type MLPredictionCreatevaluesInput = {
    set: number[]
  }

  export type MLPredictionCreatetimestampsInput = {
    set: string[]
  }

  export type MLPredictionCreateconfidenceScoresInput = {
    set: number[]
  }

  export type MLModelCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<MLModelCreateWithoutPredictionsInput, MLModelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: MLModelCreateOrConnectWithoutPredictionsInput
    connect?: MLModelWhereUniqueInput
  }

  export type MLPredictionUpdatevaluesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type MLPredictionUpdatetimestampsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MLPredictionUpdateconfidenceScoresInput = {
    set?: number[]
    push?: number | number[]
  }

  export type MLModelUpdateOneRequiredWithoutPredictionsNestedInput = {
    create?: XOR<MLModelCreateWithoutPredictionsInput, MLModelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: MLModelCreateOrConnectWithoutPredictionsInput
    upsert?: MLModelUpsertWithoutPredictionsInput
    connect?: MLModelWhereUniqueInput
    update?: XOR<XOR<MLModelUpdateToOneWithWhereWithoutPredictionsInput, MLModelUpdateWithoutPredictionsInput>, MLModelUncheckedUpdateWithoutPredictionsInput>
  }

  export type BridgeConfigCreatesymbolsInput = {
    set: string[]
  }

  export type BridgeConfigCreatetimeframesInput = {
    set: string[]
  }

  export type BridgeConfigUpdatesymbolsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BridgeConfigUpdatetimeframesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PerformanceTestResultCreateNestedManyWithoutTestInput = {
    create?: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput> | PerformanceTestResultCreateWithoutTestInput[] | PerformanceTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutTestInput | PerformanceTestResultCreateOrConnectWithoutTestInput[]
    createMany?: PerformanceTestResultCreateManyTestInputEnvelope
    connect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
  }

  export type PerformanceTestResultUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput> | PerformanceTestResultCreateWithoutTestInput[] | PerformanceTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutTestInput | PerformanceTestResultCreateOrConnectWithoutTestInput[]
    createMany?: PerformanceTestResultCreateManyTestInputEnvelope
    connect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
  }

  export type PerformanceTestResultUpdateManyWithoutTestNestedInput = {
    create?: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput> | PerformanceTestResultCreateWithoutTestInput[] | PerformanceTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutTestInput | PerformanceTestResultCreateOrConnectWithoutTestInput[]
    upsert?: PerformanceTestResultUpsertWithWhereUniqueWithoutTestInput | PerformanceTestResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: PerformanceTestResultCreateManyTestInputEnvelope
    set?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    disconnect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    delete?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    connect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    update?: PerformanceTestResultUpdateWithWhereUniqueWithoutTestInput | PerformanceTestResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: PerformanceTestResultUpdateManyWithWhereWithoutTestInput | PerformanceTestResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: PerformanceTestResultScalarWhereInput | PerformanceTestResultScalarWhereInput[]
  }

  export type PerformanceTestResultUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput> | PerformanceTestResultCreateWithoutTestInput[] | PerformanceTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutTestInput | PerformanceTestResultCreateOrConnectWithoutTestInput[]
    upsert?: PerformanceTestResultUpsertWithWhereUniqueWithoutTestInput | PerformanceTestResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: PerformanceTestResultCreateManyTestInputEnvelope
    set?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    disconnect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    delete?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    connect?: PerformanceTestResultWhereUniqueInput | PerformanceTestResultWhereUniqueInput[]
    update?: PerformanceTestResultUpdateWithWhereUniqueWithoutTestInput | PerformanceTestResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: PerformanceTestResultUpdateManyWithWhereWithoutTestInput | PerformanceTestResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: PerformanceTestResultScalarWhereInput | PerformanceTestResultScalarWhereInput[]
  }

  export type PerformanceTestCreateNestedOneWithoutResultsInput = {
    create?: XOR<PerformanceTestCreateWithoutResultsInput, PerformanceTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: PerformanceTestCreateOrConnectWithoutResultsInput
    connect?: PerformanceTestWhereUniqueInput
  }

  export type OptimizationRecommendationCreateNestedManyWithoutTestResultInput = {
    create?: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput> | OptimizationRecommendationCreateWithoutTestResultInput[] | OptimizationRecommendationUncheckedCreateWithoutTestResultInput[]
    connectOrCreate?: OptimizationRecommendationCreateOrConnectWithoutTestResultInput | OptimizationRecommendationCreateOrConnectWithoutTestResultInput[]
    createMany?: OptimizationRecommendationCreateManyTestResultInputEnvelope
    connect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
  }

  export type OptimizationRecommendationUncheckedCreateNestedManyWithoutTestResultInput = {
    create?: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput> | OptimizationRecommendationCreateWithoutTestResultInput[] | OptimizationRecommendationUncheckedCreateWithoutTestResultInput[]
    connectOrCreate?: OptimizationRecommendationCreateOrConnectWithoutTestResultInput | OptimizationRecommendationCreateOrConnectWithoutTestResultInput[]
    createMany?: OptimizationRecommendationCreateManyTestResultInputEnvelope
    connect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
  }

  export type PerformanceTestUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<PerformanceTestCreateWithoutResultsInput, PerformanceTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: PerformanceTestCreateOrConnectWithoutResultsInput
    upsert?: PerformanceTestUpsertWithoutResultsInput
    connect?: PerformanceTestWhereUniqueInput
    update?: XOR<XOR<PerformanceTestUpdateToOneWithWhereWithoutResultsInput, PerformanceTestUpdateWithoutResultsInput>, PerformanceTestUncheckedUpdateWithoutResultsInput>
  }

  export type OptimizationRecommendationUpdateManyWithoutTestResultNestedInput = {
    create?: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput> | OptimizationRecommendationCreateWithoutTestResultInput[] | OptimizationRecommendationUncheckedCreateWithoutTestResultInput[]
    connectOrCreate?: OptimizationRecommendationCreateOrConnectWithoutTestResultInput | OptimizationRecommendationCreateOrConnectWithoutTestResultInput[]
    upsert?: OptimizationRecommendationUpsertWithWhereUniqueWithoutTestResultInput | OptimizationRecommendationUpsertWithWhereUniqueWithoutTestResultInput[]
    createMany?: OptimizationRecommendationCreateManyTestResultInputEnvelope
    set?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    disconnect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    delete?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    connect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    update?: OptimizationRecommendationUpdateWithWhereUniqueWithoutTestResultInput | OptimizationRecommendationUpdateWithWhereUniqueWithoutTestResultInput[]
    updateMany?: OptimizationRecommendationUpdateManyWithWhereWithoutTestResultInput | OptimizationRecommendationUpdateManyWithWhereWithoutTestResultInput[]
    deleteMany?: OptimizationRecommendationScalarWhereInput | OptimizationRecommendationScalarWhereInput[]
  }

  export type OptimizationRecommendationUncheckedUpdateManyWithoutTestResultNestedInput = {
    create?: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput> | OptimizationRecommendationCreateWithoutTestResultInput[] | OptimizationRecommendationUncheckedCreateWithoutTestResultInput[]
    connectOrCreate?: OptimizationRecommendationCreateOrConnectWithoutTestResultInput | OptimizationRecommendationCreateOrConnectWithoutTestResultInput[]
    upsert?: OptimizationRecommendationUpsertWithWhereUniqueWithoutTestResultInput | OptimizationRecommendationUpsertWithWhereUniqueWithoutTestResultInput[]
    createMany?: OptimizationRecommendationCreateManyTestResultInputEnvelope
    set?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    disconnect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    delete?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    connect?: OptimizationRecommendationWhereUniqueInput | OptimizationRecommendationWhereUniqueInput[]
    update?: OptimizationRecommendationUpdateWithWhereUniqueWithoutTestResultInput | OptimizationRecommendationUpdateWithWhereUniqueWithoutTestResultInput[]
    updateMany?: OptimizationRecommendationUpdateManyWithWhereWithoutTestResultInput | OptimizationRecommendationUpdateManyWithWhereWithoutTestResultInput[]
    deleteMany?: OptimizationRecommendationScalarWhereInput | OptimizationRecommendationScalarWhereInput[]
  }

  export type PerformanceTestResultCreateNestedOneWithoutRecommendationsInput = {
    create?: XOR<PerformanceTestResultCreateWithoutRecommendationsInput, PerformanceTestResultUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutRecommendationsInput
    connect?: PerformanceTestResultWhereUniqueInput
  }

  export type PerformanceTestResultUpdateOneRequiredWithoutRecommendationsNestedInput = {
    create?: XOR<PerformanceTestResultCreateWithoutRecommendationsInput, PerformanceTestResultUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: PerformanceTestResultCreateOrConnectWithoutRecommendationsInput
    upsert?: PerformanceTestResultUpsertWithoutRecommendationsInput
    connect?: PerformanceTestResultWhereUniqueInput
    update?: XOR<XOR<PerformanceTestResultUpdateToOneWithWhereWithoutRecommendationsInput, PerformanceTestResultUpdateWithoutRecommendationsInput>, PerformanceTestResultUncheckedUpdateWithoutRecommendationsInput>
  }

  export type ABTestResultCreateNestedManyWithoutTestInput = {
    create?: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput> | ABTestResultCreateWithoutTestInput[] | ABTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ABTestResultCreateOrConnectWithoutTestInput | ABTestResultCreateOrConnectWithoutTestInput[]
    createMany?: ABTestResultCreateManyTestInputEnvelope
    connect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
  }

  export type ABTestResultUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput> | ABTestResultCreateWithoutTestInput[] | ABTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ABTestResultCreateOrConnectWithoutTestInput | ABTestResultCreateOrConnectWithoutTestInput[]
    createMany?: ABTestResultCreateManyTestInputEnvelope
    connect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
  }

  export type ABTestResultUpdateManyWithoutTestNestedInput = {
    create?: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput> | ABTestResultCreateWithoutTestInput[] | ABTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ABTestResultCreateOrConnectWithoutTestInput | ABTestResultCreateOrConnectWithoutTestInput[]
    upsert?: ABTestResultUpsertWithWhereUniqueWithoutTestInput | ABTestResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ABTestResultCreateManyTestInputEnvelope
    set?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    disconnect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    delete?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    connect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    update?: ABTestResultUpdateWithWhereUniqueWithoutTestInput | ABTestResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ABTestResultUpdateManyWithWhereWithoutTestInput | ABTestResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ABTestResultScalarWhereInput | ABTestResultScalarWhereInput[]
  }

  export type ABTestResultUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput> | ABTestResultCreateWithoutTestInput[] | ABTestResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: ABTestResultCreateOrConnectWithoutTestInput | ABTestResultCreateOrConnectWithoutTestInput[]
    upsert?: ABTestResultUpsertWithWhereUniqueWithoutTestInput | ABTestResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: ABTestResultCreateManyTestInputEnvelope
    set?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    disconnect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    delete?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    connect?: ABTestResultWhereUniqueInput | ABTestResultWhereUniqueInput[]
    update?: ABTestResultUpdateWithWhereUniqueWithoutTestInput | ABTestResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: ABTestResultUpdateManyWithWhereWithoutTestInput | ABTestResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: ABTestResultScalarWhereInput | ABTestResultScalarWhereInput[]
  }

  export type ABTestCreateNestedOneWithoutResultsInput = {
    create?: XOR<ABTestCreateWithoutResultsInput, ABTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ABTestCreateOrConnectWithoutResultsInput
    connect?: ABTestWhereUniqueInput
  }

  export type ABTestUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<ABTestCreateWithoutResultsInput, ABTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ABTestCreateOrConnectWithoutResultsInput
    upsert?: ABTestUpsertWithoutResultsInput
    connect?: ABTestWhereUniqueInput
    update?: XOR<XOR<ABTestUpdateToOneWithWhereWithoutResultsInput, ABTestUpdateWithoutResultsInput>, ABTestUncheckedUpdateWithoutResultsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PositionCreateWithoutOrdersInput, PositionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutOrdersInput
    connect?: PositionWhereUniqueInput
  }

  export type TradingStrategyCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TradingStrategyCreateWithoutOrdersInput, TradingStrategyUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutOrdersInput
    connect?: TradingStrategyWhereUniqueInput
  }

  export type BotCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BotCreateWithoutOrdersInput, BotUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BotCreateOrConnectWithoutOrdersInput
    connect?: BotWhereUniqueInput
  }

  export type TradingSignalCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TradingSignalCreateWithoutOrdersInput, TradingSignalUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TradingSignalCreateOrConnectWithoutOrdersInput
    connect?: TradingSignalWhereUniqueInput
  }

  export type AuditTrailCreateNestedManyWithoutOrderInput = {
    create?: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput> | AuditTrailCreateWithoutOrderInput[] | AuditTrailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutOrderInput | AuditTrailCreateOrConnectWithoutOrderInput[]
    createMany?: AuditTrailCreateManyOrderInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type AuditTrailUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput> | AuditTrailCreateWithoutOrderInput[] | AuditTrailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutOrderInput | AuditTrailCreateOrConnectWithoutOrderInput[]
    createMany?: AuditTrailCreateManyOrderInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PositionUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<PositionCreateWithoutOrdersInput, PositionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutOrdersInput
    upsert?: PositionUpsertWithoutOrdersInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutOrdersInput, PositionUpdateWithoutOrdersInput>, PositionUncheckedUpdateWithoutOrdersInput>
  }

  export type TradingStrategyUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<TradingStrategyCreateWithoutOrdersInput, TradingStrategyUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutOrdersInput
    upsert?: TradingStrategyUpsertWithoutOrdersInput
    disconnect?: TradingStrategyWhereInput | boolean
    delete?: TradingStrategyWhereInput | boolean
    connect?: TradingStrategyWhereUniqueInput
    update?: XOR<XOR<TradingStrategyUpdateToOneWithWhereWithoutOrdersInput, TradingStrategyUpdateWithoutOrdersInput>, TradingStrategyUncheckedUpdateWithoutOrdersInput>
  }

  export type BotUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<BotCreateWithoutOrdersInput, BotUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BotCreateOrConnectWithoutOrdersInput
    upsert?: BotUpsertWithoutOrdersInput
    disconnect?: BotWhereInput | boolean
    delete?: BotWhereInput | boolean
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutOrdersInput, BotUpdateWithoutOrdersInput>, BotUncheckedUpdateWithoutOrdersInput>
  }

  export type TradingSignalUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<TradingSignalCreateWithoutOrdersInput, TradingSignalUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TradingSignalCreateOrConnectWithoutOrdersInput
    upsert?: TradingSignalUpsertWithoutOrdersInput
    disconnect?: TradingSignalWhereInput | boolean
    delete?: TradingSignalWhereInput | boolean
    connect?: TradingSignalWhereUniqueInput
    update?: XOR<XOR<TradingSignalUpdateToOneWithWhereWithoutOrdersInput, TradingSignalUpdateWithoutOrdersInput>, TradingSignalUncheckedUpdateWithoutOrdersInput>
  }

  export type AuditTrailUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput> | AuditTrailCreateWithoutOrderInput[] | AuditTrailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutOrderInput | AuditTrailCreateOrConnectWithoutOrderInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutOrderInput | AuditTrailUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AuditTrailCreateManyOrderInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutOrderInput | AuditTrailUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutOrderInput | AuditTrailUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type AuditTrailUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput> | AuditTrailCreateWithoutOrderInput[] | AuditTrailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutOrderInput | AuditTrailCreateOrConnectWithoutOrderInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutOrderInput | AuditTrailUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AuditTrailCreateManyOrderInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutOrderInput | AuditTrailUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutOrderInput | AuditTrailUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type DecisionLogCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDecisionLogsInput = {
    create?: XOR<UserCreateWithoutDecisionLogsInput, UserUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDecisionLogsInput
    connect?: UserWhereUniqueInput
  }

  export type BotCreateNestedOneWithoutDecisionLogsInput = {
    create?: XOR<BotCreateWithoutDecisionLogsInput, BotUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutDecisionLogsInput
    connect?: BotWhereUniqueInput
  }

  export type TradingStrategyCreateNestedOneWithoutDecisionLogsInput = {
    create?: XOR<TradingStrategyCreateWithoutDecisionLogsInput, TradingStrategyUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutDecisionLogsInput
    connect?: TradingStrategyWhereUniqueInput
  }

  export type AuditTrailCreateNestedOneWithoutDecisionLogsInput = {
    create?: XOR<AuditTrailCreateWithoutDecisionLogsInput, AuditTrailUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: AuditTrailCreateOrConnectWithoutDecisionLogsInput
    connect?: AuditTrailWhereUniqueInput
  }

  export type DecisionLogUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutDecisionLogsNestedInput = {
    create?: XOR<UserCreateWithoutDecisionLogsInput, UserUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDecisionLogsInput
    upsert?: UserUpsertWithoutDecisionLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDecisionLogsInput, UserUpdateWithoutDecisionLogsInput>, UserUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type BotUpdateOneWithoutDecisionLogsNestedInput = {
    create?: XOR<BotCreateWithoutDecisionLogsInput, BotUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutDecisionLogsInput
    upsert?: BotUpsertWithoutDecisionLogsInput
    disconnect?: BotWhereInput | boolean
    delete?: BotWhereInput | boolean
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutDecisionLogsInput, BotUpdateWithoutDecisionLogsInput>, BotUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type TradingStrategyUpdateOneWithoutDecisionLogsNestedInput = {
    create?: XOR<TradingStrategyCreateWithoutDecisionLogsInput, TradingStrategyUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: TradingStrategyCreateOrConnectWithoutDecisionLogsInput
    upsert?: TradingStrategyUpsertWithoutDecisionLogsInput
    disconnect?: TradingStrategyWhereInput | boolean
    delete?: TradingStrategyWhereInput | boolean
    connect?: TradingStrategyWhereUniqueInput
    update?: XOR<XOR<TradingStrategyUpdateToOneWithWhereWithoutDecisionLogsInput, TradingStrategyUpdateWithoutDecisionLogsInput>, TradingStrategyUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type AuditTrailUpdateOneWithoutDecisionLogsNestedInput = {
    create?: XOR<AuditTrailCreateWithoutDecisionLogsInput, AuditTrailUncheckedCreateWithoutDecisionLogsInput>
    connectOrCreate?: AuditTrailCreateOrConnectWithoutDecisionLogsInput
    upsert?: AuditTrailUpsertWithoutDecisionLogsInput
    disconnect?: AuditTrailWhereInput | boolean
    delete?: AuditTrailWhereInput | boolean
    connect?: AuditTrailWhereUniqueInput
    update?: XOR<XOR<AuditTrailUpdateToOneWithWhereWithoutDecisionLogsInput, AuditTrailUpdateWithoutDecisionLogsInput>, AuditTrailUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type AuditTrailCreatetagsInput = {
    set: string[]
  }

  export type AuditEventCreateNestedManyWithoutAuditTrailInput = {
    create?: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput> | AuditEventCreateWithoutAuditTrailInput[] | AuditEventUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutAuditTrailInput | AuditEventCreateOrConnectWithoutAuditTrailInput[]
    createMany?: AuditEventCreateManyAuditTrailInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type DecisionLogCreateNestedManyWithoutAuditTrailInput = {
    create?: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput> | DecisionLogCreateWithoutAuditTrailInput[] | DecisionLogUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAuditTrailInput | DecisionLogCreateOrConnectWithoutAuditTrailInput[]
    createMany?: DecisionLogCreateManyAuditTrailInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutAuditTrailsInput = {
    create?: XOR<OrderCreateWithoutAuditTrailsInput, OrderUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAuditTrailsInput
    connect?: OrderWhereUniqueInput
  }

  export type AuditEventUncheckedCreateNestedManyWithoutAuditTrailInput = {
    create?: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput> | AuditEventCreateWithoutAuditTrailInput[] | AuditEventUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutAuditTrailInput | AuditEventCreateOrConnectWithoutAuditTrailInput[]
    createMany?: AuditEventCreateManyAuditTrailInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutAuditTrailInput = {
    create?: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput> | DecisionLogCreateWithoutAuditTrailInput[] | DecisionLogUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAuditTrailInput | DecisionLogCreateOrConnectWithoutAuditTrailInput[]
    createMany?: DecisionLogCreateManyAuditTrailInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type AuditTrailUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AuditEventUpdateManyWithoutAuditTrailNestedInput = {
    create?: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput> | AuditEventCreateWithoutAuditTrailInput[] | AuditEventUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutAuditTrailInput | AuditEventCreateOrConnectWithoutAuditTrailInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutAuditTrailInput | AuditEventUpsertWithWhereUniqueWithoutAuditTrailInput[]
    createMany?: AuditEventCreateManyAuditTrailInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutAuditTrailInput | AuditEventUpdateWithWhereUniqueWithoutAuditTrailInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutAuditTrailInput | AuditEventUpdateManyWithWhereWithoutAuditTrailInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type DecisionLogUpdateManyWithoutAuditTrailNestedInput = {
    create?: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput> | DecisionLogCreateWithoutAuditTrailInput[] | DecisionLogUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAuditTrailInput | DecisionLogCreateOrConnectWithoutAuditTrailInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutAuditTrailInput | DecisionLogUpsertWithWhereUniqueWithoutAuditTrailInput[]
    createMany?: DecisionLogCreateManyAuditTrailInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutAuditTrailInput | DecisionLogUpdateWithWhereUniqueWithoutAuditTrailInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutAuditTrailInput | DecisionLogUpdateManyWithWhereWithoutAuditTrailInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutAuditTrailsNestedInput = {
    create?: XOR<OrderCreateWithoutAuditTrailsInput, OrderUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAuditTrailsInput
    upsert?: OrderUpsertWithoutAuditTrailsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAuditTrailsInput, OrderUpdateWithoutAuditTrailsInput>, OrderUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type AuditEventUncheckedUpdateManyWithoutAuditTrailNestedInput = {
    create?: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput> | AuditEventCreateWithoutAuditTrailInput[] | AuditEventUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutAuditTrailInput | AuditEventCreateOrConnectWithoutAuditTrailInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutAuditTrailInput | AuditEventUpsertWithWhereUniqueWithoutAuditTrailInput[]
    createMany?: AuditEventCreateManyAuditTrailInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutAuditTrailInput | AuditEventUpdateWithWhereUniqueWithoutAuditTrailInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutAuditTrailInput | AuditEventUpdateManyWithWhereWithoutAuditTrailInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutAuditTrailNestedInput = {
    create?: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput> | DecisionLogCreateWithoutAuditTrailInput[] | DecisionLogUncheckedCreateWithoutAuditTrailInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAuditTrailInput | DecisionLogCreateOrConnectWithoutAuditTrailInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutAuditTrailInput | DecisionLogUpsertWithWhereUniqueWithoutAuditTrailInput[]
    createMany?: DecisionLogCreateManyAuditTrailInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutAuditTrailInput | DecisionLogUpdateWithWhereUniqueWithoutAuditTrailInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutAuditTrailInput | DecisionLogUpdateManyWithWhereWithoutAuditTrailInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type AuditTrailCreateNestedOneWithoutEventsInput = {
    create?: XOR<AuditTrailCreateWithoutEventsInput, AuditTrailUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AuditTrailCreateOrConnectWithoutEventsInput
    connect?: AuditTrailWhereUniqueInput
  }

  export type AuditTrailUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<AuditTrailCreateWithoutEventsInput, AuditTrailUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AuditTrailCreateOrConnectWithoutEventsInput
    upsert?: AuditTrailUpsertWithoutEventsInput
    connect?: AuditTrailWhereUniqueInput
    update?: XOR<XOR<AuditTrailUpdateToOneWithWhereWithoutEventsInput, AuditTrailUpdateWithoutEventsInput>, AuditTrailUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    key: string
    encryptedData: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    key: string
    encryptedData: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeLogCreateWithoutUserInput = {
    id?: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
  }

  export type TradeLogUncheckedCreateWithoutUserInput = {
    id?: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
  }

  export type TradeLogCreateOrConnectWithoutUserInput = {
    where: TradeLogWhereUniqueInput
    create: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput>
  }

  export type TradeLogCreateManyUserInputEnvelope = {
    data: TradeLogCreateManyUserInput | TradeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BotCreateWithoutUserInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutBotInput
    orders?: OrderCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionUncheckedCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutBotInput
    orders?: OrderUncheckedCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutUserInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput>
  }

  export type BotCreateManyUserInputEnvelope = {
    data: BotCreateManyUserInput | BotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutUserInput = {
    id?: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bot?: BotCreateNestedOneWithoutPositionsInput
    orders?: OrderCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutUserInput = {
    id?: string
    botId?: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutUserInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput>
  }

  export type PositionCreateManyUserInputEnvelope = {
    data: PositionCreateManyUserInput | PositionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RiskSettingsCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot?: BotCreateNestedOneWithoutRiskSettingsInput
  }

  export type RiskSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    botId?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskSettingsCreateOrConnectWithoutUserInput = {
    where: RiskSettingsWhereUniqueInput
    create: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput>
  }

  export type RiskSettingsCreateManyUserInputEnvelope = {
    data: RiskSettingsCreateManyUserInput | RiskSettingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RiskAlertCreateWithoutUserInput = {
    id?: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
  }

  export type RiskAlertUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
  }

  export type RiskAlertCreateOrConnectWithoutUserInput = {
    where: RiskAlertWhereUniqueInput
    create: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput>
  }

  export type RiskAlertCreateManyUserInputEnvelope = {
    data: RiskAlertCreateManyUserInput | RiskAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    position?: PositionCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DecisionLogCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    bot?: BotCreateNestedOneWithoutDecisionLogsInput
    strategy?: TradingStrategyCreateNestedOneWithoutDecisionLogsInput
    auditTrail?: AuditTrailCreateNestedOneWithoutDecisionLogsInput
  }

  export type DecisionLogUncheckedCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type DecisionLogCreateOrConnectWithoutUserInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput>
  }

  export type DecisionLogCreateManyUserInputEnvelope = {
    data: DecisionLogCreateManyUserInput | DecisionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    encryptedData?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    scopes?: StringFilter<"ApiKey"> | string
    expiry?: DateTimeFilter<"ApiKey"> | Date | string
    environment?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isRevoked?: BoolFilter<"ApiKey"> | boolean
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedBy?: StringNullableFilter<"ApiKey"> | string | null
    revokedReason?: StringNullableFilter<"ApiKey"> | string | null
    ipRestrictions?: StringNullableFilter<"ApiKey"> | string | null
    hashedSecret?: StringNullableFilter<"ApiKey"> | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    isDefault?: BoolFilter<"ApiKey"> | boolean
    rateLimits?: JsonNullableFilter<"ApiKey">
    metadata?: JsonNullableFilter<"ApiKey">
  }

  export type TradeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TradeLogWhereUniqueInput
    update: XOR<TradeLogUpdateWithoutUserInput, TradeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TradeLogCreateWithoutUserInput, TradeLogUncheckedCreateWithoutUserInput>
  }

  export type TradeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TradeLogWhereUniqueInput
    data: XOR<TradeLogUpdateWithoutUserInput, TradeLogUncheckedUpdateWithoutUserInput>
  }

  export type TradeLogUpdateManyWithWhereWithoutUserInput = {
    where: TradeLogScalarWhereInput
    data: XOR<TradeLogUpdateManyMutationInput, TradeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TradeLogScalarWhereInput = {
    AND?: TradeLogScalarWhereInput | TradeLogScalarWhereInput[]
    OR?: TradeLogScalarWhereInput[]
    NOT?: TradeLogScalarWhereInput | TradeLogScalarWhereInput[]
    id?: StringFilter<"TradeLog"> | string
    userId?: StringFilter<"TradeLog"> | string
    instrument?: StringFilter<"TradeLog"> | string
    amount?: FloatFilter<"TradeLog"> | number
    price?: FloatFilter<"TradeLog"> | number
    timestamp?: DateTimeFilter<"TradeLog"> | Date | string
    orderId?: StringNullableFilter<"TradeLog"> | string | null
    type?: StringFilter<"TradeLog"> | string
    status?: StringFilter<"TradeLog"> | string
  }

  export type BotUpsertWithWhereUniqueWithoutUserInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutUserInput, BotUncheckedUpdateWithoutUserInput>
    create: XOR<BotCreateWithoutUserInput, BotUncheckedCreateWithoutUserInput>
  }

  export type BotUpdateWithWhereUniqueWithoutUserInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutUserInput, BotUncheckedUpdateWithoutUserInput>
  }

  export type BotUpdateManyWithWhereWithoutUserInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutUserInput>
  }

  export type BotScalarWhereInput = {
    AND?: BotScalarWhereInput | BotScalarWhereInput[]
    OR?: BotScalarWhereInput[]
    NOT?: BotScalarWhereInput | BotScalarWhereInput[]
    id?: StringFilter<"Bot"> | string
    userId?: StringFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    symbol?: StringFilter<"Bot"> | string
    strategy?: StringFilter<"Bot"> | string
    timeframe?: StringFilter<"Bot"> | string
    parameters?: JsonFilter<"Bot">
    isActive?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
  }

  export type PositionUpsertWithWhereUniqueWithoutUserInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutUserInput, PositionUncheckedUpdateWithoutUserInput>
    create: XOR<PositionCreateWithoutUserInput, PositionUncheckedCreateWithoutUserInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutUserInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutUserInput, PositionUncheckedUpdateWithoutUserInput>
  }

  export type PositionUpdateManyWithWhereWithoutUserInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutUserInput>
  }

  export type PositionScalarWhereInput = {
    AND?: PositionScalarWhereInput | PositionScalarWhereInput[]
    OR?: PositionScalarWhereInput[]
    NOT?: PositionScalarWhereInput | PositionScalarWhereInput[]
    id?: StringFilter<"Position"> | string
    userId?: StringFilter<"Position"> | string
    botId?: StringNullableFilter<"Position"> | string | null
    symbol?: StringFilter<"Position"> | string
    side?: StringFilter<"Position"> | string
    entryPrice?: FloatFilter<"Position"> | number
    currentPrice?: FloatNullableFilter<"Position"> | number | null
    amount?: FloatFilter<"Position"> | number
    leverage?: FloatFilter<"Position"> | number
    takeProfitPrice?: FloatNullableFilter<"Position"> | number | null
    stopLossPrice?: FloatNullableFilter<"Position"> | number | null
    status?: StringFilter<"Position"> | string
    pnl?: FloatNullableFilter<"Position"> | number | null
    openedAt?: DateTimeFilter<"Position"> | Date | string
    closedAt?: DateTimeNullableFilter<"Position"> | Date | string | null
    metadata?: JsonNullableFilter<"Position">
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    deviceId?: StringNullableFilter<"Session"> | string | null
    isValid?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    rememberMe?: BoolFilter<"Session"> | boolean
    metadata?: JsonNullableFilter<"Session">
  }

  export type RiskSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: RiskSettingsWhereUniqueInput
    update: XOR<RiskSettingsUpdateWithoutUserInput, RiskSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<RiskSettingsCreateWithoutUserInput, RiskSettingsUncheckedCreateWithoutUserInput>
  }

  export type RiskSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: RiskSettingsWhereUniqueInput
    data: XOR<RiskSettingsUpdateWithoutUserInput, RiskSettingsUncheckedUpdateWithoutUserInput>
  }

  export type RiskSettingsUpdateManyWithWhereWithoutUserInput = {
    where: RiskSettingsScalarWhereInput
    data: XOR<RiskSettingsUpdateManyMutationInput, RiskSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type RiskSettingsScalarWhereInput = {
    AND?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
    OR?: RiskSettingsScalarWhereInput[]
    NOT?: RiskSettingsScalarWhereInput | RiskSettingsScalarWhereInput[]
    id?: StringFilter<"RiskSettings"> | string
    name?: StringFilter<"RiskSettings"> | string
    description?: StringNullableFilter<"RiskSettings"> | string | null
    userId?: StringFilter<"RiskSettings"> | string
    botId?: StringNullableFilter<"RiskSettings"> | string | null
    isActive?: BoolFilter<"RiskSettings"> | boolean
    positionSizingMethod?: StringFilter<"RiskSettings"> | string
    riskPercentage?: FloatFilter<"RiskSettings"> | number
    maxPositionSize?: FloatFilter<"RiskSettings"> | number
    kellyFraction?: FloatNullableFilter<"RiskSettings"> | number | null
    winRate?: FloatNullableFilter<"RiskSettings"> | number | null
    customSizingParams?: JsonNullableFilter<"RiskSettings">
    stopLossType?: StringFilter<"RiskSettings"> | string
    stopLossValue?: FloatFilter<"RiskSettings"> | number
    trailingCallback?: FloatNullableFilter<"RiskSettings"> | number | null
    trailingStep?: FloatNullableFilter<"RiskSettings"> | number | null
    timeLimit?: IntNullableFilter<"RiskSettings"> | number | null
    stopLossLevels?: JsonNullableFilter<"RiskSettings">
    takeProfitType?: StringFilter<"RiskSettings"> | string
    takeProfitValue?: FloatFilter<"RiskSettings"> | number
    trailingActivation?: FloatNullableFilter<"RiskSettings"> | number | null
    takeProfitLevels?: JsonNullableFilter<"RiskSettings">
    maxRiskPerTrade?: FloatFilter<"RiskSettings"> | number
    maxRiskPerSymbol?: FloatFilter<"RiskSettings"> | number
    maxRiskPerDirection?: FloatFilter<"RiskSettings"> | number
    maxTotalRisk?: FloatFilter<"RiskSettings"> | number
    maxDrawdown?: FloatFilter<"RiskSettings"> | number
    maxPositions?: IntFilter<"RiskSettings"> | number
    maxDailyLoss?: FloatFilter<"RiskSettings"> | number
    cooldownPeriod?: IntFilter<"RiskSettings"> | number
    volatilityLookback?: IntFilter<"RiskSettings"> | number
    circuitBreakerEnabled?: BoolFilter<"RiskSettings"> | boolean
    maxDailyLossBreaker?: FloatFilter<"RiskSettings"> | number
    maxDrawdownBreaker?: FloatFilter<"RiskSettings"> | number
    volatilityMultiplier?: FloatFilter<"RiskSettings"> | number
    consecutiveLossesBreaker?: IntFilter<"RiskSettings"> | number
    tradingPause?: IntFilter<"RiskSettings"> | number
    marketWideEnabled?: BoolFilter<"RiskSettings"> | boolean
    enableManualOverride?: BoolFilter<"RiskSettings"> | boolean
    createdAt?: DateTimeFilter<"RiskSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RiskSettings"> | Date | string
  }

  export type RiskAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: RiskAlertWhereUniqueInput
    update: XOR<RiskAlertUpdateWithoutUserInput, RiskAlertUncheckedUpdateWithoutUserInput>
    create: XOR<RiskAlertCreateWithoutUserInput, RiskAlertUncheckedCreateWithoutUserInput>
  }

  export type RiskAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: RiskAlertWhereUniqueInput
    data: XOR<RiskAlertUpdateWithoutUserInput, RiskAlertUncheckedUpdateWithoutUserInput>
  }

  export type RiskAlertUpdateManyWithWhereWithoutUserInput = {
    where: RiskAlertScalarWhereInput
    data: XOR<RiskAlertUpdateManyMutationInput, RiskAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type RiskAlertScalarWhereInput = {
    AND?: RiskAlertScalarWhereInput | RiskAlertScalarWhereInput[]
    OR?: RiskAlertScalarWhereInput[]
    NOT?: RiskAlertScalarWhereInput | RiskAlertScalarWhereInput[]
    id?: StringFilter<"RiskAlert"> | string
    userId?: StringFilter<"RiskAlert"> | string
    type?: StringFilter<"RiskAlert"> | string
    level?: StringFilter<"RiskAlert"> | string
    message?: StringFilter<"RiskAlert"> | string
    details?: JsonFilter<"RiskAlert">
    timestamp?: DateTimeFilter<"RiskAlert"> | Date | string
    acknowledged?: BoolFilter<"RiskAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"RiskAlert"> | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    symbol?: StringFilter<"Order"> | string
    type?: StringFilter<"Order"> | string
    side?: StringFilter<"Order"> | string
    quantity?: FloatFilter<"Order"> | number
    price?: FloatNullableFilter<"Order"> | number | null
    stopPrice?: FloatNullableFilter<"Order"> | number | null
    avgFillPrice?: FloatNullableFilter<"Order"> | number | null
    filledQuantity?: FloatFilter<"Order"> | number
    remainingQuantity?: FloatFilter<"Order"> | number
    fee?: FloatNullableFilter<"Order"> | number | null
    feeCurrency?: StringNullableFilter<"Order"> | string | null
    clientOrderId?: StringNullableFilter<"Order"> | string | null
    exchangeOrderId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    exchangeId?: StringFilter<"Order"> | string
    submittedAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    errorCode?: StringNullableFilter<"Order"> | string | null
    errorMessage?: StringNullableFilter<"Order"> | string | null
    errorDetails?: JsonNullableFilter<"Order">
    raw?: JsonNullableFilter<"Order">
    userId?: StringFilter<"Order"> | string
    positionId?: StringNullableFilter<"Order"> | string | null
    strategyId?: StringNullableFilter<"Order"> | string | null
    botId?: StringNullableFilter<"Order"> | string | null
    signalId?: StringNullableFilter<"Order"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutUserInput, DecisionLogUncheckedUpdateWithoutUserInput>
    create: XOR<DecisionLogCreateWithoutUserInput, DecisionLogUncheckedCreateWithoutUserInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutUserInput, DecisionLogUncheckedUpdateWithoutUserInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutUserInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type DecisionLogScalarWhereInput = {
    AND?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
    OR?: DecisionLogScalarWhereInput[]
    NOT?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
    id?: StringFilter<"DecisionLog"> | string
    timestamp?: DateTimeFilter<"DecisionLog"> | Date | string
    source?: StringFilter<"DecisionLog"> | string
    actionType?: StringFilter<"DecisionLog"> | string
    decision?: StringFilter<"DecisionLog"> | string
    reasonDetails?: StringNullableFilter<"DecisionLog"> | string | null
    userId?: StringNullableFilter<"DecisionLog"> | string | null
    botId?: StringNullableFilter<"DecisionLog"> | string | null
    strategyId?: StringNullableFilter<"DecisionLog"> | string | null
    symbol?: StringNullableFilter<"DecisionLog"> | string | null
    orderId?: StringNullableFilter<"DecisionLog"> | string | null
    positionId?: StringNullableFilter<"DecisionLog"> | string | null
    importance?: StringFilter<"DecisionLog"> | string
    metadata?: JsonFilter<"DecisionLog">
    tags?: StringNullableListFilter<"DecisionLog">
    auditTrailId?: StringNullableFilter<"DecisionLog"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTradeLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTradeLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTradeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradeLogsInput, UserUncheckedCreateWithoutTradeLogsInput>
  }

  export type UserUpsertWithoutTradeLogsInput = {
    update: XOR<UserUpdateWithoutTradeLogsInput, UserUncheckedUpdateWithoutTradeLogsInput>
    create: XOR<UserCreateWithoutTradeLogsInput, UserUncheckedCreateWithoutTradeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradeLogsInput, UserUncheckedUpdateWithoutTradeLogsInput>
  }

  export type UserUpdateWithoutTradeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTradeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBotsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBotsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBotsInput, UserUncheckedCreateWithoutBotsInput>
  }

  export type PositionCreateWithoutBotInput = {
    id?: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPositionsInput
    orders?: OrderCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutBotInput = {
    id?: string
    userId: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutBotInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput>
  }

  export type PositionCreateManyBotInputEnvelope = {
    data: PositionCreateManyBotInput | PositionCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type RiskSettingsCreateWithoutBotInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRiskSettingsInput
  }

  export type RiskSettingsUncheckedCreateWithoutBotInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskSettingsCreateOrConnectWithoutBotInput = {
    where: RiskSettingsWhereUniqueInput
    create: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput>
  }

  export type RiskSettingsCreateManyBotInputEnvelope = {
    data: RiskSettingsCreateManyBotInput | RiskSettingsCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutBotInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    position?: PositionCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutBotInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    signalId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBotInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput>
  }

  export type OrderCreateManyBotInputEnvelope = {
    data: OrderCreateManyBotInput | OrderCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type DecisionLogCreateWithoutBotInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    user?: UserCreateNestedOneWithoutDecisionLogsInput
    strategy?: TradingStrategyCreateNestedOneWithoutDecisionLogsInput
    auditTrail?: AuditTrailCreateNestedOneWithoutDecisionLogsInput
  }

  export type DecisionLogUncheckedCreateWithoutBotInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type DecisionLogCreateOrConnectWithoutBotInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput>
  }

  export type DecisionLogCreateManyBotInputEnvelope = {
    data: DecisionLogCreateManyBotInput | DecisionLogCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBotsInput = {
    update: XOR<UserUpdateWithoutBotsInput, UserUncheckedUpdateWithoutBotsInput>
    create: XOR<UserCreateWithoutBotsInput, UserUncheckedCreateWithoutBotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBotsInput, UserUncheckedUpdateWithoutBotsInput>
  }

  export type UserUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PositionUpsertWithWhereUniqueWithoutBotInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutBotInput, PositionUncheckedUpdateWithoutBotInput>
    create: XOR<PositionCreateWithoutBotInput, PositionUncheckedCreateWithoutBotInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutBotInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutBotInput, PositionUncheckedUpdateWithoutBotInput>
  }

  export type PositionUpdateManyWithWhereWithoutBotInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutBotInput>
  }

  export type RiskSettingsUpsertWithWhereUniqueWithoutBotInput = {
    where: RiskSettingsWhereUniqueInput
    update: XOR<RiskSettingsUpdateWithoutBotInput, RiskSettingsUncheckedUpdateWithoutBotInput>
    create: XOR<RiskSettingsCreateWithoutBotInput, RiskSettingsUncheckedCreateWithoutBotInput>
  }

  export type RiskSettingsUpdateWithWhereUniqueWithoutBotInput = {
    where: RiskSettingsWhereUniqueInput
    data: XOR<RiskSettingsUpdateWithoutBotInput, RiskSettingsUncheckedUpdateWithoutBotInput>
  }

  export type RiskSettingsUpdateManyWithWhereWithoutBotInput = {
    where: RiskSettingsScalarWhereInput
    data: XOR<RiskSettingsUpdateManyMutationInput, RiskSettingsUncheckedUpdateManyWithoutBotInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutBotInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBotInput, OrderUncheckedUpdateWithoutBotInput>
    create: XOR<OrderCreateWithoutBotInput, OrderUncheckedCreateWithoutBotInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBotInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBotInput, OrderUncheckedUpdateWithoutBotInput>
  }

  export type OrderUpdateManyWithWhereWithoutBotInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutBotInput>
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutBotInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutBotInput, DecisionLogUncheckedUpdateWithoutBotInput>
    create: XOR<DecisionLogCreateWithoutBotInput, DecisionLogUncheckedCreateWithoutBotInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutBotInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutBotInput, DecisionLogUncheckedUpdateWithoutBotInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutBotInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutBotInput>
  }

  export type UserCreateWithoutPositionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPositionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPositionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPositionsInput, UserUncheckedCreateWithoutPositionsInput>
  }

  export type BotCreateWithoutPositionsInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBotsInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutBotInput
    orders?: OrderCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutPositionsInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutBotInput
    orders?: OrderUncheckedCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutPositionsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutPositionsInput, BotUncheckedCreateWithoutPositionsInput>
  }

  export type OrderCreateWithoutPositionInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPositionInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPositionInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput>
  }

  export type OrderCreateManyPositionInputEnvelope = {
    data: OrderCreateManyPositionInput | OrderCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPositionsInput = {
    update: XOR<UserUpdateWithoutPositionsInput, UserUncheckedUpdateWithoutPositionsInput>
    create: XOR<UserCreateWithoutPositionsInput, UserUncheckedCreateWithoutPositionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPositionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPositionsInput, UserUncheckedUpdateWithoutPositionsInput>
  }

  export type UserUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotUpsertWithoutPositionsInput = {
    update: XOR<BotUpdateWithoutPositionsInput, BotUncheckedUpdateWithoutPositionsInput>
    create: XOR<BotCreateWithoutPositionsInput, BotUncheckedCreateWithoutPositionsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutPositionsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutPositionsInput, BotUncheckedUpdateWithoutPositionsInput>
  }

  export type BotUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBotsNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutBotNestedInput
    orders?: OrderUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutBotNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutPositionInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPositionInput, OrderUncheckedUpdateWithoutPositionInput>
    create: XOR<OrderCreateWithoutPositionInput, OrderUncheckedCreateWithoutPositionInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPositionInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPositionInput, OrderUncheckedUpdateWithoutPositionInput>
  }

  export type OrderUpdateManyWithWhereWithoutPositionInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPositionInput>
  }

  export type OrderCreateWithoutSignalInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    position?: PositionCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSignalInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSignalInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput>
  }

  export type OrderCreateManySignalInputEnvelope = {
    data: OrderCreateManySignalInput | OrderCreateManySignalInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutSignalInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSignalInput, OrderUncheckedUpdateWithoutSignalInput>
    create: XOR<OrderCreateWithoutSignalInput, OrderUncheckedCreateWithoutSignalInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSignalInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSignalInput, OrderUncheckedUpdateWithoutSignalInput>
  }

  export type OrderUpdateManyWithWhereWithoutSignalInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSignalInput>
  }

  export type UserCreateWithoutRiskSettingsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRiskSettingsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRiskSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRiskSettingsInput, UserUncheckedCreateWithoutRiskSettingsInput>
  }

  export type BotCreateWithoutRiskSettingsInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBotsInput
    positions?: PositionCreateNestedManyWithoutBotInput
    orders?: OrderCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutRiskSettingsInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionUncheckedCreateNestedManyWithoutBotInput
    orders?: OrderUncheckedCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutRiskSettingsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutRiskSettingsInput, BotUncheckedCreateWithoutRiskSettingsInput>
  }

  export type UserUpsertWithoutRiskSettingsInput = {
    update: XOR<UserUpdateWithoutRiskSettingsInput, UserUncheckedUpdateWithoutRiskSettingsInput>
    create: XOR<UserCreateWithoutRiskSettingsInput, UserUncheckedCreateWithoutRiskSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRiskSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRiskSettingsInput, UserUncheckedUpdateWithoutRiskSettingsInput>
  }

  export type UserUpdateWithoutRiskSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRiskSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotUpsertWithoutRiskSettingsInput = {
    update: XOR<BotUpdateWithoutRiskSettingsInput, BotUncheckedUpdateWithoutRiskSettingsInput>
    create: XOR<BotCreateWithoutRiskSettingsInput, BotUncheckedCreateWithoutRiskSettingsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutRiskSettingsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutRiskSettingsInput, BotUncheckedUpdateWithoutRiskSettingsInput>
  }

  export type BotUpdateWithoutRiskSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBotsNestedInput
    positions?: PositionUpdateManyWithoutBotNestedInput
    orders?: OrderUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutRiskSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUncheckedUpdateManyWithoutBotNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type UserCreateWithoutRiskAlertsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRiskAlertsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRiskAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRiskAlertsInput, UserUncheckedCreateWithoutRiskAlertsInput>
  }

  export type UserUpsertWithoutRiskAlertsInput = {
    update: XOR<UserUpdateWithoutRiskAlertsInput, UserUncheckedUpdateWithoutRiskAlertsInput>
    create: XOR<UserCreateWithoutRiskAlertsInput, UserUncheckedCreateWithoutRiskAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRiskAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRiskAlertsInput, UserUncheckedUpdateWithoutRiskAlertsInput>
  }

  export type UserUpdateWithoutRiskAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRiskAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StrategyExecutionCreateWithoutStrategyInput = {
    id?: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: StrategyExecutionResultCreateNestedManyWithoutExecutionInput
  }

  export type StrategyExecutionUncheckedCreateWithoutStrategyInput = {
    id?: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: StrategyExecutionResultUncheckedCreateNestedManyWithoutExecutionInput
  }

  export type StrategyExecutionCreateOrConnectWithoutStrategyInput = {
    where: StrategyExecutionWhereUniqueInput
    create: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyExecutionCreateManyStrategyInputEnvelope = {
    data: StrategyExecutionCreateManyStrategyInput | StrategyExecutionCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutStrategyInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    position?: PositionCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStrategyInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    botId?: string | null
    signalId?: string | null
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStrategyInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput>
  }

  export type OrderCreateManyStrategyInputEnvelope = {
    data: OrderCreateManyStrategyInput | OrderCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type DecisionLogCreateWithoutStrategyInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    user?: UserCreateNestedOneWithoutDecisionLogsInput
    bot?: BotCreateNestedOneWithoutDecisionLogsInput
    auditTrail?: AuditTrailCreateNestedOneWithoutDecisionLogsInput
  }

  export type DecisionLogUncheckedCreateWithoutStrategyInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type DecisionLogCreateOrConnectWithoutStrategyInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput>
  }

  export type DecisionLogCreateManyStrategyInputEnvelope = {
    data: DecisionLogCreateManyStrategyInput | DecisionLogCreateManyStrategyInput[]
    skipDuplicates?: boolean
  }

  export type StrategyExecutionUpsertWithWhereUniqueWithoutStrategyInput = {
    where: StrategyExecutionWhereUniqueInput
    update: XOR<StrategyExecutionUpdateWithoutStrategyInput, StrategyExecutionUncheckedUpdateWithoutStrategyInput>
    create: XOR<StrategyExecutionCreateWithoutStrategyInput, StrategyExecutionUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyExecutionUpdateWithWhereUniqueWithoutStrategyInput = {
    where: StrategyExecutionWhereUniqueInput
    data: XOR<StrategyExecutionUpdateWithoutStrategyInput, StrategyExecutionUncheckedUpdateWithoutStrategyInput>
  }

  export type StrategyExecutionUpdateManyWithWhereWithoutStrategyInput = {
    where: StrategyExecutionScalarWhereInput
    data: XOR<StrategyExecutionUpdateManyMutationInput, StrategyExecutionUncheckedUpdateManyWithoutStrategyInput>
  }

  export type StrategyExecutionScalarWhereInput = {
    AND?: StrategyExecutionScalarWhereInput | StrategyExecutionScalarWhereInput[]
    OR?: StrategyExecutionScalarWhereInput[]
    NOT?: StrategyExecutionScalarWhereInput | StrategyExecutionScalarWhereInput[]
    id?: StringFilter<"StrategyExecution"> | string
    strategyId?: StringFilter<"StrategyExecution"> | string
    userId?: StringFilter<"StrategyExecution"> | string
    status?: StringFilter<"StrategyExecution"> | string
    startedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    stoppedAt?: DateTimeNullableFilter<"StrategyExecution"> | Date | string | null
    runningTimeMs?: IntNullableFilter<"StrategyExecution"> | number | null
    metadata?: JsonNullableFilter<"StrategyExecution">
    createdAt?: DateTimeFilter<"StrategyExecution"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecution"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutStrategyInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStrategyInput, OrderUncheckedUpdateWithoutStrategyInput>
    create: XOR<OrderCreateWithoutStrategyInput, OrderUncheckedCreateWithoutStrategyInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStrategyInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStrategyInput, OrderUncheckedUpdateWithoutStrategyInput>
  }

  export type OrderUpdateManyWithWhereWithoutStrategyInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStrategyInput>
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutStrategyInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutStrategyInput, DecisionLogUncheckedUpdateWithoutStrategyInput>
    create: XOR<DecisionLogCreateWithoutStrategyInput, DecisionLogUncheckedCreateWithoutStrategyInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutStrategyInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutStrategyInput, DecisionLogUncheckedUpdateWithoutStrategyInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutStrategyInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutStrategyInput>
  }

  export type TradingStrategyCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyCreateOrConnectWithoutExecutionsInput = {
    where: TradingStrategyWhereUniqueInput
    create: XOR<TradingStrategyCreateWithoutExecutionsInput, TradingStrategyUncheckedCreateWithoutExecutionsInput>
  }

  export type StrategyExecutionResultCreateWithoutExecutionInput = {
    id?: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionResultUncheckedCreateWithoutExecutionInput = {
    id?: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionResultCreateOrConnectWithoutExecutionInput = {
    where: StrategyExecutionResultWhereUniqueInput
    create: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput>
  }

  export type StrategyExecutionResultCreateManyExecutionInputEnvelope = {
    data: StrategyExecutionResultCreateManyExecutionInput | StrategyExecutionResultCreateManyExecutionInput[]
    skipDuplicates?: boolean
  }

  export type TradingStrategyUpsertWithoutExecutionsInput = {
    update: XOR<TradingStrategyUpdateWithoutExecutionsInput, TradingStrategyUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TradingStrategyCreateWithoutExecutionsInput, TradingStrategyUncheckedCreateWithoutExecutionsInput>
    where?: TradingStrategyWhereInput
  }

  export type TradingStrategyUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TradingStrategyWhereInput
    data: XOR<TradingStrategyUpdateWithoutExecutionsInput, TradingStrategyUncheckedUpdateWithoutExecutionsInput>
  }

  export type TradingStrategyUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutStrategyNestedInput
  }

  export type TradingStrategyUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type StrategyExecutionResultUpsertWithWhereUniqueWithoutExecutionInput = {
    where: StrategyExecutionResultWhereUniqueInput
    update: XOR<StrategyExecutionResultUpdateWithoutExecutionInput, StrategyExecutionResultUncheckedUpdateWithoutExecutionInput>
    create: XOR<StrategyExecutionResultCreateWithoutExecutionInput, StrategyExecutionResultUncheckedCreateWithoutExecutionInput>
  }

  export type StrategyExecutionResultUpdateWithWhereUniqueWithoutExecutionInput = {
    where: StrategyExecutionResultWhereUniqueInput
    data: XOR<StrategyExecutionResultUpdateWithoutExecutionInput, StrategyExecutionResultUncheckedUpdateWithoutExecutionInput>
  }

  export type StrategyExecutionResultUpdateManyWithWhereWithoutExecutionInput = {
    where: StrategyExecutionResultScalarWhereInput
    data: XOR<StrategyExecutionResultUpdateManyMutationInput, StrategyExecutionResultUncheckedUpdateManyWithoutExecutionInput>
  }

  export type StrategyExecutionResultScalarWhereInput = {
    AND?: StrategyExecutionResultScalarWhereInput | StrategyExecutionResultScalarWhereInput[]
    OR?: StrategyExecutionResultScalarWhereInput[]
    NOT?: StrategyExecutionResultScalarWhereInput | StrategyExecutionResultScalarWhereInput[]
    id?: StringFilter<"StrategyExecutionResult"> | string
    executionId?: StringFilter<"StrategyExecutionResult"> | string
    symbol?: StringFilter<"StrategyExecutionResult"> | string
    entryTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    entryPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    exitTime?: DateTimeNullableFilter<"StrategyExecutionResult"> | Date | string | null
    exitPrice?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    direction?: StringFilter<"StrategyExecutionResult"> | string
    quantity?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLoss?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    profitLossPercentage?: FloatNullableFilter<"StrategyExecutionResult"> | number | null
    status?: StringFilter<"StrategyExecutionResult"> | string
    metadata?: JsonNullableFilter<"StrategyExecutionResult">
    createdAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
    updatedAt?: DateTimeFilter<"StrategyExecutionResult"> | Date | string
  }

  export type StrategyExecutionCreateWithoutResultsInput = {
    id?: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    strategy: TradingStrategyCreateNestedOneWithoutExecutionsInput
  }

  export type StrategyExecutionUncheckedCreateWithoutResultsInput = {
    id?: string
    strategyId: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionCreateOrConnectWithoutResultsInput = {
    where: StrategyExecutionWhereUniqueInput
    create: XOR<StrategyExecutionCreateWithoutResultsInput, StrategyExecutionUncheckedCreateWithoutResultsInput>
  }

  export type StrategyExecutionUpsertWithoutResultsInput = {
    update: XOR<StrategyExecutionUpdateWithoutResultsInput, StrategyExecutionUncheckedUpdateWithoutResultsInput>
    create: XOR<StrategyExecutionCreateWithoutResultsInput, StrategyExecutionUncheckedCreateWithoutResultsInput>
    where?: StrategyExecutionWhereInput
  }

  export type StrategyExecutionUpdateToOneWithWhereWithoutResultsInput = {
    where?: StrategyExecutionWhereInput
    data: XOR<StrategyExecutionUpdateWithoutResultsInput, StrategyExecutionUncheckedUpdateWithoutResultsInput>
  }

  export type StrategyExecutionUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    strategy?: TradingStrategyUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type StrategyExecutionUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionCreateWithoutModelInput = {
    id?: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLPredictionUncheckedCreateWithoutModelInput = {
    id?: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLPredictionCreateOrConnectWithoutModelInput = {
    where: MLPredictionWhereUniqueInput
    create: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput>
  }

  export type MLPredictionCreateManyModelInputEnvelope = {
    data: MLPredictionCreateManyModelInput | MLPredictionCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type MLPredictionUpsertWithWhereUniqueWithoutModelInput = {
    where: MLPredictionWhereUniqueInput
    update: XOR<MLPredictionUpdateWithoutModelInput, MLPredictionUncheckedUpdateWithoutModelInput>
    create: XOR<MLPredictionCreateWithoutModelInput, MLPredictionUncheckedCreateWithoutModelInput>
  }

  export type MLPredictionUpdateWithWhereUniqueWithoutModelInput = {
    where: MLPredictionWhereUniqueInput
    data: XOR<MLPredictionUpdateWithoutModelInput, MLPredictionUncheckedUpdateWithoutModelInput>
  }

  export type MLPredictionUpdateManyWithWhereWithoutModelInput = {
    where: MLPredictionScalarWhereInput
    data: XOR<MLPredictionUpdateManyMutationInput, MLPredictionUncheckedUpdateManyWithoutModelInput>
  }

  export type MLPredictionScalarWhereInput = {
    AND?: MLPredictionScalarWhereInput | MLPredictionScalarWhereInput[]
    OR?: MLPredictionScalarWhereInput[]
    NOT?: MLPredictionScalarWhereInput | MLPredictionScalarWhereInput[]
    id?: StringFilter<"MLPrediction"> | string
    modelId?: StringFilter<"MLPrediction"> | string
    symbol?: StringFilter<"MLPrediction"> | string
    timeframe?: StringFilter<"MLPrediction"> | string
    predictionType?: StringFilter<"MLPrediction"> | string
    values?: FloatNullableListFilter<"MLPrediction">
    timestamps?: StringNullableListFilter<"MLPrediction">
    confidenceScores?: FloatNullableListFilter<"MLPrediction">
    metadata?: JsonNullableFilter<"MLPrediction">
    generatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MLPrediction"> | Date | string | null
    signalGenerated?: BoolFilter<"MLPrediction"> | boolean
    signalId?: StringNullableFilter<"MLPrediction"> | string | null
    createdAt?: DateTimeFilter<"MLPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"MLPrediction"> | Date | string
  }

  export type MLModelCreateWithoutPredictionsInput = {
    id?: string
    name: string
    version: string
    modelType: string
    symbol?: string | null
    timeframe?: string | null
    description?: string | null
    status?: string
    accuracy?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    trainedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    trainingId?: string | null
    location?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLModelUncheckedCreateWithoutPredictionsInput = {
    id?: string
    name: string
    version: string
    modelType: string
    symbol?: string | null
    timeframe?: string | null
    description?: string | null
    status?: string
    accuracy?: number | null
    precision?: number | null
    recall?: number | null
    f1Score?: number | null
    trainedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    trainingId?: string | null
    location?: string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLModelCreateOrConnectWithoutPredictionsInput = {
    where: MLModelWhereUniqueInput
    create: XOR<MLModelCreateWithoutPredictionsInput, MLModelUncheckedCreateWithoutPredictionsInput>
  }

  export type MLModelUpsertWithoutPredictionsInput = {
    update: XOR<MLModelUpdateWithoutPredictionsInput, MLModelUncheckedUpdateWithoutPredictionsInput>
    create: XOR<MLModelCreateWithoutPredictionsInput, MLModelUncheckedCreateWithoutPredictionsInput>
    where?: MLModelWhereInput
  }

  export type MLModelUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: MLModelWhereInput
    data: XOR<MLModelUpdateWithoutPredictionsInput, MLModelUncheckedUpdateWithoutPredictionsInput>
  }

  export type MLModelUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelUncheckedUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    precision?: NullableFloatFieldUpdateOperationsInput | number | null
    recall?: NullableFloatFieldUpdateOperationsInput | number | null
    f1Score?: NullableFloatFieldUpdateOperationsInput | number | null
    trainedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestResultCreateWithoutTestInput = {
    id?: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendations?: OptimizationRecommendationCreateNestedManyWithoutTestResultInput
  }

  export type PerformanceTestResultUncheckedCreateWithoutTestInput = {
    id?: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    recommendations?: OptimizationRecommendationUncheckedCreateNestedManyWithoutTestResultInput
  }

  export type PerformanceTestResultCreateOrConnectWithoutTestInput = {
    where: PerformanceTestResultWhereUniqueInput
    create: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput>
  }

  export type PerformanceTestResultCreateManyTestInputEnvelope = {
    data: PerformanceTestResultCreateManyTestInput | PerformanceTestResultCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceTestResultUpsertWithWhereUniqueWithoutTestInput = {
    where: PerformanceTestResultWhereUniqueInput
    update: XOR<PerformanceTestResultUpdateWithoutTestInput, PerformanceTestResultUncheckedUpdateWithoutTestInput>
    create: XOR<PerformanceTestResultCreateWithoutTestInput, PerformanceTestResultUncheckedCreateWithoutTestInput>
  }

  export type PerformanceTestResultUpdateWithWhereUniqueWithoutTestInput = {
    where: PerformanceTestResultWhereUniqueInput
    data: XOR<PerformanceTestResultUpdateWithoutTestInput, PerformanceTestResultUncheckedUpdateWithoutTestInput>
  }

  export type PerformanceTestResultUpdateManyWithWhereWithoutTestInput = {
    where: PerformanceTestResultScalarWhereInput
    data: XOR<PerformanceTestResultUpdateManyMutationInput, PerformanceTestResultUncheckedUpdateManyWithoutTestInput>
  }

  export type PerformanceTestResultScalarWhereInput = {
    AND?: PerformanceTestResultScalarWhereInput | PerformanceTestResultScalarWhereInput[]
    OR?: PerformanceTestResultScalarWhereInput[]
    NOT?: PerformanceTestResultScalarWhereInput | PerformanceTestResultScalarWhereInput[]
    id?: StringFilter<"PerformanceTestResult"> | string
    testId?: StringFilter<"PerformanceTestResult"> | string
    status?: StringFilter<"PerformanceTestResult"> | string
    startTime?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    endTime?: DateTimeNullableFilter<"PerformanceTestResult"> | Date | string | null
    duration?: IntNullableFilter<"PerformanceTestResult"> | number | null
    metrics?: JsonFilter<"PerformanceTestResult">
    errors?: JsonNullableFilter<"PerformanceTestResult">
    createdAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceTestResult"> | Date | string
  }

  export type PerformanceTestCreateWithoutResultsInput = {
    id?: string
    name: string
    description?: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp?: number | null
    targetEndpoint?: string | null
    modelId?: string | null
    strategyId?: string | null
    symbol?: string | null
    timeframe?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    description?: string | null
    testType: string
    duration: number
    concurrency: number
    rampUp?: number | null
    targetEndpoint?: string | null
    modelId?: string | null
    strategyId?: string | null
    symbol?: string | null
    timeframe?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestCreateOrConnectWithoutResultsInput = {
    where: PerformanceTestWhereUniqueInput
    create: XOR<PerformanceTestCreateWithoutResultsInput, PerformanceTestUncheckedCreateWithoutResultsInput>
  }

  export type OptimizationRecommendationCreateWithoutTestResultInput = {
    id?: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
  }

  export type OptimizationRecommendationUncheckedCreateWithoutTestResultInput = {
    id?: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
  }

  export type OptimizationRecommendationCreateOrConnectWithoutTestResultInput = {
    where: OptimizationRecommendationWhereUniqueInput
    create: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput>
  }

  export type OptimizationRecommendationCreateManyTestResultInputEnvelope = {
    data: OptimizationRecommendationCreateManyTestResultInput | OptimizationRecommendationCreateManyTestResultInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceTestUpsertWithoutResultsInput = {
    update: XOR<PerformanceTestUpdateWithoutResultsInput, PerformanceTestUncheckedUpdateWithoutResultsInput>
    create: XOR<PerformanceTestCreateWithoutResultsInput, PerformanceTestUncheckedCreateWithoutResultsInput>
    where?: PerformanceTestWhereInput
  }

  export type PerformanceTestUpdateToOneWithWhereWithoutResultsInput = {
    where?: PerformanceTestWhereInput
    data: XOR<PerformanceTestUpdateWithoutResultsInput, PerformanceTestUncheckedUpdateWithoutResultsInput>
  }

  export type PerformanceTestUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    concurrency?: IntFieldUpdateOperationsInput | number
    rampUp?: NullableIntFieldUpdateOperationsInput | number | null
    targetEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationUpsertWithWhereUniqueWithoutTestResultInput = {
    where: OptimizationRecommendationWhereUniqueInput
    update: XOR<OptimizationRecommendationUpdateWithoutTestResultInput, OptimizationRecommendationUncheckedUpdateWithoutTestResultInput>
    create: XOR<OptimizationRecommendationCreateWithoutTestResultInput, OptimizationRecommendationUncheckedCreateWithoutTestResultInput>
  }

  export type OptimizationRecommendationUpdateWithWhereUniqueWithoutTestResultInput = {
    where: OptimizationRecommendationWhereUniqueInput
    data: XOR<OptimizationRecommendationUpdateWithoutTestResultInput, OptimizationRecommendationUncheckedUpdateWithoutTestResultInput>
  }

  export type OptimizationRecommendationUpdateManyWithWhereWithoutTestResultInput = {
    where: OptimizationRecommendationScalarWhereInput
    data: XOR<OptimizationRecommendationUpdateManyMutationInput, OptimizationRecommendationUncheckedUpdateManyWithoutTestResultInput>
  }

  export type OptimizationRecommendationScalarWhereInput = {
    AND?: OptimizationRecommendationScalarWhereInput | OptimizationRecommendationScalarWhereInput[]
    OR?: OptimizationRecommendationScalarWhereInput[]
    NOT?: OptimizationRecommendationScalarWhereInput | OptimizationRecommendationScalarWhereInput[]
    id?: StringFilter<"OptimizationRecommendation"> | string
    testResultId?: StringFilter<"OptimizationRecommendation"> | string
    category?: StringFilter<"OptimizationRecommendation"> | string
    impact?: StringFilter<"OptimizationRecommendation"> | string
    description?: StringFilter<"OptimizationRecommendation"> | string
    implementation?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    estimatedImprovement?: StringNullableFilter<"OptimizationRecommendation"> | string | null
    createdAt?: DateTimeFilter<"OptimizationRecommendation"> | Date | string
  }

  export type PerformanceTestResultCreateWithoutRecommendationsInput = {
    id?: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    test: PerformanceTestCreateNestedOneWithoutResultsInput
  }

  export type PerformanceTestResultUncheckedCreateWithoutRecommendationsInput = {
    id?: string
    testId: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestResultCreateOrConnectWithoutRecommendationsInput = {
    where: PerformanceTestResultWhereUniqueInput
    create: XOR<PerformanceTestResultCreateWithoutRecommendationsInput, PerformanceTestResultUncheckedCreateWithoutRecommendationsInput>
  }

  export type PerformanceTestResultUpsertWithoutRecommendationsInput = {
    update: XOR<PerformanceTestResultUpdateWithoutRecommendationsInput, PerformanceTestResultUncheckedUpdateWithoutRecommendationsInput>
    create: XOR<PerformanceTestResultCreateWithoutRecommendationsInput, PerformanceTestResultUncheckedCreateWithoutRecommendationsInput>
    where?: PerformanceTestResultWhereInput
  }

  export type PerformanceTestResultUpdateToOneWithWhereWithoutRecommendationsInput = {
    where?: PerformanceTestResultWhereInput
    data: XOR<PerformanceTestResultUpdateWithoutRecommendationsInput, PerformanceTestResultUncheckedUpdateWithoutRecommendationsInput>
  }

  export type PerformanceTestResultUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: PerformanceTestUpdateOneRequiredWithoutResultsNestedInput
  }

  export type PerformanceTestResultUncheckedUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultCreateWithoutTestInput = {
    id?: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestResultUncheckedCreateWithoutTestInput = {
    id?: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestResultCreateOrConnectWithoutTestInput = {
    where: ABTestResultWhereUniqueInput
    create: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput>
  }

  export type ABTestResultCreateManyTestInputEnvelope = {
    data: ABTestResultCreateManyTestInput | ABTestResultCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type ABTestResultUpsertWithWhereUniqueWithoutTestInput = {
    where: ABTestResultWhereUniqueInput
    update: XOR<ABTestResultUpdateWithoutTestInput, ABTestResultUncheckedUpdateWithoutTestInput>
    create: XOR<ABTestResultCreateWithoutTestInput, ABTestResultUncheckedCreateWithoutTestInput>
  }

  export type ABTestResultUpdateWithWhereUniqueWithoutTestInput = {
    where: ABTestResultWhereUniqueInput
    data: XOR<ABTestResultUpdateWithoutTestInput, ABTestResultUncheckedUpdateWithoutTestInput>
  }

  export type ABTestResultUpdateManyWithWhereWithoutTestInput = {
    where: ABTestResultScalarWhereInput
    data: XOR<ABTestResultUpdateManyMutationInput, ABTestResultUncheckedUpdateManyWithoutTestInput>
  }

  export type ABTestResultScalarWhereInput = {
    AND?: ABTestResultScalarWhereInput | ABTestResultScalarWhereInput[]
    OR?: ABTestResultScalarWhereInput[]
    NOT?: ABTestResultScalarWhereInput | ABTestResultScalarWhereInput[]
    id?: StringFilter<"ABTestResult"> | string
    testId?: StringFilter<"ABTestResult"> | string
    status?: StringFilter<"ABTestResult"> | string
    startDate?: DateTimeFilter<"ABTestResult"> | Date | string
    endDate?: DateTimeNullableFilter<"ABTestResult"> | Date | string | null
    variantAMetrics?: JsonFilter<"ABTestResult">
    variantBMetrics?: JsonFilter<"ABTestResult">
    winner?: StringNullableFilter<"ABTestResult"> | string | null
    improvement?: FloatNullableFilter<"ABTestResult"> | number | null
    confidenceLevel?: FloatNullableFilter<"ABTestResult"> | number | null
    notes?: StringNullableFilter<"ABTestResult"> | string | null
    createdAt?: DateTimeFilter<"ABTestResult"> | Date | string
    updatedAt?: DateTimeFilter<"ABTestResult"> | Date | string
  }

  export type ABTestCreateWithoutResultsInput = {
    id?: string
    name: string
    description?: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    description?: string | null
    variantA: string
    variantB: string
    type: string
    metric: string
    targetImprovement: number
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestCreateOrConnectWithoutResultsInput = {
    where: ABTestWhereUniqueInput
    create: XOR<ABTestCreateWithoutResultsInput, ABTestUncheckedCreateWithoutResultsInput>
  }

  export type ABTestUpsertWithoutResultsInput = {
    update: XOR<ABTestUpdateWithoutResultsInput, ABTestUncheckedUpdateWithoutResultsInput>
    create: XOR<ABTestCreateWithoutResultsInput, ABTestUncheckedCreateWithoutResultsInput>
    where?: ABTestWhereInput
  }

  export type ABTestUpdateToOneWithWhereWithoutResultsInput = {
    where?: ABTestWhereInput
    data: XOR<ABTestUpdateWithoutResultsInput, ABTestUncheckedUpdateWithoutResultsInput>
  }

  export type ABTestUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    variantA?: StringFieldUpdateOperationsInput | string
    variantB?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    targetImprovement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PositionCreateWithoutOrdersInput = {
    id?: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPositionsInput
    bot?: BotCreateNestedOneWithoutPositionsInput
  }

  export type PositionUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    botId?: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PositionCreateOrConnectWithoutOrdersInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutOrdersInput, PositionUncheckedCreateWithoutOrdersInput>
  }

  export type TradingStrategyCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionUncheckedCreateNestedManyWithoutStrategyInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyCreateOrConnectWithoutOrdersInput = {
    where: TradingStrategyWhereUniqueInput
    create: XOR<TradingStrategyCreateWithoutOrdersInput, TradingStrategyUncheckedCreateWithoutOrdersInput>
  }

  export type BotCreateWithoutOrdersInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBotsInput
    positions?: PositionCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionUncheckedCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutBotInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutOrdersInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutOrdersInput, BotUncheckedCreateWithoutOrdersInput>
  }

  export type TradingSignalCreateWithoutOrdersInput = {
    id?: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice?: number | null
    stopLoss?: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date | string
    expiresAt?: Date | string | null
    source: string
    metadata: JsonNullValueInput | InputJsonValue
    predictionValues: JsonNullValueInput | InputJsonValue
    validatedAt?: Date | string | null
    validationStatus?: boolean
    validationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradingSignalUncheckedCreateWithoutOrdersInput = {
    id?: string
    symbol: string
    type: string
    direction: string
    strength: string
    timeframe: string
    price: number
    targetPrice?: number | null
    stopLoss?: number | null
    confidenceScore: number
    expectedReturn: number
    expectedRisk: number
    riskRewardRatio: number
    generatedAt: Date | string
    expiresAt?: Date | string | null
    source: string
    metadata: JsonNullValueInput | InputJsonValue
    predictionValues: JsonNullValueInput | InputJsonValue
    validatedAt?: Date | string | null
    validationStatus?: boolean
    validationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradingSignalCreateOrConnectWithoutOrdersInput = {
    where: TradingSignalWhereUniqueInput
    create: XOR<TradingSignalCreateWithoutOrdersInput, TradingSignalUncheckedCreateWithoutOrdersInput>
  }

  export type AuditTrailCreateWithoutOrderInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventCreateNestedManyWithoutAuditTrailInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutAuditTrailInput
  }

  export type AuditTrailUncheckedCreateWithoutOrderInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedCreateNestedManyWithoutAuditTrailInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutAuditTrailInput
  }

  export type AuditTrailCreateOrConnectWithoutOrderInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput>
  }

  export type AuditTrailCreateManyOrderInputEnvelope = {
    data: AuditTrailCreateManyOrderInput | AuditTrailCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PositionUpsertWithoutOrdersInput = {
    update: XOR<PositionUpdateWithoutOrdersInput, PositionUncheckedUpdateWithoutOrdersInput>
    create: XOR<PositionCreateWithoutOrdersInput, PositionUncheckedCreateWithoutOrdersInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutOrdersInput, PositionUncheckedUpdateWithoutOrdersInput>
  }

  export type PositionUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPositionsNestedInput
    bot?: BotUpdateOneWithoutPositionsNestedInput
  }

  export type PositionUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TradingStrategyUpsertWithoutOrdersInput = {
    update: XOR<TradingStrategyUpdateWithoutOrdersInput, TradingStrategyUncheckedUpdateWithoutOrdersInput>
    create: XOR<TradingStrategyCreateWithoutOrdersInput, TradingStrategyUncheckedCreateWithoutOrdersInput>
    where?: TradingStrategyWhereInput
  }

  export type TradingStrategyUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TradingStrategyWhereInput
    data: XOR<TradingStrategyUpdateWithoutOrdersInput, TradingStrategyUncheckedUpdateWithoutOrdersInput>
  }

  export type TradingStrategyUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutStrategyNestedInput
  }

  export type TradingStrategyUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUncheckedUpdateManyWithoutStrategyNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type BotUpsertWithoutOrdersInput = {
    update: XOR<BotUpdateWithoutOrdersInput, BotUncheckedUpdateWithoutOrdersInput>
    create: XOR<BotCreateWithoutOrdersInput, BotUncheckedCreateWithoutOrdersInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutOrdersInput, BotUncheckedUpdateWithoutOrdersInput>
  }

  export type BotUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBotsNestedInput
    positions?: PositionUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUncheckedUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type TradingSignalUpsertWithoutOrdersInput = {
    update: XOR<TradingSignalUpdateWithoutOrdersInput, TradingSignalUncheckedUpdateWithoutOrdersInput>
    create: XOR<TradingSignalCreateWithoutOrdersInput, TradingSignalUncheckedCreateWithoutOrdersInput>
    where?: TradingSignalWhereInput
  }

  export type TradingSignalUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TradingSignalWhereInput
    data: XOR<TradingSignalUpdateWithoutOrdersInput, TradingSignalUncheckedUpdateWithoutOrdersInput>
  }

  export type TradingSignalUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradingSignalUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    targetPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceScore?: IntFieldUpdateOperationsInput | number
    expectedReturn?: FloatFieldUpdateOperationsInput | number
    expectedRisk?: FloatFieldUpdateOperationsInput | number
    riskRewardRatio?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    predictionValues?: JsonNullValueInput | InputJsonValue
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationStatus?: BoolFieldUpdateOperationsInput | boolean
    validationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUpsertWithWhereUniqueWithoutOrderInput = {
    where: AuditTrailWhereUniqueInput
    update: XOR<AuditTrailUpdateWithoutOrderInput, AuditTrailUncheckedUpdateWithoutOrderInput>
    create: XOR<AuditTrailCreateWithoutOrderInput, AuditTrailUncheckedCreateWithoutOrderInput>
  }

  export type AuditTrailUpdateWithWhereUniqueWithoutOrderInput = {
    where: AuditTrailWhereUniqueInput
    data: XOR<AuditTrailUpdateWithoutOrderInput, AuditTrailUncheckedUpdateWithoutOrderInput>
  }

  export type AuditTrailUpdateManyWithWhereWithoutOrderInput = {
    where: AuditTrailScalarWhereInput
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyWithoutOrderInput>
  }

  export type AuditTrailScalarWhereInput = {
    AND?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    OR?: AuditTrailScalarWhereInput[]
    NOT?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    trailType?: StringFilter<"AuditTrail"> | string
    entityId?: StringFilter<"AuditTrail"> | string
    entityType?: StringFilter<"AuditTrail"> | string
    startTime?: DateTimeFilter<"AuditTrail"> | Date | string
    endTime?: DateTimeNullableFilter<"AuditTrail"> | Date | string | null
    status?: StringFilter<"AuditTrail"> | string
    summary?: StringNullableFilter<"AuditTrail"> | string | null
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    orderId?: StringNullableFilter<"AuditTrail"> | string | null
    tags?: StringNullableListFilter<"AuditTrail">
    metadata?: JsonNullableFilter<"AuditTrail">
  }

  export type UserCreateWithoutDecisionLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDecisionLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDecisionLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDecisionLogsInput, UserUncheckedCreateWithoutDecisionLogsInput>
  }

  export type BotCreateWithoutDecisionLogsInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBotsInput
    positions?: PositionCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutBotInput
    orders?: OrderCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutDecisionLogsInput = {
    id?: string
    userId: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    positions?: PositionUncheckedCreateNestedManyWithoutBotInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutBotInput
    orders?: OrderUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutDecisionLogsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutDecisionLogsInput, BotUncheckedCreateWithoutDecisionLogsInput>
  }

  export type TradingStrategyCreateWithoutDecisionLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionCreateNestedManyWithoutStrategyInput
    orders?: OrderCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyUncheckedCreateWithoutDecisionLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    timeHorizon: string
    symbols?: TradingStrategyCreatesymbolsInput | string[]
    entryRules: JsonNullValueInput | InputJsonValue
    exitRules: JsonNullValueInput | InputJsonValue
    positionSizing: JsonNullValueInput | InputJsonValue
    riskManagement: JsonNullValueInput | InputJsonValue
    userId: string
    isPublic?: boolean
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: StrategyExecutionUncheckedCreateNestedManyWithoutStrategyInput
    orders?: OrderUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type TradingStrategyCreateOrConnectWithoutDecisionLogsInput = {
    where: TradingStrategyWhereUniqueInput
    create: XOR<TradingStrategyCreateWithoutDecisionLogsInput, TradingStrategyUncheckedCreateWithoutDecisionLogsInput>
  }

  export type AuditTrailCreateWithoutDecisionLogsInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventCreateNestedManyWithoutAuditTrailInput
    order?: OrderCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateWithoutDecisionLogsInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    orderId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedCreateNestedManyWithoutAuditTrailInput
  }

  export type AuditTrailCreateOrConnectWithoutDecisionLogsInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutDecisionLogsInput, AuditTrailUncheckedCreateWithoutDecisionLogsInput>
  }

  export type UserUpsertWithoutDecisionLogsInput = {
    update: XOR<UserUpdateWithoutDecisionLogsInput, UserUncheckedUpdateWithoutDecisionLogsInput>
    create: XOR<UserCreateWithoutDecisionLogsInput, UserUncheckedCreateWithoutDecisionLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDecisionLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDecisionLogsInput, UserUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type UserUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotUpsertWithoutDecisionLogsInput = {
    update: XOR<BotUpdateWithoutDecisionLogsInput, BotUncheckedUpdateWithoutDecisionLogsInput>
    create: XOR<BotCreateWithoutDecisionLogsInput, BotUncheckedCreateWithoutDecisionLogsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutDecisionLogsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutDecisionLogsInput, BotUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type BotUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBotsNestedInput
    positions?: PositionUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutBotNestedInput
    orders?: OrderUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUncheckedUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutBotNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBotNestedInput
  }

  export type TradingStrategyUpsertWithoutDecisionLogsInput = {
    update: XOR<TradingStrategyUpdateWithoutDecisionLogsInput, TradingStrategyUncheckedUpdateWithoutDecisionLogsInput>
    create: XOR<TradingStrategyCreateWithoutDecisionLogsInput, TradingStrategyUncheckedCreateWithoutDecisionLogsInput>
    where?: TradingStrategyWhereInput
  }

  export type TradingStrategyUpdateToOneWithWhereWithoutDecisionLogsInput = {
    where?: TradingStrategyWhereInput
    data: XOR<TradingStrategyUpdateWithoutDecisionLogsInput, TradingStrategyUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type TradingStrategyUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUpdateManyWithoutStrategyNestedInput
    orders?: OrderUpdateManyWithoutStrategyNestedInput
  }

  export type TradingStrategyUncheckedUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeHorizon?: StringFieldUpdateOperationsInput | string
    symbols?: TradingStrategyUpdatesymbolsInput | string[]
    entryRules?: JsonNullValueInput | InputJsonValue
    exitRules?: JsonNullValueInput | InputJsonValue
    positionSizing?: JsonNullValueInput | InputJsonValue
    riskManagement?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: StrategyExecutionUncheckedUpdateManyWithoutStrategyNestedInput
    orders?: OrderUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type AuditTrailUpsertWithoutDecisionLogsInput = {
    update: XOR<AuditTrailUpdateWithoutDecisionLogsInput, AuditTrailUncheckedUpdateWithoutDecisionLogsInput>
    create: XOR<AuditTrailCreateWithoutDecisionLogsInput, AuditTrailUncheckedCreateWithoutDecisionLogsInput>
    where?: AuditTrailWhereInput
  }

  export type AuditTrailUpdateToOneWithWhereWithoutDecisionLogsInput = {
    where?: AuditTrailWhereInput
    data: XOR<AuditTrailUpdateWithoutDecisionLogsInput, AuditTrailUncheckedUpdateWithoutDecisionLogsInput>
  }

  export type AuditTrailUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUpdateManyWithoutAuditTrailNestedInput
    order?: OrderUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateWithoutDecisionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedUpdateManyWithoutAuditTrailNestedInput
  }

  export type AuditEventCreateWithoutAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUncheckedCreateWithoutAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventCreateOrConnectWithoutAuditTrailInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput>
  }

  export type AuditEventCreateManyAuditTrailInputEnvelope = {
    data: AuditEventCreateManyAuditTrailInput | AuditEventCreateManyAuditTrailInput[]
    skipDuplicates?: boolean
  }

  export type DecisionLogCreateWithoutAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    user?: UserCreateNestedOneWithoutDecisionLogsInput
    bot?: BotCreateNestedOneWithoutDecisionLogsInput
    strategy?: TradingStrategyCreateNestedOneWithoutDecisionLogsInput
  }

  export type DecisionLogUncheckedCreateWithoutAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
  }

  export type DecisionLogCreateOrConnectWithoutAuditTrailInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput>
  }

  export type DecisionLogCreateManyAuditTrailInputEnvelope = {
    data: DecisionLogCreateManyAuditTrailInput | DecisionLogCreateManyAuditTrailInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutAuditTrailsInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutOrdersInput
    position?: PositionCreateNestedOneWithoutOrdersInput
    strategy?: TradingStrategyCreateNestedOneWithoutOrdersInput
    bot?: BotCreateNestedOneWithoutOrdersInput
    signal?: TradingSignalCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutAuditTrailsInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
  }

  export type OrderCreateOrConnectWithoutAuditTrailsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAuditTrailsInput, OrderUncheckedCreateWithoutAuditTrailsInput>
  }

  export type AuditEventUpsertWithWhereUniqueWithoutAuditTrailInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutAuditTrailInput, AuditEventUncheckedUpdateWithoutAuditTrailInput>
    create: XOR<AuditEventCreateWithoutAuditTrailInput, AuditEventUncheckedCreateWithoutAuditTrailInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutAuditTrailInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutAuditTrailInput, AuditEventUncheckedUpdateWithoutAuditTrailInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutAuditTrailInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutAuditTrailInput>
  }

  export type AuditEventScalarWhereInput = {
    AND?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    OR?: AuditEventScalarWhereInput[]
    NOT?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    auditTrailId?: StringFilter<"AuditEvent"> | string
    timestamp?: DateTimeFilter<"AuditEvent"> | Date | string
    eventType?: StringFilter<"AuditEvent"> | string
    component?: StringFilter<"AuditEvent"> | string
    action?: StringFilter<"AuditEvent"> | string
    status?: StringFilter<"AuditEvent"> | string
    details?: JsonNullableFilter<"AuditEvent">
    dataBefore?: JsonNullableFilter<"AuditEvent">
    dataAfter?: JsonNullableFilter<"AuditEvent">
    metadata?: JsonNullableFilter<"AuditEvent">
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutAuditTrailInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutAuditTrailInput, DecisionLogUncheckedUpdateWithoutAuditTrailInput>
    create: XOR<DecisionLogCreateWithoutAuditTrailInput, DecisionLogUncheckedCreateWithoutAuditTrailInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutAuditTrailInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutAuditTrailInput, DecisionLogUncheckedUpdateWithoutAuditTrailInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutAuditTrailInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutAuditTrailInput>
  }

  export type OrderUpsertWithoutAuditTrailsInput = {
    update: XOR<OrderUpdateWithoutAuditTrailsInput, OrderUncheckedUpdateWithoutAuditTrailsInput>
    create: XOR<OrderCreateWithoutAuditTrailsInput, OrderUncheckedCreateWithoutAuditTrailsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAuditTrailsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAuditTrailsInput, OrderUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type OrderUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    position?: PositionUpdateOneWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailCreateWithoutEventsInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    decisionLogs?: DecisionLogCreateNestedManyWithoutAuditTrailInput
    order?: OrderCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateWithoutEventsInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    orderId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutAuditTrailInput
  }

  export type AuditTrailCreateOrConnectWithoutEventsInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutEventsInput, AuditTrailUncheckedCreateWithoutEventsInput>
  }

  export type AuditTrailUpsertWithoutEventsInput = {
    update: XOR<AuditTrailUpdateWithoutEventsInput, AuditTrailUncheckedUpdateWithoutEventsInput>
    create: XOR<AuditTrailCreateWithoutEventsInput, AuditTrailUncheckedCreateWithoutEventsInput>
    where?: AuditTrailWhereInput
  }

  export type AuditTrailUpdateToOneWithWhereWithoutEventsInput = {
    where?: AuditTrailWhereInput
    data: XOR<AuditTrailUpdateWithoutEventsInput, AuditTrailUncheckedUpdateWithoutEventsInput>
  }

  export type AuditTrailUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    decisionLogs?: DecisionLogUpdateManyWithoutAuditTrailNestedInput
    order?: OrderUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutAuditTrailNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutUserInput
    positions?: PositionCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiry?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    oauthProvider?: string | null
    oauthId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    tradeLogs?: TradeLogUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutUserInput
    positions?: PositionUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    riskSettings?: RiskSettingsUncheckedCreateNestedManyWithoutUserInput
    riskAlerts?: RiskAlertUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    decisionLogs?: DecisionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutUserNestedInput
    positions?: PositionUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    tradeLogs?: TradeLogUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutUserNestedInput
    positions?: PositionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutUserNestedInput
    riskAlerts?: RiskAlertUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    key: string
    encryptedData: string
    name?: string
    scopes: string
    expiry: Date | string
    environment?: string
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    ipRestrictions?: string | null
    hashedSecret?: string | null
    usageCount?: number
    isDefault?: boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TradeLogCreateManyUserInput = {
    id?: string
    instrument: string
    amount: number
    price: number
    timestamp?: Date | string
    orderId?: string | null
    type: string
    status: string
  }

  export type BotCreateManyUserInput = {
    id?: string
    name: string
    symbol: string
    strategy: string
    timeframe: string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateManyUserInput = {
    id?: string
    botId?: string | null
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    deviceId?: string | null
    isValid?: boolean
    expiresAt: Date | string
    lastActiveAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    rememberMe?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RiskSettingsCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    botId?: string | null
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAlertCreateManyUserInput = {
    id?: string
    type: string
    level: string
    message: string
    details: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    acknowledged?: boolean
    resolvedAt?: Date | string | null
  }

  export type OrderCreateManyUserInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    details: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type DecisionLogCreateManyUserInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    encryptedData?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scopes?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipRestrictions?: NullableStringFieldUpdateOperationsInput | string | null
    hashedSecret?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    rateLimits?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TradeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TradeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TradeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrument?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUpdateManyWithoutBotNestedInput
    orders?: OrderUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positions?: PositionUncheckedUpdateManyWithoutBotNestedInput
    riskSettings?: RiskSettingsUncheckedUpdateManyWithoutBotNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBotNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bot?: BotUpdateOneWithoutPositionsNestedInput
    orders?: OrderUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberMe?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RiskSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneWithoutRiskSettingsNestedInput
  }

  export type RiskSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskSettingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    position?: PositionUpdateOneWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    bot?: BotUpdateOneWithoutDecisionLogsNestedInput
    strategy?: TradingStrategyUpdateOneWithoutDecisionLogsNestedInput
    auditTrail?: AuditTrailUpdateOneWithoutDecisionLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PositionCreateManyBotInput = {
    id?: string
    userId: string
    symbol: string
    side: string
    entryPrice: number
    currentPrice?: number | null
    amount: number
    leverage?: number
    takeProfitPrice?: number | null
    stopLossPrice?: number | null
    status: string
    pnl?: number | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RiskSettingsCreateManyBotInput = {
    id?: string
    name: string
    description?: string | null
    userId: string
    isActive?: boolean
    positionSizingMethod: string
    riskPercentage: number
    maxPositionSize: number
    kellyFraction?: number | null
    winRate?: number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType: string
    stopLossValue: number
    trailingCallback?: number | null
    trailingStep?: number | null
    timeLimit?: number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType: string
    takeProfitValue: number
    trailingActivation?: number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade: number
    maxRiskPerSymbol: number
    maxRiskPerDirection: number
    maxTotalRisk: number
    maxDrawdown: number
    maxPositions: number
    maxDailyLoss: number
    cooldownPeriod: number
    volatilityLookback: number
    circuitBreakerEnabled?: boolean
    maxDailyLossBreaker: number
    maxDrawdownBreaker: number
    volatilityMultiplier: number
    consecutiveLossesBreaker: number
    tradingPause: number
    marketWideEnabled?: boolean
    enableManualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyBotInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    signalId?: string | null
  }

  export type DecisionLogCreateManyBotInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type PositionUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPositionsNestedInput
    orders?: OrderUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    orders?: OrderUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    entryPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    leverage?: FloatFieldUpdateOperationsInput | number
    takeProfitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stopLossPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    pnl?: NullableFloatFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RiskSettingsUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRiskSettingsNestedInput
  }

  export type RiskSettingsUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskSettingsUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    positionSizingMethod?: StringFieldUpdateOperationsInput | string
    riskPercentage?: FloatFieldUpdateOperationsInput | number
    maxPositionSize?: FloatFieldUpdateOperationsInput | number
    kellyFraction?: NullableFloatFieldUpdateOperationsInput | number | null
    winRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customSizingParams?: NullableJsonNullValueInput | InputJsonValue
    stopLossType?: StringFieldUpdateOperationsInput | string
    stopLossValue?: FloatFieldUpdateOperationsInput | number
    trailingCallback?: NullableFloatFieldUpdateOperationsInput | number | null
    trailingStep?: NullableFloatFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    stopLossLevels?: NullableJsonNullValueInput | InputJsonValue
    takeProfitType?: StringFieldUpdateOperationsInput | string
    takeProfitValue?: FloatFieldUpdateOperationsInput | number
    trailingActivation?: NullableFloatFieldUpdateOperationsInput | number | null
    takeProfitLevels?: NullableJsonNullValueInput | InputJsonValue
    maxRiskPerTrade?: FloatFieldUpdateOperationsInput | number
    maxRiskPerSymbol?: FloatFieldUpdateOperationsInput | number
    maxRiskPerDirection?: FloatFieldUpdateOperationsInput | number
    maxTotalRisk?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    maxPositions?: IntFieldUpdateOperationsInput | number
    maxDailyLoss?: FloatFieldUpdateOperationsInput | number
    cooldownPeriod?: IntFieldUpdateOperationsInput | number
    volatilityLookback?: IntFieldUpdateOperationsInput | number
    circuitBreakerEnabled?: BoolFieldUpdateOperationsInput | boolean
    maxDailyLossBreaker?: FloatFieldUpdateOperationsInput | number
    maxDrawdownBreaker?: FloatFieldUpdateOperationsInput | number
    volatilityMultiplier?: FloatFieldUpdateOperationsInput | number
    consecutiveLossesBreaker?: IntFieldUpdateOperationsInput | number
    tradingPause?: IntFieldUpdateOperationsInput | number
    marketWideEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableManualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    position?: PositionUpdateOneWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    user?: UserUpdateOneWithoutDecisionLogsNestedInput
    strategy?: TradingStrategyUpdateOneWithoutDecisionLogsNestedInput
    auditTrail?: AuditTrailUpdateOneWithoutDecisionLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyPositionInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    strategyId?: string | null
    botId?: string | null
    signalId?: string | null
  }

  export type OrderUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManySignalInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    strategyId?: string | null
    botId?: string | null
  }

  export type OrderUpdateWithoutSignalInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    position?: PositionUpdateOneWithoutOrdersNestedInput
    strategy?: TradingStrategyUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSignalInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSignalInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyExecutionCreateManyStrategyInput = {
    id?: string
    userId: string
    status: string
    startedAt?: Date | string
    stoppedAt?: Date | string | null
    runningTimeMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyStrategyInput = {
    id?: string
    status: string
    symbol: string
    type: string
    side: string
    quantity: number
    price?: number | null
    stopPrice?: number | null
    avgFillPrice?: number | null
    filledQuantity: number
    remainingQuantity: number
    fee?: number | null
    feeCurrency?: string | null
    clientOrderId?: string | null
    exchangeOrderId?: string | null
    source: string
    exchangeId: string
    submittedAt: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    positionId?: string | null
    botId?: string | null
    signalId?: string | null
  }

  export type DecisionLogCreateManyStrategyInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
    auditTrailId?: string | null
  }

  export type StrategyExecutionUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: StrategyExecutionResultUpdateManyWithoutExecutionNestedInput
  }

  export type StrategyExecutionUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: StrategyExecutionResultUncheckedUpdateManyWithoutExecutionNestedInput
  }

  export type StrategyExecutionUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stoppedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runningTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    position?: PositionUpdateOneWithoutOrdersNestedInput
    bot?: BotUpdateOneWithoutOrdersNestedInput
    signal?: TradingSignalUpdateOneWithoutOrdersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stopPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    avgFillPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    filledQuantity?: FloatFieldUpdateOperationsInput | number
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feeCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    clientOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    exchangeId?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    raw?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    user?: UserUpdateOneWithoutDecisionLogsNestedInput
    bot?: BotUpdateOneWithoutDecisionLogsNestedInput
    auditTrail?: AuditTrailUpdateOneWithoutDecisionLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DecisionLogUncheckedUpdateManyWithoutStrategyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    auditTrailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyExecutionResultCreateManyExecutionInput = {
    id?: string
    symbol: string
    entryTime?: Date | string | null
    entryPrice?: number | null
    exitTime?: Date | string | null
    exitPrice?: number | null
    direction: string
    quantity?: number | null
    profitLoss?: number | null
    profitLossPercentage?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrategyExecutionResultUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionResultUncheckedUpdateWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyExecutionResultUncheckedUpdateManyWithoutExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    entryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entryPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    exitTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    direction?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLoss?: NullableFloatFieldUpdateOperationsInput | number | null
    profitLossPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionCreateManyModelInput = {
    id?: string
    symbol: string
    timeframe: string
    predictionType: string
    values?: MLPredictionCreatevaluesInput | number[]
    timestamps?: MLPredictionCreatetimestampsInput | string[]
    confidenceScores?: MLPredictionCreateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    expiresAt?: Date | string | null
    signalGenerated?: boolean
    signalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MLPredictionUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLPredictionUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
    predictionType?: StringFieldUpdateOperationsInput | string
    values?: MLPredictionUpdatevaluesInput | number[]
    timestamps?: MLPredictionUpdatetimestampsInput | string[]
    confidenceScores?: MLPredictionUpdateconfidenceScoresInput | number[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signalGenerated?: BoolFieldUpdateOperationsInput | boolean
    signalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceTestResultCreateManyTestInput = {
    id?: string
    status: string
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    metrics: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceTestResultUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendations?: OptimizationRecommendationUpdateManyWithoutTestResultNestedInput
  }

  export type PerformanceTestResultUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendations?: OptimizationRecommendationUncheckedUpdateManyWithoutTestResultNestedInput
  }

  export type PerformanceTestResultUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metrics?: JsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationCreateManyTestResultInput = {
    id?: string
    category: string
    impact: string
    description: string
    implementation?: string | null
    estimatedImprovement?: string | null
    createdAt?: Date | string
  }

  export type OptimizationRecommendationUpdateWithoutTestResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationUncheckedUpdateWithoutTestResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecommendationUncheckedUpdateManyWithoutTestResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    implementation?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImprovement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultCreateManyTestInput = {
    id?: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    variantAMetrics: JsonNullValueInput | InputJsonValue
    variantBMetrics: JsonNullValueInput | InputJsonValue
    winner?: string | null
    improvement?: number | null
    confidenceLevel?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestResultUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestResultUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantAMetrics?: JsonNullValueInput | InputJsonValue
    variantBMetrics?: JsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateManyOrderInput = {
    id?: string
    trailType: string
    entityId: string
    entityType: string
    startTime?: Date | string
    endTime?: Date | string | null
    status?: string
    summary?: string | null
    userId?: string | null
    tags?: AuditTrailCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditTrailUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUpdateManyWithoutAuditTrailNestedInput
    decisionLogs?: DecisionLogUpdateManyWithoutAuditTrailNestedInput
  }

  export type AuditTrailUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    events?: AuditEventUncheckedUpdateManyWithoutAuditTrailNestedInput
    decisionLogs?: DecisionLogUncheckedUpdateManyWithoutAuditTrailNestedInput
  }

  export type AuditTrailUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    trailType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: AuditTrailUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventCreateManyAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    eventType: string
    component: string
    action: string
    status: string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DecisionLogCreateManyAuditTrailInput = {
    id?: string
    timestamp?: Date | string
    source: string
    actionType: string
    decision: string
    reasonDetails?: string | null
    userId?: string | null
    botId?: string | null
    strategyId?: string | null
    symbol?: string | null
    orderId?: string | null
    positionId?: string | null
    importance: string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogCreatetagsInput | string[]
  }

  export type AuditEventUpdateWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUncheckedUpdateWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditEventUncheckedUpdateManyWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    dataBefore?: NullableJsonNullValueInput | InputJsonValue
    dataAfter?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DecisionLogUpdateWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
    user?: UserUpdateOneWithoutDecisionLogsNestedInput
    bot?: BotUpdateOneWithoutDecisionLogsNestedInput
    strategy?: TradingStrategyUpdateOneWithoutDecisionLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutAuditTrailInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    decision?: StringFieldUpdateOperationsInput | string
    reasonDetails?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    strategyId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    importance?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: DecisionLogUpdatetagsInput | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}