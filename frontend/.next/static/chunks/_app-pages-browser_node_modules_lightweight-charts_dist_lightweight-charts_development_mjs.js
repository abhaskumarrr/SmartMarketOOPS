"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_lightweight-charts_dist_lightweight-charts_development_mjs"],{

/***/ "(app-pages-browser)/../node_modules/fancy-canvas/canvas-element-bitmap-size.mjs":
/*!*******************************************************************!*\
  !*** ../node_modules/fancy-canvas/canvas-element-bitmap-size.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bindTo: () => (/* binding */ bindTo)\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/../node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device-pixel-ratio.mjs */ \"(app-pages-browser)/../node_modules/fancy-canvas/device-pixel-ratio.mjs\");\n\n\nvar DevicePixelContentBoxBinding = /** @class */ (function () {\n    function DevicePixelContentBoxBinding(canvasElement, transformBitmapSize, options) {\n        var _a;\n        this._canvasElement = null;\n        this._bitmapSizeChangedListeners = [];\n        this._suggestedBitmapSize = null;\n        this._suggestedBitmapSizeChangedListeners = [];\n        // devicePixelRatio approach\n        this._devicePixelRatioObservable = null;\n        // ResizeObserver approach\n        this._canvasElementResizeObserver = null;\n        this._canvasElement = canvasElement;\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._canvasElement.clientWidth,\n            height: this._canvasElement.clientHeight,\n        });\n        this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : (function (size) { return size; });\n        this._allowResizeObserver = (_a = options === null || options === void 0 ? void 0 : options.allowResizeObserver) !== null && _a !== void 0 ? _a : true;\n        this._chooseAndInitObserver();\n        // we MAY leave the constuctor without any bitmap size observation mechanics initialized\n    }\n    DevicePixelContentBoxBinding.prototype.dispose = function () {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            throw new Error('Object is disposed');\n        }\n        (_a = this._canvasElementResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this._canvasElementResizeObserver = null;\n        (_b = this._devicePixelRatioObservable) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._devicePixelRatioObservable = null;\n        this._suggestedBitmapSizeChangedListeners.length = 0;\n        this._bitmapSizeChangedListeners.length = 0;\n        this._canvasElement = null;\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElement\", {\n        get: function () {\n            if (this._canvasElement === null) {\n                throw new Error('Object is disposed');\n            }\n            return this._canvasElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElementClientSize\", {\n        get: function () {\n            return this._canvasElementClientSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"bitmapSize\", {\n        get: function () {\n            return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: this.canvasElement.width,\n                height: this.canvasElement.height,\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Use this function to change canvas element client size until binding is disposed\n     * @param clientSize New client size for bound HTMLCanvasElement\n     */\n    DevicePixelContentBoxBinding.prototype.resizeCanvasElement = function (clientSize) {\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(clientSize);\n        this.canvasElement.style.width = \"\".concat(this._canvasElementClientSize.width, \"px\");\n        this.canvasElement.style.height = \"\".concat(this._canvasElementClientSize.height, \"px\");\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype.subscribeBitmapSizeChanged = function (listener) {\n        this._bitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeBitmapSizeChanged = function (listener) {\n        this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function (l) { return l !== listener; });\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"suggestedBitmapSize\", {\n        get: function () {\n            return this._suggestedBitmapSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DevicePixelContentBoxBinding.prototype.subscribeSuggestedBitmapSizeChanged = function (listener) {\n        this._suggestedBitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeSuggestedBitmapSizeChanged = function (listener) {\n        this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function (l) { return l !== listener; });\n    };\n    DevicePixelContentBoxBinding.prototype.applySuggestedBitmapSize = function () {\n        if (this._suggestedBitmapSize === null) {\n            // nothing to apply\n            return;\n        }\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        this._suggestedBitmapSize = null;\n        this._resizeBitmap(oldSuggestedSize);\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);\n    };\n    DevicePixelContentBoxBinding.prototype._resizeBitmap = function (newSize) {\n        var oldSize = this.bitmapSize;\n        if ((0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSize, newSize)) {\n            return;\n        }\n        this.canvasElement.width = newSize.width;\n        this.canvasElement.height = newSize.height;\n        this._emitBitmapSizeChanged(oldSize, newSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitBitmapSizeChanged = function (oldSize, newSize) {\n        var _this = this;\n        this._bitmapSizeChangedListeners.forEach(function (listener) { return listener.call(_this, oldSize, newSize); });\n    };\n    DevicePixelContentBoxBinding.prototype._suggestNewBitmapSize = function (newSize) {\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        var finalNewSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(this._transformBitmapSize(newSize, this._canvasElementClientSize));\n        var newSuggestedSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this.bitmapSize, finalNewSize) ? null : finalNewSize;\n        if (oldSuggestedSize === null && newSuggestedSize === null) {\n            return;\n        }\n        if (oldSuggestedSize !== null && newSuggestedSize !== null\n            && (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSuggestedSize, newSuggestedSize)) {\n            return;\n        }\n        this._suggestedBitmapSize = newSuggestedSize;\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitSuggestedBitmapSizeChanged = function (oldSize, newSize) {\n        var _this = this;\n        this._suggestedBitmapSizeChangedListeners.forEach(function (listener) { return listener.call(_this, oldSize, newSize); });\n    };\n    DevicePixelContentBoxBinding.prototype._chooseAndInitObserver = function () {\n        var _this = this;\n        if (!this._allowResizeObserver) {\n            this._initDevicePixelRatioObservable();\n            return;\n        }\n        isDevicePixelContentBoxSupported()\n            .then(function (isSupported) {\n            return isSupported ?\n                _this._initResizeObserver() :\n                _this._initDevicePixelRatioObservable();\n        });\n    };\n    // devicePixelRatio approach\n    DevicePixelContentBoxBinding.prototype._initDevicePixelRatioObservable = function () {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            throw new Error('No window is associated with the canvas');\n        }\n        this._devicePixelRatioObservable = (0,_device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__.createObservable)(win);\n        this._devicePixelRatioObservable.subscribe(function () { return _this._invalidateBitmapSize(); });\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype._invalidateBitmapSize = function () {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            return;\n        }\n        var ratio = (_b = (_a = this._devicePixelRatioObservable) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio;\n        var canvasRects = this._canvasElement.getClientRects();\n        var newSize = \n        // eslint-disable-next-line no-negated-condition\n        canvasRects[0] !== undefined ?\n            predictedBitmapSize(canvasRects[0], ratio) :\n            (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: this._canvasElementClientSize.width * ratio,\n                height: this._canvasElementClientSize.height * ratio,\n            });\n        this._suggestNewBitmapSize(newSize);\n    };\n    // ResizeObserver approach\n    DevicePixelContentBoxBinding.prototype._initResizeObserver = function () {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        this._canvasElementResizeObserver = new ResizeObserver(function (entries) {\n            var entry = entries.find(function (entry) { return entry.target === _this._canvasElement; });\n            if (!entry || !entry.devicePixelContentBoxSize || !entry.devicePixelContentBoxSize[0]) {\n                return;\n            }\n            var entrySize = entry.devicePixelContentBoxSize[0];\n            var newSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: entrySize.inlineSize,\n                height: entrySize.blockSize,\n            });\n            _this._suggestNewBitmapSize(newSize);\n        });\n        this._canvasElementResizeObserver.observe(this._canvasElement, { box: 'device-pixel-content-box' });\n    };\n    return DevicePixelContentBoxBinding;\n}());\nfunction bindTo(canvasElement, target) {\n    if (target.type === 'device-pixel-content-box') {\n        return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);\n    }\n    throw new Error('Unsupported binding target');\n}\nfunction canvasElementWindow(canvasElement) {\n    // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement\n    // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return canvasElement.ownerDocument.defaultView;\n}\nfunction isDevicePixelContentBoxSupported() {\n    return new Promise(function (resolve) {\n        var ro = new ResizeObserver(function (entries) {\n            resolve(entries.every(function (entry) { return 'devicePixelContentBoxSize' in entry; }));\n            ro.disconnect();\n        });\n        ro.observe(document.body, { box: 'device-pixel-content-box' });\n    })\n        .catch(function () { return false; });\n}\nfunction predictedBitmapSize(canvasRect, ratio) {\n    return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n        width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) -\n            Math.round(canvasRect.left * ratio),\n        height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) -\n            Math.round(canvasRect.top * ratio),\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2NhbnZhcy1lbGVtZW50LWJpdG1hcC1zaXplLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDa0Q7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtDQUFJO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOElBQThJLGNBQWM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQUk7QUFDdkI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtDQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csd0JBQXdCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsd0JBQXdCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGdEQUFnRDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQUk7QUFDL0IsK0JBQStCLHFEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixnREFBZ0Q7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5RUFBZ0M7QUFDM0UsaUVBQWlFLHVDQUF1QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFJO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsK0NBQStDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFJO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QseUVBQXlFLGlDQUFpQztBQUMxRztBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4Q0FBOEM7QUFDbkc7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLGlDQUFpQztBQUNyRSxLQUFLO0FBQ0wsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsK0NBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL2FiaGFza3VtYXJyci9Eb2N1bWVudHMvR2l0SHViL1NtYXJ0TWFya2V0T09QUy9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2NhbnZhcy1lbGVtZW50LWJpdG1hcC1zaXplLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbFNpemVzLCBzaXplIH0gZnJvbSBcIi4vc2l6ZS5tanNcIjtcbmltcG9ydCB7IGNyZWF0ZU9ic2VydmFibGUgYXMgY3JlYXRlRGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUgfSBmcm9tIFwiLi9kZXZpY2UtcGl4ZWwtcmF0aW8ubWpzXCI7XG52YXIgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nKGNhbnZhc0VsZW1lbnQsIHRyYW5zZm9ybUJpdG1hcFNpemUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzID0gW107XG4gICAgICAgIC8vIGRldmljZVBpeGVsUmF0aW8gYXBwcm9hY2hcbiAgICAgICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUgPSBudWxsO1xuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcHByb2FjaFxuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50UmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50ID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUgPSBzaXplKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9jYW52YXNFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9jYW52YXNFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUJpdG1hcFNpemUgPSB0cmFuc2Zvcm1CaXRtYXBTaXplICE9PSBudWxsICYmIHRyYW5zZm9ybUJpdG1hcFNpemUgIT09IHZvaWQgMCA/IHRyYW5zZm9ybUJpdG1hcFNpemUgOiAoZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIHNpemU7IH0pO1xuICAgICAgICB0aGlzLl9hbGxvd1Jlc2l6ZU9ic2VydmVyID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93UmVzaXplT2JzZXJ2ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIHRoaXMuX2Nob29zZUFuZEluaXRPYnNlcnZlcigpO1xuICAgICAgICAvLyB3ZSBNQVkgbGVhdmUgdGhlIGNvbnN0dWN0b3Igd2l0aG91dCBhbnkgYml0bWFwIHNpemUgb2JzZXJ2YXRpb24gbWVjaGFuaWNzIGluaXRpYWxpemVkXG4gICAgfVxuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBpcyBkaXNwb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudFJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgKF9iID0gdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudCA9IG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUsIFwiY2FudmFzRWxlbWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBpcyBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUsIFwiY2FudmFzRWxlbWVudENsaWVudFNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZSwgXCJiaXRtYXBTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSBjYW52YXMgZWxlbWVudCBjbGllbnQgc2l6ZSB1bnRpbCBiaW5kaW5nIGlzIGRpc3Bvc2VkXG4gICAgICogQHBhcmFtIGNsaWVudFNpemUgTmV3IGNsaWVudCBzaXplIGZvciBib3VuZCBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqL1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLnJlc2l6ZUNhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAoY2xpZW50U2l6ZSkge1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZSA9IHNpemUoY2xpZW50U2l6ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplLndpZHRoLCBcInB4XCIpO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQodGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlQml0bWFwU2l6ZSgpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuc3Vic2NyaWJlQml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS51bnN1YnNjcmliZUJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzID0gdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUsIFwic3VnZ2VzdGVkQml0bWFwU2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMgPSB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgIT09IGxpc3RlbmVyOyB9KTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gYXBwbHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkU3VnZ2VzdGVkU2l6ZSA9IHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemU7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemUgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZXNpemVCaXRtYXAob2xkU3VnZ2VzdGVkU2l6ZSk7XG4gICAgICAgIHRoaXMuX2VtaXRTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZChvbGRTdWdnZXN0ZWRTaXplLCB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9yZXNpemVCaXRtYXAgPSBmdW5jdGlvbiAobmV3U2l6ZSkge1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuYml0bWFwU2l6ZTtcbiAgICAgICAgaWYgKGVxdWFsU2l6ZXMob2xkU2l6ZSwgbmV3U2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VtaXRCaXRtYXBTaXplQ2hhbmdlZChvbGRTaXplLCBuZXdTaXplKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9lbWl0Qml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkU2l6ZSwgbmV3U2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuY2FsbChfdGhpcywgb2xkU2l6ZSwgbmV3U2l6ZSk7IH0pO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX3N1Z2dlc3ROZXdCaXRtYXBTaXplID0gZnVuY3Rpb24gKG5ld1NpemUpIHtcbiAgICAgICAgdmFyIG9sZFN1Z2dlc3RlZFNpemUgPSB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplO1xuICAgICAgICB2YXIgZmluYWxOZXdTaXplID0gc2l6ZSh0aGlzLl90cmFuc2Zvcm1CaXRtYXBTaXplKG5ld1NpemUsIHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplKSk7XG4gICAgICAgIHZhciBuZXdTdWdnZXN0ZWRTaXplID0gZXF1YWxTaXplcyh0aGlzLmJpdG1hcFNpemUsIGZpbmFsTmV3U2l6ZSkgPyBudWxsIDogZmluYWxOZXdTaXplO1xuICAgICAgICBpZiAob2xkU3VnZ2VzdGVkU2l6ZSA9PT0gbnVsbCAmJiBuZXdTdWdnZXN0ZWRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFN1Z2dlc3RlZFNpemUgIT09IG51bGwgJiYgbmV3U3VnZ2VzdGVkU2l6ZSAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgZXF1YWxTaXplcyhvbGRTdWdnZXN0ZWRTaXplLCBuZXdTdWdnZXN0ZWRTaXplKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemUgPSBuZXdTdWdnZXN0ZWRTaXplO1xuICAgICAgICB0aGlzLl9lbWl0U3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQob2xkU3VnZ2VzdGVkU2l6ZSwgbmV3U3VnZ2VzdGVkU2l6ZSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5fZW1pdFN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZFNpemUsIG5ld1NpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmNhbGwoX3RoaXMsIG9sZFNpemUsIG5ld1NpemUpOyB9KTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9jaG9vc2VBbmRJbml0T2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fYWxsb3dSZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdERldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXNEZXZpY2VQaXhlbENvbnRlbnRCb3hTdXBwb3J0ZWQoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQgP1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbml0UmVzaXplT2JzZXJ2ZXIoKSA6XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luaXREZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGRldmljZVBpeGVsUmF0aW8gYXBwcm9hY2hcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5faW5pdERldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaXQgbG9va3MgbGlrZSB3ZSBhcmUgYWxyZWFkeSBkZWFkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbiA9IGNhbnZhc0VsZW1lbnRXaW5kb3codGhpcy5fY2FudmFzRWxlbWVudCk7XG4gICAgICAgIGlmICh3aW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2luZG93IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FudmFzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUgPSBjcmVhdGVEZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSh3aW4pO1xuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2ludmFsaWRhdGVCaXRtYXBTaXplKCk7IH0pO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlQml0bWFwU2l6ZSgpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2ludmFsaWRhdGVCaXRtYXBTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaXQgbG9va3MgbGlrZSB3ZSBhcmUgYWxyZWFkeSBkZWFkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbiA9IGNhbnZhc0VsZW1lbnRXaW5kb3codGhpcy5fY2FudmFzRWxlbWVudCk7XG4gICAgICAgIGlmICh3aW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF0aW8gPSAoX2IgPSAoX2EgPSB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB3aW4uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdmFyIGNhbnZhc1JlY3RzID0gdGhpcy5fY2FudmFzRWxlbWVudC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICB2YXIgbmV3U2l6ZSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cbiAgICAgICAgY2FudmFzUmVjdHNbMF0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBwcmVkaWN0ZWRCaXRtYXBTaXplKGNhbnZhc1JlY3RzWzBdLCByYXRpbykgOlxuICAgICAgICAgICAgc2l6ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplLndpZHRoICogcmF0aW8sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZS5oZWlnaHQgKiByYXRpbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdWdnZXN0TmV3Qml0bWFwU2l6ZShuZXdTaXplKTtcbiAgICB9O1xuICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFwcHJvYWNoXG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2luaXRSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2Ugd2UgYXJlIGFscmVhZHkgZGVhZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkudGFyZ2V0ID09PSBfdGhpcy5fY2FudmFzRWxlbWVudDsgfSk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5IHx8ICFlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplIHx8ICFlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVudHJ5U2l6ZSA9IGVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemVbMF07XG4gICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHNpemUoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBlbnRyeVNpemUuaW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVudHJ5U2l6ZS5ibG9ja1NpemUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLl9zdWdnZXN0TmV3Qml0bWFwU2l6ZShuZXdTaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuX2NhbnZhc0VsZW1lbnQsIHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBiaW5kVG8oY2FudmFzRWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC50eXBlID09PSAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94Jykge1xuICAgICAgICByZXR1cm4gbmV3IERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcoY2FudmFzRWxlbWVudCwgdGFyZ2V0LnRyYW5zZm9ybSwgdGFyZ2V0Lm9wdGlvbnMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJpbmRpbmcgdGFyZ2V0Jyk7XG59XG5mdW5jdGlvbiBjYW52YXNFbGVtZW50V2luZG93KGNhbnZhc0VsZW1lbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gRE9NIExldmVsIDIgQ29yZSBzcGVjaWZpY2F0aW9uLCBvd25lckRvY3VtZW50IHNob3VsZCBuZXZlciBiZSBudWxsIGZvciBIVE1MQ2FudmFzRWxlbWVudFxuICAgIC8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9jb3JlLmh0bWwjbm9kZS1vd25lckRvY1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcbn1cbmZ1bmN0aW9uIGlzRGV2aWNlUGl4ZWxDb250ZW50Qm94U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZW50cmllcy5ldmVyeShmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICdkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplJyBpbiBlbnRyeTsgfSkpO1xuICAgICAgICAgICAgcm8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm8ub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbn1cbmZ1bmN0aW9uIHByZWRpY3RlZEJpdG1hcFNpemUoY2FudmFzUmVjdCwgcmF0aW8pIHtcbiAgICByZXR1cm4gc2l6ZSh7XG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGNhbnZhc1JlY3QubGVmdCAqIHJhdGlvICsgY2FudmFzUmVjdC53aWR0aCAqIHJhdGlvKSAtXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNhbnZhc1JlY3QubGVmdCAqIHJhdGlvKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGNhbnZhc1JlY3QudG9wICogcmF0aW8gKyBjYW52YXNSZWN0LmhlaWdodCAqIHJhdGlvKSAtXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNhbnZhc1JlY3QudG9wICogcmF0aW8pLFxuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/fancy-canvas/canvas-rendering-target.mjs":
/*!****************************************************************!*\
  !*** ../node_modules/fancy-canvas/canvas-rendering-target.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: () => (/* binding */ CanvasRenderingTarget2D),\n/* harmony export */   createCanvasRenderingTarget2D: () => (/* binding */ createCanvasRenderingTarget2D),\n/* harmony export */   tryCreateCanvasRenderingTarget2D: () => (/* binding */ tryCreateCanvasRenderingTarget2D)\n/* harmony export */ });\n/**\n * @experimental\n */\nvar CanvasRenderingTarget2D = /** @class */ (function () {\n    function CanvasRenderingTarget2D(context, mediaSize, bitmapSize) {\n        if (mediaSize.width === 0 || mediaSize.height === 0) {\n            throw new TypeError('Rendering target could only be created on a media with positive width and height');\n        }\n        this._mediaSize = mediaSize;\n        // !Number.isInteger(bitmapSize.width) || !Number.isInteger(bitmapSize.height)\n        if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n            throw new TypeError('Rendering target could only be created using a bitmap with positive integer width and height');\n        }\n        this._bitmapSize = bitmapSize;\n        this._context = context;\n    }\n    CanvasRenderingTarget2D.prototype.useMediaCoordinateSpace = function (f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize,\n            });\n        }\n        finally {\n            this._context.restore();\n        }\n    };\n    CanvasRenderingTarget2D.prototype.useBitmapCoordinateSpace = function (f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize,\n                bitmapSize: this._bitmapSize,\n                horizontalPixelRatio: this._horizontalPixelRatio,\n                verticalPixelRatio: this._verticalPixelRatio,\n            });\n        }\n        finally {\n            this._context.restore();\n        }\n    };\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_horizontalPixelRatio\", {\n        get: function () {\n            return this._bitmapSize.width / this._mediaSize.width;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_verticalPixelRatio\", {\n        get: function () {\n            return this._bitmapSize.height / this._mediaSize.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CanvasRenderingTarget2D;\n}());\n\n/**\n * @experimental\n */\nfunction createCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    var bitmapSize = binding.bitmapSize;\n    var context = binding.canvasElement.getContext('2d', contextOptions);\n    if (context === null) {\n        throw new Error('Could not get 2d drawing context from bound canvas element. Has the canvas already been set to a different context mode?');\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n/**\n * @experimental\n */\nfunction tryCreateCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    if (mediaSize.width === 0 || mediaSize.height === 0) {\n        return null;\n    }\n    var bitmapSize = binding.bitmapSize;\n    if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n        return null;\n    }\n    var context = binding.canvasElement.getContext('2d', contextOptions);\n    if (context === null) {\n        return null;\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2NhbnZhcy1yZW5kZXJpbmctdGFyZ2V0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ2tDO0FBQ25DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FiaGFza3VtYXJyci9Eb2N1bWVudHMvR2l0SHViL1NtYXJ0TWFya2V0T09QUy9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2NhbnZhcy1yZW5kZXJpbmctdGFyZ2V0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIENhbnZhc1JlbmRlcmluZ1RhcmdldDJEID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmluZ1RhcmdldDJEKGNvbnRleHQsIG1lZGlhU2l6ZSwgYml0bWFwU2l6ZSkge1xuICAgICAgICBpZiAobWVkaWFTaXplLndpZHRoID09PSAwIHx8IG1lZGlhU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlbmRlcmluZyB0YXJnZXQgY291bGQgb25seSBiZSBjcmVhdGVkIG9uIGEgbWVkaWEgd2l0aCBwb3NpdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFTaXplID0gbWVkaWFTaXplO1xuICAgICAgICAvLyAhTnVtYmVyLmlzSW50ZWdlcihiaXRtYXBTaXplLndpZHRoKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihiaXRtYXBTaXplLmhlaWdodClcbiAgICAgICAgaWYgKGJpdG1hcFNpemUud2lkdGggPT09IDAgfHwgYml0bWFwU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlbmRlcmluZyB0YXJnZXQgY291bGQgb25seSBiZSBjcmVhdGVkIHVzaW5nIGEgYml0bWFwIHdpdGggcG9zaXRpdmUgaW50ZWdlciB3aWR0aCBhbmQgaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZSA9IGJpdG1hcFNpemU7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUudXNlTWVkaWFDb29yZGluYXRlU3BhY2UgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBkbyBub3QgdXNlIHJlc2V0VHJhbnNmb3JtIHRvIHN1cHBvcnQgb2xkIHZlcnNpb25zIG9mIEVkZ2VcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zY2FsZSh0aGlzLl9ob3Jpem9udGFsUGl4ZWxSYXRpbywgdGhpcy5fdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIHJldHVybiBmKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIG1lZGlhU2l6ZTogdGhpcy5fbWVkaWFTaXplLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQucHJvdG90eXBlLnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIGRvIG5vdCB1c2UgcmVzZXRUcmFuc2Zvcm0gdG8gc3VwcG9ydCBvbGQgdmVyc2lvbnMgb2YgRWRnZVxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZih7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZWRpYVNpemU6IHRoaXMuX21lZGlhU2l6ZSxcbiAgICAgICAgICAgICAgICBiaXRtYXBTaXplOiB0aGlzLl9iaXRtYXBTaXplLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxQaXhlbFJhdGlvOiB0aGlzLl9ob3Jpem9udGFsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFBpeGVsUmF0aW86IHRoaXMuX3ZlcnRpY2FsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUsIFwiX2hvcml6b250YWxQaXhlbFJhdGlvXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYml0bWFwU2l6ZS53aWR0aCAvIHRoaXMuX21lZGlhU2l6ZS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNSZW5kZXJpbmdUYXJnZXQyRC5wcm90b3R5cGUsIFwiX3ZlcnRpY2FsUGl4ZWxSYXRpb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdG1hcFNpemUuaGVpZ2h0IC8gdGhpcy5fbWVkaWFTaXplLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRDtcbn0oKSk7XG5leHBvcnQgeyBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCB9O1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRChiaW5kaW5nLCBjb250ZXh0T3B0aW9ucykge1xuICAgIHZhciBtZWRpYVNpemUgPSBiaW5kaW5nLmNhbnZhc0VsZW1lbnRDbGllbnRTaXplO1xuICAgIHZhciBiaXRtYXBTaXplID0gYmluZGluZy5iaXRtYXBTaXplO1xuICAgIHZhciBjb250ZXh0ID0gYmluZGluZy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJywgY29udGV4dE9wdGlvbnMpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCAyZCBkcmF3aW5nIGNvbnRleHQgZnJvbSBib3VuZCBjYW52YXMgZWxlbWVudC4gSGFzIHRoZSBjYW52YXMgYWxyZWFkeSBiZWVuIHNldCB0byBhIGRpZmZlcmVudCBjb250ZXh0IG1vZGU/Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoY29udGV4dCwgbWVkaWFTaXplLCBiaXRtYXBTaXplKTtcbn1cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoYmluZGluZywgY29udGV4dE9wdGlvbnMpIHtcbiAgICB2YXIgbWVkaWFTaXplID0gYmluZGluZy5jYW52YXNFbGVtZW50Q2xpZW50U2l6ZTtcbiAgICBpZiAobWVkaWFTaXplLndpZHRoID09PSAwIHx8IG1lZGlhU2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiaXRtYXBTaXplID0gYmluZGluZy5iaXRtYXBTaXplO1xuICAgIGlmIChiaXRtYXBTaXplLndpZHRoID09PSAwIHx8IGJpdG1hcFNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IGJpbmRpbmcuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcsIGNvbnRleHRPcHRpb25zKTtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRChjb250ZXh0LCBtZWRpYVNpemUsIGJpdG1hcFNpemUpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/fancy-canvas/canvas-rendering-target.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/fancy-canvas/device-pixel-ratio.mjs":
/*!***********************************************************!*\
  !*** ../node_modules/fancy-canvas/device-pixel-ratio.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createObservable: () => (/* binding */ createObservable)\n/* harmony export */ });\nvar Observable = /** @class */ (function () {\n    function Observable(win) {\n        var _this = this;\n        this._resolutionListener = function () { return _this._onResolutionChanged(); };\n        this._resolutionMediaQueryList = null;\n        this._observers = [];\n        this._window = win;\n        this._installResolutionListener();\n    }\n    Observable.prototype.dispose = function () {\n        this._uninstallResolutionListener();\n        this._window = null;\n    };\n    Object.defineProperty(Observable.prototype, \"value\", {\n        get: function () {\n            return this._window.devicePixelRatio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Observable.prototype.subscribe = function (next) {\n        var _this = this;\n        var observer = { next: next };\n        this._observers.push(observer);\n        return {\n            unsubscribe: function () {\n                _this._observers = _this._observers.filter(function (o) { return o !== observer; });\n            },\n        };\n    };\n    Observable.prototype._installResolutionListener = function () {\n        if (this._resolutionMediaQueryList !== null) {\n            throw new Error('Resolution listener is already installed');\n        }\n        var dppx = this._window.devicePixelRatio;\n        this._resolutionMediaQueryList = this._window.matchMedia(\"all and (resolution: \".concat(dppx, \"dppx)\"));\n        // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n        this._resolutionMediaQueryList.addListener(this._resolutionListener);\n    };\n    Observable.prototype._uninstallResolutionListener = function () {\n        if (this._resolutionMediaQueryList !== null) {\n            // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n            this._resolutionMediaQueryList.removeListener(this._resolutionListener);\n            this._resolutionMediaQueryList = null;\n        }\n    };\n    Observable.prototype._reinstallResolutionListener = function () {\n        this._uninstallResolutionListener();\n        this._installResolutionListener();\n    };\n    Observable.prototype._onResolutionChanged = function () {\n        var _this = this;\n        this._observers.forEach(function (observer) { return observer.next(_this._window.devicePixelRatio); });\n        this._reinstallResolutionListener();\n    };\n    return Observable;\n}());\nfunction createObservable(win) {\n    return new Observable(win);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2RldmljZS1waXhlbC1yYXRpby5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx3QkFBd0I7QUFDbEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1REFBdUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FiaGFza3VtYXJyci9Eb2N1bWVudHMvR2l0SHViL1NtYXJ0TWFya2V0T09QUy9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2RldmljZS1waXhlbC1yYXRpby5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE9ic2VydmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZSh3aW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uUmVzb2x1dGlvbkNoYW5nZWQoKTsgfTtcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IHdpbjtcbiAgICAgICAgdGhpcy5faW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lcigpO1xuICAgIH1cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bmluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9ic2VydmVyID0geyBuZXh0OiBuZXh0IH07XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX29ic2VydmVycyA9IF90aGlzLl9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICE9PSBvYnNlcnZlcjsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2luc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x1dGlvbiBsaXN0ZW5lciBpcyBhbHJlYWR5IGluc3RhbGxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcHB4ID0gdGhpcy5fd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCA9IHRoaXMuX3dpbmRvdy5tYXRjaE1lZGlhKFwiYWxsIGFuZCAocmVzb2x1dGlvbjogXCIuY29uY2F0KGRwcHgsIFwiZHBweClcIikpO1xuICAgICAgICAvLyBJRSBhbmQgc29tZSB2ZXJzaW9ucyBvZiBFZGdlIGRvIG5vdCBzdXBwb3J0IGFkZEV2ZW50TGlzdGVuZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIHdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGRlcHJlY2F0ZWQgYWRkTGlzdGVuZXIvcmVtb3ZlTGlzdGVuZXJcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKHRoaXMuX3Jlc29sdXRpb25MaXN0ZW5lcik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fdW5pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJRSBhbmQgc29tZSB2ZXJzaW9ucyBvZiBFZGdlIGRvIG5vdCBzdXBwb3J0IGFkZEV2ZW50TGlzdGVuZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIHdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGRlcHJlY2F0ZWQgYWRkTGlzdGVuZXIvcmVtb3ZlTGlzdGVuZXJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9yZXNvbHV0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3JlaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuX2luc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9vblJlc29sdXRpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoX3RoaXMuX3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTsgfSk7XG4gICAgICAgIHRoaXMuX3JlaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUod2luKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHdpbik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/fancy-canvas/device-pixel-ratio.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/fancy-canvas/index.mjs":
/*!**********************************************!*\
  !*** ../node_modules/fancy-canvas/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasRenderingTarget2D),\n/* harmony export */   bindCanvasElementBitmapSizeTo: () => (/* reexport safe */ _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__.bindTo),\n/* harmony export */   createCanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.createCanvasRenderingTarget2D),\n/* harmony export */   equalSizes: () => (/* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes),\n/* harmony export */   size: () => (/* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   tryCreateCanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.tryCreateCanvasRenderingTarget2D)\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/../node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas-element-bitmap-size.mjs */ \"(app-pages-browser)/../node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\");\n/* harmony import */ var _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas-rendering-target.mjs */ \"(app-pages-browser)/../node_modules/fancy-canvas/canvas-rendering-target.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOEM7QUFDOEM7QUFDOEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hYmhhc2t1bWFycnIvRG9jdW1lbnRzL0dpdEh1Yi9TbWFydE1hcmtldE9PUFMvbm9kZV9tb2R1bGVzL2ZhbmN5LWNhbnZhcy9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgc2l6ZSwgZXF1YWxTaXplcyB9IGZyb20gXCIuL3NpemUubWpzXCI7XG5leHBvcnQgeyBiaW5kVG8gYXMgYmluZENhbnZhc0VsZW1lbnRCaXRtYXBTaXplVG8sIH0gZnJvbSBcIi4vY2FudmFzLWVsZW1lbnQtYml0bWFwLXNpemUubWpzXCI7XG5leHBvcnQgeyBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCwgY3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQsIHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJELCB9IGZyb20gXCIuL2NhbnZhcy1yZW5kZXJpbmctdGFyZ2V0Lm1qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/fancy-canvas/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/fancy-canvas/size.mjs":
/*!*********************************************!*\
  !*** ../node_modules/fancy-canvas/size.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalSizes: () => (/* binding */ equalSizes),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\nfunction size(_a) {\n    var width = _a.width, height = _a.height;\n    if (width < 0) {\n        throw new Error('Negative width is not allowed for Size');\n    }\n    if (height < 0) {\n        throw new Error('Negative height is not allowed for Size');\n    }\n    return {\n        width: width,\n        height: height,\n    };\n}\nfunction equalSizes(first, second) {\n    return (first.width === second.width) &&\n        (first.height === second.height);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL3NpemUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FiaGFza3VtYXJyci9Eb2N1bWVudHMvR2l0SHViL1NtYXJ0TWFya2V0T09QUy9ub2RlX21vZHVsZXMvZmFuY3ktY2FudmFzL3NpemUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBzaXplKF9hKSB7XG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgd2lkdGggaXMgbm90IGFsbG93ZWQgZm9yIFNpemUnKTtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWdhdGl2ZSBoZWlnaHQgaXMgbm90IGFsbG93ZWQgZm9yIFNpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsU2l6ZXMoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiAoZmlyc3Qud2lkdGggPT09IHNlY29uZC53aWR0aCkgJiZcbiAgICAgICAgKGZpcnN0LmhlaWdodCA9PT0gc2Vjb25kLmhlaWdodCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/fancy-canvas/size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/lightweight-charts/dist/lightweight-charts.development.mjs":
/*!**********************************************************************************!*\
  !*** ../node_modules/lightweight-charts/dist/lightweight-charts.development.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AreaSeries: () => (/* binding */ areaSeries),\n/* harmony export */   BarSeries: () => (/* binding */ barSeries),\n/* harmony export */   BaselineSeries: () => (/* binding */ baselineSeries),\n/* harmony export */   CandlestickSeries: () => (/* binding */ candlestickSeries),\n/* harmony export */   ColorType: () => (/* binding */ ColorType),\n/* harmony export */   CrosshairMode: () => (/* binding */ CrosshairMode),\n/* harmony export */   HistogramSeries: () => (/* binding */ histogramSeries),\n/* harmony export */   LastPriceAnimationMode: () => (/* binding */ LastPriceAnimationMode),\n/* harmony export */   LineSeries: () => (/* binding */ lineSeries),\n/* harmony export */   LineStyle: () => (/* binding */ LineStyle),\n/* harmony export */   LineType: () => (/* binding */ LineType),\n/* harmony export */   MismatchDirection: () => (/* binding */ MismatchDirection),\n/* harmony export */   PriceLineSource: () => (/* binding */ PriceLineSource),\n/* harmony export */   PriceScaleMode: () => (/* binding */ PriceScaleMode),\n/* harmony export */   TickMarkType: () => (/* binding */ TickMarkType),\n/* harmony export */   TrackingModeExitMode: () => (/* binding */ TrackingModeExitMode),\n/* harmony export */   createChart: () => (/* binding */ createChart),\n/* harmony export */   createChartEx: () => (/* binding */ createChartEx),\n/* harmony export */   createImageWatermark: () => (/* binding */ createImageWatermark),\n/* harmony export */   createOptionsChart: () => (/* binding */ createOptionsChart),\n/* harmony export */   createSeriesMarkers: () => (/* binding */ createSeriesMarkers),\n/* harmony export */   createTextWatermark: () => (/* binding */ createTextWatermark),\n/* harmony export */   createUpDownMarkers: () => (/* binding */ createUpDownMarkers),\n/* harmony export */   createYieldCurveChart: () => (/* binding */ createYieldCurveChart),\n/* harmony export */   customSeriesDefaultOptions: () => (/* binding */ customSeriesDefaultOptions),\n/* harmony export */   defaultHorzScaleBehavior: () => (/* binding */ defaultHorzScaleBehavior),\n/* harmony export */   isBusinessDay: () => (/* binding */ isBusinessDay),\n/* harmony export */   isUTCTimestamp: () => (/* binding */ isUTCTimestamp),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var fancy_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fancy-canvas */ \"(app-pages-browser)/../node_modules/fancy-canvas/index.mjs\");\n/*!\n * @license\n * TradingView Lightweight Charts™ v5.0.7\n * Copyright (c) 2025 TradingView, Inc.\n * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n */ \nconst customStyleDefaults$1 = {\n    color: '#2196f3'\n};\nconst seriesOptionsDefaults = {\n    title: '',\n    visible: true,\n    lastValueVisible: true,\n    priceLineVisible: true,\n    priceLineSource: 0 /* PriceLineSource.LastBar */ ,\n    priceLineWidth: 1,\n    priceLineColor: '',\n    priceLineStyle: 2 /* LineStyle.Dashed */ ,\n    baseLineVisible: true,\n    baseLineWidth: 1,\n    baseLineColor: '#B2B5BE',\n    baseLineStyle: 0 /* LineStyle.Solid */ ,\n    priceFormat: {\n        type: 'price',\n        precision: 2,\n        minMove: 0.01\n    }\n};\n/**\n * Represents the possible line types.\n */ var LineType;\n(function(LineType) {\n    /**\n     * A line.\n     */ LineType[LineType[\"Simple\"] = 0] = \"Simple\";\n    /**\n     * A stepped line.\n     */ LineType[LineType[\"WithSteps\"] = 1] = \"WithSteps\";\n    /**\n     * A curved line.\n     */ LineType[LineType[\"Curved\"] = 2] = \"Curved\";\n})(LineType || (LineType = {}));\n/**\n * Represents the possible line styles.\n */ var LineStyle;\n(function(LineStyle) {\n    /**\n     * A solid line.\n     */ LineStyle[LineStyle[\"Solid\"] = 0] = \"Solid\";\n    /**\n     * A dotted line.\n     */ LineStyle[LineStyle[\"Dotted\"] = 1] = \"Dotted\";\n    /**\n     * A dashed line.\n     */ LineStyle[LineStyle[\"Dashed\"] = 2] = \"Dashed\";\n    /**\n     * A dashed line with bigger dashes.\n     */ LineStyle[LineStyle[\"LargeDashed\"] = 3] = \"LargeDashed\";\n    /**\n     * A dotted line with more space between dots.\n     */ LineStyle[LineStyle[\"SparseDotted\"] = 4] = \"SparseDotted\";\n})(LineStyle || (LineStyle = {}));\nfunction setLineStyle(ctx, style) {\n    const dashPatterns = {\n        [0 /* LineStyle.Solid */ ]: [],\n        [1 /* LineStyle.Dotted */ ]: [\n            ctx.lineWidth,\n            ctx.lineWidth\n        ],\n        [2 /* LineStyle.Dashed */ ]: [\n            2 * ctx.lineWidth,\n            2 * ctx.lineWidth\n        ],\n        [3 /* LineStyle.LargeDashed */ ]: [\n            6 * ctx.lineWidth,\n            6 * ctx.lineWidth\n        ],\n        [4 /* LineStyle.SparseDotted */ ]: [\n            ctx.lineWidth,\n            4 * ctx.lineWidth\n        ]\n    };\n    const dashPattern = dashPatterns[style];\n    ctx.setLineDash(dashPattern);\n}\nfunction drawHorizontalLine(ctx, y, left, right) {\n    ctx.beginPath();\n    const correction = ctx.lineWidth % 2 ? 0.5 : 0;\n    ctx.moveTo(left, y + correction);\n    ctx.lineTo(right, y + correction);\n    ctx.stroke();\n}\nfunction drawVerticalLine(ctx, x, top, bottom) {\n    ctx.beginPath();\n    const correction = ctx.lineWidth % 2 ? 0.5 : 0;\n    ctx.moveTo(x + correction, top);\n    ctx.lineTo(x + correction, bottom);\n    ctx.stroke();\n}\nfunction strokeInPixel(ctx, drawFunction) {\n    ctx.save();\n    if (ctx.lineWidth % 2) {\n        ctx.translate(0.5, 0.5);\n    }\n    drawFunction();\n    ctx.restore();\n}\n/**\n * Checks an assertion. Throws if the assertion is failed.\n *\n * @param condition - Result of the assertion evaluation\n * @param message - Text to include in the exception message\n */ function assert(condition, message) {\n    if (!condition) {\n        throw new Error('Assertion failed' + (message ? ': ' + message : ''));\n    }\n}\nfunction ensureDefined(value) {\n    if (value === undefined) {\n        throw new Error('Value is undefined');\n    }\n    return value;\n}\nfunction ensureNotNull(value) {\n    if (value === null) {\n        throw new Error('Value is null');\n    }\n    return value;\n}\nfunction ensure(value) {\n    return ensureNotNull(ensureDefined(value));\n}\n/**\n * Compile time check for never\n */ function ensureNever(value) {}\nclass Delegate {\n    _internal_subscribe(callback, linkedObject, singleshot) {\n        const listener = {\n            _internal_callback: callback,\n            _internal_linkedObject: linkedObject,\n            _internal_singleshot: singleshot === true\n        };\n        this._private__listeners.push(listener);\n    }\n    _internal_unsubscribe(callback) {\n        const index = this._private__listeners.findIndex((listener)=>callback === listener._internal_callback);\n        if (index > -1) {\n            this._private__listeners.splice(index, 1);\n        }\n    }\n    _internal_unsubscribeAll(linkedObject) {\n        this._private__listeners = this._private__listeners.filter((listener)=>listener._internal_linkedObject !== linkedObject);\n    }\n    _internal_fire(param1, param2, param3) {\n        const listenersSnapshot = [\n            ...this._private__listeners\n        ];\n        this._private__listeners = this._private__listeners.filter((listener)=>!listener._internal_singleshot);\n        listenersSnapshot.forEach((listener)=>listener._internal_callback(param1, param2, param3));\n    }\n    _internal_hasListeners() {\n        return this._private__listeners.length > 0;\n    }\n    _internal_destroy() {\n        this._private__listeners = [];\n    }\n    constructor(){\n        this._private__listeners = [];\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction merge(dst) {\n    for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        sources[_key - 1] = arguments[_key];\n    }\n    for (const src of sources){\n        // eslint-disable-next-line no-restricted-syntax\n        for(const i in src){\n            if (src[i] === undefined || !Object.prototype.hasOwnProperty.call(src, i) || [\n                '__proto__',\n                'constructor',\n                'prototype'\n            ].includes(i)) {\n                continue;\n            }\n            if ('object' !== typeof src[i] || dst[i] === undefined || Array.isArray(src[i])) {\n                dst[i] = src[i];\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                merge(dst[i], src[i]);\n            }\n        }\n    }\n    return dst;\n}\nfunction isNumber(value) {\n    return typeof value === 'number' && isFinite(value);\n}\nfunction isInteger(value) {\n    return typeof value === 'number' && value % 1 === 0;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction clone(object) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const o = object;\n    if (!o || 'object' !== typeof o) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return o;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let c;\n    if (Array.isArray(o)) {\n        c = [];\n    } else {\n        c = {};\n    }\n    let p;\n    let v;\n    // eslint-disable-next-line no-restricted-syntax\n    for(p in o){\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,no-prototype-builtins\n        if (o.hasOwnProperty(p)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            v = o[p];\n            if (v && 'object' === typeof v) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = clone(v);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = v;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return c;\n}\nfunction notNull(t) {\n    return t !== null;\n}\nfunction undefinedIfNull(t) {\n    return t === null ? undefined : t;\n}\n/**\n * Default font family.\n * Must be used to generate font string when font is not specified.\n */ const defaultFontFamily = \"-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif\";\n/**\n * Generates a font string, which can be used to set in canvas' font property.\n * If no family provided, {@link defaultFontFamily} will be used.\n *\n * @param size - Font size in pixels.\n * @param family - Optional font family.\n * @param style - Optional font style.\n * @returns The font string.\n */ function makeFont(size, family, style) {\n    if (style !== undefined) {\n        style = \"\".concat(style, \" \");\n    } else {\n        style = '';\n    }\n    if (family === undefined) {\n        family = defaultFontFamily;\n    }\n    return \"\".concat(style).concat(size, \"px \").concat(family);\n}\nclass PriceAxisRendererOptionsProvider {\n    _internal_options() {\n        const rendererOptions = this._private__rendererOptions;\n        const currentFontSize = this._private__fontSize();\n        const currentFontFamily = this._private__fontFamily();\n        if (rendererOptions._internal_fontSize !== currentFontSize || rendererOptions._internal_fontFamily !== currentFontFamily) {\n            rendererOptions._internal_fontSize = currentFontSize;\n            rendererOptions._internal_fontFamily = currentFontFamily;\n            rendererOptions._internal_font = makeFont(currentFontSize, currentFontFamily);\n            rendererOptions._internal_paddingTop = 2.5 / 12 * currentFontSize; // 2.5 px for 12px font\n            rendererOptions._internal_paddingBottom = rendererOptions._internal_paddingTop;\n            rendererOptions._internal_paddingInner = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_paddingOuter = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_baselineOffset = 0;\n        }\n        rendererOptions._internal_color = this._private__textColor();\n        rendererOptions._internal_paneBackgroundColor = this._private__paneBackgroundColor();\n        return this._private__rendererOptions;\n    }\n    _private__textColor() {\n        return this._private__chartModel._internal_options()['layout'].textColor;\n    }\n    _private__paneBackgroundColor() {\n        return this._private__chartModel._internal_backgroundTopColor();\n    }\n    _private__fontSize() {\n        return this._private__chartModel._internal_options()['layout'].fontSize;\n    }\n    _private__fontFamily() {\n        return this._private__chartModel._internal_options()['layout'].fontFamily;\n    }\n    constructor(chartModel){\n        this._private__rendererOptions = {\n            _internal_borderSize: 1 /* RendererConstants.BorderSize */ ,\n            _internal_tickLength: 5 /* RendererConstants.TickLength */ ,\n            _internal_fontSize: NaN,\n            _internal_font: '',\n            _internal_fontFamily: '',\n            _internal_color: '',\n            _internal_paneBackgroundColor: '',\n            _internal_paddingBottom: 0,\n            _internal_paddingInner: 0,\n            _internal_paddingOuter: 0,\n            _internal_paddingTop: 0,\n            _internal_baselineOffset: 0\n        };\n        this._private__chartModel = chartModel;\n    }\n}\nfunction normalizeRgbComponent(component) {\n    if (component < 0) {\n        return 0;\n    }\n    if (component > 255) {\n        return 255;\n    }\n    // NaN values are treated as 0\n    return Math.round(component) || 0;\n}\nfunction normalizeAlphaComponent(component) {\n    if (component <= 0 || component > 1) {\n        return Math.min(Math.max(component, 0), 1);\n    }\n    // limit the precision of all numbers to at most 4 digits in fractional part\n    return Math.round(component * 10000) / 10000;\n}\nfunction rgbaToGrayscale(rgbValue) {\n    // Originally, the NTSC RGB to YUV formula\n    // perfected by @eugene-korobko's black magic\n    const redComponentGrayscaleWeight = 0.199;\n    const greenComponentGrayscaleWeight = 0.687;\n    const blueComponentGrayscaleWeight = 0.114;\n    return redComponentGrayscaleWeight * rgbValue[0] + greenComponentGrayscaleWeight * rgbValue[1] + blueComponentGrayscaleWeight * rgbValue[2];\n}\n/**\n * For colors which fall within the sRGB space, the browser can\n * be used to convert the color string into a rgb /rgba string.\n *\n * For other colors, it will be returned as specified (i.e. for\n * newer formats like display-p3)\n *\n * See: https://www.w3.org/TR/css-color-4/#serializing-sRGB-values\n */ function getRgbStringViaBrowser(color) {\n    const element = document.createElement('div');\n    element.style.display = 'none';\n    // We append to the body as it is the most reliable way to get a color reading\n    // appending to the chart container or similar element can result in the following\n    // getComputedStyle returning empty strings on each check.\n    document.body.appendChild(element);\n    element.style.color = color;\n    const computed = window.getComputedStyle(element).color;\n    document.body.removeChild(element);\n    return computed;\n}\nclass ColorParser {\n    /**\n     * We fallback to RGBA here since supporting alpha transformations\n     * on wider color gamuts would currently be a lot of extra code\n     * for very little benefit due to actual usage.\n     */ _internal_applyAlpha(color, alpha) {\n        // special case optimization\n        if (color === 'transparent') {\n            return color;\n        }\n        const originRgba = this._private__parseColor(color);\n        const originAlpha = originRgba[3];\n        return \"rgba(\".concat(originRgba[0], \", \").concat(originRgba[1], \", \").concat(originRgba[2], \", \").concat(alpha * originAlpha, \")\");\n    }\n    _internal_generateContrastColors(background) {\n        const rgba = this._private__parseColor(background);\n        return {\n            _internal_background: \"rgb(\".concat(rgba[0], \", \").concat(rgba[1], \", \").concat(rgba[2], \")\"),\n            _internal_foreground: rgbaToGrayscale(rgba) > 160 ? 'black' : 'white'\n        };\n    }\n    _internal_colorStringToGrayscale(background) {\n        return rgbaToGrayscale(this._private__parseColor(background));\n    }\n    _internal_gradientColorAtPercent(topColor, bottomColor, percent) {\n        const [topR, topG, topB, topA] = this._private__parseColor(topColor);\n        const [bottomR, bottomG, bottomB, bottomA] = this._private__parseColor(bottomColor);\n        const resultRgba = [\n            normalizeRgbComponent(topR + percent * (bottomR - topR)),\n            normalizeRgbComponent(topG + percent * (bottomG - topG)),\n            normalizeRgbComponent(topB + percent * (bottomB - topB)),\n            normalizeAlphaComponent(topA + percent * (bottomA - topA))\n        ];\n        return \"rgba(\".concat(resultRgba[0], \", \").concat(resultRgba[1], \", \").concat(resultRgba[2], \", \").concat(resultRgba[3], \")\");\n    }\n    _private__parseColor(color) {\n        const cached = this._private__rgbaCache.get(color);\n        if (cached) {\n            return cached;\n        }\n        const computed = getRgbStringViaBrowser(color);\n        const match = computed.match(/^rgba?\\s*\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d+))?\\)$/);\n        if (!match) {\n            if (this._private__customParsers.length) {\n                for (const parser of this._private__customParsers){\n                    const result = parser(color);\n                    if (result) {\n                        this._private__rgbaCache.set(color, result);\n                        return result;\n                    }\n                }\n            }\n            throw new Error(\"Failed to parse color: \".concat(color));\n        }\n        const rgba = [\n            parseInt(match[1], 10),\n            parseInt(match[2], 10),\n            parseInt(match[3], 10),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n        this._private__rgbaCache.set(color, rgba);\n        return rgba;\n    }\n    constructor(customParsers, initialCache){\n        this._private__rgbaCache = new Map();\n        this._private__customParsers = customParsers;\n        if (initialCache) {\n            this._private__rgbaCache = initialCache;\n        }\n    }\n}\nclass CompositeRenderer {\n    _internal_setRenderers(renderers) {\n        this._private__renderers = renderers;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__renderers.forEach((r)=>{\n            r._internal_draw(target, isHovered, hitTestData);\n        });\n    }\n    constructor(){\n        this._private__renderers = [];\n    }\n}\nclass BitmapCoordinatesPaneRenderer {\n    _internal_draw(target, isHovered, hitTestData) {\n        target.useBitmapCoordinateSpace((scope)=>this._internal__drawImpl(scope, isHovered, hitTestData));\n    }\n}\nclass PaneRendererMarks extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._internal__data === null || this._internal__data._internal_visibleRange === null) {\n            return;\n        }\n        const visibleRange = this._internal__data._internal_visibleRange;\n        const data = this._internal__data;\n        const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        const correction = tickWidth % 2 / 2;\n        const draw = (radiusMedia)=>{\n            ctx.beginPath();\n            for(let i = visibleRange.to - 1; i >= visibleRange.from; --i){\n                const point = data._internal_items[i];\n                const centerX = Math.round(point._internal_x * horizontalPixelRatio) + correction; // correct x coordinate only\n                const centerY = point._internal_y * verticalPixelRatio;\n                const radius = radiusMedia * verticalPixelRatio + correction;\n                ctx.moveTo(centerX, centerY);\n                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n            }\n            ctx.fill();\n        };\n        if (data._internal_lineWidth > 0) {\n            ctx.fillStyle = data._internal_backColor;\n            draw(data._internal_radius + data._internal_lineWidth);\n        }\n        ctx.fillStyle = data._internal_lineColor;\n        draw(data._internal_radius);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nfunction createEmptyMarkerData() {\n    return {\n        _internal_items: [\n            {\n                _internal_x: 0,\n                _internal_y: 0,\n                _internal_time: 0,\n                _internal_price: 0\n            }\n        ],\n        _internal_lineColor: '',\n        _internal_backColor: '',\n        _internal_radius: 0,\n        _internal_lineWidth: 0,\n        _internal_visibleRange: null\n    };\n}\nconst rangeForSinglePoint = {\n    from: 0,\n    to: 1\n};\nclass CrosshairMarksPaneView {\n    _internal_update(updateType) {\n        this._private__createMarkerRenderersIfNeeded();\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__compositeRenderer;\n    }\n    _private__createMarkerRenderersIfNeeded() {\n        const serieses = this._private__pane._internal_orderedSources();\n        if (serieses.length !== this._private__markersRenderers.length) {\n            this._private__markersData = serieses.map(createEmptyMarkerData);\n            this._private__markersRenderers = this._private__markersData.map((data)=>{\n                const res = new PaneRendererMarks();\n                res._internal_setData(data);\n                return res;\n            });\n            this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n        }\n    }\n    _private__updateImpl() {\n        const forceHidden = this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */  || !this._private__crosshair._internal_visible();\n        const serieses = this._private__pane._internal_orderedSeries();\n        const timePointIndex = this._private__crosshair._internal_appliedIndex();\n        const timeScale = this._private__chartModel._internal_timeScale();\n        this._private__createMarkerRenderersIfNeeded();\n        serieses.forEach((s, index)=>{\n            const data = this._private__markersData[index];\n            const seriesData = s._internal_markerDataAtIndex(timePointIndex);\n            const firstValue = s._internal_firstValue();\n            if (forceHidden || seriesData === null || !s._internal_visible() || firstValue === null) {\n                data._internal_visibleRange = null;\n                return;\n            }\n            data._internal_lineColor = seriesData._internal_backgroundColor;\n            data._internal_radius = seriesData._internal_radius;\n            data._internal_lineWidth = seriesData._internal_borderWidth;\n            data._internal_items[0]._internal_price = seriesData._internal_price;\n            data._internal_items[0]._internal_y = s._internal_priceScale()._internal_priceToCoordinate(seriesData._internal_price, firstValue._internal_value);\n            var _seriesData__internal_borderColor;\n            data._internal_backColor = (_seriesData__internal_borderColor = seriesData._internal_borderColor) !== null && _seriesData__internal_borderColor !== void 0 ? _seriesData__internal_borderColor : this._private__chartModel._internal_backgroundColorAtYPercentFromTop(data._internal_items[0]._internal_y / s._internal_priceScale()._internal_height());\n            data._internal_items[0]._internal_time = timePointIndex;\n            data._internal_items[0]._internal_x = timeScale._internal_indexToCoordinate(timePointIndex);\n            data._internal_visibleRange = rangeForSinglePoint;\n        });\n    }\n    constructor(chartModel, crosshair, pane){\n        this._private__compositeRenderer = new CompositeRenderer();\n        this._private__markersRenderers = [];\n        this._private__markersData = [];\n        this._private__invalidated = true;\n        this._private__chartModel = chartModel;\n        this._private__crosshair = crosshair;\n        this._private__pane = pane;\n        this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n    }\n}\nclass CrosshairRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        const vertLinesVisible = this._private__data._internal_vertLine._internal_visible;\n        const horzLinesVisible = this._private__data._internal_horzLine._internal_visible;\n        if (!vertLinesVisible && !horzLinesVisible) {\n            return;\n        }\n        const x = Math.round(this._private__data._internal_x * horizontalPixelRatio);\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        ctx.lineCap = 'butt';\n        if (vertLinesVisible && x >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_vertLine._internal_lineWidth * horizontalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_vertLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_vertLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_vertLine._internal_lineStyle);\n            drawVerticalLine(ctx, x, 0, bitmapSize.height);\n        }\n        if (horzLinesVisible && y >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_horzLine._internal_lineWidth * verticalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_horzLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_horzLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_horzLine._internal_lineStyle);\n            drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n        }\n    }\n    constructor(data){\n        super();\n        this._private__data = data;\n    }\n}\nclass CrosshairPaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer(pane) {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const visible = this._private__source._internal_visible();\n        const crosshairOptions = this._private__pane._internal_model()._internal_options().crosshair;\n        const data = this._private__rendererData;\n        if (crosshairOptions.mode === 2 /* CrosshairMode.Hidden */ ) {\n            data._internal_horzLine._internal_visible = false;\n            data._internal_vertLine._internal_visible = false;\n            return;\n        }\n        data._internal_horzLine._internal_visible = visible && this._private__source._internal_horzLineVisible(this._private__pane);\n        data._internal_vertLine._internal_visible = visible && this._private__source._internal_vertLineVisible();\n        data._internal_horzLine._internal_lineWidth = crosshairOptions.horzLine.width;\n        data._internal_horzLine._internal_lineStyle = crosshairOptions.horzLine.style;\n        data._internal_horzLine._internal_color = crosshairOptions.horzLine.color;\n        data._internal_vertLine._internal_lineWidth = crosshairOptions.vertLine.width;\n        data._internal_vertLine._internal_lineStyle = crosshairOptions.vertLine.style;\n        data._internal_vertLine._internal_color = crosshairOptions.vertLine.color;\n        data._internal_x = this._private__source._internal_appliedX();\n        data._internal_y = this._private__source._internal_appliedY();\n    }\n    constructor(source, pane){\n        this._private__invalidated = true;\n        this._private__rendererData = {\n            _internal_vertLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: '',\n                _internal_visible: false\n            },\n            _internal_horzLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: '',\n                _internal_visible: false\n            },\n            _internal_x: 0,\n            _internal_y: 0\n        };\n        this._private__renderer = new CrosshairRenderer(this._private__rendererData);\n        this._private__source = source;\n        this._private__pane = pane;\n    }\n}\n/**\n * Fills rectangle's inner border (so, all the filled area is limited by the [x, x + width]*[y, y + height] region)\n * ```\n * (x, y)\n * O***********************|*****\n * |        border         |  ^\n * |   *****************   |  |\n * |   |               |   |  |\n * | b |               | b |  h\n * | o |               | o |  e\n * | r |               | r |  i\n * | d |               | d |  g\n * | e |               | e |  h\n * | r |               | r |  t\n * |   |               |   |  |\n * |   *****************   |  |\n * |        border         |  v\n * |***********************|*****\n * |                       |\n * |<------- width ------->|\n * ```\n *\n * @param ctx - Context to draw on\n * @param x - Left side of the target rectangle\n * @param y - Top side of the target rectangle\n * @param width - Width of the target rectangle\n * @param height - Height of the target rectangle\n * @param borderWidth - Width of border to fill, must be less than width and height of the target rectangle\n */ function fillRectInnerBorder(ctx, x, y, width, height, borderWidth) {\n    // horizontal (top and bottom) edges\n    ctx.fillRect(x + borderWidth, y, width - borderWidth * 2, borderWidth);\n    ctx.fillRect(x + borderWidth, y + height - borderWidth, width - borderWidth * 2, borderWidth);\n    // vertical (left and right) edges\n    ctx.fillRect(x, y, borderWidth, height);\n    ctx.fillRect(x + width - borderWidth, y, borderWidth, height);\n}\nfunction clearRect(ctx, x, y, w, h, clearColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = 'copy';\n    ctx.fillStyle = clearColor;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\nfunction changeBorderRadius(borderRadius, offset) {\n    return borderRadius.map((x)=>x === 0 ? x : x + offset);\n}\nfunction drawRoundRect(// eslint:disable-next-line:max-params\nctx, x, y, w, h, radii) {\n    /**\n     * As of May 2023, all of the major browsers now support ctx.roundRect() so we should\n     * be able to switch to the native version soon.\n     */ ctx.beginPath();\n    if (ctx.roundRect) {\n        ctx.roundRect(x, y, w, h, radii);\n        return;\n    }\n    /*\n     * Deprecate the rest in v5.\n     */ ctx.lineTo(x + w - radii[1], y);\n    if (radii[1] !== 0) {\n        ctx.arcTo(x + w, y, x + w, y + radii[1], radii[1]);\n    }\n    ctx.lineTo(x + w, y + h - radii[2]);\n    if (radii[2] !== 0) {\n        ctx.arcTo(x + w, y + h, x + w - radii[2], y + h, radii[2]);\n    }\n    ctx.lineTo(x + radii[3], y + h);\n    if (radii[3] !== 0) {\n        ctx.arcTo(x, y + h, x, y + h - radii[3], radii[3]);\n    }\n    ctx.lineTo(x, y + radii[0]);\n    if (radii[0] !== 0) {\n        ctx.arcTo(x, y, x + radii[0], y, radii[0]);\n    }\n}\n/**\n * Draws a rounded rect with a border.\n *\n * This function assumes that the colors will be solid, without\n * any alpha. (This allows us to fix a rendering artefact.)\n *\n * @param outerBorderRadius - The radius of the border (outer edge)\n */ // eslint-disable-next-line max-params\nfunction drawRoundRectWithBorder(ctx, left, top, width, height, backgroundColor) {\n    let borderWidth = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0, outerBorderRadius = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [\n        0,\n        0,\n        0,\n        0\n    ], borderColor = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : '';\n    ctx.save();\n    if (!borderWidth || !borderColor || borderColor === backgroundColor) {\n        drawRoundRect(ctx, left, top, width, height, outerBorderRadius);\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n        return;\n    }\n    const halfBorderWidth = borderWidth / 2;\n    const radii = changeBorderRadius(outerBorderRadius, -halfBorderWidth);\n    drawRoundRect(ctx, left + halfBorderWidth, top + halfBorderWidth, width - borderWidth, height - borderWidth, radii);\n    if (backgroundColor !== 'transparent') {\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n    }\n    if (borderColor !== 'transparent') {\n        ctx.lineWidth = borderWidth;\n        ctx.strokeStyle = borderColor;\n        ctx.closePath();\n        ctx.stroke();\n    }\n    ctx.restore();\n}\n// eslint-disable-next-line max-params\nfunction clearRectWithGradient(ctx, x, y, w, h, topColor, bottomColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = 'copy';\n    const gradient = ctx.createLinearGradient(0, 0, 0, h);\n    gradient.addColorStop(0, topColor);\n    gradient.addColorStop(1, bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\nclass PriceAxisViewRenderer {\n    _internal_setData(data, commonData) {\n        this._private__data = data;\n        this._private__commonData = commonData;\n    }\n    _internal_height(rendererOptions, useSecondLine) {\n        if (!this._private__data._internal_visible) {\n            return 0;\n        }\n        return rendererOptions._internal_fontSize + rendererOptions._internal_paddingTop + rendererOptions._internal_paddingBottom;\n    }\n    _internal_draw(target, rendererOptions, textWidthCache, align) {\n        if (!this._private__data._internal_visible || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textColor = this._private__data._internal_color;\n        const backgroundColor = this._private__commonData._internal_background;\n        const geometry = target.useBitmapCoordinateSpace({\n            \"useBitmapCoordinateSpace[geometry]\": (scope)=>{\n                const ctx = scope.context;\n                ctx.font = rendererOptions._internal_font;\n                const geom = this._private__calculateGeometry(scope, rendererOptions, textWidthCache, align);\n                const gb = geom._internal_bitmap;\n                /*\n             draw label. backgroundColor will always be a solid color (no alpha) [see generateContrastColors in color.ts].\n             Therefore we can draw the rounded label using simplified code (drawRoundRectWithBorder) that doesn't need to ensure the background and the border don't overlap.\n            */ if (geom._internal_alignRight) {\n                    drawRoundRectWithBorder(ctx, gb._internal_xOutside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, backgroundColor, gb._internal_horzBorder, [\n                        gb._internal_radius,\n                        0,\n                        0,\n                        gb._internal_radius\n                    ], backgroundColor);\n                } else {\n                    drawRoundRectWithBorder(ctx, gb._internal_xInside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, backgroundColor, gb._internal_horzBorder, [\n                        0,\n                        gb._internal_radius,\n                        gb._internal_radius,\n                        0\n                    ], backgroundColor);\n                }\n                // draw tick\n                if (this._private__data._internal_tickVisible) {\n                    ctx.fillStyle = textColor;\n                    ctx.fillRect(gb._internal_xInside, gb._internal_yMid, gb._internal_xTick - gb._internal_xInside, gb._internal_tickHeight);\n                }\n                // draw separator\n                if (this._private__data._internal_borderVisible) {\n                    ctx.fillStyle = rendererOptions._internal_paneBackgroundColor;\n                    ctx.fillRect(geom._internal_alignRight ? gb._internal_right - gb._internal_horzBorder : 0, gb._internal_yTop, gb._internal_horzBorder, gb._internal_yBottom - gb._internal_yTop);\n                }\n                return geom;\n            }\n        }[\"useBitmapCoordinateSpace[geometry]\"]);\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const gm = geometry._internal_media;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = geometry._internal_alignRight ? 'right' : 'left';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = textColor;\n            ctx.fillText(this._private__data._internal_text, gm._internal_xText, (gm._internal_yTop + gm._internal_yBottom) / 2 + gm._internal_textMidCorrection);\n        });\n    }\n    _private__calculateGeometry(scope, rendererOptions, textWidthCache, align) {\n        const { context: ctx, bitmapSize, mediaSize, horizontalPixelRatio, verticalPixelRatio } = scope;\n        const tickSize = this._private__data._internal_tickVisible || !this._private__data._internal_moveTextToInvisibleTick ? rendererOptions._internal_tickLength : 0;\n        const horzBorder = this._private__data._internal_separatorVisible ? rendererOptions._internal_borderSize : 0;\n        const paddingTop = rendererOptions._internal_paddingTop + this._private__commonData._internal_additionalPaddingTop;\n        const paddingBottom = rendererOptions._internal_paddingBottom + this._private__commonData._internal_additionalPaddingBottom;\n        const paddingInner = rendererOptions._internal_paddingInner;\n        const paddingOuter = rendererOptions._internal_paddingOuter;\n        const text = this._private__data._internal_text;\n        const actualTextHeight = rendererOptions._internal_fontSize;\n        const textMidCorrection = textWidthCache._internal_yMidCorrection(ctx, text);\n        const textWidth = Math.ceil(textWidthCache._internal_measureText(ctx, text));\n        const totalHeight = actualTextHeight + paddingTop + paddingBottom;\n        const totalWidth = rendererOptions._internal_borderSize + paddingInner + paddingOuter + textWidth + tickSize;\n        const tickHeightBitmap = Math.max(1, Math.floor(verticalPixelRatio));\n        let totalHeightBitmap = Math.round(totalHeight * verticalPixelRatio);\n        if (totalHeightBitmap % 2 !== tickHeightBitmap % 2) {\n            totalHeightBitmap += 1;\n        }\n        const horzBorderBitmap = horzBorder > 0 ? Math.max(1, Math.floor(horzBorder * horizontalPixelRatio)) : 0;\n        const totalWidthBitmap = Math.round(totalWidth * horizontalPixelRatio);\n        // tick overlaps scale border\n        const tickSizeBitmap = Math.round(tickSize * horizontalPixelRatio);\n        var _this__private__commonData__internal_fixedCoordinate;\n        const yMid = (_this__private__commonData__internal_fixedCoordinate = this._private__commonData._internal_fixedCoordinate) !== null && _this__private__commonData__internal_fixedCoordinate !== void 0 ? _this__private__commonData__internal_fixedCoordinate : this._private__commonData._internal_coordinate;\n        const yMidBitmap = Math.round(yMid * verticalPixelRatio) - Math.floor(verticalPixelRatio * 0.5);\n        const yTopBitmap = Math.floor(yMidBitmap + tickHeightBitmap / 2 - totalHeightBitmap / 2);\n        const yBottomBitmap = yTopBitmap + totalHeightBitmap;\n        const alignRight = align === 'right';\n        const xInside = alignRight ? mediaSize.width - horzBorder : horzBorder;\n        const xInsideBitmap = alignRight ? bitmapSize.width - horzBorderBitmap : horzBorderBitmap;\n        let xOutsideBitmap;\n        let xTickBitmap;\n        let xText;\n        if (alignRight) {\n            // 2               1\n            //\n            //              6  5\n            //\n            // 3               4\n            xOutsideBitmap = xInsideBitmap - totalWidthBitmap;\n            xTickBitmap = xInsideBitmap - tickSizeBitmap;\n            xText = xInside - tickSize - paddingInner - horzBorder;\n        } else {\n            // 1               2\n            //\n            // 6  5\n            //\n            // 4               3\n            xOutsideBitmap = xInsideBitmap + totalWidthBitmap;\n            xTickBitmap = xInsideBitmap + tickSizeBitmap;\n            xText = xInside + tickSize + paddingInner;\n        }\n        return {\n            _internal_alignRight: alignRight,\n            _internal_bitmap: {\n                _internal_yTop: yTopBitmap,\n                _internal_yMid: yMidBitmap,\n                _internal_yBottom: yBottomBitmap,\n                _internal_totalWidth: totalWidthBitmap,\n                _internal_totalHeight: totalHeightBitmap,\n                // TODO: it is better to have different horizontal and vertical radii\n                _internal_radius: 2 * horizontalPixelRatio,\n                _internal_horzBorder: horzBorderBitmap,\n                _internal_xOutside: xOutsideBitmap,\n                _internal_xInside: xInsideBitmap,\n                _internal_xTick: xTickBitmap,\n                _internal_tickHeight: tickHeightBitmap,\n                _internal_right: bitmapSize.width\n            },\n            _internal_media: {\n                _internal_yTop: yTopBitmap / verticalPixelRatio,\n                _internal_yBottom: yBottomBitmap / verticalPixelRatio,\n                _internal_xText: xText,\n                _internal_textMidCorrection: textMidCorrection\n            }\n        };\n    }\n    constructor(data, commonData){\n        this._internal_setData(data, commonData);\n    }\n}\nclass PriceAxisView {\n    _internal_text() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_text;\n    }\n    _internal_coordinate() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__commonRendererData._internal_coordinate;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_height(rendererOptions) {\n        let useSecondLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return Math.max(this._private__axisRenderer._internal_height(rendererOptions, useSecondLine), this._private__paneRenderer._internal_height(rendererOptions, useSecondLine));\n    }\n    _internal_getFixedCoordinate() {\n        return this._private__commonRendererData._internal_fixedCoordinate || 0;\n    }\n    _internal_setFixedCoordinate(value) {\n        this._private__commonRendererData._internal_fixedCoordinate = value;\n    }\n    _internal_isVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible || this._private__paneRendererData._internal_visible;\n    }\n    _internal_isAxisLabelVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible;\n    }\n    _internal_renderer(priceScale) {\n        this._private__updateRendererDataIfNeeded();\n        // force update tickVisible state from price scale options\n        // because we don't have and we can't have price axis in other methods\n        // (like paneRenderer or any other who call _updateRendererDataIfNeeded)\n        this._private__axisRendererData._internal_tickVisible = this._private__axisRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__paneRendererData._internal_tickVisible = this._private__paneRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__axisRenderer;\n    }\n    _internal_paneRenderer() {\n        this._private__updateRendererDataIfNeeded();\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__paneRenderer;\n    }\n    _private__updateRendererDataIfNeeded() {\n        if (this._private__invalidated) {\n            this._private__axisRendererData._internal_tickVisible = true;\n            this._private__paneRendererData._internal_tickVisible = false;\n            this._internal__updateRendererData(this._private__axisRendererData, this._private__paneRendererData, this._private__commonRendererData);\n        }\n    }\n    constructor(ctor){\n        this._private__commonRendererData = {\n            _internal_coordinate: 0,\n            _internal_background: '#000',\n            _internal_additionalPaddingBottom: 0,\n            _internal_additionalPaddingTop: 0\n        };\n        this._private__axisRendererData = {\n            _internal_text: '',\n            _internal_visible: false,\n            _internal_tickVisible: true,\n            _internal_moveTextToInvisibleTick: false,\n            _internal_borderColor: '',\n            _internal_color: '#FFF',\n            _internal_borderVisible: false,\n            _internal_separatorVisible: false\n        };\n        this._private__paneRendererData = {\n            _internal_text: '',\n            _internal_visible: false,\n            _internal_tickVisible: false,\n            _internal_moveTextToInvisibleTick: true,\n            _internal_borderColor: '',\n            _internal_color: '#FFF',\n            _internal_borderVisible: true,\n            _internal_separatorVisible: true\n        };\n        this._private__invalidated = true;\n        this._private__axisRenderer = new (ctor || PriceAxisViewRenderer)(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer = new (ctor || PriceAxisViewRenderer)(this._private__paneRendererData, this._private__commonRendererData);\n    }\n}\nclass CrosshairPriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        if (this._private__source._internal_options().mode === 2 /* CrosshairMode.Hidden */ ) {\n            return;\n        }\n        const options = this._private__source._internal_options().horzLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (!this._private__source._internal_visible() || this._private__priceScale._internal_isEmpty() || firstValue === null) {\n            return;\n        }\n        const colors = this._private__priceScale._internal_colorParser()._internal_generateContrastColors(options.labelBackgroundColor);\n        commonRendererData._internal_background = colors._internal_background;\n        axisRendererData._internal_color = colors._internal_foreground;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        const value = this._private__valueProvider(this._private__priceScale);\n        commonRendererData._internal_coordinate = value._internal_coordinate;\n        axisRendererData._internal_text = this._private__priceScale._internal_formatPrice(value._internal_price, firstValue);\n        axisRendererData._internal_visible = true;\n    }\n    constructor(source, priceScale, valueProvider){\n        super();\n        this._private__source = source;\n        this._private__priceScale = priceScale;\n        this._private__valueProvider = valueProvider;\n    }\n}\nconst optimizationReplacementRe = /[1-9]/g;\nconst radius$1 = 2;\nclass TimeAxisViewRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_draw(target, rendererOptions) {\n        if (this._private__data === null || this._private__data._internal_visible === false || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textWidth = target.useMediaCoordinateSpace({\n            \"useMediaCoordinateSpace[textWidth]\": (param)=>{\n                let { context: ctx } = param;\n                ctx.font = rendererOptions._internal_font;\n                return Math.round(rendererOptions._internal_widthCache._internal_measureText(ctx, ensureNotNull(this._private__data)._internal_text, optimizationReplacementRe));\n            }\n        }[\"useMediaCoordinateSpace[textWidth]\"]);\n        if (textWidth <= 0) {\n            return;\n        }\n        const horzMargin = rendererOptions._internal_paddingHorizontal;\n        const labelWidth = textWidth + 2 * horzMargin;\n        const labelWidthHalf = labelWidth / 2;\n        const timeScaleWidth = this._private__data._internal_width;\n        let coordinate = this._private__data._internal_coordinate;\n        let x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (x1 < 0) {\n            coordinate = coordinate + Math.abs(0 - x1);\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        } else if (x1 + labelWidth > timeScaleWidth) {\n            coordinate = coordinate - Math.abs(timeScaleWidth - (x1 + labelWidth));\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        }\n        const x2 = x1 + labelWidth;\n        const y1 = 0;\n        const y2 = Math.ceil(y1 + rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize + rendererOptions._internal_paddingBottom);\n        target.useBitmapCoordinateSpace((param)=>{\n            let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n            const data = ensureNotNull(this._private__data);\n            ctx.fillStyle = data._internal_background;\n            const x1scaled = Math.round(x1 * horizontalPixelRatio);\n            const y1scaled = Math.round(y1 * verticalPixelRatio);\n            const x2scaled = Math.round(x2 * horizontalPixelRatio);\n            const y2scaled = Math.round(y2 * verticalPixelRatio);\n            const radiusScaled = Math.round(radius$1 * horizontalPixelRatio);\n            ctx.beginPath();\n            ctx.moveTo(x1scaled, y1scaled);\n            ctx.lineTo(x1scaled, y2scaled - radiusScaled);\n            ctx.arcTo(x1scaled, y2scaled, x1scaled + radiusScaled, y2scaled, radiusScaled);\n            ctx.lineTo(x2scaled - radiusScaled, y2scaled);\n            ctx.arcTo(x2scaled, y2scaled, x2scaled, y2scaled - radiusScaled, radiusScaled);\n            ctx.lineTo(x2scaled, y1scaled);\n            ctx.fill();\n            if (data._internal_tickVisible) {\n                const tickX = Math.round(data._internal_coordinate * horizontalPixelRatio);\n                const tickTop = y1scaled;\n                const tickBottom = Math.round((tickTop + rendererOptions._internal_tickLength) * verticalPixelRatio);\n                ctx.fillStyle = data._internal_color;\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.fillRect(tickX - tickOffset, tickTop, tickWidth, tickBottom - tickTop);\n            }\n        });\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const data = ensureNotNull(this._private__data);\n            const yText = y1 + rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize / 2;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = data._internal_color;\n            const textYCorrection = rendererOptions._internal_widthCache._internal_yMidCorrection(ctx, 'Apr0');\n            ctx.translate(x1 + horzMargin, yText + textYCorrection);\n            ctx.fillText(data._internal_text, 0, 0);\n        });\n    }\n    constructor(){\n        this._private__data = null;\n    }\n}\nclass CrosshairTimeAxisView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        this._private__renderer._internal_setData(this._private__rendererData);\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const data = this._private__rendererData;\n        data._internal_visible = false;\n        if (this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */ ) {\n            return;\n        }\n        const options = this._private__crosshair._internal_options().vertLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        data._internal_width = timeScale._internal_width();\n        const value = this._private__valueProvider();\n        if (value === null) {\n            return;\n        }\n        data._internal_coordinate = value._internal_coordinate;\n        const currentTime = timeScale._internal_indexToTimeScalePoint(this._private__crosshair._internal_appliedIndex());\n        data._internal_text = timeScale._internal_formatDateTime(ensureNotNull(currentTime));\n        data._internal_visible = true;\n        const colors = this._private__model._internal_colorParser()._internal_generateContrastColors(options.labelBackgroundColor);\n        data._internal_background = colors._internal_background;\n        data._internal_color = colors._internal_foreground;\n        data._internal_tickVisible = timeScale._internal_options().ticksVisible;\n    }\n    constructor(crosshair, model, valueProvider){\n        this._private__invalidated = true;\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__rendererData = {\n            _internal_visible: false,\n            _internal_background: '#4c525e',\n            _internal_color: 'white',\n            _internal_text: '',\n            _internal_width: 0,\n            _internal_coordinate: NaN,\n            _internal_tickVisible: true\n        };\n        this._private__crosshair = crosshair;\n        this._private__model = model;\n        this._private__valueProvider = valueProvider;\n    }\n}\nclass DataSource {\n    _internal_zorder() {\n        return this._private__zorder;\n    }\n    _internal_setZorder(zorder) {\n        this._private__zorder = zorder;\n    }\n    _internal_priceScale() {\n        return this._internal__priceScale;\n    }\n    _internal_setPriceScale(priceScale) {\n        this._internal__priceScale = priceScale;\n    }\n    _internal_labelPaneViews(pane) {\n        return [];\n    }\n    _internal_timeAxisViews() {\n        return [];\n    }\n    _internal_visible() {\n        return true;\n    }\n    constructor(){\n        this._internal__priceScale = null;\n        this._private__zorder = 0;\n    }\n}\n/**\n * Represents the crosshair mode.\n */ var CrosshairMode;\n(function(CrosshairMode) {\n    /**\n     * This mode allows crosshair to move freely on the chart.\n     */ CrosshairMode[CrosshairMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * This mode sticks crosshair's horizontal line to the price value of a single-value series or to the close price of OHLC-based series.\n     */ CrosshairMode[CrosshairMode[\"Magnet\"] = 1] = \"Magnet\";\n    /**\n     * This mode disables rendering of the crosshair.\n     */ CrosshairMode[CrosshairMode[\"Hidden\"] = 2] = \"Hidden\";\n    /**\n     * This mode sticks crosshair's horizontal line to the price value of a single-value series or to the open/high/low/close price of OHLC-based series.\n     */ CrosshairMode[CrosshairMode[\"MagnetOHLC\"] = 3] = \"MagnetOHLC\";\n})(CrosshairMode || (CrosshairMode = {}));\nclass Crosshair extends DataSource {\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_saveOriginCoord(x, y) {\n        this._private__originX = x;\n        this._private__originY = y;\n    }\n    _internal_clearOriginCoord() {\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n    }\n    _internal_originCoordX() {\n        return this._private__originX;\n    }\n    _internal_originCoordY() {\n        return this._private__originY;\n    }\n    _internal_setPosition(index, price, pane) {\n        if (!this._private__subscribed) {\n            this._private__subscribed = true;\n        }\n        this._private__visible = true;\n        this._private__tryToUpdateViews(index, price, pane);\n    }\n    _internal_appliedIndex() {\n        return this._private__index;\n    }\n    _internal_appliedX() {\n        return this._private__x;\n    }\n    _internal_appliedY() {\n        return this._private__y;\n    }\n    _internal_visible() {\n        return this._private__visible;\n    }\n    _internal_clearPosition() {\n        this._private__visible = false;\n        this._private__setIndexToLastSeriesBarIndex();\n        this._private__price = NaN;\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__pane = null;\n        this._internal_clearOriginCoord();\n        this._internal_updateAllViews();\n    }\n    _internal_paneViews(pane) {\n        let crosshairPaneView = this._private__crosshairPaneViewCache.get(pane);\n        if (!crosshairPaneView) {\n            crosshairPaneView = new CrosshairPaneView(this, pane);\n            this._private__crosshairPaneViewCache.set(pane, crosshairPaneView);\n        }\n        let markersPaneView = this._private__markersPaneViewCache.get(pane);\n        if (!markersPaneView) {\n            markersPaneView = new CrosshairMarksPaneView(this._private__model, this, pane);\n            this._private__markersPaneViewCache.set(pane, markersPaneView);\n        }\n        return [\n            crosshairPaneView,\n            markersPaneView\n        ];\n    }\n    _internal_horzLineVisible(pane) {\n        return pane === this._private__pane && this._private__options.horzLine.visible;\n    }\n    _internal_vertLineVisible() {\n        return this._private__options.vertLine.visible;\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (!this._private__visible || this._private__pane !== pane) {\n            this._private__priceAxisViews.clear();\n        }\n        const views = [];\n        if (this._private__pane === pane) {\n            views.push(this._private__createPriceAxisViewOnDemand(this._private__priceAxisViews, priceScale, this._private__currentPosPriceProvider));\n        }\n        return views;\n    }\n    _internal_timeAxisViews() {\n        return this._private__visible ? [\n            this._private__timeAxisView\n        ] : [];\n    }\n    _internal_pane() {\n        return this._private__pane;\n    }\n    _internal_updateAllViews() {\n        this._private__model._internal_panes().forEach((pane)=>{\n            var _this__private__crosshairPaneViewCache_get, _this__private__markersPaneViewCache_get;\n            (_this__private__crosshairPaneViewCache_get = this._private__crosshairPaneViewCache.get(pane)) === null || _this__private__crosshairPaneViewCache_get === void 0 ? void 0 : _this__private__crosshairPaneViewCache_get._internal_update();\n            (_this__private__markersPaneViewCache_get = this._private__markersPaneViewCache.get(pane)) === null || _this__private__markersPaneViewCache_get === void 0 ? void 0 : _this__private__markersPaneViewCache_get._internal_update();\n        });\n        this._private__priceAxisViews.forEach((value)=>value._internal_update());\n        this._private__timeAxisView._internal_update();\n    }\n    _private__priceScaleByPane(pane) {\n        if (pane && !pane._internal_defaultPriceScale()._internal_isEmpty()) {\n            return pane._internal_defaultPriceScale();\n        }\n        return null;\n    }\n    _private__tryToUpdateViews(index, price, pane) {\n        if (this._private__tryToUpdateData(index, price, pane)) {\n            this._internal_updateAllViews();\n        }\n    }\n    _private__tryToUpdateData(newIndex, newPrice, newPane) {\n        const oldX = this._private__x;\n        const oldY = this._private__y;\n        const oldPrice = this._private__price;\n        const oldIndex = this._private__index;\n        const oldPane = this._private__pane;\n        const priceScale = this._private__priceScaleByPane(newPane);\n        this._private__index = newIndex;\n        this._private__x = isNaN(newIndex) ? NaN : this._private__model._internal_timeScale()._internal_indexToCoordinate(newIndex);\n        this._private__pane = newPane;\n        const firstValue = priceScale !== null ? priceScale._internal_firstValue() : null;\n        if (priceScale !== null && firstValue !== null) {\n            this._private__price = newPrice;\n            this._private__y = priceScale._internal_priceToCoordinate(newPrice, firstValue);\n        } else {\n            this._private__price = NaN;\n            this._private__y = NaN;\n        }\n        return oldX !== this._private__x || oldY !== this._private__y || oldIndex !== this._private__index || oldPrice !== this._private__price || oldPane !== this._private__pane;\n    }\n    _private__setIndexToLastSeriesBarIndex() {\n        const lastIndexes = this._private__model._internal_serieses().map((s)=>s._internal_bars()._internal_lastIndex()).filter(notNull);\n        const lastBarIndex = lastIndexes.length === 0 ? null : Math.max(...lastIndexes);\n        this._private__index = lastBarIndex !== null ? lastBarIndex : NaN;\n    }\n    _private__createPriceAxisViewOnDemand(map, priceScale, valueProvider) {\n        let view = map.get(priceScale);\n        if (view === undefined) {\n            view = new CrosshairPriceAxisView(this, priceScale, valueProvider);\n            map.set(priceScale, view);\n        }\n        return view;\n    }\n    constructor(model, options){\n        super();\n        this._private__pane = null;\n        this._private__price = NaN;\n        this._private__index = 0;\n        this._private__visible = false; // initially the crosshair should not be visible, until the user interacts.\n        this._private__priceAxisViews = new Map();\n        this._private__subscribed = false;\n        this._private__crosshairPaneViewCache = new WeakMap();\n        this._private__markersPaneViewCache = new WeakMap();\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n        this._private__model = model;\n        this._private__options = options;\n        const valuePriceProvider = (rawPriceProvider, rawCoordinateProvider)=>{\n            return (priceScale)=>{\n                const coordinate = rawCoordinateProvider();\n                const rawPrice = rawPriceProvider();\n                if (priceScale === ensureNotNull(this._private__pane)._internal_defaultPriceScale()) {\n                    // price must be defined\n                    return {\n                        _internal_price: rawPrice,\n                        _internal_coordinate: coordinate\n                    };\n                } else {\n                    // always convert from coordinate\n                    const firstValue = ensureNotNull(priceScale._internal_firstValue());\n                    const price = priceScale._internal_coordinateToPrice(coordinate, firstValue);\n                    return {\n                        _internal_price: price,\n                        _internal_coordinate: coordinate\n                    };\n                }\n            };\n        };\n        const valueTimeProvider = (rawIndexProvider, rawCoordinateProvider)=>{\n            return ()=>{\n                const time = this._private__model._internal_timeScale()._internal_indexToTime(rawIndexProvider());\n                const coordinate = rawCoordinateProvider();\n                if (!time || !Number.isFinite(coordinate)) {\n                    return null;\n                }\n                return {\n                    _internal_time: time,\n                    _internal_coordinate: coordinate\n                };\n            };\n        };\n        // for current position always return both price and coordinate\n        this._private__currentPosPriceProvider = valuePriceProvider(()=>this._private__price, ()=>this._private__y);\n        const currentPosTimeProvider = valueTimeProvider(()=>this._private__index, ()=>this._internal_appliedX());\n        this._private__timeAxisView = new CrosshairTimeAxisView(this, model, currentPosTimeProvider);\n    }\n}\nfunction isDefaultPriceScale(priceScaleId) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    return priceScaleId === \"left\" /* DefaultPriceScaleId.Left */  || priceScaleId === \"right\" /* DefaultPriceScaleId.Right */ ;\n}\nfunction mergePaneInvalidation(beforeValue, newValue) {\n    if (beforeValue === undefined) {\n        return newValue;\n    }\n    const level = Math.max(beforeValue._internal_level, newValue._internal_level);\n    const autoScale = beforeValue._internal_autoScale || newValue._internal_autoScale;\n    return {\n        _internal_level: level,\n        _internal_autoScale: autoScale\n    };\n}\nclass InvalidateMask {\n    _internal_invalidatePane(paneIndex, invalidation) {\n        const prevValue = this._private__invalidatedPanes.get(paneIndex);\n        const newValue = mergePaneInvalidation(prevValue, invalidation);\n        this._private__invalidatedPanes.set(paneIndex, newValue);\n    }\n    _internal_fullInvalidation() {\n        return this._private__globalLevel;\n    }\n    _internal_invalidateForPane(paneIndex) {\n        const paneInvalidation = this._private__invalidatedPanes.get(paneIndex);\n        if (paneInvalidation === undefined) {\n            return {\n                _internal_level: this._private__globalLevel\n            };\n        }\n        return {\n            _internal_level: Math.max(this._private__globalLevel, paneInvalidation._internal_level),\n            _internal_autoScale: paneInvalidation._internal_autoScale\n        };\n    }\n    _internal_setFitContent() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 0 /* TimeScaleInvalidationType.FitContent */ \n            }\n        ];\n    }\n    _internal_applyRange(range) {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 1 /* TimeScaleInvalidationType.ApplyRange */ ,\n                _internal_value: range\n            }\n        ];\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 5 /* TimeScaleInvalidationType.Animation */ ,\n            _internal_value: animation\n        });\n    }\n    _internal_stopTimeScaleAnimation() {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 6 /* TimeScaleInvalidationType.StopAnimation */ \n        });\n    }\n    _internal_resetTimeScale() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [\n            {\n                _internal_type: 4 /* TimeScaleInvalidationType.Reset */ \n            }\n        ];\n    }\n    _internal_setBarSpacing(barSpacing) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ ,\n            _internal_value: barSpacing\n        });\n    }\n    _internal_setRightOffset(offset) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({\n            _internal_type: 3 /* TimeScaleInvalidationType.ApplyRightOffset */ ,\n            _internal_value: offset\n        });\n    }\n    _internal_timeScaleInvalidations() {\n        return this._private__timeScaleInvalidations;\n    }\n    _internal_merge(other) {\n        for (const tsInvalidation of other._private__timeScaleInvalidations){\n            this._private__applyTimeScaleInvalidation(tsInvalidation);\n        }\n        this._private__globalLevel = Math.max(this._private__globalLevel, other._private__globalLevel);\n        other._private__invalidatedPanes.forEach((invalidation, index)=>{\n            this._internal_invalidatePane(index, invalidation);\n        });\n    }\n    static _internal_light() {\n        return new InvalidateMask(2 /* InvalidationLevel.Light */ );\n    }\n    static _internal_full() {\n        return new InvalidateMask(3 /* InvalidationLevel.Full */ );\n    }\n    _private__applyTimeScaleInvalidation(invalidation) {\n        switch(invalidation._internal_type){\n            case 0 /* TimeScaleInvalidationType.FitContent */ :\n                this._internal_setFitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */ :\n                this._internal_applyRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ :\n                this._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */ :\n                this._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */ :\n                this._internal_resetTimeScale();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */ :\n                this._internal_setTimeScaleAnimation(invalidation._internal_value);\n                break;\n            case 6 /* TimeScaleInvalidationType.StopAnimation */ :\n                this._private__removeTimeScaleAnimation();\n        }\n    }\n    _private__removeTimeScaleAnimation() {\n        const index = this._private__timeScaleInvalidations.findIndex((inv)=>inv._internal_type === 5 /* TimeScaleInvalidationType.Animation */ );\n        if (index !== -1) {\n            this._private__timeScaleInvalidations.splice(index, 1);\n        }\n    }\n    constructor(globalLevel){\n        this._private__invalidatedPanes = new Map();\n        this._private__timeScaleInvalidations = [];\n        this._private__globalLevel = globalLevel;\n    }\n}\nconst formatterOptions = {\n    _internal_decimalSign: '.'\n};\n/**\n * @param value - The number of convert.\n * @param length - The length. Must be between 0 and 16 inclusive.\n */ function numberToStringWithLeadingZero(value, length) {\n    if (!isNumber(value)) {\n        return 'n/a';\n    }\n    if (!isInteger(length)) {\n        throw new TypeError('invalid length');\n    }\n    if (length < 0 || length > 16) {\n        throw new TypeError('invalid length');\n    }\n    if (length === 0) {\n        return value.toString();\n    }\n    const dummyString = '0000000000000000';\n    return (dummyString + value.toString()).slice(-length);\n}\nclass PriceFormatter {\n    format(price) {\n        // \\u2212 is unicode's minus sign https://www.fileformat.info/info/unicode/char/2212/index.htm\n        // we should use it because it has the same width as plus sign +\n        const sign = price < 0 ? '\\u2212' : '';\n        price = Math.abs(price);\n        return sign + this._private__formatAsDecimal(price);\n    }\n    _private__calculateDecimal() {\n        // check if this._base is power of 10\n        // for double fractional _fractionalLength if for the main fractional only\n        this._internal__fractionalLength = 0;\n        if (this._private__priceScale > 0 && this._private__minMove > 0) {\n            let base = this._private__priceScale;\n            while(base > 1){\n                base /= 10;\n                this._internal__fractionalLength++;\n            }\n        }\n    }\n    _private__formatAsDecimal(price) {\n        const base = this._private__priceScale / this._private__minMove;\n        let intPart = Math.floor(price);\n        let fracString = '';\n        const fracLength = this._internal__fractionalLength !== undefined ? this._internal__fractionalLength : NaN;\n        if (base > 1) {\n            let fracPart = +(Math.round(price * base) - intPart * base).toFixed(this._internal__fractionalLength);\n            if (fracPart >= base) {\n                fracPart -= base;\n                intPart += 1;\n            }\n            fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(+fracPart.toFixed(this._internal__fractionalLength) * this._private__minMove, fracLength);\n        } else {\n            // should round int part to min move\n            intPart = Math.round(intPart * base) / base;\n            // if min move > 1, fractional part is always = 0\n            if (fracLength > 0) {\n                fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(0, fracLength);\n            }\n        }\n        return intPart.toFixed(0) + fracString;\n    }\n    constructor(priceScale, minMove){\n        if (!minMove) {\n            minMove = 1;\n        }\n        if (!isNumber(priceScale) || !isInteger(priceScale)) {\n            priceScale = 100;\n        }\n        if (priceScale < 0) {\n            throw new TypeError('invalid base');\n        }\n        this._private__priceScale = priceScale;\n        this._private__minMove = minMove;\n        this._private__calculateDecimal();\n    }\n}\nclass PercentageFormatter extends PriceFormatter {\n    format(price) {\n        return \"\".concat(super.format(price), \"%\");\n    }\n    constructor(priceScale = 100){\n        super(priceScale);\n    }\n}\nclass VolumeFormatter {\n    format(vol) {\n        let sign = '';\n        if (vol < 0) {\n            sign = '-';\n            vol = -vol;\n        }\n        if (vol < 995) {\n            return sign + this._private__formatNumber(vol);\n        } else if (vol < 999995) {\n            return sign + this._private__formatNumber(vol / 1000) + 'K';\n        } else if (vol < 999999995) {\n            vol = 1000 * Math.round(vol / 1000);\n            return sign + this._private__formatNumber(vol / 1000000) + 'M';\n        } else {\n            vol = 1000000 * Math.round(vol / 1000000);\n            return sign + this._private__formatNumber(vol / 1000000000) + 'B';\n        }\n    }\n    _private__formatNumber(value) {\n        let res;\n        const priceScale = Math.pow(10, this._private__precision);\n        value = Math.round(value * priceScale) / priceScale;\n        if (value >= 1e-15 && value < 1) {\n            res = value.toFixed(this._private__precision).replace(/\\.?0+$/, ''); // regex removes trailing zeroes\n        } else {\n            res = String(value);\n        }\n        return res.replace(/(\\.[1-9]*)0+$/, (e, p1)=>p1);\n    }\n    constructor(precision){\n        this._private__precision = precision;\n    }\n}\nconst defaultReplacementRe = /[2-9]/g;\nclass TextWidthCache {\n    _internal_reset() {\n        this._private__actualSize = 0;\n        this._private__cache.clear();\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n    }\n    _internal_measureText(ctx, text, optimizationReplacementRe) {\n        return this._private__getMetrics(ctx, text, optimizationReplacementRe).width;\n    }\n    _internal_yMidCorrection(ctx, text, optimizationReplacementRe) {\n        const metrics = this._private__getMetrics(ctx, text, optimizationReplacementRe);\n        // if actualBoundingBoxAscent/actualBoundingBoxDescent are not supported we use 0 as a fallback\n        return ((metrics.actualBoundingBoxAscent || 0) - (metrics.actualBoundingBoxDescent || 0)) / 2;\n    }\n    _private__getMetrics(ctx, text, optimizationReplacementRe) {\n        const re = optimizationReplacementRe || defaultReplacementRe;\n        const cacheString = String(text).replace(re, '0');\n        if (this._private__cache.has(cacheString)) {\n            return ensureDefined(this._private__cache.get(cacheString))._internal_metrics;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels[this._private__oldestTick];\n            delete this._private__tick2Labels[this._private__oldestTick];\n            this._private__cache.delete(oldestValue);\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        ctx.save();\n        ctx.textBaseline = 'middle';\n        const metrics = ctx.measureText(cacheString);\n        ctx.restore();\n        if (metrics.width === 0 && !!text.length) {\n            // measureText can return 0 in FF depending on a canvas size, don't cache it\n            return metrics;\n        }\n        this._private__cache.set(cacheString, {\n            _internal_metrics: metrics,\n            _internal_tick: this._private__usageTick\n        });\n        this._private__tick2Labels[this._private__usageTick] = cacheString;\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return metrics;\n    }\n    constructor(size = 50){\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n        this._private__cache = new Map();\n        this._private__maxSize = size;\n    }\n}\nclass PanePriceAxisViewRenderer {\n    _internal_setParams(priceAxisViewRenderer, rendererOptions, align) {\n        this._private__priceAxisViewRenderer = priceAxisViewRenderer;\n        this._private__rendererOptions = rendererOptions;\n        this._private__align = align;\n    }\n    _internal_draw(target) {\n        if (this._private__rendererOptions === null || this._private__priceAxisViewRenderer === null) {\n            return;\n        }\n        this._private__priceAxisViewRenderer._internal_draw(target, this._private__rendererOptions, this._private__textWidthCache, this._private__align);\n    }\n    constructor(textWidthCache){\n        this._private__priceAxisViewRenderer = null;\n        this._private__rendererOptions = null;\n        this._private__align = 'right';\n        this._private__textWidthCache = textWidthCache;\n    }\n}\nclass PanePriceAxisView {\n    _internal_renderer() {\n        const pane = this._private__chartModel._internal_paneForSource(this._private__dataSource);\n        if (pane === null) {\n            return null;\n        }\n        // this price scale will be used to find label placement only (left, right, none)\n        const priceScale = pane._internal_isOverlay(this._private__dataSource) ? pane._internal_defaultVisiblePriceScale() : this._private__dataSource._internal_priceScale();\n        if (priceScale === null) {\n            return null;\n        }\n        const position = pane._internal_priceScalePosition(priceScale);\n        if (position === 'overlay') {\n            return null;\n        }\n        const options = this._private__chartModel._internal_priceAxisRendererOptions();\n        if (options._internal_fontSize !== this._private__fontSize) {\n            this._private__fontSize = options._internal_fontSize;\n            this._private__textWidthCache._internal_reset();\n        }\n        this._private__renderer._internal_setParams(this._private__priceAxisView._internal_paneRenderer(), options, position);\n        return this._private__renderer;\n    }\n    constructor(priceAxisView, dataSource, chartModel){\n        this._private__priceAxisView = priceAxisView;\n        this._private__textWidthCache = new TextWidthCache(50); // when should we clear cache?\n        this._private__dataSource = dataSource;\n        this._private__chartModel = chartModel;\n        this._private__fontSize = -1;\n        this._private__renderer = new PanePriceAxisViewRenderer(this._private__textWidthCache);\n    }\n}\nclass HorizontalLineRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_hitTest(x, y) {\n        var _this__private__data;\n        if (!((_this__private__data = this._private__data) === null || _this__private__data === void 0 ? void 0 : _this__private__data._internal_visible)) {\n            return null;\n        }\n        const { _internal_y: itemY, _internal_lineWidth: lineWidth, _internal_externalId: externalId } = this._private__data;\n        // add a fixed area threshold around line (Y + width) for hit test\n        if (y >= itemY - lineWidth - 7 /* Constants.HitTestThreshold */  && y <= itemY + lineWidth + 7 /* Constants.HitTestThreshold */ ) {\n            return {\n                _internal_hitTestData: this._private__data,\n                _internal_externalId: externalId\n            };\n        }\n        return null;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        if (this._private__data._internal_visible === false) {\n            return;\n        }\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        if (y < 0 || y > bitmapSize.height) {\n            return;\n        }\n        ctx.lineCap = 'butt';\n        ctx.strokeStyle = this._private__data._internal_color;\n        ctx.lineWidth = Math.floor(this._private__data._internal_lineWidth * horizontalPixelRatio);\n        setLineStyle(ctx, this._private__data._internal_lineStyle);\n        drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nclass SeriesHorizontalLinePaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._internal__lineRenderer;\n    }\n    constructor(series){\n        this._internal__lineRendererData = {\n            _internal_y: 0,\n            _internal_color: 'rgba(0, 0, 0, 0)',\n            _internal_lineWidth: 1,\n            _internal_lineStyle: 0 /* LineStyle.Solid */ ,\n            _internal_visible: false\n        };\n        this._internal__lineRenderer = new HorizontalLineRenderer();\n        this._private__invalidated = true;\n        this._internal__series = series;\n        this._internal__model = series._internal_model();\n        this._internal__lineRenderer._internal_setData(this._internal__lineRendererData);\n    }\n}\nclass SeriesHorizontalBaseLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        this._internal__lineRendererData._internal_visible = false;\n        const priceScale = this._internal__series._internal_priceScale();\n        const mode = priceScale._internal_mode()._internal_mode;\n        if (mode !== 2 /* PriceScaleMode.Percentage */  && mode !== 3 /* PriceScaleMode.IndexedTo100 */ ) {\n            return;\n        }\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.baseLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__lineRendererData._internal_visible = true;\n        this._internal__lineRendererData._internal_y = priceScale._internal_priceToCoordinate(firstValue._internal_value, firstValue._internal_value);\n        this._internal__lineRendererData._internal_color = seriesOptions.baseLineColor;\n        this._internal__lineRendererData._internal_lineWidth = seriesOptions.baseLineWidth;\n        this._internal__lineRendererData._internal_lineStyle = seriesOptions.baseLineStyle;\n    }\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series){\n        super(series);\n    }\n}\nclass SeriesLastPriceAnimationRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_data() {\n        return this._private__data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        const data = this._private__data;\n        if (data === null) {\n            return;\n        }\n        const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        const correction = tickWidth % 2 / 2;\n        const centerX = Math.round(data._internal_center.x * horizontalPixelRatio) + correction; // correct x coordinate only\n        const centerY = data._internal_center.y * verticalPixelRatio;\n        ctx.fillStyle = data._internal_seriesLineColor;\n        ctx.beginPath();\n        // TODO: it is better to have different horizontal and vertical radii\n        const centerPointRadius = Math.max(2, data._internal_seriesLineWidth * 1.5) * horizontalPixelRatio;\n        ctx.arc(centerX, centerY, centerPointRadius, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.fillStyle = data._internal_fillColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.lineWidth = tickWidth;\n        ctx.strokeStyle = data._internal_strokeColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio + tickWidth / 2, 0, 2 * Math.PI, false);\n        ctx.stroke();\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nconst animationStagesData = [\n    {\n        _internal_start: 0,\n        _internal_end: 0.25 /* Constants.Stage1Period */ ,\n        _internal_startRadius: 4 /* Constants.Stage1StartCircleRadius */ ,\n        _internal_endRadius: 10 /* Constants.Stage1EndCircleRadius */ ,\n        _internal_startFillAlpha: 0.25 /* Constants.Stage1StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage1EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0.4 /* Constants.Stage1StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0.8 /* Constants.Stage1EndStrokeAlpha */ \n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */ ,\n        _internal_end: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */ ,\n        _internal_startRadius: 10 /* Constants.Stage2StartCircleRadius */ ,\n        _internal_endRadius: 14 /* Constants.Stage2EndCircleRadius */ ,\n        _internal_startFillAlpha: 0 /* Constants.Stage2StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage2EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0.8 /* Constants.Stage2StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage2EndStrokeAlpha */ \n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */ ,\n        _internal_end: 0.25 /* Constants.Stage1Period */  + 0.275 /* Constants.Stage2Period */  + 0.475 /* Constants.Stage3Period */ ,\n        _internal_startRadius: 14 /* Constants.Stage3StartCircleRadius */ ,\n        _internal_endRadius: 14 /* Constants.Stage3EndCircleRadius */ ,\n        _internal_startFillAlpha: 0 /* Constants.Stage3StartFillAlpha */ ,\n        _internal_endFillAlpha: 0 /* Constants.Stage3EndFillAlpha */ ,\n        _internal_startStrokeAlpha: 0 /* Constants.Stage3StartStrokeAlpha */ ,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage3EndStrokeAlpha */ \n    }\n];\nfunction radius(stage, startRadius, endRadius) {\n    return startRadius + (endRadius - startRadius) * stage;\n}\nclass SeriesLastPriceAnimationPaneView {\n    _internal_onDataCleared() {\n        this._private__endTime = this._private__startTime - 1;\n        this._internal_update();\n    }\n    _internal_onNewRealtimeDataReceived() {\n        this._internal_update();\n        if (this._private__series._internal_options().lastPriceAnimation === 2 /* LastPriceAnimationMode.OnDataUpdate */ ) {\n            const now = performance.now();\n            const timeToAnimationEnd = this._private__endTime - now;\n            if (timeToAnimationEnd > 0) {\n                if (timeToAnimationEnd < 2600 /* Constants.AnimationPeriod */  / 4) {\n                    this._private__endTime += 2600 /* Constants.AnimationPeriod */ ;\n                }\n                return;\n            }\n            this._private__startTime = now;\n            this._private__endTime = now + 2600 /* Constants.AnimationPeriod */ ;\n        }\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_invalidateStage() {\n        this._private__stageInvalidated = true;\n    }\n    _internal_visible() {\n        // center point is always visible if lastPriceAnimation is not LastPriceAnimationMode.Disabled\n        return this._private__series._internal_options().lastPriceAnimation !== 0 /* LastPriceAnimationMode.Disabled */ ;\n    }\n    _internal_animationActive() {\n        switch(this._private__series._internal_options().lastPriceAnimation){\n            case 0 /* LastPriceAnimationMode.Disabled */ :\n                return false;\n            case 1 /* LastPriceAnimationMode.Continuous */ :\n                return true;\n            case 2 /* LastPriceAnimationMode.OnDataUpdate */ :\n                return performance.now() <= this._private__endTime;\n        }\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n            this._private__stageInvalidated = false;\n        } else if (this._private__stageInvalidated) {\n            this._private__updateRendererDataStage();\n            this._private__stageInvalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        this._private__renderer._internal_setData(null);\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const visibleRange = timeScale._internal_visibleStrictRange();\n        const firstValue = this._private__series._internal_firstValue();\n        if (visibleRange === null || firstValue === null) {\n            return;\n        }\n        const lastValue = this._private__series._internal_lastValueData(true);\n        if (lastValue._internal_noData || !visibleRange._internal_contains(lastValue._internal_index)) {\n            return;\n        }\n        const lastValuePoint = {\n            x: timeScale._internal_indexToCoordinate(lastValue._internal_index),\n            y: this._private__series._internal_priceScale()._internal_priceToCoordinate(lastValue._internal_price, firstValue._internal_value)\n        };\n        const seriesLineColor = lastValue._internal_color;\n        const seriesLineWidth = this._private__series._internal_options().lineWidth;\n        const data = this._private__animationData(this._private__duration(), seriesLineColor);\n        this._private__renderer._internal_setData({\n            _internal_seriesLineColor: seriesLineColor,\n            _internal_seriesLineWidth: seriesLineWidth,\n            _internal_fillColor: data._internal_fillColor,\n            _internal_strokeColor: data._internal_strokeColor,\n            _internal_radius: data._internal_radius,\n            _internal_center: lastValuePoint\n        });\n    }\n    _private__updateRendererDataStage() {\n        const rendererData = this._private__renderer._internal_data();\n        if (rendererData !== null) {\n            const data = this._private__animationData(this._private__duration(), rendererData._internal_seriesLineColor);\n            rendererData._internal_fillColor = data._internal_fillColor;\n            rendererData._internal_strokeColor = data._internal_strokeColor;\n            rendererData._internal_radius = data._internal_radius;\n        }\n    }\n    _private__duration() {\n        return this._internal_animationActive() ? performance.now() - this._private__startTime : 2600 /* Constants.AnimationPeriod */  - 1;\n    }\n    _private__color(seriesLineColor, stage, startAlpha, endAlpha) {\n        const alpha = startAlpha + (endAlpha - startAlpha) * stage;\n        return this._private__series._internal_model()._internal_colorParser()._internal_applyAlpha(seriesLineColor, alpha);\n    }\n    _private__animationData(durationSinceStart, lineColor) {\n        const globalStage = durationSinceStart % 2600 /* Constants.AnimationPeriod */  / 2600 /* Constants.AnimationPeriod */ ;\n        let currentStageData;\n        for (const stageData of animationStagesData){\n            if (globalStage >= stageData._internal_start && globalStage <= stageData._internal_end) {\n                currentStageData = stageData;\n                break;\n            }\n        }\n        assert(currentStageData !== undefined, 'Last price animation internal logic error');\n        const subStage = (globalStage - currentStageData._internal_start) / (currentStageData._internal_end - currentStageData._internal_start);\n        return {\n            _internal_fillColor: this._private__color(lineColor, subStage, currentStageData._internal_startFillAlpha, currentStageData._internal_endFillAlpha),\n            _internal_strokeColor: this._private__color(lineColor, subStage, currentStageData._internal_startStrokeAlpha, currentStageData._internal_endStrokeAlpha),\n            _internal_radius: radius(subStage, currentStageData._internal_startRadius, currentStageData._internal_endRadius)\n        };\n    }\n    constructor(series){\n        this._private__renderer = new SeriesLastPriceAnimationRenderer();\n        this._private__invalidated = true;\n        this._private__stageInvalidated = true;\n        this._private__startTime = performance.now();\n        this._private__endTime = this._private__startTime - 1;\n        this._private__series = series;\n    }\n}\nclass SeriesPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.priceLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const lastValueData = this._internal__series._internal_lastValueData(seriesOptions.priceLineSource === 0 /* PriceLineSource.LastBar */ );\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = lastValueData._internal_coordinate;\n        data._internal_color = this._internal__series._internal_priceLineColor(lastValueData._internal_color);\n        data._internal_lineWidth = seriesOptions.priceLineWidth;\n        data._internal_lineStyle = seriesOptions.priceLineStyle;\n    }\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series){\n        super(series);\n    }\n}\nclass SeriesPriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const source = this._private__source;\n        if (!source._internal_visible()) {\n            return;\n        }\n        const seriesOptions = source._internal_options();\n        const showSeriesLastValue = seriesOptions.lastValueVisible;\n        const showSymbolLabel = source._internal_title() !== '';\n        const showPriceAndPercentage = seriesOptions.seriesLastValueMode === 0 /* PriceAxisLastValueMode.LastPriceAndPercentageValue */ ;\n        const lastValueData = source._internal_lastValueData(false);\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        if (showSeriesLastValue) {\n            axisRendererData._internal_text = this._internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage);\n            axisRendererData._internal_visible = axisRendererData._internal_text.length !== 0;\n        }\n        if (showSymbolLabel || showPriceAndPercentage) {\n            paneRendererData._internal_text = this._internal__paneText(lastValueData, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage);\n            paneRendererData._internal_visible = paneRendererData._internal_text.length > 0;\n        }\n        const lastValueColor = source._internal_priceLineColor(lastValueData._internal_color);\n        const colors = this._private__source._internal_model()._internal_colorParser()._internal_generateContrastColors(lastValueColor);\n        commonRendererData._internal_background = colors._internal_background;\n        commonRendererData._internal_coordinate = lastValueData._internal_coordinate;\n        paneRendererData._internal_borderColor = source._internal_model()._internal_backgroundColorAtYPercentFromTop(lastValueData._internal_coordinate / source._internal_priceScale()._internal_height());\n        axisRendererData._internal_borderColor = lastValueColor;\n        axisRendererData._internal_color = colors._internal_foreground;\n        paneRendererData._internal_color = colors._internal_foreground;\n    }\n    _internal__paneText(lastValue, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage) {\n        let result = '';\n        const title = this._private__source._internal_title();\n        if (showSymbolLabel && title.length !== 0) {\n            result += \"\".concat(title, \" \");\n        }\n        if (showSeriesLastValue && showPriceAndPercentage) {\n            result += this._private__source._internal_priceScale()._internal_isPercentage() ? lastValue._internal_formattedPriceAbsolute : lastValue._internal_formattedPricePercentage;\n        }\n        return result.trim();\n    }\n    _internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage) {\n        if (!showSeriesLastValue) {\n            return '';\n        }\n        if (!showPriceAndPercentage) {\n            return lastValueData._internal_text;\n        }\n        return this._private__source._internal_priceScale()._internal_isPercentage() ? lastValueData._internal_formattedPricePercentage : lastValueData._internal_formattedPriceAbsolute;\n    }\n    constructor(source){\n        super();\n        this._private__source = source;\n    }\n}\nfunction computeFiniteResult(method, valueOne, valueTwo, fallback) {\n    const firstFinite = Number.isFinite(valueOne);\n    const secondFinite = Number.isFinite(valueTwo);\n    if (firstFinite && secondFinite) {\n        return method(valueOne, valueTwo);\n    }\n    return !firstFinite && !secondFinite ? fallback : firstFinite ? valueOne : valueTwo;\n}\nclass PriceRangeImpl {\n    _internal_equals(pr) {\n        if (pr === null) {\n            return false;\n        }\n        return this._private__minValue === pr._private__minValue && this._private__maxValue === pr._private__maxValue;\n    }\n    _internal_clone() {\n        return new PriceRangeImpl(this._private__minValue, this._private__maxValue);\n    }\n    _internal_minValue() {\n        return this._private__minValue;\n    }\n    _internal_maxValue() {\n        return this._private__maxValue;\n    }\n    _internal_length() {\n        return this._private__maxValue - this._private__minValue;\n    }\n    _internal_isEmpty() {\n        return this._private__maxValue === this._private__minValue || Number.isNaN(this._private__maxValue) || Number.isNaN(this._private__minValue);\n    }\n    _internal_merge(anotherRange) {\n        if (anotherRange === null) {\n            return this;\n        }\n        return new PriceRangeImpl(computeFiniteResult(Math.min, this._internal_minValue(), anotherRange._internal_minValue(), -Infinity), computeFiniteResult(Math.max, this._internal_maxValue(), anotherRange._internal_maxValue(), Infinity));\n    }\n    _internal_scaleAroundCenter(coeff) {\n        if (!isNumber(coeff)) {\n            return;\n        }\n        const delta = this._private__maxValue - this._private__minValue;\n        if (delta === 0) {\n            return;\n        }\n        const center = (this._private__maxValue + this._private__minValue) * 0.5;\n        let maxDelta = this._private__maxValue - center;\n        let minDelta = this._private__minValue - center;\n        maxDelta *= coeff;\n        minDelta *= coeff;\n        this._private__maxValue = center + maxDelta;\n        this._private__minValue = center + minDelta;\n    }\n    _internal_shift(delta) {\n        if (!isNumber(delta)) {\n            return;\n        }\n        this._private__maxValue += delta;\n        this._private__minValue += delta;\n    }\n    _internal_toRaw() {\n        return {\n            minValue: this._private__minValue,\n            maxValue: this._private__maxValue\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return raw === null ? null : new PriceRangeImpl(raw.minValue, raw.maxValue);\n    }\n    constructor(minValue, maxValue){\n        this._private__minValue = minValue;\n        this._private__maxValue = maxValue;\n    }\n}\nclass AutoscaleInfoImpl {\n    _internal_priceRange() {\n        return this._private__priceRange;\n    }\n    _internal_margins() {\n        return this._private__margins;\n    }\n    _internal_toRaw() {\n        return {\n            priceRange: this._private__priceRange === null ? null : this._private__priceRange._internal_toRaw(),\n            margins: this._private__margins || undefined\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return raw === null ? null : new AutoscaleInfoImpl(PriceRangeImpl._internal_fromRaw(raw.priceRange), raw.margins);\n    }\n    constructor(priceRange, margins){\n        this._private__priceRange = priceRange;\n        this._private__margins = margins || null;\n    }\n}\nclass CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const lineOptions = this._private__priceLine._internal_options();\n        if (!this._internal__series._internal_visible() || !lineOptions.lineVisible) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = y;\n        data._internal_color = lineOptions.color;\n        data._internal_lineWidth = lineOptions.lineWidth;\n        data._internal_lineStyle = lineOptions.lineStyle;\n        data._internal_externalId = this._private__priceLine._internal_options().id;\n    }\n    constructor(series, priceLine){\n        super(series);\n        this._private__priceLine = priceLine;\n    }\n}\nclass CustomPriceLinePriceAxisView extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const options = this._private__priceLine._internal_options();\n        const labelVisible = options.axisLabelVisible;\n        const showPaneLabel = options.title !== '';\n        const series = this._private__series;\n        if (!labelVisible || !series._internal_visible()) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        if (showPaneLabel) {\n            paneRendererData._internal_text = options.title;\n            paneRendererData._internal_visible = true;\n        }\n        paneRendererData._internal_borderColor = series._internal_model()._internal_backgroundColorAtYPercentFromTop(y / series._internal_priceScale()._internal_height());\n        axisRendererData._internal_text = this._private__formatPrice(options.price);\n        axisRendererData._internal_visible = true;\n        const colors = this._private__series._internal_model()._internal_colorParser()._internal_generateContrastColors(options.axisLabelColor || options.color);\n        commonData._internal_background = colors._internal_background;\n        const textColor = options.axisLabelTextColor || colors._internal_foreground;\n        axisRendererData._internal_color = textColor; // price text\n        paneRendererData._internal_color = textColor; // title text\n        commonData._internal_coordinate = y;\n    }\n    _private__formatPrice(price) {\n        const firstValue = this._private__series._internal_firstValue();\n        if (firstValue === null) {\n            return '';\n        }\n        return this._private__series._internal_priceScale()._internal_formatPrice(price, firstValue._internal_value);\n    }\n    constructor(series, priceLine){\n        super();\n        this._private__series = series;\n        this._private__priceLine = priceLine;\n    }\n}\nclass CustomPriceLine {\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_update();\n        this._private__series._internal_model()._internal_lightUpdate();\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneView() {\n        return this._private__priceLineView;\n    }\n    _internal_labelPaneView() {\n        return this._private__panePriceAxisView;\n    }\n    _internal_priceAxisView() {\n        return this._private__priceAxisView;\n    }\n    _internal_update() {\n        this._private__priceLineView._internal_update();\n        this._private__priceAxisView._internal_update();\n    }\n    _internal_yCoord() {\n        const series = this._private__series;\n        const priceScale = series._internal_priceScale();\n        const timeScale = series._internal_model()._internal_timeScale();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return null;\n        }\n        const firstValue = series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return priceScale._internal_priceToCoordinate(this._private__options.price, firstValue._internal_value);\n    }\n    constructor(series, options){\n        this._private__series = series;\n        this._private__options = options;\n        this._private__priceLineView = new CustomPriceLinePaneView(series, this);\n        this._private__priceAxisView = new CustomPriceLinePriceAxisView(series, this);\n        this._private__panePriceAxisView = new PanePriceAxisView(this._private__priceAxisView, series, series._internal_model());\n    }\n}\nclass PriceDataSource extends DataSource {\n    _internal_model() {\n        return this._private__model;\n    }\n    constructor(model){\n        super();\n        this._private__model = model;\n    }\n}\nconst barStyleFnMap = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Bar: (findBar, barStyle, barIndex, precomputedBars)=>{\n        const upColor = barStyle.upColor;\n        const downColor = barStyle.downColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */ ]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ]);\n        var _currentBar__internal_color;\n        return {\n            _internal_barColor: (_currentBar__internal_color = currentBar._internal_color) !== null && _currentBar__internal_color !== void 0 ? _currentBar__internal_color : isUp ? upColor : downColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Candlestick: (findBar, candlestickStyle, barIndex, precomputedBars)=>{\n        const upColor = candlestickStyle.upColor;\n        const downColor = candlestickStyle.downColor;\n        const borderUpColor = candlestickStyle.borderUpColor;\n        const borderDownColor = candlestickStyle.borderDownColor;\n        const wickUpColor = candlestickStyle.wickUpColor;\n        const wickDownColor = candlestickStyle.wickDownColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */ ]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ]);\n        var _currentBar__internal_color, _currentBar__internal_borderColor, _currentBar__internal_wickColor;\n        return {\n            _internal_barColor: (_currentBar__internal_color = currentBar._internal_color) !== null && _currentBar__internal_color !== void 0 ? _currentBar__internal_color : isUp ? upColor : downColor,\n            _internal_barBorderColor: (_currentBar__internal_borderColor = currentBar._internal_borderColor) !== null && _currentBar__internal_borderColor !== void 0 ? _currentBar__internal_borderColor : isUp ? borderUpColor : borderDownColor,\n            _internal_barWickColor: (_currentBar__internal_wickColor = currentBar._internal_wickColor) !== null && _currentBar__internal_wickColor !== void 0 ? _currentBar__internal_wickColor : isUp ? wickUpColor : wickDownColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Custom: (findBar, customStyle, barIndex, precomputedBars)=>{\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        var _currentBar__internal_color;\n        return {\n            _internal_barColor: (_currentBar__internal_color = currentBar._internal_color) !== null && _currentBar__internal_color !== void 0 ? _currentBar__internal_color : customStyle.color\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Area: (findBar, areaStyle, barIndex, precomputedBars)=>{\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        var _currentBar__internal_lineColor, _currentBar__internal_lineColor1, _currentBar__internal_topColor, _currentBar__internal_bottomColor;\n        return {\n            _internal_barColor: (_currentBar__internal_lineColor = currentBar._internal_lineColor) !== null && _currentBar__internal_lineColor !== void 0 ? _currentBar__internal_lineColor : areaStyle.lineColor,\n            _internal_lineColor: (_currentBar__internal_lineColor1 = currentBar._internal_lineColor) !== null && _currentBar__internal_lineColor1 !== void 0 ? _currentBar__internal_lineColor1 : areaStyle.lineColor,\n            _internal_topColor: (_currentBar__internal_topColor = currentBar._internal_topColor) !== null && _currentBar__internal_topColor !== void 0 ? _currentBar__internal_topColor : areaStyle.topColor,\n            _internal_bottomColor: (_currentBar__internal_bottomColor = currentBar._internal_bottomColor) !== null && _currentBar__internal_bottomColor !== void 0 ? _currentBar__internal_bottomColor : areaStyle.bottomColor\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Baseline: (findBar, baselineStyle, barIndex, precomputedBars)=>{\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isAboveBaseline = currentBar._internal_value[3 /* PlotRowValueIndex.Close */ ] >= baselineStyle.baseValue.price;\n        var _currentBar__internal_topLineColor, _currentBar__internal_bottomLineColor, _currentBar__internal_topFillColor1, _currentBar__internal_topFillColor2, _currentBar__internal_bottomFillColor1, _currentBar__internal_bottomFillColor2;\n        return {\n            _internal_barColor: isAboveBaseline ? baselineStyle.topLineColor : baselineStyle.bottomLineColor,\n            _internal_topLineColor: (_currentBar__internal_topLineColor = currentBar._internal_topLineColor) !== null && _currentBar__internal_topLineColor !== void 0 ? _currentBar__internal_topLineColor : baselineStyle.topLineColor,\n            _internal_bottomLineColor: (_currentBar__internal_bottomLineColor = currentBar._internal_bottomLineColor) !== null && _currentBar__internal_bottomLineColor !== void 0 ? _currentBar__internal_bottomLineColor : baselineStyle.bottomLineColor,\n            _internal_topFillColor1: (_currentBar__internal_topFillColor1 = currentBar._internal_topFillColor1) !== null && _currentBar__internal_topFillColor1 !== void 0 ? _currentBar__internal_topFillColor1 : baselineStyle.topFillColor1,\n            _internal_topFillColor2: (_currentBar__internal_topFillColor2 = currentBar._internal_topFillColor2) !== null && _currentBar__internal_topFillColor2 !== void 0 ? _currentBar__internal_topFillColor2 : baselineStyle.topFillColor2,\n            _internal_bottomFillColor1: (_currentBar__internal_bottomFillColor1 = currentBar._internal_bottomFillColor1) !== null && _currentBar__internal_bottomFillColor1 !== void 0 ? _currentBar__internal_bottomFillColor1 : baselineStyle.bottomFillColor1,\n            _internal_bottomFillColor2: (_currentBar__internal_bottomFillColor2 = currentBar._internal_bottomFillColor2) !== null && _currentBar__internal_bottomFillColor2 !== void 0 ? _currentBar__internal_bottomFillColor2 : baselineStyle.bottomFillColor2\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Line: (findBar, lineStyle, barIndex, precomputedBars)=>{\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        var _currentBar__internal_color, _currentBar__internal_color1;\n        return {\n            _internal_barColor: (_currentBar__internal_color = currentBar._internal_color) !== null && _currentBar__internal_color !== void 0 ? _currentBar__internal_color : lineStyle.color,\n            _internal_lineColor: (_currentBar__internal_color1 = currentBar._internal_color) !== null && _currentBar__internal_color1 !== void 0 ? _currentBar__internal_color1 : lineStyle.color\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Histogram: (findBar, histogramStyle, barIndex, precomputedBars)=>{\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        var _currentBar__internal_color;\n        return {\n            _internal_barColor: (_currentBar__internal_color = currentBar._internal_color) !== null && _currentBar__internal_color !== void 0 ? _currentBar__internal_color : histogramStyle.color\n        };\n    }\n};\nclass SeriesBarColorer {\n    _internal_barStyle(barIndex, precomputedBars) {\n        // precomputedBars: {value: [Array BarValues], previousValue: [Array BarValues] | undefined}\n        // Used to avoid binary search if bars are already known\n        return this._private__styleGetter(this._private__findBar, this._private__series._internal_options(), barIndex, precomputedBars);\n    }\n    constructor(series){\n        this._private__findBar = (barIndex, precomputedBars)=>{\n            if (precomputedBars !== undefined) {\n                return precomputedBars._internal_value;\n            }\n            return this._private__series._internal_bars()._internal_valueAt(barIndex);\n        };\n        this._private__series = series;\n        this._private__styleGetter = barStyleFnMap[series._internal_seriesType()];\n    }\n}\n/**\n * Binary function that accepts two arguments (the first of the type of array elements, and the second is always val), and returns a value convertible to bool.\n * The value returned indicates whether the first argument is considered to go before the second.\n * The function shall not modify any of its arguments.\n */ function boundCompare(lower, arr, value, compare) {\n    let start = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, to = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : arr.length;\n    let count = to - start;\n    while(0 < count){\n        const count2 = count >> 1;\n        const mid = start + count2;\n        if (compare(arr[mid], value) === lower) {\n            start = mid + 1;\n            count -= count2 + 1;\n        } else {\n            count = count2;\n        }\n    }\n    return start;\n}\nconst lowerBound = boundCompare.bind(null, true);\nconst upperBound = boundCompare.bind(null, false);\n/**\n * Search direction if no data found at provided index\n */ var MismatchDirection;\n(function(MismatchDirection) {\n    /**\n     * Search the nearest left item\n     */ MismatchDirection[MismatchDirection[\"NearestLeft\"] = -1] = \"NearestLeft\";\n    /**\n     * Do not search\n     */ MismatchDirection[MismatchDirection[\"None\"] = 0] = \"None\";\n    /**\n     * Search the nearest right item\n     */ MismatchDirection[MismatchDirection[\"NearestRight\"] = 1] = \"NearestRight\";\n})(MismatchDirection || (MismatchDirection = {}));\n// TODO: think about changing it dynamically\nconst CHUNK_SIZE = 30;\n/**\n * PlotList is an array of plot rows\n * each plot row consists of key (index in timescale) and plot value map\n */ class PlotList {\n    // @returns Last row\n    _internal_last() {\n        return this._internal_size() > 0 ? this._private__items[this._private__items.length - 1] : null;\n    }\n    _internal_firstIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt(0) : null;\n    }\n    _internal_lastIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt(this._private__items.length - 1) : null;\n    }\n    _internal_size() {\n        return this._private__items.length;\n    }\n    _internal_isEmpty() {\n        return this._internal_size() === 0;\n    }\n    _internal_contains(index) {\n        return this._private__search(index, 0 /* MismatchDirection.None */ ) !== null;\n    }\n    _internal_valueAt(index) {\n        return this._internal_search(index);\n    }\n    _internal_search(index) {\n        let searchMode = arguments.length > 1 && arguments[1] !== void 0 /* MismatchDirection.None */  ? arguments[1] : 0;\n        const pos = this._private__search(index, searchMode);\n        if (pos === null) {\n            return null;\n        }\n        return {\n            ...this._private__valueAt(pos),\n            _internal_index: this._private__indexAt(pos)\n        };\n    }\n    _internal_rows() {\n        return this._private__items;\n    }\n    _internal_minMaxOnRangeCached(start, end, plots) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        for (const plot of plots){\n            const plotMinMax = this._private__minMaxOnRangeCachedImpl(start, end, plot);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n    _internal_setData(plotRows) {\n        this._private__rowSearchCache.clear();\n        this._private__minMaxCache.clear();\n        this._private__items = plotRows;\n        this._private__indices = plotRows.map((plotRow)=>plotRow._internal_index);\n    }\n    // TimePointIndex values for fulfilled data points\n    _internal_indices() {\n        return this._private__indices;\n    }\n    _private__indexAt(offset) {\n        return this._private__items[offset]._internal_index;\n    }\n    _private__valueAt(offset) {\n        return this._private__items[offset];\n    }\n    _private__search(index, searchMode) {\n        const exactPos = this._private__bsearch(index);\n        if (exactPos === null && searchMode !== 0 /* MismatchDirection.None */ ) {\n            switch(searchMode){\n                case -1 /* MismatchDirection.NearestLeft */ :\n                    return this._private__searchNearestLeft(index);\n                case 1 /* MismatchDirection.NearestRight */ :\n                    return this._private__searchNearestRight(index);\n                default:\n                    throw new TypeError('Unknown search mode');\n            }\n        }\n        return exactPos;\n    }\n    _private__searchNearestLeft(index) {\n        let nearestLeftPos = this._private__lowerbound(index);\n        if (nearestLeftPos > 0) {\n            nearestLeftPos = nearestLeftPos - 1;\n        }\n        return nearestLeftPos !== this._private__items.length && this._private__indexAt(nearestLeftPos) < index ? nearestLeftPos : null;\n    }\n    _private__searchNearestRight(index) {\n        const nearestRightPos = this._private__upperbound(index);\n        return nearestRightPos !== this._private__items.length && index < this._private__indexAt(nearestRightPos) ? nearestRightPos : null;\n    }\n    _private__bsearch(index) {\n        const start = this._private__lowerbound(index);\n        if (start !== this._private__items.length && !(index < this._private__items[start]._internal_index)) {\n            return start;\n        }\n        return null;\n    }\n    _private__lowerbound(index) {\n        return lowerBound(this._private__items, index, (a, b)=>a._internal_index < b);\n    }\n    _private__upperbound(index) {\n        return upperBound(this._private__items, index, (a, b)=>a._internal_index > b);\n    }\n    _private__plotMinMax(startIndex, endIndexExclusive, plotIndex) {\n        let result = null;\n        for(let i = startIndex; i < endIndexExclusive; i++){\n            const values = this._private__items[i]._internal_value;\n            const v = values[plotIndex];\n            if (Number.isNaN(v)) {\n                continue;\n            }\n            if (result === null) {\n                result = {\n                    _internal_min: v,\n                    _internal_max: v\n                };\n            } else {\n                if (v < result._internal_min) {\n                    result._internal_min = v;\n                }\n                if (v > result._internal_max) {\n                    result._internal_max = v;\n                }\n            }\n        }\n        return result;\n    }\n    _private__minMaxOnRangeCachedImpl(start, end, plotIndex) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        // assume that bar indexes only increase\n        const firstIndex = ensureNotNull(this._internal_firstIndex());\n        const lastIndex = ensureNotNull(this._internal_lastIndex());\n        const s = Math.max(start, firstIndex);\n        const e = Math.min(end, lastIndex);\n        const cachedLow = Math.ceil(s / CHUNK_SIZE) * CHUNK_SIZE;\n        const cachedHigh = Math.max(cachedLow, Math.floor(e / CHUNK_SIZE) * CHUNK_SIZE);\n        {\n            const startIndex = this._private__lowerbound(s);\n            const endIndex = this._private__upperbound(Math.min(e, cachedLow, end)); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        let minMaxCache = this._private__minMaxCache.get(plotIndex);\n        if (minMaxCache === undefined) {\n            minMaxCache = new Map();\n            this._private__minMaxCache.set(plotIndex, minMaxCache);\n        }\n        // now go cached\n        for(let c = Math.max(cachedLow + 1, s); c < cachedHigh; c += CHUNK_SIZE){\n            const chunkIndex = Math.floor(c / CHUNK_SIZE);\n            let chunkMinMax = minMaxCache.get(chunkIndex);\n            if (chunkMinMax === undefined) {\n                const chunkStart = this._private__lowerbound(chunkIndex * CHUNK_SIZE);\n                const chunkEnd = this._private__upperbound((chunkIndex + 1) * CHUNK_SIZE - 1);\n                chunkMinMax = this._private__plotMinMax(chunkStart, chunkEnd, plotIndex);\n                minMaxCache.set(chunkIndex, chunkMinMax);\n            }\n            result = mergeMinMax(result, chunkMinMax);\n        }\n        // tail\n        {\n            const startIndex = this._private__lowerbound(cachedHigh);\n            const endIndex = this._private__upperbound(e); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n    constructor(){\n        this._private__items = [];\n        this._private__minMaxCache = new Map();\n        this._private__rowSearchCache = new Map();\n        this._private__indices = [];\n    }\n}\nfunction mergeMinMax(first, second) {\n    if (first === null) {\n        return second;\n    } else {\n        if (second === null) {\n            return first;\n        } else {\n            // merge MinMax values\n            const min = Math.min(first._internal_min, second._internal_min);\n            const max = Math.max(first._internal_max, second._internal_max);\n            return {\n                _internal_min: min,\n                _internal_max: max\n            };\n        }\n    }\n}\nfunction createSeriesPlotList() {\n    return new PlotList();\n}\nclass PrimitiveRendererWrapper {\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__baseRenderer.draw(target);\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        var _this__private__baseRenderer_drawBackground, _this__private__baseRenderer;\n        (_this__private__baseRenderer_drawBackground = (_this__private__baseRenderer = this._private__baseRenderer).drawBackground) === null || _this__private__baseRenderer_drawBackground === void 0 ? void 0 : _this__private__baseRenderer_drawBackground.call(_this__private__baseRenderer, target);\n    }\n    constructor(baseRenderer){\n        this._private__baseRenderer = baseRenderer;\n    }\n}\nclass PrimitivePaneViewWrapper {\n    _internal_renderer() {\n        var _this__private__cache;\n        const baseRenderer = this._private__paneView.renderer();\n        if (baseRenderer === null) {\n            return null;\n        }\n        if (((_this__private__cache = this._private__cache) === null || _this__private__cache === void 0 ? void 0 : _this__private__cache._internal_base) === baseRenderer) {\n            return this._private__cache._internal_wrapper;\n        }\n        const wrapper = new PrimitiveRendererWrapper(baseRenderer);\n        this._private__cache = {\n            _internal_base: baseRenderer,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_zOrder() {\n        var _this__private__paneView_zOrder, _this__private__paneView;\n        var _this__private__paneView_zOrder1;\n        return (_this__private__paneView_zOrder1 = (_this__private__paneView_zOrder = (_this__private__paneView = this._private__paneView).zOrder) === null || _this__private__paneView_zOrder === void 0 ? void 0 : _this__private__paneView_zOrder.call(_this__private__paneView)) !== null && _this__private__paneView_zOrder1 !== void 0 ? _this__private__paneView_zOrder1 : 'normal';\n    }\n    constructor(paneView){\n        this._private__cache = null;\n        this._private__paneView = paneView;\n    }\n}\nclass PrimitiveWrapper {\n    _internal_primitive() {\n        return this._internal__primitive;\n    }\n    _internal_updateAllViews() {\n        var _this__internal__primitive_updateAllViews, _this__internal__primitive;\n        (_this__internal__primitive_updateAllViews = (_this__internal__primitive = this._internal__primitive).updateAllViews) === null || _this__internal__primitive_updateAllViews === void 0 ? void 0 : _this__internal__primitive_updateAllViews.call(_this__internal__primitive);\n    }\n    _internal_paneViews() {\n        var _this__internal__primitive_paneViews, _this__internal__primitive, _this__private__paneViewsCache;\n        var _this__internal__primitive_paneViews1;\n        const base = (_this__internal__primitive_paneViews1 = (_this__internal__primitive_paneViews = (_this__internal__primitive = this._internal__primitive).paneViews) === null || _this__internal__primitive_paneViews === void 0 ? void 0 : _this__internal__primitive_paneViews.call(_this__internal__primitive)) !== null && _this__internal__primitive_paneViews1 !== void 0 ? _this__internal__primitive_paneViews1 : [];\n        if (((_this__private__paneViewsCache = this._private__paneViewsCache) === null || _this__private__paneViewsCache === void 0 ? void 0 : _this__private__paneViewsCache._internal_base) === base) {\n            return this._private__paneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new PrimitivePaneViewWrapper(pw));\n        this._private__paneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_hitTest(x, y) {\n        var _this__internal__primitive_hitTest, _this__internal__primitive;\n        var _this__internal__primitive_hitTest1;\n        return (_this__internal__primitive_hitTest1 = (_this__internal__primitive_hitTest = (_this__internal__primitive = this._internal__primitive).hitTest) === null || _this__internal__primitive_hitTest === void 0 ? void 0 : _this__internal__primitive_hitTest.call(_this__internal__primitive, x, y)) !== null && _this__internal__primitive_hitTest1 !== void 0 ? _this__internal__primitive_hitTest1 : null;\n    }\n    constructor(primitive){\n        this._private__paneViewsCache = null;\n        this._internal__primitive = primitive;\n    }\n}\nlet PanePrimitiveWrapper$1 = class PanePrimitiveWrapper extends PrimitiveWrapper {\n    _internal_labelPaneViews() {\n        return [];\n    }\n};\nclass SeriesPrimitiveRendererWrapper {\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__baseRenderer.draw(target);\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        var _this__private__baseRenderer_drawBackground, _this__private__baseRenderer;\n        (_this__private__baseRenderer_drawBackground = (_this__private__baseRenderer = this._private__baseRenderer).drawBackground) === null || _this__private__baseRenderer_drawBackground === void 0 ? void 0 : _this__private__baseRenderer_drawBackground.call(_this__private__baseRenderer, target);\n    }\n    constructor(baseRenderer){\n        this._private__baseRenderer = baseRenderer;\n    }\n}\nclass SeriesPrimitivePaneViewWrapper {\n    _internal_renderer() {\n        var _this__private__cache;\n        const baseRenderer = this._private__paneView.renderer();\n        if (baseRenderer === null) {\n            return null;\n        }\n        if (((_this__private__cache = this._private__cache) === null || _this__private__cache === void 0 ? void 0 : _this__private__cache._internal_base) === baseRenderer) {\n            return this._private__cache._internal_wrapper;\n        }\n        const wrapper = new SeriesPrimitiveRendererWrapper(baseRenderer);\n        this._private__cache = {\n            _internal_base: baseRenderer,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_zOrder() {\n        var _this__private__paneView_zOrder, _this__private__paneView;\n        var _this__private__paneView_zOrder1;\n        return (_this__private__paneView_zOrder1 = (_this__private__paneView_zOrder = (_this__private__paneView = this._private__paneView).zOrder) === null || _this__private__paneView_zOrder === void 0 ? void 0 : _this__private__paneView_zOrder.call(_this__private__paneView)) !== null && _this__private__paneView_zOrder1 !== void 0 ? _this__private__paneView_zOrder1 : 'normal';\n    }\n    constructor(paneView){\n        this._private__cache = null;\n        this._private__paneView = paneView;\n    }\n}\nfunction getAxisViewData(baseView) {\n    var _baseView_fixedCoordinate, _baseView_visible, _baseView_tickVisible;\n    var _baseView_visible1, _baseView_tickVisible1;\n    return {\n        _internal_text: baseView.text(),\n        _internal_coordinate: baseView.coordinate(),\n        _internal_fixedCoordinate: (_baseView_fixedCoordinate = baseView.fixedCoordinate) === null || _baseView_fixedCoordinate === void 0 ? void 0 : _baseView_fixedCoordinate.call(baseView),\n        _internal_color: baseView.textColor(),\n        _internal_background: baseView.backColor(),\n        _internal_visible: (_baseView_visible1 = (_baseView_visible = baseView.visible) === null || _baseView_visible === void 0 ? void 0 : _baseView_visible.call(baseView)) !== null && _baseView_visible1 !== void 0 ? _baseView_visible1 : true,\n        _internal_tickVisible: (_baseView_tickVisible1 = (_baseView_tickVisible = baseView.tickVisible) === null || _baseView_tickVisible === void 0 ? void 0 : _baseView_tickVisible.call(baseView)) !== null && _baseView_tickVisible1 !== void 0 ? _baseView_tickVisible1 : true\n    };\n}\nclass SeriesPrimitiveTimeAxisViewWrapper {\n    _internal_renderer() {\n        this._private__renderer._internal_setData({\n            _internal_width: this._private__timeScale._internal_width(),\n            ...getAxisViewData(this._private__baseView)\n        });\n        return this._private__renderer;\n    }\n    constructor(baseView, timeScale){\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__baseView = baseView;\n        this._private__timeScale = timeScale;\n    }\n}\nclass SeriesPrimitivePriceAxisViewWrapper extends PriceAxisView {\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        const data = getAxisViewData(this._private__baseView);\n        commonRendererData._internal_background = data._internal_background;\n        axisRendererData._internal_color = data._internal_color;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        commonRendererData._internal_coordinate = data._internal_coordinate;\n        commonRendererData._internal_fixedCoordinate = data._internal_fixedCoordinate;\n        axisRendererData._internal_text = data._internal_text;\n        axisRendererData._internal_visible = data._internal_visible;\n        axisRendererData._internal_tickVisible = data._internal_tickVisible;\n    }\n    constructor(baseView, priceScale){\n        super();\n        this._private__baseView = baseView;\n        this._private__priceScale = priceScale;\n    }\n}\nclass SeriesPrimitiveWrapper extends PrimitiveWrapper {\n    _internal_timeAxisViews() {\n        var _this__internal__primitive_timeAxisViews, _this__internal__primitive, _this__private__timeAxisViewsCache;\n        var _this__internal__primitive_timeAxisViews1;\n        const base = (_this__internal__primitive_timeAxisViews1 = (_this__internal__primitive_timeAxisViews = (_this__internal__primitive = this._internal__primitive).timeAxisViews) === null || _this__internal__primitive_timeAxisViews === void 0 ? void 0 : _this__internal__primitive_timeAxisViews.call(_this__internal__primitive)) !== null && _this__internal__primitive_timeAxisViews1 !== void 0 ? _this__internal__primitive_timeAxisViews1 : [];\n        if (((_this__private__timeAxisViewsCache = this._private__timeAxisViewsCache) === null || _this__private__timeAxisViewsCache === void 0 ? void 0 : _this__private__timeAxisViewsCache._internal_base) === base) {\n            return this._private__timeAxisViewsCache._internal_wrapper;\n        }\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const wrapper = base.map((aw)=>new SeriesPrimitiveTimeAxisViewWrapper(aw, timeScale));\n        this._private__timeAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_priceAxisViews() {\n        var _this__internal__primitive_priceAxisViews, _this__internal__primitive, _this__private__priceAxisViewsCache;\n        var _this__internal__primitive_priceAxisViews1;\n        const base = (_this__internal__primitive_priceAxisViews1 = (_this__internal__primitive_priceAxisViews = (_this__internal__primitive = this._internal__primitive).priceAxisViews) === null || _this__internal__primitive_priceAxisViews === void 0 ? void 0 : _this__internal__primitive_priceAxisViews.call(_this__internal__primitive)) !== null && _this__internal__primitive_priceAxisViews1 !== void 0 ? _this__internal__primitive_priceAxisViews1 : [];\n        if (((_this__private__priceAxisViewsCache = this._private__priceAxisViewsCache) === null || _this__private__priceAxisViewsCache === void 0 ? void 0 : _this__private__priceAxisViewsCache._internal_base) === base) {\n            return this._private__priceAxisViewsCache._internal_wrapper;\n        }\n        const priceScale = this._private__series._internal_priceScale();\n        const wrapper = base.map((aw)=>new SeriesPrimitivePriceAxisViewWrapper(aw, priceScale));\n        this._private__priceAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_priceAxisPaneViews() {\n        var _this__internal__primitive_priceAxisPaneViews, _this__internal__primitive, _this__private__priceAxisPaneViewsCache;\n        var _this__internal__primitive_priceAxisPaneViews1;\n        const base = (_this__internal__primitive_priceAxisPaneViews1 = (_this__internal__primitive_priceAxisPaneViews = (_this__internal__primitive = this._internal__primitive).priceAxisPaneViews) === null || _this__internal__primitive_priceAxisPaneViews === void 0 ? void 0 : _this__internal__primitive_priceAxisPaneViews.call(_this__internal__primitive)) !== null && _this__internal__primitive_priceAxisPaneViews1 !== void 0 ? _this__internal__primitive_priceAxisPaneViews1 : [];\n        if (((_this__private__priceAxisPaneViewsCache = this._private__priceAxisPaneViewsCache) === null || _this__private__priceAxisPaneViewsCache === void 0 ? void 0 : _this__private__priceAxisPaneViewsCache._internal_base) === base) {\n            return this._private__priceAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__priceAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_timeAxisPaneViews() {\n        var _this__internal__primitive_timeAxisPaneViews, _this__internal__primitive, _this__private__timeAxisPaneViewsCache;\n        var _this__internal__primitive_timeAxisPaneViews1;\n        const base = (_this__internal__primitive_timeAxisPaneViews1 = (_this__internal__primitive_timeAxisPaneViews = (_this__internal__primitive = this._internal__primitive).timeAxisPaneViews) === null || _this__internal__primitive_timeAxisPaneViews === void 0 ? void 0 : _this__internal__primitive_timeAxisPaneViews.call(_this__internal__primitive)) !== null && _this__internal__primitive_timeAxisPaneViews1 !== void 0 ? _this__internal__primitive_timeAxisPaneViews1 : [];\n        if (((_this__private__timeAxisPaneViewsCache = this._private__timeAxisPaneViewsCache) === null || _this__private__timeAxisPaneViewsCache === void 0 ? void 0 : _this__private__timeAxisPaneViewsCache._internal_base) === base) {\n            return this._private__timeAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw)=>new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__timeAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper\n        };\n        return wrapper;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        var _this__internal__primitive_autoscaleInfo, _this__internal__primitive;\n        var _this__internal__primitive_autoscaleInfo1;\n        return (_this__internal__primitive_autoscaleInfo1 = (_this__internal__primitive_autoscaleInfo = (_this__internal__primitive = this._internal__primitive).autoscaleInfo) === null || _this__internal__primitive_autoscaleInfo === void 0 ? void 0 : _this__internal__primitive_autoscaleInfo.call(_this__internal__primitive, startTimePoint, endTimePoint)) !== null && _this__internal__primitive_autoscaleInfo1 !== void 0 ? _this__internal__primitive_autoscaleInfo1 : null;\n    }\n    constructor(primitive, series){\n        super(primitive);\n        this._private__timeAxisViewsCache = null;\n        this._private__priceAxisViewsCache = null;\n        this._private__priceAxisPaneViewsCache = null;\n        this._private__timeAxisPaneViewsCache = null;\n        this._private__series = series;\n    }\n}\nfunction extractPrimitivePaneViews(primitives, extractor, zOrder, destination) {\n    primitives.forEach((wrapper)=>{\n        extractor(wrapper).forEach((paneView)=>{\n            if (paneView._internal_zOrder() !== zOrder) {\n                return;\n            }\n            destination.push(paneView);\n        });\n    });\n}\nfunction primitivePaneViewsExtractor(wrapper) {\n    return wrapper._internal_paneViews();\n}\nfunction primitivePricePaneViewsExtractor(wrapper) {\n    return wrapper._internal_priceAxisPaneViews();\n}\nfunction primitiveTimePaneViewsExtractor(wrapper) {\n    return wrapper._internal_timeAxisPaneViews();\n}\nconst lineBasedSeries = [\n    'Area',\n    'Line',\n    'Baseline'\n];\nclass Series extends PriceDataSource {\n    _internal_destroy() {\n        if (this._private__animationTimeoutId !== null) {\n            clearTimeout(this._private__animationTimeoutId);\n        }\n    }\n    _internal_priceLineColor(lastBarColor) {\n        return this._private__options.priceLineColor || lastBarColor;\n    }\n    _internal_lastValueData(globalLast) {\n        const noDataRes = {\n            _internal_noData: true\n        };\n        const priceScale = this._internal_priceScale();\n        if (this._internal_model()._internal_timeScale()._internal_isEmpty() || priceScale._internal_isEmpty() || this._private__data._internal_isEmpty()) {\n            return noDataRes;\n        }\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        const firstValue = this._internal_firstValue();\n        if (visibleBars === null || firstValue === null) {\n            return noDataRes;\n        }\n        // find range of bars inside range\n        // TODO: make it more optimal\n        let bar;\n        let lastIndex;\n        if (globalLast) {\n            const lastBar = this._private__data._internal_last();\n            if (lastBar === null) {\n                return noDataRes;\n            }\n            bar = lastBar;\n            lastIndex = lastBar._internal_index;\n        } else {\n            const endBar = this._private__data._internal_search(visibleBars._internal_right(), -1 /* MismatchDirection.NearestLeft */ );\n            if (endBar === null) {\n                return noDataRes;\n            }\n            bar = this._private__data._internal_valueAt(endBar._internal_index);\n            if (bar === null) {\n                return noDataRes;\n            }\n            lastIndex = endBar._internal_index;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        const barColorer = this._internal_barColorer();\n        const style = barColorer._internal_barStyle(lastIndex, {\n            _internal_value: bar\n        });\n        const coordinate = priceScale._internal_priceToCoordinate(price, firstValue._internal_value);\n        return {\n            _internal_noData: false,\n            _internal_price: price,\n            _internal_text: priceScale._internal_formatPrice(price, firstValue._internal_value),\n            _internal_formattedPriceAbsolute: priceScale._internal_formatPriceAbsolute(price),\n            _internal_formattedPricePercentage: priceScale._internal_formatPricePercentage(price, firstValue._internal_value),\n            _internal_color: style._internal_barColor,\n            _internal_coordinate: coordinate,\n            _internal_index: lastIndex\n        };\n    }\n    _internal_barColorer() {\n        if (this._private__barColorerCache !== null) {\n            return this._private__barColorerCache;\n        }\n        this._private__barColorerCache = new SeriesBarColorer(this);\n        return this._private__barColorerCache;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        const targetPriceScaleId = options.priceScaleId;\n        if (targetPriceScaleId !== undefined && targetPriceScaleId !== this._private__options.priceScaleId) {\n            // series cannot do it itself, ask model\n            this._internal_model()._internal_moveSeriesToScale(this, targetPriceScaleId);\n        }\n        merge(this._private__options, options);\n        if (options.priceFormat !== undefined) {\n            this._private__recreateFormatter();\n            // updated formatter might affect rendering  and as a consequence of this the width of price axis might be changed\n            // thus we need to force the chart to do a full update to apply changes correctly\n            // full update is quite heavy operation in terms of performance\n            // but updating formatter looks like quite rare so forcing a full update here shouldn't affect the performance a lot\n            this._internal_model()._internal_fullUpdate();\n        }\n        this._internal_model()._internal_updateSource(this);\n        // a series might affect crosshair by some options (like crosshair markers)\n        // that's why we need to update crosshair as well\n        this._internal_model()._internal_updateCrosshair();\n        this._private__paneView._internal_update('options');\n    }\n    _internal_setData(data, updateInfo) {\n        this._private__data._internal_setData(data);\n        this._private__paneView._internal_update('data');\n        if (this._private__lastPriceAnimationPaneView !== null) {\n            if (updateInfo && updateInfo._internal_lastBarUpdatedOrNewBarsAddedToTheRight) {\n                this._private__lastPriceAnimationPaneView._internal_onNewRealtimeDataReceived();\n            } else if (data.length === 0) {\n                this._private__lastPriceAnimationPaneView._internal_onDataCleared();\n            }\n        }\n        const sourcePane = this._internal_model()._internal_paneForSource(this);\n        this._internal_model()._internal_recalculatePane(sourcePane);\n        this._internal_model()._internal_updateSource(this);\n        this._internal_model()._internal_updateCrosshair();\n        this._internal_model()._internal_lightUpdate();\n    }\n    _internal_createPriceLine(options) {\n        const result = new CustomPriceLine(this, options);\n        this._private__customPriceLines.push(result);\n        this._internal_model()._internal_updateSource(this);\n        return result;\n    }\n    _internal_removePriceLine(line) {\n        const index = this._private__customPriceLines.indexOf(line);\n        if (index !== -1) {\n            this._private__customPriceLines.splice(index, 1);\n        }\n        this._internal_model()._internal_updateSource(this);\n    }\n    _internal_priceLines() {\n        return this._private__customPriceLines;\n    }\n    _internal_seriesType() {\n        return this._private__seriesType;\n    }\n    _internal_firstValue() {\n        const bar = this._internal_firstBar();\n        if (bar === null) {\n            return null;\n        }\n        return {\n            _internal_value: bar._internal_value[3 /* PlotRowValueIndex.Close */ ],\n            _internal_timePoint: bar._internal_time\n        };\n    }\n    _internal_firstBar() {\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const startTimePoint = visibleBars._internal_left();\n        return this._private__data._internal_search(startTimePoint, 1 /* MismatchDirection.NearestRight */ );\n    }\n    _internal_bars() {\n        return this._private__data;\n    }\n    _internal_dataAt(time) {\n        const prices = this._private__data._internal_valueAt(time);\n        if (prices === null) {\n            return null;\n        }\n        if (this._private__seriesType === 'Bar' || this._private__seriesType === 'Candlestick' || this._private__seriesType === 'Custom') {\n            return {\n                _internal_open: prices._internal_value[0 /* PlotRowValueIndex.Open */ ],\n                _internal_high: prices._internal_value[1 /* PlotRowValueIndex.High */ ],\n                _internal_low: prices._internal_value[2 /* PlotRowValueIndex.Low */ ],\n                _internal_close: prices._internal_value[3 /* PlotRowValueIndex.Close */ ]\n            };\n        } else {\n            return prices._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        }\n    }\n    _internal_topPaneViews(pane) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, 'top', res);\n        const animationPaneView = this._private__lastPriceAnimationPaneView;\n        if (animationPaneView === null || !animationPaneView._internal_visible()) {\n            return res;\n        }\n        if (this._private__animationTimeoutId === null && animationPaneView._internal_animationActive()) {\n            this._private__animationTimeoutId = setTimeout(()=>{\n                this._private__animationTimeoutId = null;\n                this._internal_model()._internal_cursorUpdate();\n            }, 0);\n        }\n        animationPaneView._internal_invalidateStage();\n        res.unshift(animationPaneView);\n        return res;\n    }\n    _internal_paneViews() {\n        const res = [];\n        if (!this._private__isOverlay()) {\n            res.push(this._private__baseHorizontalLineView);\n        }\n        res.push(this._private__paneView, this._private__priceLineView);\n        const priceLineViews = this._private__customPriceLines.map((line)=>line._internal_paneView());\n        res.push(...priceLineViews);\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, 'normal', res);\n        return res;\n    }\n    _internal_bottomPaneViews() {\n        return this._private__extractPaneViews(primitivePaneViewsExtractor, 'bottom');\n    }\n    _internal_pricePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitivePricePaneViewsExtractor, zOrder);\n    }\n    _internal_timePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitiveTimePaneViewsExtractor, zOrder);\n    }\n    _internal_primitiveHitTest(x, y) {\n        return this._private__primitives.map((primitive)=>primitive._internal_hitTest(x, y)).filter((result)=>result !== null);\n    }\n    _internal_labelPaneViews() {\n        return [\n            this._private__panePriceAxisView,\n            ...this._private__customPriceLines.map((line)=>line._internal_labelPaneView())\n        ];\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (priceScale !== this._internal__priceScale && !this._private__isOverlay()) {\n            return [];\n        }\n        const result = [\n            ...this._private__priceAxisViews\n        ];\n        for (const customPriceLine of this._private__customPriceLines){\n            result.push(customPriceLine._internal_priceAxisView());\n        }\n        this._private__primitives.forEach((wrapper)=>{\n            result.push(...wrapper._internal_priceAxisViews());\n        });\n        return result;\n    }\n    _internal_timeAxisViews() {\n        const res = [];\n        this._private__primitives.forEach((wrapper)=>{\n            res.push(...wrapper._internal_timeAxisViews());\n        });\n        return res;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        if (this._private__options.autoscaleInfoProvider !== undefined) {\n            const autoscaleInfo = this._private__options.autoscaleInfoProvider(()=>{\n                const res = this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n                return res === null ? null : res._internal_toRaw();\n            });\n            return AutoscaleInfoImpl._internal_fromRaw(autoscaleInfo);\n        }\n        return this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n    }\n    _internal_minMove() {\n        return this._private__options.priceFormat.minMove;\n    }\n    _internal_formatter() {\n        return this._private__formatter;\n    }\n    _internal_updateAllViews() {\n        var _this__private__lastPriceAnimationPaneView;\n        this._private__paneView._internal_update();\n        for (const priceAxisView of this._private__priceAxisViews){\n            priceAxisView._internal_update();\n        }\n        for (const customPriceLine of this._private__customPriceLines){\n            customPriceLine._internal_update();\n        }\n        this._private__priceLineView._internal_update();\n        this._private__baseHorizontalLineView._internal_update();\n        (_this__private__lastPriceAnimationPaneView = this._private__lastPriceAnimationPaneView) === null || _this__private__lastPriceAnimationPaneView === void 0 ? void 0 : _this__private__lastPriceAnimationPaneView._internal_update();\n        this._private__primitives.forEach((wrapper)=>wrapper._internal_updateAllViews());\n    }\n    _internal_priceScale() {\n        return ensureNotNull(super._internal_priceScale());\n    }\n    _internal_markerDataAtIndex(index) {\n        const getValue = (this._private__seriesType === 'Line' || this._private__seriesType === 'Area' || this._private__seriesType === 'Baseline') && this._private__options.crosshairMarkerVisible;\n        if (!getValue) {\n            return null;\n        }\n        const bar = this._private__data._internal_valueAt(index);\n        if (bar === null) {\n            return null;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */ ];\n        const radius = this._private__markerRadius();\n        const borderColor = this._private__markerBorderColor();\n        const borderWidth = this._private__markerBorderWidth();\n        const backgroundColor = this._private__markerBackgroundColor(index);\n        return {\n            _internal_price: price,\n            _internal_radius: radius,\n            _internal_borderColor: borderColor,\n            _internal_borderWidth: borderWidth,\n            _internal_backgroundColor: backgroundColor\n        };\n    }\n    _internal_title() {\n        return this._private__options.title;\n    }\n    _internal_visible() {\n        return this._private__options.visible;\n    }\n    _internal_attachPrimitive(primitive) {\n        this._private__primitives.push(new SeriesPrimitiveWrapper(primitive, this));\n    }\n    _internal_detachPrimitive(source) {\n        this._private__primitives = this._private__primitives.filter((wrapper)=>wrapper._internal_primitive() !== source);\n    }\n    _internal_customSeriesPlotValuesBuilder() {\n        if (this._private__seriesType !== 'Custom') {\n            return undefined;\n        }\n        return (data)=>{\n            return this._private__paneView._internal_priceValueBuilder(data);\n        };\n    }\n    _internal_customSeriesWhitespaceCheck() {\n        if (this._private__seriesType !== 'Custom') {\n            return undefined;\n        }\n        return (data)=>{\n            return this._private__paneView._internal_isWhitespace(data);\n        };\n    }\n    _internal_fulfilledIndices() {\n        return this._private__data._internal_indices();\n    }\n    _private__isOverlay() {\n        const priceScale = this._internal_priceScale();\n        return !isDefaultPriceScale(priceScale._internal_id());\n    }\n    _private__autoscaleInfoImpl(startTimePoint, endTimePoint) {\n        if (!isInteger(startTimePoint) || !isInteger(endTimePoint) || this._private__data._internal_isEmpty()) {\n            return null;\n        }\n        // TODO: refactor this\n        // series data is strongly hardcoded to keep bars\n        const plots = this._private__seriesType === 'Line' || this._private__seriesType === 'Area' || this._private__seriesType === 'Baseline' || this._private__seriesType === 'Histogram' ? [\n            3 /* PlotRowValueIndex.Close */ \n        ] : [\n            2 /* PlotRowValueIndex.Low */ ,\n            1 /* PlotRowValueIndex.High */ \n        ];\n        const barsMinMax = this._private__data._internal_minMaxOnRangeCached(startTimePoint, endTimePoint, plots);\n        let range = barsMinMax !== null ? new PriceRangeImpl(barsMinMax._internal_min, barsMinMax._internal_max) : null;\n        let margins = null;\n        if (this._internal_seriesType() === 'Histogram') {\n            const base = this._private__options.base;\n            const rangeWithBase = new PriceRangeImpl(base, base);\n            range = range !== null ? range._internal_merge(rangeWithBase) : rangeWithBase;\n        }\n        this._private__primitives.forEach((primitive)=>{\n            const primitiveAutoscale = primitive._internal_autoscaleInfo(startTimePoint, endTimePoint);\n            if (primitiveAutoscale === null || primitiveAutoscale === void 0 ? void 0 : primitiveAutoscale.priceRange) {\n                const primitiveRange = new PriceRangeImpl(primitiveAutoscale.priceRange.minValue, primitiveAutoscale.priceRange.maxValue);\n                range = range !== null ? range._internal_merge(primitiveRange) : primitiveRange;\n            }\n            if (primitiveAutoscale === null || primitiveAutoscale === void 0 ? void 0 : primitiveAutoscale.margins) {\n                margins = primitiveAutoscale.margins;\n            }\n        });\n        return new AutoscaleInfoImpl(range, margins);\n    }\n    _private__markerRadius() {\n        switch(this._private__seriesType){\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                return this._private__options.crosshairMarkerRadius;\n        }\n        return 0;\n    }\n    _private__markerBorderColor() {\n        switch(this._private__seriesType){\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                {\n                    const crosshairMarkerBorderColor = this._private__options.crosshairMarkerBorderColor;\n                    if (crosshairMarkerBorderColor.length !== 0) {\n                        return crosshairMarkerBorderColor;\n                    }\n                }\n        }\n        return null;\n    }\n    _private__markerBorderWidth() {\n        switch(this._private__seriesType){\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                return this._private__options.crosshairMarkerBorderWidth;\n        }\n        return 0;\n    }\n    _private__markerBackgroundColor(index) {\n        switch(this._private__seriesType){\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                {\n                    const crosshairMarkerBackgroundColor = this._private__options.crosshairMarkerBackgroundColor;\n                    if (crosshairMarkerBackgroundColor.length !== 0) {\n                        return crosshairMarkerBackgroundColor;\n                    }\n                }\n        }\n        return this._internal_barColorer()._internal_barStyle(index)._internal_barColor;\n    }\n    _private__recreateFormatter() {\n        switch(this._private__options.priceFormat.type){\n            case 'custom':\n                {\n                    this._private__formatter = {\n                        format: this._private__options.priceFormat.formatter\n                    };\n                    break;\n                }\n            case 'volume':\n                {\n                    this._private__formatter = new VolumeFormatter(this._private__options.priceFormat.precision);\n                    break;\n                }\n            case 'percent':\n                {\n                    this._private__formatter = new PercentageFormatter(this._private__options.priceFormat.precision);\n                    break;\n                }\n            default:\n                {\n                    const priceScale = Math.pow(10, this._private__options.priceFormat.precision);\n                    this._private__formatter = new PriceFormatter(priceScale, this._private__options.priceFormat.minMove * priceScale);\n                }\n        }\n        if (this._internal__priceScale !== null) {\n            this._internal__priceScale._internal_updateFormatter();\n        }\n    }\n    _private__extractPaneViews(extractor, zOrder) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, extractor, zOrder, res);\n        return res;\n    }\n    constructor(model, seriesType, options, createPaneView, customPaneView){\n        super(model);\n        this._private__data = createSeriesPlotList();\n        this._private__priceLineView = new SeriesPriceLinePaneView(this);\n        this._private__customPriceLines = [];\n        this._private__baseHorizontalLineView = new SeriesHorizontalBaseLinePaneView(this);\n        this._private__lastPriceAnimationPaneView = null;\n        this._private__barColorerCache = null;\n        this._private__animationTimeoutId = null;\n        this._private__primitives = [];\n        this._private__options = options;\n        this._private__seriesType = seriesType;\n        const priceAxisView = new SeriesPriceAxisView(this);\n        this._private__priceAxisViews = [\n            priceAxisView\n        ];\n        this._private__panePriceAxisView = new PanePriceAxisView(priceAxisView, this, model);\n        if (lineBasedSeries.includes(this._private__seriesType)) {\n            this._private__lastPriceAnimationPaneView = new SeriesLastPriceAnimationPaneView(this);\n        }\n        this._private__recreateFormatter();\n        this._private__paneView = createPaneView(this, this._internal_model(), customPaneView);\n    }\n}\nconst magnetPlotRowKeys = [\n    3 /* PlotRowValueIndex.Close */ \n];\nconst magnetOHLCPlotRowKeys = [\n    0 /* PlotRowValueIndex.Open */ ,\n    1 /* PlotRowValueIndex.High */ ,\n    2 /* PlotRowValueIndex.Low */ ,\n    3 /* PlotRowValueIndex.Close */ \n];\nclass Magnet {\n    _internal_align(price, index, pane) {\n        let res = price;\n        if (this._private__options.mode === 0 /* CrosshairMode.Normal */ ) {\n            return res;\n        }\n        const defaultPriceScale = pane._internal_defaultPriceScale();\n        const firstValue = defaultPriceScale._internal_firstValue();\n        if (firstValue === null) {\n            return res;\n        }\n        const y = defaultPriceScale._internal_priceToCoordinate(price, firstValue);\n        // get all serieses from the pane\n        const serieses = pane._internal_dataSources().filter((ds)=>ds instanceof Series);\n        const candidates = serieses.reduce((acc, series)=>{\n            if (pane._internal_isOverlay(series) || !series._internal_visible()) {\n                return acc;\n            }\n            const ps = series._internal_priceScale();\n            const bars = series._internal_bars();\n            if (ps._internal_isEmpty() || !bars._internal_contains(index)) {\n                return acc;\n            }\n            const bar = bars._internal_valueAt(index);\n            if (bar === null) {\n                return acc;\n            }\n            // convert bar to pixels\n            const firstPrice = ensure(series._internal_firstValue());\n            const plotRowKeys = this._private__options.mode === 3 /* CrosshairMode.MagnetOHLC */  ? magnetOHLCPlotRowKeys : magnetPlotRowKeys;\n            return acc.concat(plotRowKeys.map((key)=>ps._internal_priceToCoordinate(bar._internal_value[key], firstPrice._internal_value)));\n        }, []);\n        if (candidates.length === 0) {\n            return res;\n        }\n        candidates.sort((y1, y2)=>Math.abs(y1 - y) - Math.abs(y2 - y));\n        const nearest = candidates[0];\n        res = defaultPriceScale._internal_coordinateToPrice(nearest, firstValue);\n        return res;\n    }\n    constructor(options){\n        this._private__options = options;\n    }\n}\nfunction clamp(value, minVal, maxVal) {\n    return Math.min(Math.max(value, minVal), maxVal);\n}\nfunction isBaseDecimal(value) {\n    if (value < 0) {\n        return false;\n    }\n    for(let current = value; current > 1; current /= 10){\n        if (current % 10 !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction greaterOrEqual(x1, x2, epsilon) {\n    return x2 - x1 <= epsilon;\n}\nfunction equal(x1, x2, epsilon) {\n    return Math.abs(x1 - x2) < epsilon;\n}\n// We can't use Math.min(...arr) because that would only support arrays shorter than 65536 items.\nfunction min(arr) {\n    if (arr.length < 1) {\n        throw Error('array is empty');\n    }\n    let minVal = arr[0];\n    for(let i = 1; i < arr.length; ++i){\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\nfunction ceiledEven(x) {\n    const ceiled = Math.ceil(x);\n    return ceiled % 2 !== 0 ? ceiled - 1 : ceiled;\n}\nfunction ceiledOdd(x) {\n    const ceiled = Math.ceil(x);\n    return ceiled % 2 === 0 ? ceiled - 1 : ceiled;\n}\nclass GridRenderer extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null) {\n            return;\n        }\n        const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        ctx.lineWidth = lineWidth;\n        strokeInPixel(ctx, ()=>{\n            const data = ensureNotNull(this._private__data);\n            if (data._internal_vertLinesVisible) {\n                ctx.strokeStyle = data._internal_vertLinesColor;\n                setLineStyle(ctx, data._internal_vertLineStyle);\n                ctx.beginPath();\n                for (const timeMark of data._internal_timeMarks){\n                    const x = Math.round(timeMark._internal_coord * horizontalPixelRatio);\n                    ctx.moveTo(x, -lineWidth);\n                    ctx.lineTo(x, bitmapSize.height + lineWidth);\n                }\n                ctx.stroke();\n            }\n            if (data._internal_horzLinesVisible) {\n                ctx.strokeStyle = data._internal_horzLinesColor;\n                setLineStyle(ctx, data._internal_horzLineStyle);\n                ctx.beginPath();\n                for (const priceMark of data._internal_priceMarks){\n                    const y = Math.round(priceMark._internal_coord * verticalPixelRatio);\n                    ctx.moveTo(-lineWidth, y);\n                    ctx.lineTo(bitmapSize.width + lineWidth, y);\n                }\n                ctx.stroke();\n            }\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n    }\n}\nclass GridPaneView {\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            const gridOptions = this._private__pane._internal_model()._internal_options().grid;\n            const data = {\n                _internal_horzLinesVisible: gridOptions.horzLines.visible,\n                _internal_vertLinesVisible: gridOptions.vertLines.visible,\n                _internal_horzLinesColor: gridOptions.horzLines.color,\n                _internal_vertLinesColor: gridOptions.vertLines.color,\n                _internal_horzLineStyle: gridOptions.horzLines.style,\n                _internal_vertLineStyle: gridOptions.vertLines.style,\n                _internal_priceMarks: this._private__pane._internal_defaultPriceScale()._internal_marks(),\n                // need this conversiom because TimeMark is a part of external interface\n                // and fields inside TimeMark are not minified\n                _internal_timeMarks: (this._private__pane._internal_model()._internal_timeScale()._internal_marks() || []).map((tm)=>{\n                    return {\n                        _internal_coord: tm.coord\n                    };\n                })\n            };\n            this._private__renderer._internal_setData(data);\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    constructor(pane){\n        this._private__renderer = new GridRenderer();\n        this._private__invalidated = true;\n        this._private__pane = pane;\n    }\n}\nclass Grid {\n    _internal_paneView() {\n        return this._private__paneView;\n    }\n    constructor(pane){\n        this._private__paneView = new GridPaneView(pane);\n    }\n}\nconst defLogFormula = {\n    _internal_logicalOffset: 4,\n    _internal_coordOffset: 0.0001\n};\nfunction fromPercent(value, baseValue) {\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return value / 100 * baseValue + baseValue;\n}\nfunction toPercent(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue;\n    return baseValue < 0 ? -result : result;\n}\nfunction toPercentRange(priceRange, baseValue) {\n    const minPercent = toPercent(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toPercent(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction fromIndexedTo100(value, baseValue) {\n    value -= 100;\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return value / 100 * baseValue + baseValue;\n}\nfunction toIndexedTo100(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue + 100;\n    return baseValue < 0 ? -result : result;\n}\nfunction toIndexedTo100Range(priceRange, baseValue) {\n    const minPercent = toIndexedTo100(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toIndexedTo100(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction toLog(price, logFormula) {\n    const m = Math.abs(price);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.log10(m + logFormula._internal_coordOffset) + logFormula._internal_logicalOffset;\n    return price < 0 ? -res : res;\n}\nfunction fromLog(logical, logFormula) {\n    const m = Math.abs(logical);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.pow(10, m - logFormula._internal_logicalOffset) - logFormula._internal_coordOffset;\n    return logical < 0 ? -res : res;\n}\nfunction convertPriceRangeToLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = toLog(priceRange._internal_minValue(), logFormula);\n    const max = toLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction canConvertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return false;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return isFinite(min) && isFinite(max);\n}\nfunction convertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction logFormulaForPriceRange(range) {\n    if (range === null) {\n        return defLogFormula;\n    }\n    const diff = Math.abs(range._internal_maxValue() - range._internal_minValue());\n    if (diff >= 1 || diff < 1e-15) {\n        return defLogFormula;\n    }\n    const digits = Math.ceil(Math.abs(Math.log10(diff)));\n    const logicalOffset = defLogFormula._internal_logicalOffset + digits;\n    const coordOffset = 1 / Math.pow(10, logicalOffset);\n    return {\n        _internal_logicalOffset: logicalOffset,\n        _internal_coordOffset: coordOffset\n    };\n}\nfunction logFormulasAreSame(f1, f2) {\n    return f1._internal_logicalOffset === f2._internal_logicalOffset && f1._internal_coordOffset === f2._internal_coordOffset;\n}\nclass PriceTickSpanCalculator {\n    _internal_tickSpan(high, low, maxTickSpan) {\n        const minMovement = this._private__base === 0 ? 0 : 1 / this._private__base;\n        let resultTickSpan = Math.pow(10, Math.max(0, Math.ceil(Math.log10(high - low))));\n        let index = 0;\n        let c = this._private__integralDividers[0];\n        // eslint-disable-next-line no-constant-condition\n        while(true){\n            // the second part is actual for small with very small values like 1e-10\n            // greaterOrEqual fails for such values\n            const resultTickSpanLargerMinMovement = greaterOrEqual(resultTickSpan, minMovement, 1e-14 /* Constants.TickSpanEpsilon */ ) && resultTickSpan > minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ;\n            const resultTickSpanLargerMaxTickSpan = greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */ );\n            const resultTickSpanLarger1 = greaterOrEqual(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */ );\n            const haveToContinue = resultTickSpanLargerMinMovement && resultTickSpanLargerMaxTickSpan && resultTickSpanLarger1;\n            if (!haveToContinue) {\n                break;\n            }\n            resultTickSpan /= c;\n            c = this._private__integralDividers[++index % this._private__integralDividers.length];\n        }\n        if (resultTickSpan <= minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ) {\n            resultTickSpan = minMovement;\n        }\n        resultTickSpan = Math.max(1, resultTickSpan);\n        if (this._private__fractionalDividers.length > 0 && equal(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */ )) {\n            index = 0;\n            c = this._private__fractionalDividers[0];\n            while(greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */ ) && resultTickSpan > minMovement + 1e-14 /* Constants.TickSpanEpsilon */ ){\n                resultTickSpan /= c;\n                c = this._private__fractionalDividers[++index % this._private__fractionalDividers.length];\n            }\n        }\n        return resultTickSpan;\n    }\n    constructor(base, integralDividers){\n        this._private__base = base;\n        this._private__integralDividers = integralDividers;\n        if (isBaseDecimal(this._private__base)) {\n            this._private__fractionalDividers = [\n                2,\n                2.5,\n                2\n            ];\n        } else {\n            this._private__fractionalDividers = [];\n            for(let baseRest = this._private__base; baseRest !== 1;){\n                if (baseRest % 2 === 0) {\n                    this._private__fractionalDividers.push(2);\n                    baseRest /= 2;\n                } else if (baseRest % 5 === 0) {\n                    this._private__fractionalDividers.push(2, 2.5);\n                    baseRest /= 5;\n                } else {\n                    throw new Error('unexpected base');\n                }\n                if (this._private__fractionalDividers.length > 100) {\n                    throw new Error('something wrong with base');\n                }\n            }\n        }\n    }\n}\nconst TICK_DENSITY = 2.5;\nclass PriceTickMarkBuilder {\n    _internal_tickSpan(high, low) {\n        if (high < low) {\n            throw new Error('high < low');\n        }\n        const scaleHeight = this._private__priceScale._internal_height();\n        const markHeight = this._private__tickMarkHeight();\n        const maxTickSpan = (high - low) * markHeight / scaleHeight;\n        const spanCalculator1 = new PriceTickSpanCalculator(this._private__base, [\n            2,\n            2.5,\n            2\n        ]);\n        const spanCalculator2 = new PriceTickSpanCalculator(this._private__base, [\n            2,\n            2,\n            2.5\n        ]);\n        const spanCalculator3 = new PriceTickSpanCalculator(this._private__base, [\n            2.5,\n            2,\n            2\n        ]);\n        const spans = [];\n        spans.push(spanCalculator1._internal_tickSpan(high, low, maxTickSpan), spanCalculator2._internal_tickSpan(high, low, maxTickSpan), spanCalculator3._internal_tickSpan(high, low, maxTickSpan));\n        return min(spans);\n    }\n    _internal_rebuildTickMarks() {\n        const priceScale = this._private__priceScale;\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue === null) {\n            this._private__marks = [];\n            return;\n        }\n        const scaleHeight = priceScale._internal_height();\n        const bottom = this._private__coordinateToLogicalFunc(scaleHeight - 1, firstValue);\n        const top = this._private__coordinateToLogicalFunc(0, firstValue);\n        const extraTopBottomMargin = this._private__priceScale._internal_options().entireTextOnly ? this._private__fontHeight() / 2 : 0;\n        const minCoord = extraTopBottomMargin;\n        const maxCoord = scaleHeight - 1 - extraTopBottomMargin;\n        const high = Math.max(bottom, top);\n        const low = Math.min(bottom, top);\n        if (high === low) {\n            this._private__marks = [];\n            return;\n        }\n        const span = this._internal_tickSpan(high, low);\n        this._private__updateMarks(firstValue, span, high, low, minCoord, maxCoord);\n        if (priceScale._internal_hasVisibleEdgeMarks() && this._private__shouldApplyEdgeMarks(span, low, high)) {\n            const padding = this._private__priceScale._internal_getEdgeMarksPadding();\n            this._private__applyEdgeMarks(firstValue, span, minCoord, maxCoord, padding, padding * 2);\n        }\n    }\n    _internal_marks() {\n        return this._private__marks;\n    }\n    _private__fontHeight() {\n        return this._private__priceScale._internal_fontSize();\n    }\n    _private__tickMarkHeight() {\n        return Math.ceil(this._private__fontHeight() * TICK_DENSITY);\n    }\n    _private__updateMarks(firstValue, span, high, low, minCoord, maxCoord) {\n        const marks = this._private__marks;\n        const priceScale = this._private__priceScale;\n        let mod = high % span;\n        mod += mod < 0 ? span : 0;\n        const sign = high >= low ? 1 : -1;\n        let prevCoord = null;\n        let targetIndex = 0;\n        for(let logical = high - mod; logical > low; logical -= span){\n            const coord = this._private__logicalToCoordinateFunc(logical, firstValue, true);\n            // check if there is place for it\n            // this is required for log scale\n            if (prevCoord !== null && Math.abs(coord - prevCoord) < this._private__tickMarkHeight()) {\n                continue;\n            }\n            // check if a tick mark is partially visible and skip it if entireTextOnly is true\n            if (coord < minCoord || coord > maxCoord) {\n                continue;\n            }\n            if (targetIndex < marks.length) {\n                marks[targetIndex]._internal_coord = coord;\n                marks[targetIndex]._internal_label = priceScale._internal_formatLogical(logical);\n            } else {\n                marks.push({\n                    _internal_coord: coord,\n                    _internal_label: priceScale._internal_formatLogical(logical)\n                });\n            }\n            targetIndex++;\n            prevCoord = coord;\n            if (priceScale._internal_isLog()) {\n                // recalc span\n                span = this._internal_tickSpan(logical * sign, low);\n            }\n        }\n        marks.length = targetIndex;\n    }\n    _private__applyEdgeMarks(firstValue, span, minCoord, maxCoord, minPadding, maxPadding) {\n        const marks = this._private__marks;\n        // top boundary\n        const topMark = this._private__computeBoundaryPriceMark(firstValue, minCoord, minPadding, maxPadding);\n        // bottom boundary\n        const bottomMark = this._private__computeBoundaryPriceMark(firstValue, maxCoord, -maxPadding, -minPadding);\n        const spanPx = this._private__logicalToCoordinateFunc(0, firstValue, true) - this._private__logicalToCoordinateFunc(span, firstValue, true);\n        if (marks.length > 0 && marks[0]._internal_coord - topMark._internal_coord < spanPx / 2) {\n            marks.shift();\n        }\n        if (marks.length > 0 && bottomMark._internal_coord - marks[marks.length - 1]._internal_coord < spanPx / 2) {\n            marks.pop();\n        }\n        marks.unshift(topMark);\n        marks.push(bottomMark);\n    }\n    _private__computeBoundaryPriceMark(firstValue, coord, minPadding, maxPadding) {\n        const avgPadding = (minPadding + maxPadding) / 2;\n        const value1 = this._private__coordinateToLogicalFunc(coord + minPadding, firstValue);\n        const value2 = this._private__coordinateToLogicalFunc(coord + maxPadding, firstValue);\n        const minValue = Math.min(value1, value2);\n        const maxValue = Math.max(value1, value2);\n        const valueSpan = Math.max(0.1, this._internal_tickSpan(maxValue, minValue));\n        const value = this._private__coordinateToLogicalFunc(coord + avgPadding, firstValue);\n        const roundedValue = value - value % valueSpan;\n        const roundedCoord = this._private__logicalToCoordinateFunc(roundedValue, firstValue, true);\n        return {\n            _internal_label: this._private__priceScale._internal_formatLogical(roundedValue),\n            _internal_coord: roundedCoord\n        };\n    }\n    _private__shouldApplyEdgeMarks(span, low, high) {\n        let range = ensure(this._private__priceScale._internal_priceRange());\n        if (this._private__priceScale._internal_isLog()) {\n            range = convertPriceRangeFromLog(range, this._private__priceScale._internal_getLogFormula());\n        }\n        return range._internal_minValue() - low < span && high - range._internal_maxValue() < span;\n    }\n    constructor(priceScale, base, coordinateToLogicalFunc, logicalToCoordinateFunc){\n        this._private__marks = [];\n        this._private__priceScale = priceScale;\n        this._private__base = base;\n        this._private__coordinateToLogicalFunc = coordinateToLogicalFunc;\n        this._private__logicalToCoordinateFunc = logicalToCoordinateFunc;\n    }\n}\nfunction sortSources(sources) {\n    return sources.slice().sort((s1, s2)=>{\n        return ensureNotNull(s1._internal_zorder()) - ensureNotNull(s2._internal_zorder());\n    });\n}\n/**\n * Represents the price scale mode.\n */ var PriceScaleMode;\n(function(PriceScaleMode) {\n    /**\n     * Price scale shows prices. Price range changes linearly.\n     */ PriceScaleMode[PriceScaleMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * Price scale shows prices. Price range changes logarithmically.\n     */ PriceScaleMode[PriceScaleMode[\"Logarithmic\"] = 1] = \"Logarithmic\";\n    /**\n     * Price scale shows percentage values according the first visible value of the price scale.\n     * The first visible value is 0% in this mode.\n     */ PriceScaleMode[PriceScaleMode[\"Percentage\"] = 2] = \"Percentage\";\n    /**\n     * The same as percentage mode, but the first value is moved to 100.\n     */ PriceScaleMode[PriceScaleMode[\"IndexedTo100\"] = 3] = \"IndexedTo100\";\n})(PriceScaleMode || (PriceScaleMode = {}));\nconst percentageFormatter = new PercentageFormatter();\nconst defaultPriceFormatter = new PriceFormatter(100, 1);\nclass PriceScale {\n    _internal_id() {\n        return this._private__id;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_updateFormatter();\n        if (options.mode !== undefined) {\n            this._internal_setMode({\n                _internal_mode: options.mode\n            });\n        }\n        if (options.scaleMargins !== undefined) {\n            const top = ensureDefined(options.scaleMargins.top);\n            const bottom = ensureDefined(options.scaleMargins.bottom);\n            if (top < 0 || top > 1) {\n                throw new Error(\"Invalid top margin - expect value between 0 and 1, given=\".concat(top));\n            }\n            if (bottom < 0 || bottom > 1) {\n                throw new Error(\"Invalid bottom margin - expect value between 0 and 1, given=\".concat(bottom));\n            }\n            if (top + bottom > 1) {\n                throw new Error(\"Invalid margins - sum of margins must be less than 1, given=\".concat(top + bottom));\n            }\n            this._private__invalidateInternalHeightCache();\n            this._private__marksCache = null;\n        }\n    }\n    _internal_isAutoScale() {\n        return this._private__options.autoScale;\n    }\n    _internal_isCustomPriceRange() {\n        return this._private__isCustomPriceRange;\n    }\n    _internal_isLog() {\n        return this._private__options.mode === 1 /* PriceScaleMode.Logarithmic */ ;\n    }\n    _internal_isPercentage() {\n        return this._private__options.mode === 2 /* PriceScaleMode.Percentage */ ;\n    }\n    _internal_isIndexedTo100() {\n        return this._private__options.mode === 3 /* PriceScaleMode.IndexedTo100 */ ;\n    }\n    _internal_getLogFormula() {\n        return this._private__logFormula;\n    }\n    _internal_mode() {\n        return {\n            _internal_autoScale: this._private__options.autoScale,\n            _internal_isInverted: this._private__options.invertScale,\n            _internal_mode: this._private__options.mode\n        };\n    }\n    // eslint-disable-next-line complexity\n    _internal_setMode(newMode) {\n        const oldMode = this._internal_mode();\n        let priceRange = null;\n        if (newMode._internal_autoScale !== undefined) {\n            this._private__options.autoScale = newMode._internal_autoScale;\n        }\n        if (newMode._internal_mode !== undefined) {\n            this._private__options.mode = newMode._internal_mode;\n            if (newMode._internal_mode === 2 /* PriceScaleMode.Percentage */  || newMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */ ) {\n                this._private__options.autoScale = true;\n            }\n            // TODO: Remove after making rebuildTickMarks lazy\n            this._private__invalidatedForRange._internal_isValid = false;\n        }\n        // define which scale converted from\n        if (oldMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */  && newMode._internal_mode !== oldMode._internal_mode) {\n            if (canConvertPriceRangeFromLog(this._private__priceRange, this._private__logFormula)) {\n                priceRange = convertPriceRangeFromLog(this._private__priceRange, this._private__logFormula);\n                if (priceRange !== null) {\n                    this._internal_setPriceRange(priceRange);\n                }\n            } else {\n                this._private__options.autoScale = true;\n            }\n        }\n        // define which scale converted to\n        if (newMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */  && newMode._internal_mode !== oldMode._internal_mode) {\n            priceRange = convertPriceRangeToLog(this._private__priceRange, this._private__logFormula);\n            if (priceRange !== null) {\n                this._internal_setPriceRange(priceRange);\n            }\n        }\n        const modeChanged = oldMode._internal_mode !== this._private__options.mode;\n        if (modeChanged && (oldMode._internal_mode === 2 /* PriceScaleMode.Percentage */  || this._internal_isPercentage())) {\n            this._internal_updateFormatter();\n        }\n        if (modeChanged && (oldMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */  || this._internal_isIndexedTo100())) {\n            this._internal_updateFormatter();\n        }\n        if (newMode._internal_isInverted !== undefined && oldMode._internal_isInverted !== newMode._internal_isInverted) {\n            this._private__options.invertScale = newMode._internal_isInverted;\n            this._private__onIsInvertedChanged();\n        }\n        this._private__modeChanged._internal_fire(oldMode, this._internal_mode());\n    }\n    _internal_modeChanged() {\n        return this._private__modeChanged;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setHeight(value) {\n        if (this._private__height === value) {\n            return;\n        }\n        this._private__height = value;\n        this._private__invalidateInternalHeightCache();\n        this._private__marksCache = null;\n    }\n    _internal_internalHeight() {\n        if (this._private__internalHeightCache) {\n            return this._private__internalHeightCache;\n        }\n        const res = this._internal_height() - this._private__topMarginPx() - this._private__bottomMarginPx();\n        this._private__internalHeightCache = res;\n        return res;\n    }\n    _internal_priceRange() {\n        this._private__makeSureItIsValid();\n        return this._private__priceRange;\n    }\n    _internal_setPriceRange(newPriceRange, isForceSetValue) {\n        const oldPriceRange = this._private__priceRange;\n        if (!isForceSetValue && !(oldPriceRange === null && newPriceRange !== null) && (oldPriceRange === null || oldPriceRange._internal_equals(newPriceRange))) {\n            return;\n        }\n        this._private__marksCache = null;\n        this._private__priceRange = newPriceRange;\n    }\n    _internal_setCustomPriceRange(newPriceRange) {\n        this._internal_setPriceRange(newPriceRange);\n        this._private__toggleCustomPriceRange(newPriceRange !== null);\n    }\n    _internal_isEmpty() {\n        this._private__makeSureItIsValid();\n        return this._private__height === 0 || !this._private__priceRange || this._private__priceRange._internal_isEmpty();\n    }\n    _internal_invertedCoordinate(coordinate) {\n        return this._internal_isInverted() ? coordinate : this._internal_height() - 1 - coordinate;\n    }\n    _internal_priceToCoordinate(price, baseValue) {\n        if (this._internal_isPercentage()) {\n            price = toPercent(price, baseValue);\n        } else if (this._internal_isIndexedTo100()) {\n            price = toIndexedTo100(price, baseValue);\n        }\n        return this._private__logicalToCoordinate(price, baseValue);\n    }\n    _internal_pointsArrayToCoordinates(points, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = this._internal_internalHeight() - 1;\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = visibleRange === undefined ? 0 : visibleRange.from;\n        const toIndex = visibleRange === undefined ? points.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for(let i = fromIndex; i < toIndex; i++){\n            const point = points[i];\n            const price = point._internal_price;\n            if (isNaN(price)) {\n                continue;\n            }\n            let logical = price;\n            if (transformFn !== null) {\n                logical = transformFn(point._internal_price, baseValue);\n            }\n            const invCoordinate = bh + hmm * (logical - min);\n            const coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            point._internal_y = coordinate;\n        }\n    }\n    _internal_barPricesToCoordinates(pricesList, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = this._internal_internalHeight() - 1;\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = visibleRange === undefined ? 0 : visibleRange.from;\n        const toIndex = visibleRange === undefined ? pricesList.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for(let i = fromIndex; i < toIndex; i++){\n            const bar = pricesList[i];\n            let openLogical = bar._internal_open;\n            let highLogical = bar._internal_high;\n            let lowLogical = bar._internal_low;\n            let closeLogical = bar._internal_close;\n            if (transformFn !== null) {\n                openLogical = transformFn(bar._internal_open, baseValue);\n                highLogical = transformFn(bar._internal_high, baseValue);\n                lowLogical = transformFn(bar._internal_low, baseValue);\n                closeLogical = transformFn(bar._internal_close, baseValue);\n            }\n            let invCoordinate = bh + hmm * (openLogical - min);\n            let coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_openY = coordinate;\n            invCoordinate = bh + hmm * (highLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_highY = coordinate;\n            invCoordinate = bh + hmm * (lowLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_lowY = coordinate;\n            invCoordinate = bh + hmm * (closeLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_closeY = coordinate;\n        }\n    }\n    _internal_coordinateToPrice(coordinate, baseValue) {\n        const logical = this._private__coordinateToLogical(coordinate, baseValue);\n        return this._internal_logicalToPrice(logical, baseValue);\n    }\n    _internal_logicalToPrice(logical, baseValue) {\n        let value = logical;\n        if (this._internal_isPercentage()) {\n            value = fromPercent(value, baseValue);\n        } else if (this._internal_isIndexedTo100()) {\n            value = fromIndexedTo100(value, baseValue);\n        }\n        return value;\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_orderedSources() {\n        if (!this._private__cachedOrderedSources) {\n            this._private__cachedOrderedSources = sortSources(this._private__dataSources);\n        }\n        return this._private__cachedOrderedSources;\n    }\n    _internal_addDataSource(source) {\n        if (this._private__dataSources.indexOf(source) !== -1) {\n            return;\n        }\n        this._private__dataSources.push(source);\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_removeDataSource(source) {\n        const index = this._private__dataSources.indexOf(source);\n        if (index === -1) {\n            throw new Error('source is not attached to scale');\n        }\n        this._private__dataSources.splice(index, 1);\n        if (this._private__dataSources.length === 0) {\n            this._internal_setMode({\n                _internal_autoScale: true\n            });\n            // if no sources on price scale let's clear price range cache as well as enabling auto scale\n            this._internal_setPriceRange(null);\n        }\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_firstValue() {\n        // TODO: cache the result\n        let result = null;\n        for (const source of this._private__dataSources){\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            if (result === null || firstValue._internal_timePoint < result._internal_timePoint) {\n                result = firstValue;\n            }\n        }\n        return result === null ? null : result._internal_value;\n    }\n    _internal_isInverted() {\n        return this._private__options.invertScale;\n    }\n    _internal_marks() {\n        const firstValueIsNull = this._internal_firstValue() === null;\n        // do not recalculate marks if firstValueIsNull is true because in this case we'll always get empty result\n        // this could happen in case when a series had some data and then you set empty data to it (in a simplified case)\n        // we could display an empty price scale, but this is not good from UX\n        // so in this case we need to keep an previous marks to display them on the scale\n        // as one of possible examples for this situation could be the following:\n        // let's say you have a study/indicator attached to a price scale and then you decide to stop it, i.e. remove its data because of its visibility\n        // a user will see the previous marks on the scale until you turn on your study back or remove it from the chart completely\n        if (this._private__marksCache !== null && (firstValueIsNull || this._private__marksCache._internal_firstValueIsNull === firstValueIsNull)) {\n            return this._private__marksCache._internal_marks;\n        }\n        this._private__markBuilder._internal_rebuildTickMarks();\n        const marks = this._private__markBuilder._internal_marks();\n        this._private__marksCache = {\n            _internal_marks: marks,\n            _internal_firstValueIsNull: firstValueIsNull\n        };\n        this._private__onMarksChanged._internal_fire();\n        return marks;\n    }\n    _internal_onMarksChanged() {\n        return this._private__onMarksChanged;\n    }\n    _internal_startScale(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        // invert x\n        this._private__scaleStartPoint = this._private__height - x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scaleTo(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._internal_setMode({\n            _internal_autoScale: false\n        });\n        // invert x\n        x = this._private__height - x;\n        if (x < 0) {\n            x = 0;\n        }\n        let scaleCoeff = (this._private__scaleStartPoint + (this._private__height - 1) * 0.2) / (x + (this._private__height - 1) * 0.2);\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        scaleCoeff = Math.max(scaleCoeff, 0.1);\n        newPriceRange._internal_scaleAroundCenter(scaleCoeff);\n        this._internal_setPriceRange(newPriceRange);\n    }\n    _internal_endScale() {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_startScroll(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scrollTo(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const priceUnitsPerPixel = ensureNotNull(this._internal_priceRange())._internal_length() / (this._internal_internalHeight() - 1);\n        let pixelDelta = x - this._private__scrollStartPoint;\n        if (this._internal_isInverted()) {\n            pixelDelta *= -1;\n        }\n        const priceDelta = pixelDelta * priceUnitsPerPixel;\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        newPriceRange._internal_shift(priceDelta);\n        this._internal_setPriceRange(newPriceRange, true);\n        this._private__marksCache = null;\n    }\n    _internal_endScroll() {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_formatter() {\n        if (!this._private__formatter) {\n            this._internal_updateFormatter();\n        }\n        return this._private__formatter;\n    }\n    _internal_formatPrice(price, firstValue) {\n        switch(this._private__options.mode){\n            case 2 /* PriceScaleMode.Percentage */ :\n                return this._private__formatPercentage(toPercent(price, firstValue));\n            case 3 /* PriceScaleMode.IndexedTo100 */ :\n                return this._internal_formatter().format(toIndexedTo100(price, firstValue));\n            default:\n                return this._private__formatPrice(price);\n        }\n    }\n    _internal_formatLogical(logical) {\n        switch(this._private__options.mode){\n            case 2 /* PriceScaleMode.Percentage */ :\n                return this._private__formatPercentage(logical);\n            case 3 /* PriceScaleMode.IndexedTo100 */ :\n                return this._internal_formatter().format(logical);\n            default:\n                return this._private__formatPrice(logical);\n        }\n    }\n    _internal_formatPriceAbsolute(price) {\n        return this._private__formatPrice(price, ensureNotNull(this._private__formatterSource)._internal_formatter());\n    }\n    _internal_formatPricePercentage(price, baseValue) {\n        price = toPercent(price, baseValue);\n        return this._private__formatPercentage(price, percentageFormatter);\n    }\n    _internal_sourcesForAutoScale() {\n        return this._private__dataSources;\n    }\n    _internal_recalculatePriceRange(visibleBars) {\n        this._private__invalidatedForRange = {\n            _internal_visibleBars: visibleBars,\n            _internal_isValid: false\n        };\n    }\n    _internal_updateAllViews() {\n        this._private__dataSources.forEach((s)=>s._internal_updateAllViews());\n    }\n    _internal_hasVisibleEdgeMarks() {\n        return this._private__options.ensureEdgeTickMarksVisible && this._internal_isAutoScale();\n    }\n    _internal_getEdgeMarksPadding() {\n        return this._internal_fontSize() / 2;\n    }\n    _internal_updateFormatter() {\n        this._private__marksCache = null;\n        let zOrder = Infinity;\n        this._private__formatterSource = null;\n        // choose source with the lowest zorder\n        for (const source of this._private__dataSources){\n            if (source._internal_zorder() < zOrder) {\n                zOrder = source._internal_zorder();\n                this._private__formatterSource = source;\n            }\n        }\n        let base = 100;\n        if (this._private__formatterSource !== null) {\n            base = Math.round(1 / this._private__formatterSource._internal_minMove());\n        }\n        this._private__formatter = defaultPriceFormatter;\n        if (this._internal_isPercentage()) {\n            this._private__formatter = percentageFormatter;\n            base = 100;\n        } else if (this._internal_isIndexedTo100()) {\n            this._private__formatter = new PriceFormatter(100, 1);\n            base = 100;\n        } else {\n            if (this._private__formatterSource !== null) {\n                // user\n                this._private__formatter = this._private__formatterSource._internal_formatter();\n            }\n        }\n        this._private__markBuilder = new PriceTickMarkBuilder(this, base, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    _internal_invalidateSourcesCache() {\n        this._private__cachedOrderedSources = null;\n    }\n    _internal_colorParser() {\n        return this._private__colorParser;\n    }\n    _private__toggleCustomPriceRange(v) {\n        this._private__isCustomPriceRange = v;\n    }\n    _private__topMarginPx() {\n        return this._internal_isInverted() ? this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow : this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove;\n    }\n    _private__bottomMarginPx() {\n        return this._internal_isInverted() ? this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove : this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow;\n    }\n    _private__makeSureItIsValid() {\n        if (!this._private__invalidatedForRange._internal_isValid) {\n            this._private__invalidatedForRange._internal_isValid = true;\n            this._private__recalculatePriceRangeImpl();\n        }\n    }\n    _private__invalidateInternalHeightCache() {\n        this._private__internalHeightCache = null;\n    }\n    _private__logicalToCoordinate(logical, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        logical = this._internal_isLog() && logical ? toLog(logical, this._private__logFormula) : logical;\n        const range = ensureNotNull(this._internal_priceRange());\n        const invCoordinate = this._private__bottomMarginPx() + (this._internal_internalHeight() - 1) * (logical - range._internal_minValue()) / range._internal_length();\n        const coordinate = this._internal_invertedCoordinate(invCoordinate);\n        return coordinate;\n    }\n    _private__coordinateToLogical(coordinate, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        const invCoordinate = this._internal_invertedCoordinate(coordinate);\n        const range = ensureNotNull(this._internal_priceRange());\n        const logical = range._internal_minValue() + range._internal_length() * ((invCoordinate - this._private__bottomMarginPx()) / (this._internal_internalHeight() - 1));\n        return this._internal_isLog() ? fromLog(logical, this._private__logFormula) : logical;\n    }\n    _private__onIsInvertedChanged() {\n        this._private__marksCache = null;\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    // eslint-disable-next-line complexity\n    _private__recalculatePriceRangeImpl() {\n        if (this._internal_isCustomPriceRange() && !this._internal_isAutoScale()) {\n            return;\n        }\n        const visibleBars = this._private__invalidatedForRange._internal_visibleBars;\n        if (visibleBars === null) {\n            return;\n        }\n        let priceRange = null;\n        const sources = this._internal_sourcesForAutoScale();\n        let marginAbove = 0;\n        let marginBelow = 0;\n        for (const source of sources){\n            if (!source._internal_visible()) {\n                continue;\n            }\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            const autoScaleInfo = source._internal_autoscaleInfo(visibleBars._internal_left(), visibleBars._internal_right());\n            let sourceRange = autoScaleInfo && autoScaleInfo._internal_priceRange();\n            if (sourceRange !== null) {\n                switch(this._private__options.mode){\n                    case 1 /* PriceScaleMode.Logarithmic */ :\n                        sourceRange = convertPriceRangeToLog(sourceRange, this._private__logFormula);\n                        break;\n                    case 2 /* PriceScaleMode.Percentage */ :\n                        sourceRange = toPercentRange(sourceRange, firstValue._internal_value);\n                        break;\n                    case 3 /* PriceScaleMode.IndexedTo100 */ :\n                        sourceRange = toIndexedTo100Range(sourceRange, firstValue._internal_value);\n                        break;\n                }\n                if (priceRange === null) {\n                    priceRange = sourceRange;\n                } else {\n                    priceRange = priceRange._internal_merge(ensureNotNull(sourceRange));\n                }\n                if (autoScaleInfo !== null) {\n                    const margins = autoScaleInfo._internal_margins();\n                    if (margins !== null) {\n                        marginAbove = Math.max(marginAbove, margins.above);\n                        marginBelow = Math.max(marginBelow, margins.below);\n                    }\n                }\n            }\n        }\n        if (this._internal_hasVisibleEdgeMarks()) {\n            marginAbove = Math.max(marginAbove, this._internal_getEdgeMarksPadding());\n            marginBelow = Math.max(marginBelow, this._internal_getEdgeMarksPadding());\n        }\n        if (marginAbove !== this._private__marginAbove || marginBelow !== this._private__marginBelow) {\n            this._private__marginAbove = marginAbove;\n            this._private__marginBelow = marginBelow;\n            this._private__marksCache = null;\n            this._private__invalidateInternalHeightCache();\n        }\n        if (priceRange !== null) {\n            // keep current range is new is empty\n            if (priceRange._internal_minValue() === priceRange._internal_maxValue()) {\n                const formatterSource = this._private__formatterSource;\n                const minMove = formatterSource === null || this._internal_isPercentage() || this._internal_isIndexedTo100() ? 1 : formatterSource._internal_minMove();\n                // if price range is degenerated to 1 point let's extend it by 10 min move values\n                // to avoid incorrect range and empty (blank) scale (in case of min tick much greater than 1)\n                const extendValue = 5 * minMove;\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                }\n                priceRange = new PriceRangeImpl(priceRange._internal_minValue() - extendValue, priceRange._internal_maxValue() + extendValue);\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeToLog(priceRange, this._private__logFormula);\n                }\n            }\n            if (this._internal_isLog()) {\n                const rawRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                const newLogFormula = logFormulaForPriceRange(rawRange);\n                if (!logFormulasAreSame(newLogFormula, this._private__logFormula)) {\n                    const rawSnapshot = this._private__priceRangeSnapshot !== null ? convertPriceRangeFromLog(this._private__priceRangeSnapshot, this._private__logFormula) : null;\n                    this._private__logFormula = newLogFormula;\n                    priceRange = convertPriceRangeToLog(rawRange, newLogFormula);\n                    if (rawSnapshot !== null) {\n                        this._private__priceRangeSnapshot = convertPriceRangeToLog(rawSnapshot, newLogFormula);\n                    }\n                }\n            }\n            this._internal_setPriceRange(priceRange);\n        } else {\n            // reset empty to default\n            if (this._private__priceRange === null) {\n                this._internal_setPriceRange(new PriceRangeImpl(-0.5, 0.5));\n                this._private__logFormula = logFormulaForPriceRange(null);\n            }\n        }\n    }\n    _private__getCoordinateTransformer() {\n        if (this._internal_isPercentage()) {\n            return toPercent;\n        } else if (this._internal_isIndexedTo100()) {\n            return toIndexedTo100;\n        } else if (this._internal_isLog()) {\n            return (price)=>toLog(price, this._private__logFormula);\n        }\n        return null;\n    }\n    _private__formatValue(value, formatter, fallbackFormatter) {\n        if (formatter === undefined) {\n            if (fallbackFormatter === undefined) {\n                fallbackFormatter = this._internal_formatter();\n            }\n            return fallbackFormatter.format(value);\n        }\n        return formatter(value);\n    }\n    _private__formatPrice(price, fallbackFormatter) {\n        return this._private__formatValue(price, this._private__localizationOptions.priceFormatter, fallbackFormatter);\n    }\n    _private__formatPercentage(percentage, fallbackFormatter) {\n        return this._private__formatValue(percentage, this._private__localizationOptions.percentageFormatter, fallbackFormatter);\n    }\n    constructor(id, options, layoutOptions, localizationOptions, colorParser){\n        this._private__height = 0;\n        this._private__internalHeightCache = null;\n        this._private__priceRange = null;\n        this._private__priceRangeSnapshot = null;\n        this._private__invalidatedForRange = {\n            _internal_isValid: false,\n            _internal_visibleBars: null\n        };\n        this._private__isCustomPriceRange = false;\n        this._private__marginAbove = 0;\n        this._private__marginBelow = 0;\n        this._private__onMarksChanged = new Delegate();\n        this._private__modeChanged = new Delegate();\n        this._private__dataSources = [];\n        this._private__formatterSource = null;\n        this._private__cachedOrderedSources = null;\n        this._private__marksCache = null;\n        this._private__scaleStartPoint = null;\n        this._private__scrollStartPoint = null;\n        this._private__formatter = defaultPriceFormatter;\n        this._private__logFormula = logFormulaForPriceRange(null);\n        this._private__id = id;\n        this._private__options = options;\n        this._private__layoutOptions = layoutOptions;\n        this._private__localizationOptions = localizationOptions;\n        this._private__colorParser = colorParser;\n        this._private__markBuilder = new PriceTickMarkBuilder(this, 100, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n    }\n}\nfunction isSeries(source) {\n    return source instanceof Series;\n}\nconst DEFAULT_STRETCH_FACTOR = 1000;\nconst MIN_PANE_HEIGHT = 30;\nclass Pane {\n    _internal_applyScaleOptions(options) {\n        if (options.leftPriceScale) {\n            this._private__leftPriceScale._internal_applyOptions(options.leftPriceScale);\n        }\n        if (options.rightPriceScale) {\n            this._private__rightPriceScale._internal_applyOptions(options.rightPriceScale);\n        }\n        if (options.localization) {\n            this._private__leftPriceScale._internal_updateFormatter();\n            this._private__rightPriceScale._internal_updateFormatter();\n        }\n        if (options.overlayPriceScales) {\n            const sourceArrays = Array.from(this._private__overlaySourcesByScaleId.values());\n            for (const arr of sourceArrays){\n                const priceScale = ensureNotNull(arr[0]._internal_priceScale());\n                priceScale._internal_applyOptions(options.overlayPriceScales);\n                if (options.localization) {\n                    priceScale._internal_updateFormatter();\n                }\n            }\n        }\n    }\n    _internal_priceScaleById(id) {\n        switch(id){\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case \"left\" /* DefaultPriceScaleId.Left */ :\n                {\n                    return this._private__leftPriceScale;\n                }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case \"right\" /* DefaultPriceScaleId.Right */ :\n                {\n                    return this._private__rightPriceScale;\n                }\n        }\n        if (this._private__overlaySourcesByScaleId.has(id)) {\n            return ensureDefined(this._private__overlaySourcesByScaleId.get(id))[0]._internal_priceScale();\n        }\n        return null;\n    }\n    _internal_destroy() {\n        this._internal_model()._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__leftPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__dataSources.forEach((source)=>{\n            if (source._internal_destroy) {\n                source._internal_destroy();\n            }\n        });\n        this._private__primitives = this._private__primitives.filter((primitive)=>{\n            const p = primitive._internal_primitive();\n            if (p.detached) {\n                p.detached();\n            }\n            return false;\n        });\n        this._private__destroyed._internal_fire();\n    }\n    _internal_stretchFactor() {\n        return this._private__stretchFactor;\n    }\n    _internal_setStretchFactor(factor) {\n        this._private__stretchFactor = factor;\n    }\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._internal_updateAllSources();\n    }\n    _internal_setHeight(height) {\n        this._private__height = height;\n        this._private__leftPriceScale._internal_setHeight(height);\n        this._private__rightPriceScale._internal_setHeight(height);\n        // process overlays\n        this._private__dataSources.forEach((ds)=>{\n            if (this._internal_isOverlay(ds)) {\n                const priceScale = ds._internal_priceScale();\n                if (priceScale !== null) {\n                    priceScale._internal_setHeight(height);\n                }\n            }\n        });\n        this._internal_updateAllSources();\n    }\n    _internal_series() {\n        return this._private__dataSources.filter(isSeries);\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_isOverlay(source) {\n        const priceScale = source._internal_priceScale();\n        if (priceScale === null) {\n            return true;\n        }\n        return this._private__leftPriceScale !== priceScale && this._private__rightPriceScale !== priceScale;\n    }\n    _internal_addDataSource(source, targetScaleId, keepSourcesOrder) {\n        this._private__insertDataSource(source, targetScaleId, keepSourcesOrder ? source._internal_zorder() : this._private__dataSources.length);\n    }\n    _internal_removeDataSource(source, keepSourceOrder) {\n        const index = this._private__dataSources.indexOf(source);\n        assert(index !== -1, 'removeDataSource: invalid data source');\n        this._private__dataSources.splice(index, 1);\n        if (!keepSourceOrder) {\n            this._private__dataSources.forEach((ds, i)=>ds._internal_setZorder(i));\n        }\n        const priceScaleId = ensureNotNull(source._internal_priceScale())._internal_id();\n        if (this._private__overlaySourcesByScaleId.has(priceScaleId)) {\n            const overlaySources = ensureDefined(this._private__overlaySourcesByScaleId.get(priceScaleId));\n            const overlayIndex = overlaySources.indexOf(source);\n            if (overlayIndex !== -1) {\n                overlaySources.splice(overlayIndex, 1);\n                if (overlaySources.length === 0) {\n                    this._private__overlaySourcesByScaleId.delete(priceScaleId);\n                }\n            }\n        }\n        const priceScale = source._internal_priceScale();\n        // if source has owner, it returns owner's price scale\n        // and it does not have source in their list\n        if (priceScale && priceScale._internal_dataSources().indexOf(source) >= 0) {\n            priceScale._internal_removeDataSource(source);\n            this._internal_recalculatePriceScale(priceScale);\n        }\n        this._private__cachedOrderedSources = null;\n    }\n    _internal_priceScalePosition(priceScale) {\n        if (priceScale === this._private__leftPriceScale) {\n            return 'left';\n        }\n        if (priceScale === this._private__rightPriceScale) {\n            return 'right';\n        }\n        return 'overlay';\n    }\n    _internal_leftPriceScale() {\n        return this._private__leftPriceScale;\n    }\n    _internal_rightPriceScale() {\n        return this._private__rightPriceScale;\n    }\n    _internal_startScalePrice(priceScale, x) {\n        priceScale._internal_startScale(x);\n    }\n    _internal_scalePriceTo(priceScale, x) {\n        priceScale._internal_scaleTo(x);\n        // TODO: be more smart and update only affected views\n        this._internal_updateAllSources();\n    }\n    _internal_endScalePrice(priceScale) {\n        priceScale._internal_endScale();\n    }\n    _internal_startScrollPrice(priceScale, x) {\n        priceScale._internal_startScroll(x);\n    }\n    _internal_scrollPriceTo(priceScale, x) {\n        priceScale._internal_scrollTo(x);\n        this._internal_updateAllSources();\n    }\n    _internal_endScrollPrice(priceScale) {\n        priceScale._internal_endScroll();\n    }\n    _internal_updateAllSources() {\n        this._private__dataSources.forEach((source)=>{\n            source._internal_updateAllViews();\n        });\n    }\n    _internal_defaultPriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible && this._private__rightPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__rightPriceScale;\n        } else if (this._private__model._internal_options().leftPriceScale.visible && this._private__leftPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__leftPriceScale;\n        } else if (this._private__dataSources.length !== 0) {\n            priceScale = this._private__dataSources[0]._internal_priceScale();\n        }\n        if (priceScale === null) {\n            priceScale = this._private__rightPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_defaultVisiblePriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible) {\n            priceScale = this._private__rightPriceScale;\n        } else if (this._private__model._internal_options().leftPriceScale.visible) {\n            priceScale = this._private__leftPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_recalculatePriceScale(priceScale) {\n        if (priceScale === null || !priceScale._internal_isAutoScale()) {\n            return;\n        }\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _internal_resetPriceScale(priceScale) {\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        priceScale._internal_setMode({\n            _internal_autoScale: true\n        });\n        if (visibleBars !== null) {\n            priceScale._internal_recalculatePriceRange(visibleBars);\n        }\n        this._internal_updateAllSources();\n    }\n    _internal_momentaryAutoScale() {\n        this._private__recalculatePriceScaleImpl(this._private__leftPriceScale);\n        this._private__recalculatePriceScaleImpl(this._private__rightPriceScale);\n    }\n    _internal_recalculate() {\n        this._internal_recalculatePriceScale(this._private__leftPriceScale);\n        this._internal_recalculatePriceScale(this._private__rightPriceScale);\n        this._private__dataSources.forEach((ds)=>{\n            if (this._internal_isOverlay(ds)) {\n                this._internal_recalculatePriceScale(ds._internal_priceScale());\n            }\n        });\n        this._internal_updateAllSources();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_orderedSources() {\n        if (this._private__cachedOrderedSources === null) {\n            this._private__cachedOrderedSources = sortSources(this._private__dataSources);\n        }\n        return this._private__cachedOrderedSources;\n    }\n    _internal_setSeriesOrder(series, order) {\n        order = clamp(order, 0, this._private__dataSources.length - 1);\n        const index = this._private__dataSources.indexOf(series);\n        assert(index !== -1, 'setSeriesOrder: invalid data source');\n        this._private__dataSources.splice(index, 1);\n        this._private__dataSources.splice(order, 0, series);\n        this._private__dataSources.forEach((ps, i)=>ps._internal_setZorder(i));\n        this._private__cachedOrderedSources = null;\n        for (const ps of [\n            this._private__leftPriceScale,\n            this._private__rightPriceScale\n        ]){\n            ps._internal_invalidateSourcesCache();\n            ps._internal_updateFormatter();\n        }\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_orderedSeries() {\n        return this._internal_orderedSources().filter(isSeries);\n    }\n    _internal_onDestroyed() {\n        return this._private__destroyed;\n    }\n    _internal_grid() {\n        return this._private__grid;\n    }\n    _internal_attachPrimitive(primitive) {\n        this._private__primitives.push(new PanePrimitiveWrapper$1(primitive));\n    }\n    _internal_detachPrimitive(source) {\n        this._private__primitives = this._private__primitives.filter((wrapper)=>wrapper._internal_primitive() !== source);\n        if (source.detached) {\n            source.detached();\n        }\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_primitives() {\n        return this._private__primitives;\n    }\n    _internal_primitiveHitTest(x, y) {\n        return this._private__primitives.map((primitive)=>primitive._internal_hitTest(x, y)).filter((result)=>result !== null);\n    }\n    _private__recalculatePriceScaleImpl(priceScale) {\n        // TODO: can use this checks\n        const sourceForAutoScale = priceScale._internal_sourcesForAutoScale();\n        if (sourceForAutoScale && sourceForAutoScale.length > 0 && !this._private__timeScale._internal_isEmpty()) {\n            const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n            if (visibleBars !== null) {\n                priceScale._internal_recalculatePriceRange(visibleBars);\n            }\n        }\n        priceScale._internal_updateAllViews();\n    }\n    _private__insertDataSource(source, priceScaleId, order) {\n        let priceScale = this._internal_priceScaleById(priceScaleId);\n        if (priceScale === null) {\n            priceScale = this._private__createPriceScale(priceScaleId, this._private__model._internal_options().overlayPriceScales);\n        }\n        this._private__dataSources.splice(order, 0, source);\n        if (!isDefaultPriceScale(priceScaleId)) {\n            const overlaySources = this._private__overlaySourcesByScaleId.get(priceScaleId) || [];\n            overlaySources.push(source);\n            this._private__overlaySourcesByScaleId.set(priceScaleId, overlaySources);\n        }\n        source._internal_setZorder(order);\n        priceScale._internal_addDataSource(source);\n        source._internal_setPriceScale(priceScale);\n        this._internal_recalculatePriceScale(priceScale);\n        this._private__cachedOrderedSources = null;\n    }\n    _private__onPriceScaleModeChanged(priceScale, oldMode, newMode) {\n        if (oldMode._internal_mode === newMode._internal_mode) {\n            return;\n        }\n        // momentary auto scale if we toggle percentage/indexedTo100 mode\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _private__createPriceScale(id, options) {\n        const actualOptions = {\n            visible: true,\n            autoScale: true,\n            ...clone(options)\n        };\n        const priceScale = new PriceScale(id, actualOptions, this._private__model._internal_options()['layout'], this._private__model._internal_options().localization, this._private__model._internal_colorParser());\n        priceScale._internal_setHeight(this._internal_height());\n        return priceScale;\n    }\n    constructor(timeScale, model){\n        this._private__dataSources = [];\n        this._private__overlaySourcesByScaleId = new Map();\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__stretchFactor = DEFAULT_STRETCH_FACTOR;\n        this._private__cachedOrderedSources = null;\n        this._private__destroyed = new Delegate();\n        this._private__primitives = [];\n        this._private__timeScale = timeScale;\n        this._private__model = model;\n        this._private__grid = new Grid(this);\n        const options = model._internal_options();\n        this._private__leftPriceScale = this._private__createPriceScale(\"left\" /* DefaultPriceScaleId.Left */ , options.leftPriceScale);\n        this._private__rightPriceScale = this._private__createPriceScale(\"right\" /* DefaultPriceScaleId.Right */ , options.rightPriceScale);\n        this._private__leftPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__leftPriceScale), this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__rightPriceScale), this);\n        this._internal_applyScaleOptions(options);\n    }\n}\n// returns true if item is above reference\nfunction comparePrimitiveZOrder(item, reference) {\n    return !reference || item === 'top' && reference !== 'top' || item === 'normal' && reference === 'bottom';\n}\nfunction findBestPrimitiveHitTest(sources, x, y) {\n    let bestPrimitiveHit;\n    let bestHitSource;\n    for (const source of sources){\n        var _source__internal_primitiveHitTest;\n        var _source__internal_primitiveHitTest1;\n        const primitiveHitResults = (_source__internal_primitiveHitTest1 = (_source__internal_primitiveHitTest = source._internal_primitiveHitTest) === null || _source__internal_primitiveHitTest === void 0 ? void 0 : _source__internal_primitiveHitTest.call(source, x, y)) !== null && _source__internal_primitiveHitTest1 !== void 0 ? _source__internal_primitiveHitTest1 : [];\n        for (const hitResult of primitiveHitResults){\n            if (comparePrimitiveZOrder(hitResult.zOrder, bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit.zOrder)) {\n                bestPrimitiveHit = hitResult;\n                bestHitSource = source;\n            }\n        }\n    }\n    if (!bestPrimitiveHit || !bestHitSource) {\n        return null;\n    }\n    return {\n        _internal_hit: bestPrimitiveHit,\n        _internal_source: bestHitSource\n    };\n}\nfunction convertPrimitiveHitResult(primitiveHit) {\n    return {\n        _internal_source: primitiveHit._internal_source,\n        _internal_object: {\n            _internal_externalId: primitiveHit._internal_hit.externalId\n        },\n        _internal_cursorStyle: primitiveHit._internal_hit.cursorStyle\n    };\n}\n/**\n * Performs a hit test on a collection of pane views to determine which view and object\n * is located at a given coordinate (x, y) and returns the matching pane view and\n * hit-tested result object, or null if no match is found.\n */ function hitTestPaneView(paneViews, x, y, pane) {\n    for (const paneView of paneViews){\n        const renderer = paneView._internal_renderer(pane);\n        if (renderer !== null && renderer._internal_hitTest) {\n            const result = renderer._internal_hitTest(x, y);\n            if (result !== null) {\n                return {\n                    _internal_view: paneView,\n                    _internal_object: result\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction isDataSource(source) {\n    return source._internal_paneViews !== undefined;\n}\n// eslint-disable-next-line complexity\nfunction hitTestPane(pane, x, y) {\n    const sources = [\n        pane,\n        ...pane._internal_orderedSources()\n    ];\n    const bestPrimitiveHit = findBestPrimitiveHitTest(sources, x, y);\n    if ((bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit._internal_hit.zOrder) === 'top') {\n        // a primitive hit on the 'top' layer will always beat the built-in hit tests\n        // (on normal layer) so we can return early here.\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    for (const source of sources){\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== 'bottom' && !bestPrimitiveHit._internal_hit.isBackground) {\n            // a primitive will be drawn above a built-in item like a series marker\n            // therefore it takes precedence here.\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n        if (isDataSource(source)) {\n            const sourceResult = hitTestPaneView(source._internal_paneViews(pane), x, y, pane);\n            if (sourceResult !== null) {\n                return {\n                    _internal_source: source,\n                    _internal_view: sourceResult._internal_view,\n                    _internal_object: sourceResult._internal_object\n                };\n            }\n        }\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== 'bottom' && bestPrimitiveHit._internal_hit.isBackground) {\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n    }\n    if (bestPrimitiveHit === null || bestPrimitiveHit === void 0 ? void 0 : bestPrimitiveHit._internal_hit) {\n        // return primitive hits for the 'bottom' layer\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    return null;\n}\nclass FormattedLabelsCache {\n    _internal_format(tickMark) {\n        const time = tickMark.time;\n        const cacheKey = this._private__horzScaleBehavior.cacheKey(time);\n        const tick = this._private__cache.get(cacheKey);\n        if (tick !== undefined) {\n            return tick._internal_string;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels.get(this._private__oldestTick);\n            this._private__tick2Labels.delete(this._private__oldestTick);\n            this._private__cache.delete(ensureDefined(oldestValue));\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        const str = this._private__format(tickMark);\n        this._private__cache.set(cacheKey, {\n            _internal_string: str,\n            _internal_tick: this._private__usageTick\n        });\n        this._private__tick2Labels.set(this._private__usageTick, cacheKey);\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return str;\n    }\n    constructor(format, horzScaleBehavior, size = 50){\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__cache = new Map();\n        this._private__tick2Labels = new Map();\n        this._private__format = format;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__maxSize = size;\n    }\n}\nclass RangeImpl {\n    _internal_left() {\n        return this._private__left;\n    }\n    _internal_right() {\n        return this._private__right;\n    }\n    _internal_count() {\n        return this._private__right - this._private__left + 1;\n    }\n    _internal_contains(index) {\n        return this._private__left <= index && index <= this._private__right;\n    }\n    _internal_equals(other) {\n        return this._private__left === other._internal_left() && this._private__right === other._internal_right();\n    }\n    constructor(left, right){\n        assert(left <= right, 'right should be >= left');\n        this._private__left = left;\n        this._private__right = right;\n    }\n}\nfunction areRangesEqual(first, second) {\n    if (first === null || second === null) {\n        return first === second;\n    }\n    return first._internal_equals(second);\n}\nclass TickMarks {\n    _internal_setUniformDistribution(val) {\n        this._private__uniformDistribution = val;\n        this._private__cache = null;\n    }\n    _internal_setTimeScalePoints(newPoints, firstChangedPointIndex) {\n        this._private__removeMarksSinceIndex(firstChangedPointIndex);\n        this._private__cache = null;\n        for(let index = firstChangedPointIndex; index < newPoints.length; ++index){\n            const point = newPoints[index];\n            let marksForWeight = this._private__marksByWeight.get(point.timeWeight);\n            if (marksForWeight === undefined) {\n                marksForWeight = [];\n                this._private__marksByWeight.set(point.timeWeight, marksForWeight);\n            }\n            marksForWeight.push({\n                index: index,\n                time: point.time,\n                weight: point.timeWeight,\n                originalTime: point.originalTime\n            });\n        }\n    }\n    _internal_build(spacing, maxWidth, checkIndicesForData, indicesWithDataMap, indicesWithDataId) {\n        const maxIndexesPerMark = Math.ceil(maxWidth / spacing);\n        if (this._private__cache === null || this._private__cache._internal_maxIndexesPerMark !== maxIndexesPerMark || indicesWithDataId !== this._private__cache._internal_indicesWithDataId || checkIndicesForData !== this._private__cache._internal_checkIndicesForData) {\n            this._private__cache = {\n                _internal_indicesWithDataId: indicesWithDataId,\n                _internal_checkIndicesForData: checkIndicesForData,\n                _internal_marks: this._private__buildMarksImpl(maxIndexesPerMark, checkIndicesForData, indicesWithDataMap),\n                _internal_maxIndexesPerMark: maxIndexesPerMark\n            };\n        }\n        return this._private__cache._internal_marks;\n    }\n    _private__removeMarksSinceIndex(sinceIndex) {\n        if (sinceIndex === 0) {\n            this._private__marksByWeight.clear();\n            return;\n        }\n        const weightsToClear = [];\n        this._private__marksByWeight.forEach((marks, timeWeight)=>{\n            if (sinceIndex <= marks[0].index) {\n                weightsToClear.push(timeWeight);\n            } else {\n                marks.splice(lowerBound(marks, sinceIndex, (tm)=>tm.index < sinceIndex), Infinity);\n            }\n        });\n        for (const weight of weightsToClear){\n            this._private__marksByWeight.delete(weight);\n        }\n    }\n    _private__buildMarksImpl(maxIndexesPerMark, checkIndicesForData, indicesWithDataMap) {\n        let marks = [];\n        const canBeIncluded = (mark)=>!checkIndicesForData || indicesWithDataMap.has(mark.index);\n        for (const weight of Array.from(this._private__marksByWeight.keys()).sort((a, b)=>b - a)){\n            if (!this._private__marksByWeight.get(weight)) {\n                continue;\n            }\n            // Built tickMarks are now prevMarks, and marks it as new array\n            const prevMarks = marks;\n            marks = [];\n            const prevMarksLength = prevMarks.length;\n            let prevMarksPointer = 0;\n            const currentWeight = ensureDefined(this._private__marksByWeight.get(weight));\n            const currentWeightLength = currentWeight.length;\n            let rightIndex = Infinity;\n            let leftIndex = -Infinity;\n            for(let i = 0; i < currentWeightLength; i++){\n                const mark = currentWeight[i];\n                const currentIndex = mark.index;\n                // Determine indexes with which current index will be compared\n                // All marks to the right is moved to new array\n                while(prevMarksPointer < prevMarksLength){\n                    const lastMark = prevMarks[prevMarksPointer];\n                    const lastIndex = lastMark.index;\n                    if (lastIndex < currentIndex && canBeIncluded(lastMark)) {\n                        prevMarksPointer++;\n                        marks.push(lastMark);\n                        leftIndex = lastIndex;\n                        rightIndex = Infinity;\n                    } else {\n                        rightIndex = lastIndex;\n                        break;\n                    }\n                }\n                if (rightIndex - currentIndex >= maxIndexesPerMark && currentIndex - leftIndex >= maxIndexesPerMark && canBeIncluded(mark)) {\n                    // TickMark fits. Place it into new array\n                    marks.push(mark);\n                    leftIndex = currentIndex;\n                } else {\n                    if (this._private__uniformDistribution) {\n                        return prevMarks;\n                    }\n                }\n            }\n            // Place all unused tickMarks into new array;\n            for(; prevMarksPointer < prevMarksLength; prevMarksPointer++){\n                if (canBeIncluded(prevMarks[prevMarksPointer])) {\n                    marks.push(prevMarks[prevMarksPointer]);\n                }\n            }\n        }\n        return marks;\n    }\n    constructor(){\n        this._private__marksByWeight = new Map();\n        this._private__cache = null;\n        this._private__uniformDistribution = false;\n    }\n}\nclass TimeScaleVisibleRange {\n    _internal_strictRange() {\n        if (this._private__logicalRange === null) {\n            return null;\n        }\n        return new RangeImpl(Math.floor(this._private__logicalRange._internal_left()), Math.ceil(this._private__logicalRange._internal_right()));\n    }\n    _internal_logicalRange() {\n        return this._private__logicalRange;\n    }\n    static _internal_invalid() {\n        return new TimeScaleVisibleRange(null);\n    }\n    constructor(logicalRange){\n        this._private__logicalRange = logicalRange;\n    }\n}\nconst defaultTickMarkMaxCharacterLength = 8;\nfunction markWithGreaterWeight$2(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nclass TimeScale {\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyLocalizationOptions(localizationOptions) {\n        merge(this._private__localizationOptions, localizationOptions);\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n    }\n    _internal_applyOptions(options, localizationOptions) {\n        merge(this._private__options, options);\n        if (this._private__options.fixLeftEdge) {\n            this._private__doFixLeftEdge();\n        }\n        if (this._private__options.fixRightEdge) {\n            this._private__doFixRightEdge();\n        }\n        // note that bar spacing should be applied before right offset\n        // because right offset depends on bar spacing\n        if (options.barSpacing !== undefined) {\n            this._private__model._internal_setBarSpacing(options.barSpacing);\n        }\n        if (options.rightOffset !== undefined) {\n            this._private__model._internal_setRightOffset(options.rightOffset);\n        }\n        if (options.minBarSpacing !== undefined || options.maxBarSpacing !== undefined) {\n            var _options_barSpacing;\n            // yes, if we apply bar spacing constrains then we need to correct bar spacing\n            // the easiest way is to apply it once again\n            this._private__model._internal_setBarSpacing((_options_barSpacing = options.barSpacing) !== null && _options_barSpacing !== void 0 ? _options_barSpacing : this._private__barSpacing);\n        }\n        if (options.ignoreWhitespaceIndices !== undefined && options.ignoreWhitespaceIndices !== this._private__options.ignoreWhitespaceIndices) {\n            this._internal_recalculateIndicesWithData();\n        }\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n        this._private__optionsApplied._internal_fire();\n    }\n    _internal_indexToTime(index) {\n        var _this__private__points_index;\n        var _this__private__points_index_time;\n        return (_this__private__points_index_time = (_this__private__points_index = this._private__points[index]) === null || _this__private__points_index === void 0 ? void 0 : _this__private__points_index.time) !== null && _this__private__points_index_time !== void 0 ? _this__private__points_index_time : null;\n    }\n    _internal_indexToTimeScalePoint(index) {\n        var _this__private__points_index;\n        return (_this__private__points_index = this._private__points[index]) !== null && _this__private__points_index !== void 0 ? _this__private__points_index : null;\n    }\n    _internal_timeToIndex(time, findNearest) {\n        if (this._private__points.length < 1) {\n            // no time points available\n            return null;\n        }\n        if (this._private__horzScaleBehavior.key(time) > this._private__horzScaleBehavior.key(this._private__points[this._private__points.length - 1].time)) {\n            // special case\n            return findNearest ? this._private__points.length - 1 : null;\n        }\n        const index = lowerBound(this._private__points, this._private__horzScaleBehavior.key(time), (a, b)=>this._private__horzScaleBehavior.key(a.time) < b);\n        if (this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(this._private__points[index].time)) {\n            return findNearest ? index : null;\n        }\n        return index;\n    }\n    _internal_isEmpty() {\n        return this._private__width === 0 || this._private__points.length === 0 || this._private__baseIndexOrNull === null;\n    }\n    _internal_hasPoints() {\n        return this._private__points.length > 0;\n    }\n    // strict range: integer indices of the bars in the visible range rounded in more wide direction\n    _internal_visibleStrictRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_strictRange();\n    }\n    _internal_visibleLogicalRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_logicalRange();\n    }\n    _internal_visibleTimeRange() {\n        const visibleBars = this._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const range = {\n            from: visibleBars._internal_left(),\n            to: visibleBars._internal_right()\n        };\n        return this._internal_timeRangeForLogicalRange(range);\n    }\n    _internal_timeRangeForLogicalRange(range) {\n        const from = Math.round(range.from);\n        const to = Math.round(range.to);\n        const firstIndex = ensureNotNull(this._private__firstIndex());\n        const lastIndex = ensureNotNull(this._private__lastIndex());\n        return {\n            from: ensureNotNull(this._internal_indexToTimeScalePoint(Math.max(firstIndex, from))),\n            to: ensureNotNull(this._internal_indexToTimeScalePoint(Math.min(lastIndex, to)))\n        };\n    }\n    _internal_logicalRangeForTimeRange(range) {\n        return {\n            from: ensureNotNull(this._internal_timeToIndex(range.from, true)),\n            to: ensureNotNull(this._internal_timeToIndex(range.to, true))\n        };\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_setWidth(newWidth) {\n        if (!isFinite(newWidth) || newWidth <= 0) {\n            return;\n        }\n        if (this._private__width === newWidth) {\n            return;\n        }\n        // when we change the width and we need to correct visible range because of fixing left edge\n        // we need to check the previous visible range rather than the new one\n        // because it might be updated by changing width, bar spacing, etc\n        // but we need to try to keep the same range\n        const previousVisibleRange = this._internal_visibleLogicalRange();\n        const oldWidth = this._private__width;\n        this._private__width = newWidth;\n        this._private__visibleRangeInvalidated = true;\n        if (this._private__options.lockVisibleTimeRangeOnResize && oldWidth !== 0) {\n            // recalculate bar spacing\n            const newBarSpacing = this._private__barSpacing * newWidth / oldWidth;\n            this._private__barSpacing = newBarSpacing;\n        }\n        // if time scale is scrolled to the end of data and we have fixed right edge\n        // keep left edge instead of right\n        // we need it to avoid \"shaking\" if the last bar visibility affects time scale width\n        if (this._private__options.fixLeftEdge) {\n            // note that logical left range means not the middle of a bar (it's the left border)\n            if (previousVisibleRange !== null && previousVisibleRange._internal_left() <= 0) {\n                const delta = oldWidth - newWidth;\n                // reduce  _rightOffset means move right\n                // we could move more than required - this will be fixed by _correctOffset()\n                this._private__rightOffset -= Math.round(delta / this._private__barSpacing) + 1;\n                this._private__visibleRangeInvalidated = true;\n            }\n        }\n        // updating bar spacing should be first because right offset depends on it\n        this._private__correctBarSpacing();\n        this._private__correctOffset();\n    }\n    _internal_indexToCoordinate(index) {\n        if (this._internal_isEmpty() || !isInteger(index)) {\n            return 0;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const deltaFromRight = baseIndex + this._private__rightOffset - index;\n        const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n        return coordinate;\n    }\n    _internal_indexesToCoordinates(points, visibleRange) {\n        const baseIndex = this._internal_baseIndex();\n        const indexFrom = visibleRange === undefined ? 0 : visibleRange.from;\n        const indexTo = visibleRange === undefined ? points.length : visibleRange.to;\n        for(let i = indexFrom; i < indexTo; i++){\n            const index = points[i]._internal_time;\n            const deltaFromRight = baseIndex + this._private__rightOffset - index;\n            const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n            points[i]._internal_x = coordinate;\n        }\n    }\n    _internal_coordinateToIndex(x, considerIgnoreWhitespace) {\n        const index = Math.ceil(this._private__coordinateToFloatIndex(x));\n        if (!considerIgnoreWhitespace || !this._private__options.ignoreWhitespaceIndices || this._private__shouldConsiderIndex(index)) {\n            return index;\n        }\n        return this._private__findNearestIndexWithData(index);\n    }\n    _internal_setRightOffset(offset) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__rightOffset = offset;\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_barSpacing() {\n        return this._private__barSpacing;\n    }\n    _internal_setBarSpacing(newBarSpacing) {\n        this._private__setBarSpacing(newBarSpacing);\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_rightOffset() {\n        return this._private__rightOffset;\n    }\n    // eslint-disable-next-line complexity\n    _internal_marks() {\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        if (this._private__timeMarksCache !== null) {\n            return this._private__timeMarksCache;\n        }\n        const spacing = this._private__barSpacing;\n        const fontSize = this._private__model._internal_options()['layout'].fontSize;\n        const pixelsPer8Characters = (fontSize + 4) * 5;\n        const pixelsPerCharacter = pixelsPer8Characters / defaultTickMarkMaxCharacterLength;\n        const maxLabelWidth = pixelsPerCharacter * (this._private__options.tickMarkMaxCharacterLength || defaultTickMarkMaxCharacterLength);\n        const indexPerLabel = Math.round(maxLabelWidth / spacing);\n        const visibleBars = ensureNotNull(this._internal_visibleStrictRange());\n        const firstBar = Math.max(visibleBars._internal_left(), visibleBars._internal_left() - indexPerLabel);\n        const lastBar = Math.max(visibleBars._internal_right(), visibleBars._internal_right() - indexPerLabel);\n        const items = this._private__tickMarks._internal_build(spacing, maxLabelWidth, this._private__options.ignoreWhitespaceIndices, this._private__indicesWithData, this._private__indicesWithDataUpdateId);\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second label on time scale\"\n        const earliestIndexOfSecondLabel = this._private__firstIndex() + indexPerLabel;\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second last label on time scale\"\n        const indexOfSecondLastLabel = this._private__lastIndex() - indexPerLabel;\n        const isAllScalingAndScrollingDisabled = this._private__isAllScalingAndScrollingDisabled();\n        const isLeftEdgeFixed = this._private__options.fixLeftEdge || isAllScalingAndScrollingDisabled;\n        const isRightEdgeFixed = this._private__options.fixRightEdge || isAllScalingAndScrollingDisabled;\n        let targetIndex = 0;\n        for (const tm of items){\n            if (!(firstBar <= tm.index && tm.index <= lastBar)) {\n                continue;\n            }\n            let label;\n            if (targetIndex < this._private__labels.length) {\n                label = this._private__labels[targetIndex];\n                label.coord = this._internal_indexToCoordinate(tm.index);\n                label.label = this._private__formatLabel(tm);\n                label.weight = tm.weight;\n            } else {\n                label = {\n                    needAlignCoordinate: false,\n                    coord: this._internal_indexToCoordinate(tm.index),\n                    label: this._private__formatLabel(tm),\n                    weight: tm.weight\n                };\n                this._private__labels.push(label);\n            }\n            if (this._private__barSpacing > maxLabelWidth / 2 && !isAllScalingAndScrollingDisabled) {\n                // if there is enough space then let's show all tick marks as usual\n                label.needAlignCoordinate = false;\n            } else {\n                // if a user is able to scroll after a tick mark then show it as usual, otherwise the coordinate might be aligned\n                // if the index is for the second (last) label or later (earlier) then most likely this label might be displayed without correcting the coordinate\n                label.needAlignCoordinate = isLeftEdgeFixed && tm.index <= earliestIndexOfSecondLabel || isRightEdgeFixed && tm.index >= indexOfSecondLastLabel;\n            }\n            targetIndex++;\n        }\n        this._private__labels.length = targetIndex;\n        this._private__timeMarksCache = this._private__labels;\n        return this._private__labels;\n    }\n    _internal_restoreDefault() {\n        this._private__visibleRangeInvalidated = true;\n        this._internal_setBarSpacing(this._private__options.barSpacing);\n        this._internal_setRightOffset(this._private__options.rightOffset);\n    }\n    _internal_setBaseIndex(baseIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__baseIndexOrNull = baseIndex;\n        this._private__correctOffset();\n        this._private__doFixLeftEdge();\n    }\n    /**\n     * Zoom in/out the scale around a `zoomPoint` on `scale` value.\n     *\n     * @param zoomPoint - X coordinate of the point to apply the zoom.\n     * If `rightBarStaysOnScroll` option is disabled, then will be used to restore right offset.\n     * @param scale - Zoom value (in 1/10 parts of current bar spacing).\n     * Negative value means zoom out, positive - zoom in.\n     */ _internal_zoom(zoomPoint, scale) {\n        const floatIndexAtZoomPoint = this._private__coordinateToFloatIndex(zoomPoint);\n        const barSpacing = this._internal_barSpacing();\n        const newBarSpacing = barSpacing + scale * (barSpacing / 10);\n        // zoom in/out bar spacing\n        this._internal_setBarSpacing(newBarSpacing);\n        if (!this._private__options.rightBarStaysOnScroll) {\n            // and then correct right offset to move index under zoomPoint back to its coordinate\n            this._internal_setRightOffset(this._internal_rightOffset() + (floatIndexAtZoomPoint - this._private__coordinateToFloatIndex(zoomPoint)));\n        }\n    }\n    _internal_startScale(x) {\n        if (this._private__scrollStartPoint) {\n            this._internal_endScroll();\n        }\n        if (this._private__scaleStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scaleStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scaleTo(x) {\n        if (this._private__commonTransitionStartState === null) {\n            return;\n        }\n        const startLengthFromRight = clamp(this._private__width - x, 0, this._private__width);\n        const currentLengthFromRight = clamp(this._private__width - ensureNotNull(this._private__scaleStartPoint), 0, this._private__width);\n        if (startLengthFromRight === 0 || currentLengthFromRight === 0) {\n            return;\n        }\n        this._internal_setBarSpacing(this._private__commonTransitionStartState._internal_barSpacing * startLengthFromRight / currentLengthFromRight);\n    }\n    _internal_endScale() {\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_startScroll(x) {\n        if (this._private__scrollStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scrollTo(x) {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const shiftInLogical = (this._private__scrollStartPoint - x) / this._internal_barSpacing();\n        this._private__rightOffset = ensureNotNull(this._private__commonTransitionStartState)._internal_rightOffset + shiftInLogical;\n        this._private__visibleRangeInvalidated = true;\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n    }\n    _internal_endScroll() {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_scrollToRealTime() {\n        this._internal_scrollToOffsetAnimated(this._private__options.rightOffset);\n    }\n    _internal_scrollToOffsetAnimated(offset) {\n        let animationDuration = arguments.length > 1 && arguments[1] !== void 0 /* Constants.DefaultAnimationDuration */  ? arguments[1] : 400;\n        if (!isFinite(offset)) {\n            throw new RangeError('offset is required and must be finite number');\n        }\n        if (!isFinite(animationDuration) || animationDuration <= 0) {\n            throw new RangeError('animationDuration (optional) must be finite positive number');\n        }\n        const source = this._private__rightOffset;\n        const animationStart = performance.now();\n        this._private__model._internal_setTimeScaleAnimation({\n            _internal_finished: (time)=>(time - animationStart) / animationDuration >= 1,\n            _internal_getPosition: (time)=>{\n                const animationProgress = (time - animationStart) / animationDuration;\n                const finishAnimation = animationProgress >= 1;\n                return finishAnimation ? offset : source + (offset - source) * animationProgress;\n            }\n        });\n    }\n    _internal_update(newPoints, firstChangedPointIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__points = newPoints;\n        this._private__tickMarks._internal_setTimeScalePoints(newPoints, firstChangedPointIndex);\n        this._private__correctOffset();\n    }\n    _internal_visibleBarsChanged() {\n        return this._private__visibleBarsChanged;\n    }\n    _internal_logicalRangeChanged() {\n        return this._private__logicalRangeChanged;\n    }\n    _internal_optionsApplied() {\n        return this._private__optionsApplied;\n    }\n    _internal_baseIndex() {\n        // null is used to known that baseIndex is not set yet\n        // so in methods which should known whether it is set or not\n        // we should check field `_baseIndexOrNull` instead of getter `baseIndex()`\n        // see minRightOffset for example\n        return this._private__baseIndexOrNull || 0;\n    }\n    _internal_setVisibleRange(range) {\n        const length = range._internal_count();\n        this._private__setBarSpacing(this._private__width / length);\n        this._private__rightOffset = range._internal_right() - this._internal_baseIndex();\n        this._private__correctOffset();\n        this._private__visibleRangeInvalidated = true;\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_fitContent() {\n        const first = this._private__firstIndex();\n        const last = this._private__lastIndex();\n        if (first === null || last === null) {\n            return;\n        }\n        this._internal_setVisibleRange(new RangeImpl(first, last + this._private__options.rightOffset));\n    }\n    _internal_setLogicalRange(range) {\n        const barRange = new RangeImpl(range.from, range.to);\n        this._internal_setVisibleRange(barRange);\n    }\n    _internal_formatDateTime(timeScalePoint) {\n        if (this._private__localizationOptions.timeFormatter !== undefined) {\n            return this._private__localizationOptions.timeFormatter(timeScalePoint.originalTime);\n        }\n        return this._private__horzScaleBehavior.formatHorzItem(timeScalePoint.time);\n    }\n    _internal_recalculateIndicesWithData() {\n        if (!this._private__options.ignoreWhitespaceIndices) {\n            return;\n        }\n        this._private__indicesWithData.clear();\n        const series = this._private__model._internal_serieses();\n        for (const s of series){\n            for (const index of s._internal_fulfilledIndices()){\n                this._private__indicesWithData.set(index, true);\n            }\n        }\n        this._private__indicesWithDataUpdateId++;\n    }\n    _private__isAllScalingAndScrollingDisabled() {\n        const handleScroll = this._private__model._internal_options()['handleScroll'];\n        const handleScale = this._private__model._internal_options()['handleScale'];\n        return !handleScroll.horzTouchDrag && !handleScroll.mouseWheel && !handleScroll.pressedMouseMove && !handleScroll.vertTouchDrag && !handleScale.axisDoubleClickReset.time && !handleScale.axisPressedMouseMove.time && !handleScale.mouseWheel && !handleScale.pinch;\n    }\n    _private__firstIndex() {\n        return this._private__points.length === 0 ? null : 0;\n    }\n    _private__lastIndex() {\n        return this._private__points.length === 0 ? null : this._private__points.length - 1;\n    }\n    _private__rightOffsetForCoordinate(x) {\n        return (this._private__width - 1 - x) / this._private__barSpacing;\n    }\n    _private__coordinateToFloatIndex(x) {\n        const deltaFromRight = this._private__rightOffsetForCoordinate(x);\n        const baseIndex = this._internal_baseIndex();\n        const index = baseIndex + this._private__rightOffset - deltaFromRight;\n        // JavaScript uses very strange rounding\n        // we need rounding to avoid problems with calculation errors\n        return Math.round(index * 1000000) / 1000000;\n    }\n    _private__setBarSpacing(newBarSpacing) {\n        const oldBarSpacing = this._private__barSpacing;\n        this._private__barSpacing = newBarSpacing;\n        this._private__correctBarSpacing();\n        // this._barSpacing might be changed in _correctBarSpacing\n        if (oldBarSpacing !== this._private__barSpacing) {\n            this._private__visibleRangeInvalidated = true;\n            this._private__resetTimeMarksCache();\n        }\n    }\n    _private__updateVisibleRange() {\n        if (!this._private__visibleRangeInvalidated) {\n            return;\n        }\n        this._private__visibleRangeInvalidated = false;\n        if (this._internal_isEmpty()) {\n            this._private__setVisibleRange(TimeScaleVisibleRange._internal_invalid());\n            return;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const newBarsLength = this._private__width / this._private__barSpacing;\n        const rightBorder = this._private__rightOffset + baseIndex;\n        const leftBorder = rightBorder - newBarsLength + 1;\n        const logicalRange = new RangeImpl(leftBorder, rightBorder);\n        this._private__setVisibleRange(new TimeScaleVisibleRange(logicalRange));\n    }\n    _private__correctBarSpacing() {\n        const barSpacing = clamp(this._private__barSpacing, this._private__minBarSpacing(), this._private__maxBarSpacing());\n        if (this._private__barSpacing !== barSpacing) {\n            this._private__barSpacing = barSpacing;\n            this._private__visibleRangeInvalidated = true;\n        }\n    }\n    _private__maxBarSpacing() {\n        if (this._private__options.maxBarSpacing > 0) {\n            // option takes precedance\n            return this._private__options.maxBarSpacing;\n        } else {\n            // half of the width is default value for maximum bar spacing\n            return this._private__width * 0.5;\n        }\n    }\n    _private__minBarSpacing() {\n        // if both options are enabled then limit bar spacing so that zooming-out is not possible\n        // if it would cause either the first or last points to move too far from an edge\n        if (this._private__options.fixLeftEdge && this._private__options.fixRightEdge && this._private__points.length !== 0) {\n            return this._private__width / this._private__points.length;\n        }\n        return this._private__options.minBarSpacing;\n    }\n    _private__correctOffset() {\n        // block scrolling of to past\n        const minRightOffset = this._private__minRightOffset();\n        if (minRightOffset !== null && this._private__rightOffset < minRightOffset) {\n            this._private__rightOffset = minRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n        // block scrolling of to future\n        const maxRightOffset = this._private__maxRightOffset();\n        if (this._private__rightOffset > maxRightOffset) {\n            this._private__rightOffset = maxRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n    }\n    _private__minRightOffset() {\n        const firstIndex = this._private__firstIndex();\n        const baseIndex = this._private__baseIndexOrNull;\n        if (firstIndex === null || baseIndex === null) {\n            return null;\n        }\n        const barsEstimation = this._private__options.fixLeftEdge ? this._private__width / this._private__barSpacing : Math.min(2 /* Constants.MinVisibleBarsCount */ , this._private__points.length);\n        return firstIndex - baseIndex - 1 + barsEstimation;\n    }\n    _private__maxRightOffset() {\n        return this._private__options.fixRightEdge ? 0 : this._private__width / this._private__barSpacing - Math.min(2 /* Constants.MinVisibleBarsCount */ , this._private__points.length);\n    }\n    _private__saveCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = {\n            _internal_barSpacing: this._internal_barSpacing(),\n            _internal_rightOffset: this._internal_rightOffset()\n        };\n    }\n    _private__clearCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = null;\n    }\n    _private__formatLabel(tickMark) {\n        let formatter = this._private__formattedByWeight.get(tickMark.weight);\n        if (formatter === undefined) {\n            formatter = new FormattedLabelsCache((mark)=>{\n                return this._private__formatLabelImpl(mark);\n            }, this._private__horzScaleBehavior);\n            this._private__formattedByWeight.set(tickMark.weight, formatter);\n        }\n        return formatter._internal_format(tickMark);\n    }\n    _private__formatLabelImpl(tickMark) {\n        return this._private__horzScaleBehavior.formatTickmark(tickMark, this._private__localizationOptions);\n    }\n    _private__setVisibleRange(newVisibleRange) {\n        const oldVisibleRange = this._private__visibleRange;\n        this._private__visibleRange = newVisibleRange;\n        if (!areRangesEqual(oldVisibleRange._internal_strictRange(), this._private__visibleRange._internal_strictRange())) {\n            this._private__visibleBarsChanged._internal_fire();\n        }\n        if (!areRangesEqual(oldVisibleRange._internal_logicalRange(), this._private__visibleRange._internal_logicalRange())) {\n            this._private__logicalRangeChanged._internal_fire();\n        }\n        // TODO: reset only coords in case when this._visibleBars has not been changed\n        this._private__resetTimeMarksCache();\n    }\n    _private__resetTimeMarksCache() {\n        this._private__timeMarksCache = null;\n    }\n    _private__invalidateTickMarks() {\n        this._private__resetTimeMarksCache();\n        this._private__formattedByWeight.clear();\n    }\n    _private__updateDateTimeFormatter() {\n        this._private__horzScaleBehavior.updateFormatter(this._private__localizationOptions);\n    }\n    _private__doFixLeftEdge() {\n        if (!this._private__options.fixLeftEdge) {\n            return;\n        }\n        const firstIndex = this._private__firstIndex();\n        if (firstIndex === null) {\n            return;\n        }\n        const visibleRange = this._internal_visibleStrictRange();\n        if (visibleRange === null) {\n            return;\n        }\n        const delta = visibleRange._internal_left() - firstIndex;\n        if (delta < 0) {\n            const leftEdgeOffset = this._private__rightOffset - delta - 1;\n            this._internal_setRightOffset(leftEdgeOffset);\n        }\n        this._private__correctBarSpacing();\n    }\n    _private__doFixRightEdge() {\n        this._private__correctOffset();\n        this._private__correctBarSpacing();\n    }\n    _private__shouldConsiderIndex(index) {\n        if (!this._private__options.ignoreWhitespaceIndices) {\n            return true;\n        }\n        return this._private__indicesWithData.get(index) || false;\n    }\n    _private__findNearestIndexWithData(x) {\n        const gen = testNearestIntegers(x);\n        const maxIndex = this._private__lastIndex();\n        while(maxIndex){\n            const index = gen.next().value;\n            if (this._private__indicesWithData.get(index)) {\n                return index;\n            }\n            if (index < 0 || index > maxIndex) {\n                break;\n            }\n        }\n        return x; // fallback to original index\n    }\n    constructor(model, options, localizationOptions, horzScaleBehavior){\n        this._private__width = 0;\n        this._private__baseIndexOrNull = null;\n        this._private__points = [];\n        this._private__scrollStartPoint = null;\n        this._private__scaleStartPoint = null;\n        this._private__tickMarks = new TickMarks();\n        this._private__formattedByWeight = new Map();\n        this._private__visibleRange = TimeScaleVisibleRange._internal_invalid();\n        this._private__visibleRangeInvalidated = true;\n        this._private__visibleBarsChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__optionsApplied = new Delegate();\n        this._private__commonTransitionStartState = null;\n        this._private__timeMarksCache = null;\n        this._private__indicesWithData = new Map();\n        this._private__indicesWithDataUpdateId = -1;\n        this._private__labels = [];\n        this._private__options = options;\n        this._private__localizationOptions = localizationOptions;\n        this._private__rightOffset = options.rightOffset;\n        this._private__barSpacing = options.barSpacing;\n        this._private__model = model;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__updateDateTimeFormatter();\n        this._private__tickMarks._internal_setUniformDistribution(options.uniformDistribution);\n        this._internal_recalculateIndicesWithData();\n    }\n}\nfunction* testNearestIntegers(num) {\n    const rounded = Math.round(num);\n    const isRoundedDown = rounded < num;\n    let offset = 1;\n    while(true){\n        if (isRoundedDown) {\n            yield rounded + offset;\n            yield rounded - offset;\n        } else {\n            yield rounded - offset;\n            yield rounded + offset;\n        }\n        offset++;\n    }\n}\n/// <reference types=\"_build-time-constants\" />\n/**\n * Determine how to exit the tracking mode.\n *\n * By default, mobile users will long press to deactivate the scroll and have the ability to check values and dates.\n * Another press is required to activate the scroll, be able to move left/right, zoom, etc.\n */ var TrackingModeExitMode;\n(function(TrackingModeExitMode) {\n    /**\n     * Tracking Mode will be deactivated on touch end event.\n     */ TrackingModeExitMode[TrackingModeExitMode[\"OnTouchEnd\"] = 0] = \"OnTouchEnd\";\n    /**\n     * Tracking Mode will be deactivated on the next tap event.\n     */ TrackingModeExitMode[TrackingModeExitMode[\"OnNextTap\"] = 1] = \"OnNextTap\";\n})(TrackingModeExitMode || (TrackingModeExitMode = {}));\nfunction isPanePrimitive(source) {\n    return source instanceof Pane;\n}\nclass ChartModel {\n    _internal_fullUpdate() {\n        this._private__invalidate(InvalidateMask._internal_full());\n    }\n    _internal_lightUpdate() {\n        this._private__invalidate(InvalidateMask._internal_light());\n    }\n    _internal_cursorUpdate() {\n        this._private__invalidate(new InvalidateMask(1 /* InvalidationLevel.Cursor */ ));\n    }\n    _internal_updateSource(source) {\n        const inv = this._private__invalidationMaskForSource(source);\n        this._private__invalidate(inv);\n    }\n    _internal_hoveredSource() {\n        return this._private__hoveredSource;\n    }\n    _internal_setHoveredSource(source) {\n        var _this__private__hoveredSource, _this__private__hoveredSource__internal_object, _this__private__hoveredSource1, _source__internal_object;\n        if (((_this__private__hoveredSource = this._private__hoveredSource) === null || _this__private__hoveredSource === void 0 ? void 0 : _this__private__hoveredSource._internal_source) === (source === null || source === void 0 ? void 0 : source._internal_source) && ((_this__private__hoveredSource1 = this._private__hoveredSource) === null || _this__private__hoveredSource1 === void 0 ? void 0 : (_this__private__hoveredSource__internal_object = _this__private__hoveredSource1._internal_object) === null || _this__private__hoveredSource__internal_object === void 0 ? void 0 : _this__private__hoveredSource__internal_object._internal_externalId) === (source === null || source === void 0 ? void 0 : (_source__internal_object = source._internal_object) === null || _source__internal_object === void 0 ? void 0 : _source__internal_object._internal_externalId)) {\n            return;\n        }\n        const prevSource = this._private__hoveredSource;\n        this._private__hoveredSource = source;\n        if (prevSource !== null) {\n            this._internal_updateSource(prevSource._internal_source);\n        }\n        // additional check to prevent unnecessary updates of same source\n        if (source !== null && source._internal_source !== (prevSource === null || prevSource === void 0 ? void 0 : prevSource._internal_source)) {\n            this._internal_updateSource(source._internal_source);\n        }\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._private__panes.forEach((p)=>p._internal_applyScaleOptions(options));\n        if (options.timeScale !== undefined) {\n            this._private__timeScale._internal_applyOptions(options.timeScale);\n        }\n        if (options.localization !== undefined) {\n            this._private__timeScale._internal_applyLocalizationOptions(options.localization);\n        }\n        if (options.leftPriceScale || options.rightPriceScale) {\n            this._private__priceScalesOptionsChanged._internal_fire();\n        }\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */ );\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */ );\n        this._internal_fullUpdate();\n    }\n    _internal_applyPriceScaleOptions(priceScaleId, options) {\n        let paneIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const pane = this._private__panes[paneIndex];\n        if (pane === undefined) {\n            {\n                throw new Error(\"Trying to apply price scale options with incorrect pane index: \".concat(paneIndex));\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (priceScaleId === \"left\" /* DefaultPriceScaleId.Left */ ) {\n            merge(this._private__options, {\n                leftPriceScale: options\n            });\n            pane._internal_applyScaleOptions({\n                leftPriceScale: options\n            });\n            this._private__priceScalesOptionsChanged._internal_fire();\n            this._internal_fullUpdate();\n            return;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        } else if (priceScaleId === \"right\" /* DefaultPriceScaleId.Right */ ) {\n            merge(this._private__options, {\n                rightPriceScale: options\n            });\n            pane._internal_applyScaleOptions({\n                rightPriceScale: options\n            });\n            this._private__priceScalesOptionsChanged._internal_fire();\n            this._internal_fullUpdate();\n            return;\n        }\n        const res = this._internal_findPriceScale(priceScaleId, paneIndex);\n        if (res === null) {\n            {\n                throw new Error(\"Trying to apply price scale options with incorrect ID: \".concat(priceScaleId));\n            }\n        }\n        res._internal_priceScale._internal_applyOptions(options);\n        this._private__priceScalesOptionsChanged._internal_fire();\n    }\n    _internal_findPriceScale(priceScaleId, paneIndex) {\n        const pane = this._private__panes[paneIndex];\n        if (pane === undefined) {\n            return null;\n        }\n        const priceScale = pane._internal_priceScaleById(priceScaleId);\n        if (priceScale !== null) {\n            return {\n                _internal_pane: pane,\n                _internal_priceScale: priceScale\n            };\n        }\n        return null;\n    }\n    _internal_timeScale() {\n        return this._private__timeScale;\n    }\n    _internal_panes() {\n        return this._private__panes;\n    }\n    _internal_crosshairSource() {\n        return this._private__crosshair;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_setPaneHeight(pane, height) {\n        pane._internal_setHeight(height);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._private__timeScale._internal_setWidth(this._private__width);\n        this._private__panes.forEach((pane)=>pane._internal_setWidth(width));\n        this._internal_recalculateAllPanes();\n    }\n    _internal_removePane(index) {\n        if (this._private__panes.length === 1) {\n            return;\n        }\n        assert(index >= 0 && index < this._private__panes.length, 'Invalid pane index');\n        this._private__panes.splice(index, 1);\n        this._internal_fullUpdate();\n    }\n    _internal_changePanesHeight(paneIndex, height) {\n        if (this._private__panes.length < 2) {\n            return;\n        }\n        assert(paneIndex >= 0 && paneIndex < this._private__panes.length, 'Invalid pane index');\n        const targetPane = this._private__panes[paneIndex];\n        const totalStretch = this._private__panes.reduce((prevValue, pane)=>prevValue + pane._internal_stretchFactor(), 0);\n        const totalHeight = this._private__panes.reduce((prevValue, pane)=>prevValue + pane._internal_height(), 0);\n        const maxPaneHeight = totalHeight - MIN_PANE_HEIGHT * (this._private__panes.length - 1);\n        height = Math.min(maxPaneHeight, Math.max(MIN_PANE_HEIGHT, height));\n        const pixelStretchFactor = totalStretch / totalHeight;\n        const oldHeight = targetPane._internal_height();\n        targetPane._internal_setStretchFactor(height * pixelStretchFactor);\n        let otherPanesChange = height - oldHeight;\n        let panesCount = this._private__panes.length - 1;\n        for (const pane of this._private__panes){\n            if (pane !== targetPane) {\n                const newPaneHeight = Math.min(maxPaneHeight, Math.max(30, pane._internal_height() - otherPanesChange / panesCount));\n                otherPanesChange -= pane._internal_height() - newPaneHeight;\n                panesCount -= 1;\n                const newStretchFactor = newPaneHeight * pixelStretchFactor;\n                pane._internal_setStretchFactor(newStretchFactor);\n            }\n        }\n        this._internal_fullUpdate();\n    }\n    _internal_swapPanes(first, second) {\n        assert(first >= 0 && first < this._private__panes.length && second >= 0 && second < this._private__panes.length, 'Invalid pane index');\n        const firstPane = this._private__panes[first];\n        const secondPane = this._private__panes[second];\n        this._private__panes[first] = secondPane;\n        this._private__panes[second] = firstPane;\n        this._internal_fullUpdate();\n    }\n    _internal_startScalePrice(pane, priceScale, x) {\n        pane._internal_startScalePrice(priceScale, x);\n    }\n    _internal_scalePriceTo(pane, priceScale, x) {\n        pane._internal_scalePriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_endScalePrice(pane, priceScale) {\n        pane._internal_endScalePrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_startScrollPrice(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_startScrollPrice(priceScale, x);\n    }\n    _internal_scrollPriceTo(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_scrollPriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_endScrollPrice(pane, priceScale) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_endScrollPrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_resetPriceScale(pane, priceScale) {\n        pane._internal_resetPriceScale(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */ ));\n    }\n    _internal_startScaleTime(position) {\n        this._private__timeScale._internal_startScale(position);\n    }\n    /**\n     * Zoom in/out the chart (depends on scale value).\n     *\n     * @param pointX - X coordinate of the point to apply the zoom (the point which should stay on its place)\n     * @param scale - Zoom value. Negative value means zoom out, positive - zoom in.\n     */ _internal_zoomTime(pointX, scale) {\n        const timeScale = this._internal_timeScale();\n        if (timeScale._internal_isEmpty() || scale === 0) {\n            return;\n        }\n        const timeScaleWidth = timeScale._internal_width();\n        pointX = Math.max(1, Math.min(pointX, timeScaleWidth));\n        timeScale._internal_zoom(pointX, scale);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_scrollChart(x) {\n        this._internal_startScrollTime(0);\n        this._internal_scrollTimeTo(x);\n        this._internal_endScrollTime();\n    }\n    _internal_scaleTimeTo(x) {\n        this._private__timeScale._internal_scaleTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScaleTime() {\n        this._private__timeScale._internal_endScale();\n        this._internal_lightUpdate();\n    }\n    _internal_startScrollTime(x) {\n        this._private__timeScale._internal_startScroll(x);\n    }\n    _internal_scrollTimeTo(x) {\n        this._private__timeScale._internal_scrollTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScrollTime() {\n        this._private__timeScale._internal_endScroll();\n        this._internal_lightUpdate();\n    }\n    _internal_serieses() {\n        return this._private__serieses;\n    }\n    _internal_setAndSaveCurrentPosition(x, y, event, pane, skipEvent) {\n        this._private__crosshair._internal_saveOriginCoord(x, y);\n        let price = NaN;\n        let index = this._private__timeScale._internal_coordinateToIndex(x, true);\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        if (visibleBars !== null) {\n            index = Math.min(Math.max(visibleBars._internal_left(), index), visibleBars._internal_right());\n        }\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue !== null) {\n            price = priceScale._internal_coordinateToPrice(y, firstValue);\n        }\n        price = this._private__magnet._internal_align(price, index, pane);\n        this._private__crosshair._internal_setPosition(index, price, pane);\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            const hitTest = hitTestPane(pane, x, y);\n            this._internal_setHoveredSource(hitTest && {\n                _internal_source: hitTest._internal_source,\n                _internal_object: hitTest._internal_object,\n                _internal_cursorStyle: hitTest._internal_cursorStyle || null\n            });\n            this._private__crosshairMoved._internal_fire(this._private__crosshair._internal_appliedIndex(), {\n                x,\n                y\n            }, event);\n        }\n    }\n    // A position provided external (not from an internal event listener)\n    _internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane) {\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        const y = priceScale._internal_priceToCoordinate(price, ensureNotNull(firstValue));\n        const index = this._private__timeScale._internal_timeToIndex(horizontalPosition, true);\n        const x = this._private__timeScale._internal_indexToCoordinate(ensureNotNull(index));\n        this._internal_setAndSaveCurrentPosition(x, y, null, pane, true);\n    }\n    _internal_clearCurrentPosition(skipEvent) {\n        const crosshair = this._internal_crosshairSource();\n        crosshair._internal_clearPosition();\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            this._private__crosshairMoved._internal_fire(null, null, null);\n        }\n    }\n    _internal_updateCrosshair() {\n        // apply magnet\n        const pane = this._private__crosshair._internal_pane();\n        if (pane !== null) {\n            const x = this._private__crosshair._internal_originCoordX();\n            const y = this._private__crosshair._internal_originCoordY();\n            this._internal_setAndSaveCurrentPosition(x, y, null, pane);\n        }\n        this._private__crosshair._internal_updateAllViews();\n    }\n    _internal_updateTimeScale(newBaseIndex, newPoints, firstChangedPointIndex) {\n        const oldFirstTime = this._private__timeScale._internal_indexToTime(0);\n        if (newPoints !== undefined && firstChangedPointIndex !== undefined) {\n            this._private__timeScale._internal_update(newPoints, firstChangedPointIndex);\n        }\n        const newFirstTime = this._private__timeScale._internal_indexToTime(0);\n        const currentBaseIndex = this._private__timeScale._internal_baseIndex();\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        // if time scale cannot return current visible bars range (e.g. time scale has zero-width)\n        // then we do not need to update right offset to shift visible bars range to have the same right offset as we have before new bar\n        // (and actually we cannot)\n        if (visibleBars !== null && oldFirstTime !== null && newFirstTime !== null) {\n            const isLastSeriesBarVisible = visibleBars._internal_contains(currentBaseIndex);\n            const isLeftBarShiftToLeft = this._private__horzScaleBehavior.key(oldFirstTime) > this._private__horzScaleBehavior.key(newFirstTime);\n            const isSeriesPointsAdded = newBaseIndex !== null && newBaseIndex > currentBaseIndex;\n            const isSeriesPointsAddedToRight = isSeriesPointsAdded && !isLeftBarShiftToLeft;\n            const allowShiftWhenReplacingWhitespace = this._private__timeScale._internal_options().allowShiftVisibleRangeOnWhitespaceReplacement;\n            const replacedExistingWhitespace = firstChangedPointIndex === undefined;\n            const needShiftVisibleRangeOnNewBar = isLastSeriesBarVisible && (!replacedExistingWhitespace || allowShiftWhenReplacingWhitespace) && this._private__timeScale._internal_options().shiftVisibleRangeOnNewBar;\n            if (isSeriesPointsAddedToRight && !needShiftVisibleRangeOnNewBar) {\n                const compensationShift = newBaseIndex - currentBaseIndex;\n                this._private__timeScale._internal_setRightOffset(this._private__timeScale._internal_rightOffset() - compensationShift);\n            }\n        }\n        this._private__timeScale._internal_setBaseIndex(newBaseIndex);\n    }\n    _internal_recalculatePane(pane) {\n        if (pane !== null) {\n            pane._internal_recalculate();\n        }\n    }\n    _internal_paneForSource(source) {\n        if (isPanePrimitive(source)) {\n            return source;\n        }\n        const pane = this._private__panes.find((p)=>p._internal_orderedSources().includes(source));\n        return pane === undefined ? null : pane;\n    }\n    _internal_recalculateAllPanes() {\n        this._private__panes.forEach((p)=>p._internal_recalculate());\n        this._internal_updateCrosshair();\n    }\n    _internal_destroy() {\n        this._private__panes.forEach((p)=>p._internal_destroy());\n        this._private__panes.length = 0;\n        // to avoid memleaks\n        this._private__options.localization.priceFormatter = undefined;\n        this._private__options.localization.percentageFormatter = undefined;\n        this._private__options.localization.timeFormatter = undefined;\n    }\n    _internal_rendererOptionsProvider() {\n        return this._private__rendererOptionsProvider;\n    }\n    _internal_priceAxisRendererOptions() {\n        return this._private__rendererOptionsProvider._internal_options();\n    }\n    _internal_priceScalesOptionsChanged() {\n        return this._private__priceScalesOptionsChanged;\n    }\n    _internal_addSeriesToPane(series, paneIndex) {\n        const pane = this._private__getOrCreatePane(paneIndex);\n        this._private__addSeriesToPane(series, pane);\n        this._private__serieses.push(series);\n        if (this._private__serieses.length === 1) {\n            // call fullUpdate to recalculate chart's parts geometry\n            this._internal_fullUpdate();\n        } else {\n            this._internal_lightUpdate();\n        }\n    }\n    _internal_removeSeries(series) {\n        const pane = this._internal_paneForSource(series);\n        const seriesIndex = this._private__serieses.indexOf(series);\n        assert(seriesIndex !== -1, 'Series not found');\n        const paneImpl = ensureNotNull(pane);\n        this._private__serieses.splice(seriesIndex, 1);\n        paneImpl._internal_removeDataSource(series);\n        if (series._internal_destroy) {\n            series._internal_destroy();\n        }\n        this._private__timeScale._internal_recalculateIndicesWithData();\n        this._private__cleanupIfPaneIsEmpty(paneImpl);\n    }\n    _internal_moveSeriesToScale(series, targetScaleId) {\n        const pane = ensureNotNull(this._internal_paneForSource(series));\n        pane._internal_removeDataSource(series, true);\n        pane._internal_addDataSource(series, targetScaleId, true);\n    }\n    _internal_fitContent() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setFitContent();\n        this._private__invalidate(mask);\n    }\n    _internal_setTargetLogicalRange(range) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_applyRange(range);\n        this._private__invalidate(mask);\n    }\n    _internal_resetTimeScale() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_resetTimeScale();\n        this._private__invalidate(mask);\n    }\n    _internal_setBarSpacing(spacing) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setBarSpacing(spacing);\n        this._private__invalidate(mask);\n    }\n    _internal_setRightOffset(offset) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setRightOffset(offset);\n        this._private__invalidate(mask);\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setTimeScaleAnimation(animation);\n        this._private__invalidate(mask);\n    }\n    _internal_stopTimeScaleAnimation() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_stopTimeScaleAnimation();\n        this._private__invalidate(mask);\n    }\n    _internal_defaultVisiblePriceScaleId() {\n        return this._private__options.rightPriceScale.visible ? \"right\" /* DefaultPriceScaleId.Right */  : \"left\" /* DefaultPriceScaleId.Left */ ;\n    }\n    _internal_moveSeriesToPane(series, newPaneIndex) {\n        assert(newPaneIndex >= 0, 'Index should be greater or equal to 0');\n        const fromPaneIndex = this._private__seriesPaneIndex(series);\n        if (newPaneIndex === fromPaneIndex) {\n            return;\n        }\n        const previousPane = ensureNotNull(this._internal_paneForSource(series));\n        previousPane._internal_removeDataSource(series);\n        const newPane = this._private__getOrCreatePane(newPaneIndex);\n        this._private__addSeriesToPane(series, newPane);\n        if (previousPane._internal_dataSources().length === 0) {\n            this._private__cleanupIfPaneIsEmpty(previousPane);\n        }\n    }\n    _internal_backgroundBottomColor() {\n        return this._private__backgroundBottomColor;\n    }\n    _internal_backgroundTopColor() {\n        return this._private__backgroundTopColor;\n    }\n    _internal_backgroundColorAtYPercentFromTop(percent) {\n        const bottomColor = this._private__backgroundBottomColor;\n        const topColor = this._private__backgroundTopColor;\n        if (bottomColor === topColor) {\n            // solid background\n            return bottomColor;\n        }\n        // gradient background\n        // percent should be from 0 to 100 (we're using only integer values to make cache more efficient)\n        percent = Math.max(0, Math.min(100, Math.round(percent * 100)));\n        if (this._private__gradientColorsCache === null || this._private__gradientColorsCache._internal_topColor !== topColor || this._private__gradientColorsCache._internal_bottomColor !== bottomColor) {\n            this._private__gradientColorsCache = {\n                _internal_topColor: topColor,\n                _internal_bottomColor: bottomColor,\n                _internal_colors: new Map()\n            };\n        } else {\n            const cachedValue = this._private__gradientColorsCache._internal_colors.get(percent);\n            if (cachedValue !== undefined) {\n                return cachedValue;\n            }\n        }\n        const result = this._private__colorParser._internal_gradientColorAtPercent(topColor, bottomColor, percent / 100);\n        this._private__gradientColorsCache._internal_colors.set(percent, result);\n        return result;\n    }\n    _internal_getPaneIndex(pane) {\n        return this._private__panes.indexOf(pane);\n    }\n    _internal_colorParser() {\n        return this._private__colorParser;\n    }\n    _private__getOrCreatePane(index) {\n        assert(index >= 0, 'Index should be greater or equal to 0');\n        index = Math.min(this._private__panes.length, index);\n        if (index < this._private__panes.length) {\n            return this._private__panes[index];\n        }\n        const pane = new Pane(this._private__timeScale, this);\n        this._private__panes.push(pane);\n        // we always do autoscaling on the creation\n        // if autoscale option is true, it is ok, just recalculate by invalidation mask\n        // if autoscale option is false, autoscale anyway on the first draw\n        // also there is a scenario when autoscale is true in constructor and false later on applyOptions\n        const mask = InvalidateMask._internal_full();\n        mask._internal_invalidatePane(index, {\n            _internal_level: 0 /* InvalidationLevel.None */ ,\n            _internal_autoScale: true\n        });\n        this._private__invalidate(mask);\n        return pane;\n    }\n    _private__seriesPaneIndex(series) {\n        return this._private__panes.findIndex((pane)=>pane._internal_series().includes(series));\n    }\n    _private__paneInvalidationMask(pane, level) {\n        const inv = new InvalidateMask(level);\n        if (pane !== null) {\n            const index = this._private__panes.indexOf(pane);\n            inv._internal_invalidatePane(index, {\n                _internal_level: level\n            });\n        }\n        return inv;\n    }\n    _private__invalidationMaskForSource(source, invalidateType) {\n        if (invalidateType === undefined) {\n            invalidateType = 2 /* InvalidationLevel.Light */ ;\n        }\n        return this._private__paneInvalidationMask(this._internal_paneForSource(source), invalidateType);\n    }\n    _private__invalidate(mask) {\n        if (this._private__invalidateHandler) {\n            this._private__invalidateHandler(mask);\n        }\n        this._private__panes.forEach((pane)=>pane._internal_grid()._internal_paneView()._internal_update());\n    }\n    _private__addSeriesToPane(series, pane) {\n        const priceScaleId = series._internal_options().priceScaleId;\n        const targetScaleId = priceScaleId !== undefined ? priceScaleId : this._internal_defaultVisiblePriceScaleId();\n        pane._internal_addDataSource(series, targetScaleId);\n        if (!isDefaultPriceScale(targetScaleId)) {\n            // let's apply that options again to apply margins\n            series._internal_applyOptions(series._internal_options());\n        }\n    }\n    _private__getBackgroundColor(side) {\n        const layoutOptions = this._private__options['layout'];\n        if (layoutOptions.background.type === \"gradient\" /* ColorType.VerticalGradient */ ) {\n            return side === 0 /* BackgroundColorSide.Top */  ? layoutOptions.background.topColor : layoutOptions.background.bottomColor;\n        }\n        return layoutOptions.background.color;\n    }\n    _private__cleanupIfPaneIsEmpty(pane) {\n        if (pane._internal_dataSources().length === 0 && this._private__panes.length > 1) {\n            this._private__panes.splice(this._internal_getPaneIndex(pane), 1);\n            this._internal_fullUpdate();\n        }\n    }\n    constructor(invalidateHandler, options, horzScaleBehavior){\n        this._private__panes = [];\n        this._private__serieses = [];\n        this._private__width = 0;\n        this._private__hoveredSource = null;\n        this._private__priceScalesOptionsChanged = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__gradientColorsCache = null;\n        this._private__invalidateHandler = invalidateHandler;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__colorParser = new ColorParser(this._private__options.layout.colorParsers);\n        this._private__rendererOptionsProvider = new PriceAxisRendererOptionsProvider(this);\n        this._private__timeScale = new TimeScale(this, options.timeScale, this._private__options.localization, horzScaleBehavior);\n        this._private__crosshair = new Crosshair(this, options.crosshair);\n        this._private__magnet = new Magnet(options.crosshair);\n        this._private__getOrCreatePane(0);\n        this._private__panes[0]._internal_setStretchFactor(DEFAULT_STRETCH_FACTOR * 2);\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */ );\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */ );\n    }\n}\nfunction fillUpDownCandlesticksColors(options) {\n    if (options.borderColor !== undefined) {\n        options.borderUpColor = options.borderColor;\n        options.borderDownColor = options.borderColor;\n    }\n    if (options.wickColor !== undefined) {\n        options.wickUpColor = options.wickColor;\n        options.wickDownColor = options.wickColor;\n    }\n}\n/**\n * Represents the type of the last price animation for series such as area or line.\n */ var LastPriceAnimationMode;\n(function(LastPriceAnimationMode) {\n    /**\n     * Animation is always disabled\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n     * Animation is always enabled.\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"Continuous\"] = 1] = \"Continuous\";\n    /**\n     * Animation is active after new data.\n     */ LastPriceAnimationMode[LastPriceAnimationMode[\"OnDataUpdate\"] = 2] = \"OnDataUpdate\";\n})(LastPriceAnimationMode || (LastPriceAnimationMode = {}));\nfunction precisionByMinMove(minMove) {\n    if (minMove >= 1) {\n        return 0;\n    }\n    let i = 0;\n    for(; i < 8; i++){\n        const intPart = Math.round(minMove);\n        const fractPart = Math.abs(intPart - minMove);\n        if (fractPart < 1e-8) {\n            return i;\n        }\n        minMove = minMove * 10;\n    }\n    return i;\n}\n/**\n * Represents the source of data to be used for the horizontal price line.\n */ var PriceLineSource;\n(function(PriceLineSource) {\n    /**\n     * Use the last bar data.\n     */ PriceLineSource[PriceLineSource[\"LastBar\"] = 0] = \"LastBar\";\n    /**\n     * Use the last visible data of the chart viewport.\n     */ PriceLineSource[PriceLineSource[\"LastVisible\"] = 1] = \"LastVisible\";\n})(PriceLineSource || (PriceLineSource = {}));\n/**\n * Represents a type of color.\n */ var ColorType;\n(function(ColorType) {\n    /** Solid color */ ColorType[\"Solid\"] = \"solid\";\n    /** Vertical gradient color */ ColorType[\"VerticalGradient\"] = \"gradient\";\n})(ColorType || (ColorType = {}));\n/**\n * Check if a time value is a business day object.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link BusinessDay} object, false otherwise.\n */ function isBusinessDay(time) {\n    return !isNumber(time) && !isString(time);\n}\n/**\n * Check if a time value is a UTC timestamp number.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link UTCTimestamp} number, false otherwise.\n */ function isUTCTimestamp(time) {\n    return isNumber(time);\n}\n/**\n * Represents the type of a tick mark on the time axis.\n */ var TickMarkType;\n(function(TickMarkType) {\n    /**\n     * The start of the year (e.g. it's the first tick mark in a year).\n     */ TickMarkType[TickMarkType[\"Year\"] = 0] = \"Year\";\n    /**\n     * The start of the month (e.g. it's the first tick mark in a month).\n     */ TickMarkType[TickMarkType[\"Month\"] = 1] = \"Month\";\n    /**\n     * A day of the month.\n     */ TickMarkType[TickMarkType[\"DayOfMonth\"] = 2] = \"DayOfMonth\";\n    /**\n     * A time without seconds.\n     */ TickMarkType[TickMarkType[\"Time\"] = 3] = \"Time\";\n    /**\n     * A time with seconds.\n     */ TickMarkType[TickMarkType[\"TimeWithSeconds\"] = 4] = \"TimeWithSeconds\";\n})(TickMarkType || (TickMarkType = {}));\nconst getMonth = (date)=>date.getUTCMonth() + 1;\nconst getDay = (date)=>date.getUTCDate();\nconst getYear = (date)=>date.getUTCFullYear();\nconst dd = (date)=>numberToStringWithLeadingZero(getDay(date), 2);\nconst MMMM = (date, locale)=>new Date(date.getUTCFullYear(), date.getUTCMonth(), 1).toLocaleString(locale, {\n        month: 'long'\n    });\n_c = MMMM;\nconst MMM = (date, locale)=>new Date(date.getUTCFullYear(), date.getUTCMonth(), 1).toLocaleString(locale, {\n        month: 'short'\n    });\n_c1 = MMM;\nconst MM = (date)=>numberToStringWithLeadingZero(getMonth(date), 2);\n_c2 = MM;\nconst yy = (date)=>numberToStringWithLeadingZero(getYear(date) % 100, 2);\nconst yyyy = (date)=>numberToStringWithLeadingZero(getYear(date), 4);\nfunction formatDate(date, format, locale) {\n    return format.replace(/yyyy/g, yyyy(date)).replace(/yy/g, yy(date)).replace(/MMMM/g, MMMM(date, locale)).replace(/MMM/g, MMM(date, locale)).replace(/MM/g, MM(date)).replace(/dd/g, dd(date));\n}\nclass DateFormatter {\n    _internal_format(date) {\n        return formatDate(date, this._private__dateFormat, this._private__locale);\n    }\n    constructor(dateFormat = 'yyyy-MM-dd', locale = 'default'){\n        this._private__dateFormat = dateFormat;\n        this._private__locale = locale;\n    }\n}\nclass TimeFormatter {\n    _internal_format(date) {\n        return this._private__formatStr.replace('%h', numberToStringWithLeadingZero(date.getUTCHours(), 2)).replace('%m', numberToStringWithLeadingZero(date.getUTCMinutes(), 2)).replace('%s', numberToStringWithLeadingZero(date.getUTCSeconds(), 2));\n    }\n    constructor(format){\n        this._private__formatStr = format || '%h:%m:%s';\n    }\n}\nconst defaultParams = {\n    _internal_dateFormat: 'yyyy-MM-dd',\n    _internal_timeFormat: '%h:%m:%s',\n    _internal_dateTimeSeparator: ' ',\n    _internal_locale: 'default'\n};\nclass DateTimeFormatter {\n    _internal_format(dateTime) {\n        return \"\".concat(this._private__dateFormatter._internal_format(dateTime)).concat(this._private__separator).concat(this._private__timeFormatter._internal_format(dateTime));\n    }\n    constructor(params = {}){\n        const formatterParams = {\n            ...defaultParams,\n            ...params\n        };\n        this._private__dateFormatter = new DateFormatter(formatterParams._internal_dateFormat, formatterParams._internal_locale);\n        this._private__timeFormatter = new TimeFormatter(formatterParams._internal_timeFormat);\n        this._private__separator = formatterParams._internal_dateTimeSeparator;\n    }\n}\nfunction defaultTickMarkFormatter(timePoint, tickMarkType, locale) {\n    const formatOptions = {};\n    switch(tickMarkType){\n        case 0 /* TickMarkType.Year */ :\n            formatOptions.year = 'numeric';\n            break;\n        case 1 /* TickMarkType.Month */ :\n            formatOptions.month = 'short';\n            break;\n        case 2 /* TickMarkType.DayOfMonth */ :\n            formatOptions.day = 'numeric';\n            break;\n        case 3 /* TickMarkType.Time */ :\n            formatOptions.hour12 = false;\n            formatOptions.hour = '2-digit';\n            formatOptions.minute = '2-digit';\n            break;\n        case 4 /* TickMarkType.TimeWithSeconds */ :\n            formatOptions.hour12 = false;\n            formatOptions.hour = '2-digit';\n            formatOptions.minute = '2-digit';\n            formatOptions.second = '2-digit';\n            break;\n    }\n    const date = timePoint._internal_businessDay === undefined ? new Date(timePoint._internal_timestamp * 1000) : new Date(Date.UTC(timePoint._internal_businessDay.year, timePoint._internal_businessDay.month - 1, timePoint._internal_businessDay.day));\n    // from given date we should use only as UTC date or timestamp\n    // but to format as locale date we can convert UTC date to local date\n    const localDateFromUtc = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n    return localDateFromUtc.toLocaleString(locale, formatOptions);\n}\nfunction hours(count) {\n    return count * 60 * 60 * 1000;\n}\nfunction minutes(count) {\n    return count * 60 * 1000;\n}\nfunction seconds(count) {\n    return count * 1000;\n}\nconst intradayWeightDivisors = [\n    {\n        _internal_divisor: seconds(1),\n        _internal_weight: 10 /* TickMarkWeight.Second */ \n    },\n    {\n        _internal_divisor: minutes(1),\n        _internal_weight: 20 /* TickMarkWeight.Minute1 */ \n    },\n    {\n        _internal_divisor: minutes(5),\n        _internal_weight: 21 /* TickMarkWeight.Minute5 */ \n    },\n    {\n        _internal_divisor: minutes(30),\n        _internal_weight: 22 /* TickMarkWeight.Minute30 */ \n    },\n    {\n        _internal_divisor: hours(1),\n        _internal_weight: 30 /* TickMarkWeight.Hour1 */ \n    },\n    {\n        _internal_divisor: hours(3),\n        _internal_weight: 31 /* TickMarkWeight.Hour3 */ \n    },\n    {\n        _internal_divisor: hours(6),\n        _internal_weight: 32 /* TickMarkWeight.Hour6 */ \n    },\n    {\n        _internal_divisor: hours(12),\n        _internal_weight: 33 /* TickMarkWeight.Hour12 */ \n    }\n];\nfunction weightByTime(currentDate, prevDate) {\n    if (currentDate.getUTCFullYear() !== prevDate.getUTCFullYear()) {\n        return 70 /* TickMarkWeight.Year */ ;\n    } else if (currentDate.getUTCMonth() !== prevDate.getUTCMonth()) {\n        return 60 /* TickMarkWeight.Month */ ;\n    } else if (currentDate.getUTCDate() !== prevDate.getUTCDate()) {\n        return 50 /* TickMarkWeight.Day */ ;\n    }\n    for(let i = intradayWeightDivisors.length - 1; i >= 0; --i){\n        if (Math.floor(prevDate.getTime() / intradayWeightDivisors[i]._internal_divisor) !== Math.floor(currentDate.getTime() / intradayWeightDivisors[i]._internal_divisor)) {\n            return intradayWeightDivisors[i]._internal_weight;\n        }\n    }\n    return 0 /* TickMarkWeight.LessThanSecond */ ;\n}\nfunction cast(t) {\n    return t;\n}\nfunction fillWeightsForPoints(sortedTimePoints) {\n    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (sortedTimePoints.length === 0) {\n        return;\n    }\n    let prevTime = startIndex === 0 ? null : cast(sortedTimePoints[startIndex - 1].time)._internal_timestamp;\n    let prevDate = prevTime !== null ? new Date(prevTime * 1000) : null;\n    let totalTimeDiff = 0;\n    for(let index = startIndex; index < sortedTimePoints.length; ++index){\n        const currentPoint = sortedTimePoints[index];\n        const currentDate = new Date(cast(currentPoint.time)._internal_timestamp * 1000);\n        if (prevDate !== null) {\n            currentPoint.timeWeight = weightByTime(currentDate, prevDate);\n        }\n        totalTimeDiff += cast(currentPoint.time)._internal_timestamp - (prevTime || cast(currentPoint.time)._internal_timestamp);\n        prevTime = cast(currentPoint.time)._internal_timestamp;\n        prevDate = currentDate;\n    }\n    if (startIndex === 0 && sortedTimePoints.length > 1) {\n        // let's guess a weight for the first point\n        // let's say the previous point was average time back in the history\n        const averageTimeDiff = Math.ceil(totalTimeDiff / (sortedTimePoints.length - 1));\n        const approxPrevDate = new Date((cast(sortedTimePoints[0].time)._internal_timestamp - averageTimeDiff) * 1000);\n        sortedTimePoints[0].timeWeight = weightByTime(new Date(cast(sortedTimePoints[0].time)._internal_timestamp * 1000), approxPrevDate);\n    }\n}\nfunction businessDayConverter(time) {\n    let businessDay = time;\n    if (isString(time)) {\n        businessDay = stringToBusinessDay(time);\n    }\n    if (!isBusinessDay(businessDay)) {\n        throw new Error('time must be of type BusinessDay');\n    }\n    const date = new Date(Date.UTC(businessDay.year, businessDay.month - 1, businessDay.day, 0, 0, 0, 0));\n    return {\n        _internal_timestamp: Math.round(date.getTime() / 1000),\n        _internal_businessDay: businessDay\n    };\n}\nfunction timestampConverter(time) {\n    if (!isUTCTimestamp(time)) {\n        throw new Error('time must be of type isUTCTimestamp');\n    }\n    return {\n        _internal_timestamp: time\n    };\n}\nfunction selectTimeConverter(data) {\n    if (data.length === 0) {\n        return null;\n    }\n    if (isBusinessDay(data[0].time) || isString(data[0].time)) {\n        return businessDayConverter;\n    }\n    return timestampConverter;\n}\nconst validDateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nfunction convertTime(time) {\n    if (isUTCTimestamp(time)) {\n        return timestampConverter(time);\n    }\n    if (!isBusinessDay(time)) {\n        return businessDayConverter(stringToBusinessDay(time));\n    }\n    return businessDayConverter(time);\n}\nfunction stringToBusinessDay(value) {\n    {\n        // in some browsers (I look at your Chrome) the Date constructor may accept invalid date string\n        // but parses them in 'implementation specific' way\n        // for example 2019-1-1 isn't the same as 2019-01-01 (for Chrome both are 'valid' date strings)\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=968939\n        // so, we need to be sure that date has valid format to avoid strange behavior and hours of debugging\n        // but let's do this in development build only because of perf\n        if (!validDateRegex.test(value)) {\n            throw new Error(\"Invalid date string=\".concat(value, \", expected format=yyyy-mm-dd\"));\n        }\n    }\n    const d = new Date(value);\n    if (isNaN(d.getTime())) {\n        throw new Error(\"Invalid date string=\".concat(value, \", expected format=yyyy-mm-dd\"));\n    }\n    return {\n        day: d.getUTCDate(),\n        month: d.getUTCMonth() + 1,\n        year: d.getUTCFullYear()\n    };\n}\nfunction convertStringToBusinessDay(value) {\n    if (isString(value.time)) {\n        value.time = stringToBusinessDay(value.time);\n    }\n}\nfunction convertStringsToBusinessDays(data) {\n    return data.forEach(convertStringToBusinessDay);\n}\n// eslint-disable-next-line complexity\nfunction weightToTickMarkType(weight, timeVisible, secondsVisible) {\n    switch(weight){\n        case 0 /* TickMarkWeight.LessThanSecond */ :\n        case 10 /* TickMarkWeight.Second */ :\n            return timeVisible ? secondsVisible ? 4 /* TickMarkType.TimeWithSeconds */  : 3 /* TickMarkType.Time */  : 2 /* TickMarkType.DayOfMonth */ ;\n        case 20 /* TickMarkWeight.Minute1 */ :\n        case 21 /* TickMarkWeight.Minute5 */ :\n        case 22 /* TickMarkWeight.Minute30 */ :\n        case 30 /* TickMarkWeight.Hour1 */ :\n        case 31 /* TickMarkWeight.Hour3 */ :\n        case 32 /* TickMarkWeight.Hour6 */ :\n        case 33 /* TickMarkWeight.Hour12 */ :\n            return timeVisible ? 3 /* TickMarkType.Time */  : 2 /* TickMarkType.DayOfMonth */ ;\n        case 50 /* TickMarkWeight.Day */ :\n            return 2 /* TickMarkType.DayOfMonth */ ;\n        case 60 /* TickMarkWeight.Month */ :\n            return 1 /* TickMarkType.Month */ ;\n        case 70 /* TickMarkWeight.Year */ :\n            return 0 /* TickMarkType.Year */ ;\n    }\n}\nclass HorzScaleBehaviorTime {\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n        this.updateFormatter(options.localization);\n    }\n    preprocessData(data) {\n        if (Array.isArray(data)) {\n            convertStringsToBusinessDays(data);\n        } else {\n            convertStringToBusinessDay(data);\n        }\n    }\n    createConverterToInternalObj(data) {\n        return ensureNotNull(selectTimeConverter(data));\n    }\n    key(item) {\n        // eslint-disable-next-line no-restricted-syntax\n        if (typeof item === 'object' && \"_internal_timestamp\" in item) {\n            return item._internal_timestamp;\n        } else {\n            return this.key(this.convertHorzItemToInternal(item));\n        }\n    }\n    cacheKey(item) {\n        const time = item;\n        return time._internal_businessDay === undefined ? new Date(time._internal_timestamp * 1000).getTime() : new Date(Date.UTC(time._internal_businessDay.year, time._internal_businessDay.month - 1, time._internal_businessDay.day)).getTime();\n    }\n    convertHorzItemToInternal(item) {\n        return convertTime(item);\n    }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        const dateFormat = options.dateFormat;\n        if (this._private__options.timeScale.timeVisible) {\n            this._private__dateTimeFormatter = new DateTimeFormatter({\n                _internal_dateFormat: dateFormat,\n                _internal_timeFormat: this._private__options.timeScale.secondsVisible ? '%h:%m:%s' : '%h:%m',\n                _internal_dateTimeSeparator: '   ',\n                _internal_locale: options.locale\n            });\n        } else {\n            this._private__dateTimeFormatter = new DateFormatter(dateFormat, options.locale);\n        }\n    }\n    formatHorzItem(item) {\n        const tp = item;\n        return this._private__dateTimeFormatter._internal_format(new Date(tp._internal_timestamp * 1000));\n    }\n    formatTickmark(tickMark, localizationOptions) {\n        const tickMarkType = weightToTickMarkType(tickMark.weight, this._private__options.timeScale.timeVisible, this._private__options.timeScale.secondsVisible);\n        const options = this._private__options.timeScale;\n        if (options.tickMarkFormatter !== undefined) {\n            const tickMarkString = options.tickMarkFormatter(tickMark.originalTime, tickMarkType, localizationOptions.locale);\n            if (tickMarkString !== null) {\n                return tickMarkString;\n            }\n        }\n        return defaultTickMarkFormatter(tickMark.time, tickMarkType, localizationOptions.locale);\n    }\n    maxTickMarkWeight(tickMarks) {\n        let maxWeight = tickMarks.reduce(markWithGreaterWeight$2, tickMarks[0]).weight;\n        // special case: it looks strange if 15:00 is bold but 14:00 is not\n        // so if maxWeight > TickMarkWeight.Hour1 and < TickMarkWeight.Day reduce it to TickMarkWeight.Hour1\n        if (maxWeight > 30 /* TickMarkWeight.Hour1 */  && maxWeight < 50 /* TickMarkWeight.Day */ ) {\n            maxWeight = 30 /* TickMarkWeight.Hour1 */ ;\n        }\n        return maxWeight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        fillWeightsForPoints(sortedTimePoints, startIndex);\n    }\n    static _internal_applyDefaults(options) {\n        return merge({\n            localization: {\n                dateFormat: 'dd MMM \\'yy'\n            }\n        }, options !== null && options !== void 0 ? options : {});\n    }\n}\n/**\n * When you're trying to use the library in server-side context (for instance in SSR)\n * you don't have some browser-specific variables like navigator or window\n * and if the library will use them on the top level of the library\n * the import will fail due ReferenceError\n * thus, this allows use the navigator on the top level and being imported in server-side context as well\n * See issue #446\n */ // eslint-disable-next-line @typescript-eslint/tslint/config\nconst isRunningOnClientSide = typeof window !== 'undefined';\nfunction isFF() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n}\nfunction isIOS() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    return /iPhone|iPad|iPod/.test(window.navigator.platform);\n}\nfunction isChrome() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.chrome !== undefined;\n}\n// Determine whether the browser is running on windows.\nfunction isWindows() {\n    var _navigator_userAgentData, _navigator;\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // more accurate if available\n    if ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator_userAgentData = _navigator.userAgentData) === null || _navigator_userAgentData === void 0 ? void 0 : _navigator_userAgentData.platform) {\n        return navigator.userAgentData.platform === 'Windows';\n    }\n    return navigator.userAgent.toLowerCase().indexOf('win') >= 0;\n}\n// Determine whether the browser is Chromium based.\nfunction isChromiumBased() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    if (!navigator.userAgentData) {\n        return false;\n    }\n    return navigator.userAgentData.brands.some((brand)=>{\n        return brand.brand.includes('Chromium');\n    });\n}\n/// <reference types=\"_build-time-constants\" />\nfunction warn(msg) {\n    {\n        // eslint-disable-next-line no-console\n        console.warn(msg);\n    }\n}\n// on Hi-DPI CSS size * Device Pixel Ratio should be integer to avoid smoothing\n// For chart widget we decrease the size because we must be inside container.\n// For time axis this is not important, since it just affects space for pane widgets\nfunction suggestChartSize(originalSize) {\n    const integerWidth = Math.floor(originalSize.width);\n    const integerHeight = Math.floor(originalSize.height);\n    const width = integerWidth - integerWidth % 2;\n    const height = integerHeight - integerHeight % 2;\n    return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n        width,\n        height\n    });\n}\nfunction suggestTimeScaleHeight(originalHeight) {\n    return originalHeight + originalHeight % 2;\n}\nfunction suggestPriceScaleWidth(originalWidth) {\n    return originalWidth + originalWidth % 2;\n}\nfunction preventScrollByWheelClick(el) {\n    if (!isChrome()) {\n        return;\n    }\n    el.addEventListener('mousedown', (e)=>{\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (e.button === 1 /* MouseEventButton.Middle */ ) {\n            // prevent incorrect scrolling event\n            e.preventDefault();\n            return false;\n        }\n        return undefined;\n    });\n}\n// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum\nclass MouseEventHandler {\n    _internal_destroy() {\n        if (this._private__unsubscribeOutsideMouseEvents !== null) {\n            this._private__unsubscribeOutsideMouseEvents();\n            this._private__unsubscribeOutsideMouseEvents = null;\n        }\n        if (this._private__unsubscribeOutsideTouchEvents !== null) {\n            this._private__unsubscribeOutsideTouchEvents();\n            this._private__unsubscribeOutsideTouchEvents = null;\n        }\n        if (this._private__unsubscribeMousemove !== null) {\n            this._private__unsubscribeMousemove();\n            this._private__unsubscribeMousemove = null;\n        }\n        if (this._private__unsubscribeRootMouseEvents !== null) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (this._private__unsubscribeRootTouchEvents !== null) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        if (this._private__unsubscribeMobileSafariEvents !== null) {\n            this._private__unsubscribeMobileSafariEvents();\n            this._private__unsubscribeMobileSafariEvents = null;\n        }\n        this._private__clearLongTapTimeout();\n        this._private__resetClickTimeout();\n    }\n    _private__mouseEnterHandler(enterEvent) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        const boundMouseMoveHandler = this._private__mouseMoveHandler.bind(this);\n        this._private__unsubscribeMousemove = ()=>{\n            this._private__target.removeEventListener('mousemove', boundMouseMoveHandler);\n        };\n        this._private__target.addEventListener('mousemove', boundMouseMoveHandler);\n        if (this._private__firesTouchEvents(enterEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(enterEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseEnterEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__resetClickTimeout() {\n        if (this._private__clickTimeoutId !== null) {\n            clearTimeout(this._private__clickTimeoutId);\n        }\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n    }\n    _private__resetTapTimeout() {\n        if (this._private__tapTimeoutId !== null) {\n            clearTimeout(this._private__tapTimeoutId);\n        }\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n    }\n    _private__mouseMoveHandler(moveEvent) {\n        if (this._private__mousePressed || this._private__touchMoveStartPosition !== null) {\n            return;\n        }\n        if (this._private__firesTouchEvents(moveEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(moveEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseMoveEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__touchMoveHandler(moveEvent) {\n        const touch = touchWithId(moveEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(moveEvent);\n        if (this._private__startPinchMiddlePoint !== null) {\n            return;\n        }\n        if (this._private__preventTouchDragProcess) {\n            return;\n        }\n        // prevent pinch if move event comes faster than the second touch\n        this._private__pinchPrevented = true;\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(touch), ensureNotNull(this._private__touchMoveStartPosition));\n        const { _internal_xOffset: xOffset, _internal_yOffset: yOffset, _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (!this._private__touchMoveExceededManhattanDistance && manhattanDistance < 5 /* Constants.CancelTapManhattanDistance */ ) {\n            return;\n        }\n        if (!this._private__touchMoveExceededManhattanDistance) {\n            // first time when current position exceeded manhattan distance\n            // vertical drag is more important than horizontal drag\n            // because we scroll the page vertically often than horizontally\n            const correctedXOffset = xOffset * 0.5;\n            // a drag can be only if touch page scroll isn't allowed\n            const isVertDrag = yOffset >= correctedXOffset && !this._private__options._internal_treatVertTouchDragAsPageScroll();\n            const isHorzDrag = correctedXOffset > yOffset && !this._private__options._internal_treatHorzTouchDragAsPageScroll();\n            // if drag event happened then we should revert preventDefault state to original one\n            // and try to process the drag event\n            // else we shouldn't prevent default of the event and ignore processing the drag event\n            if (!isVertDrag && !isHorzDrag) {\n                this._private__preventTouchDragProcess = true;\n            }\n            this._private__touchMoveExceededManhattanDistance = true;\n            // if manhattan distance is more that 5 - we should cancel tap event\n            this._private__cancelTap = true;\n            this._private__clearLongTapTimeout();\n            this._private__resetTapTimeout();\n        }\n        if (!this._private__preventTouchDragProcess) {\n            const compatEvent = this._private__makeCompatEvent(moveEvent, touch);\n            this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchMoveEvent);\n            // we should prevent default in case of touch only\n            // to prevent scroll of the page\n            preventDefault(moveEvent);\n        }\n    }\n    _private__mouseMoveWithDownHandler(moveEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (moveEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(moveEvent), ensureNotNull(this._private__mouseMoveStartPosition));\n        const { _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (manhattanDistance >= 5 /* Constants.CancelClickManhattanDistance */ ) {\n            // if manhattan distance is more that 5 - we should cancel click event\n            this._private__cancelClick = true;\n            this._private__resetClickTimeout();\n        }\n        if (this._private__cancelClick) {\n            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded\n            const compatEvent = this._private__makeCompatEvent(moveEvent);\n            this._private__processMouseEvent(compatEvent, this._private__handler._internal_pressedMouseMoveEvent);\n        }\n    }\n    _private__touchMouseMoveWithDownInfo(currentPosition, startPosition) {\n        const xOffset = Math.abs(startPosition._internal_x - currentPosition._internal_x);\n        const yOffset = Math.abs(startPosition._internal_y - currentPosition._internal_y);\n        const manhattanDistance = xOffset + yOffset;\n        return {\n            _internal_xOffset: xOffset,\n            _internal_yOffset: yOffset,\n            _internal_manhattanDistance: manhattanDistance\n        };\n    }\n    // eslint-disable-next-line complexity\n    _private__touchEndHandler(touchEndEvent) {\n        let touch = touchWithId(touchEndEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null && touchEndEvent.touches.length === 0) {\n            // something went wrong, somehow we missed the required touchend event\n            // probably the browser has not sent this event\n            touch = touchEndEvent.changedTouches[0];\n        }\n        if (touch === null) {\n            return;\n        }\n        this._private__activeTouchId = null;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(touchEndEvent);\n        this._private__clearLongTapTimeout();\n        this._private__touchMoveStartPosition = null;\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        const compatEvent = this._private__makeCompatEvent(touchEndEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchEndEvent);\n        ++this._private__tapCount;\n        if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(touch), this._private__tapPosition);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */  && !this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n            }\n            this._private__resetTapTimeout();\n        } else {\n            if (!this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_tapEvent);\n                // do not fire mouse events if tap handler was executed\n                // prevent click event on new dom element (who appeared after tap)\n                if (this._private__handler._internal_tapEvent) {\n                    preventDefault(touchEndEvent);\n                }\n            }\n        }\n        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap\n        // we handle mouseDoubleClickEvent here ourselves\n        if (this._private__tapCount === 0) {\n            preventDefault(touchEndEvent);\n        }\n        if (touchEndEvent.touches.length === 0) {\n            if (this._private__longTapActive) {\n                this._private__longTapActive = false;\n                // prevent native click event\n                preventDefault(touchEndEvent);\n            }\n        }\n    }\n    _private__mouseUpHandler(mouseUpEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (mouseUpEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(mouseUpEvent);\n        this._private__mouseMoveStartPosition = null;\n        this._private__mousePressed = false;\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (isFF()) {\n            const rootElement = this._private__target.ownerDocument.documentElement;\n            rootElement.removeEventListener('mouseleave', this._private__onFirefoxOutsideMouseUp);\n        }\n        if (this._private__firesTouchEvents(mouseUpEvent)) {\n            return;\n        }\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseUpEvent);\n        ++this._private__clickCount;\n        if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(mouseUpEvent), this._private__clickPosition);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */  && !this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n            }\n            this._private__resetClickTimeout();\n        } else {\n            if (!this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseClickEvent);\n            }\n        }\n    }\n    _private__clearLongTapTimeout() {\n        if (this._private__longTapTimeoutId === null) {\n            return;\n        }\n        clearTimeout(this._private__longTapTimeoutId);\n        this._private__longTapTimeoutId = null;\n    }\n    _private__touchStartHandler(downEvent) {\n        if (this._private__activeTouchId !== null) {\n            return;\n        }\n        const touch = downEvent.changedTouches[0];\n        this._private__activeTouchId = touch.identifier;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(downEvent);\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        this._private__cancelTap = false;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__touchMoveStartPosition = getPosition(touch);\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        {\n            const boundTouchMoveWithDownHandler = this._private__touchMoveHandler.bind(this);\n            const boundTouchEndHandler = this._private__touchEndHandler.bind(this);\n            this._private__unsubscribeRootTouchEvents = ()=>{\n                rootElement.removeEventListener('touchmove', boundTouchMoveWithDownHandler);\n                rootElement.removeEventListener('touchend', boundTouchEndHandler);\n            };\n            rootElement.addEventListener('touchmove', boundTouchMoveWithDownHandler, {\n                passive: false\n            });\n            rootElement.addEventListener('touchend', boundTouchEndHandler, {\n                passive: false\n            });\n            this._private__clearLongTapTimeout();\n            this._private__longTapTimeoutId = setTimeout(this._private__longTapHandler.bind(this, downEvent), 240 /* Delay.LongTap */ );\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchStartEvent);\n        if (!this._private__tapTimeoutId) {\n            this._private__tapCount = 0;\n            this._private__tapTimeoutId = setTimeout(this._private__resetTapTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._private__tapPosition = getPosition(touch);\n        }\n    }\n    _private__mouseDownHandler(downEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (downEvent.button !== 0 /* MouseEventButton.Left */ ) {\n            return;\n        }\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        if (isFF()) {\n            rootElement.addEventListener('mouseleave', this._private__onFirefoxOutsideMouseUp);\n        }\n        this._private__cancelClick = false;\n        this._private__mouseMoveStartPosition = getPosition(downEvent);\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        {\n            const boundMouseMoveWithDownHandler = this._private__mouseMoveWithDownHandler.bind(this);\n            const boundMouseUpHandler = this._private__mouseUpHandler.bind(this);\n            this._private__unsubscribeRootMouseEvents = ()=>{\n                rootElement.removeEventListener('mousemove', boundMouseMoveWithDownHandler);\n                rootElement.removeEventListener('mouseup', boundMouseUpHandler);\n            };\n            rootElement.addEventListener('mousemove', boundMouseMoveWithDownHandler);\n            rootElement.addEventListener('mouseup', boundMouseUpHandler);\n        }\n        this._private__mousePressed = true;\n        if (this._private__firesTouchEvents(downEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDownEvent);\n        if (!this._private__clickTimeoutId) {\n            this._private__clickCount = 0;\n            this._private__clickTimeoutId = setTimeout(this._private__resetClickTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._private__clickPosition = getPosition(downEvent);\n        }\n    }\n    _private__init() {\n        this._private__target.addEventListener('mouseenter', this._private__mouseEnterHandler.bind(this));\n        // Do not show context menu when something went wrong\n        this._private__target.addEventListener('touchcancel', this._private__clearLongTapTimeout.bind(this));\n        {\n            const doc = this._private__target.ownerDocument;\n            const outsideHandler = (event)=>{\n                if (!this._private__handler._internal_mouseDownOutsideEvent) {\n                    return;\n                }\n                if (event.composed && this._private__target.contains(event.composedPath()[0])) {\n                    return;\n                }\n                if (event.target && this._private__target.contains(event.target)) {\n                    return;\n                }\n                this._private__handler._internal_mouseDownOutsideEvent();\n            };\n            this._private__unsubscribeOutsideTouchEvents = ()=>{\n                doc.removeEventListener('touchstart', outsideHandler);\n            };\n            this._private__unsubscribeOutsideMouseEvents = ()=>{\n                doc.removeEventListener('mousedown', outsideHandler);\n            };\n            doc.addEventListener('mousedown', outsideHandler);\n            doc.addEventListener('touchstart', outsideHandler, {\n                passive: true\n            });\n        }\n        if (isIOS()) {\n            this._private__unsubscribeMobileSafariEvents = ()=>{\n                this._private__target.removeEventListener('dblclick', this._private__onMobileSafariDoubleClick);\n            };\n            this._private__target.addEventListener('dblclick', this._private__onMobileSafariDoubleClick);\n        }\n        this._private__target.addEventListener('mouseleave', this._private__mouseLeaveHandler.bind(this));\n        this._private__target.addEventListener('touchstart', this._private__touchStartHandler.bind(this), {\n            passive: true\n        });\n        preventScrollByWheelClick(this._private__target);\n        this._private__target.addEventListener('mousedown', this._private__mouseDownHandler.bind(this));\n        this._private__initPinch();\n        // Hey mobile Safari, what's up?\n        // If mobile Safari doesn't have any touchmove handler with passive=false\n        // it treats a touchstart and the following touchmove events as cancelable=false,\n        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).\n        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.\n        this._private__target.addEventListener('touchmove', ()=>{}, {\n            passive: false\n        });\n    }\n    _private__initPinch() {\n        if (this._private__handler._internal_pinchStartEvent === undefined && this._private__handler._internal_pinchEvent === undefined && this._private__handler._internal_pinchEndEvent === undefined) {\n            return;\n        }\n        this._private__target.addEventListener('touchstart', (event)=>this._private__checkPinchState(event.touches), {\n            passive: true\n        });\n        this._private__target.addEventListener('touchmove', (event)=>{\n            if (event.touches.length !== 2 || this._private__startPinchMiddlePoint === null) {\n                return;\n            }\n            if (this._private__handler._internal_pinchEvent !== undefined) {\n                const currentDistance = getDistance(event.touches[0], event.touches[1]);\n                const scale = currentDistance / this._private__startPinchDistance;\n                this._private__handler._internal_pinchEvent(this._private__startPinchMiddlePoint, scale);\n                preventDefault(event);\n            }\n        }, {\n            passive: false\n        });\n        this._private__target.addEventListener('touchend', (event)=>{\n            this._private__checkPinchState(event.touches);\n        });\n    }\n    _private__checkPinchState(touches) {\n        if (touches.length === 1) {\n            this._private__pinchPrevented = false;\n        }\n        if (touches.length !== 2 || this._private__pinchPrevented || this._private__longTapActive) {\n            this._private__stopPinch();\n        } else {\n            this._private__startPinch(touches);\n        }\n    }\n    _private__startPinch(touches) {\n        const box = getBoundingClientRect(this._private__target);\n        this._private__startPinchMiddlePoint = {\n            _internal_x: (touches[0].clientX - box.left + (touches[1].clientX - box.left)) / 2,\n            _internal_y: (touches[0].clientY - box.top + (touches[1].clientY - box.top)) / 2\n        };\n        this._private__startPinchDistance = getDistance(touches[0], touches[1]);\n        if (this._private__handler._internal_pinchStartEvent !== undefined) {\n            this._private__handler._internal_pinchStartEvent();\n        }\n        this._private__clearLongTapTimeout();\n    }\n    _private__stopPinch() {\n        if (this._private__startPinchMiddlePoint === null) {\n            return;\n        }\n        this._private__startPinchMiddlePoint = null;\n        if (this._private__handler._internal_pinchEndEvent !== undefined) {\n            this._private__handler._internal_pinchEndEvent();\n        }\n    }\n    _private__mouseLeaveHandler(event) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        if (this._private__firesTouchEvents(event)) {\n            return;\n        }\n        if (!this._private__acceptMouseLeave) {\n            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way\n            // just ignore this event if there was no mouse move or mouse enter events\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseLeaveEvent);\n        // accept all mouse leave events if it's not an iOS device\n        this._private__acceptMouseLeave = !isIOS();\n    }\n    _private__longTapHandler(event) {\n        const touch = touchWithId(event.touches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_longTapEvent);\n        this._private__cancelTap = true;\n        // long tap is active until touchend event with 0 touches occurred\n        this._private__longTapActive = true;\n    }\n    _private__firesTouchEvents(e) {\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents !== undefined) {\n            return e.sourceCapabilities.firesTouchEvents;\n        }\n        return eventTimeStamp(e) < this._private__lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */ ;\n    }\n    _private__processTouchEvent(event, callback) {\n        if (callback) {\n            callback.call(this._private__handler, event);\n        }\n    }\n    _private__processMouseEvent(event, callback) {\n        if (!callback) {\n            return;\n        }\n        callback.call(this._private__handler, event);\n    }\n    _private__makeCompatEvent(event, touch) {\n        // TouchEvent has no clientX/Y coordinates:\n        // We have to use the last Touch instead\n        const eventLike = touch || event;\n        const box = this._private__target.getBoundingClientRect() || {\n            left: 0,\n            top: 0\n        };\n        return {\n            clientX: eventLike.clientX,\n            clientY: eventLike.clientY,\n            pageX: eventLike.pageX,\n            pageY: eventLike.pageY,\n            screenX: eventLike.screenX,\n            screenY: eventLike.screenY,\n            localX: eventLike.clientX - box.left,\n            localY: eventLike.clientY - box.top,\n            ctrlKey: event.ctrlKey,\n            altKey: event.altKey,\n            shiftKey: event.shiftKey,\n            metaKey: event.metaKey,\n            _internal_isTouch: !event.type.startsWith('mouse') && event.type !== 'contextmenu' && event.type !== 'click',\n            _internal_srcType: event.type,\n            _internal_target: eventLike.target,\n            _internal_view: event.view,\n            _internal_preventDefault: ()=>{\n                if (event.type !== 'touchstart') {\n                    // touchstart is passive and cannot be prevented\n                    preventDefault(event);\n                }\n            }\n        };\n    }\n    constructor(target, handler, options){\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = {\n            _internal_x: Number.NEGATIVE_INFINITY,\n            _internal_y: Number.POSITIVE_INFINITY\n        };\n        this._private__longTapTimeoutId = null;\n        this._private__longTapActive = false;\n        this._private__mouseMoveStartPosition = null;\n        this._private__touchMoveStartPosition = null;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__cancelClick = false;\n        this._private__cancelTap = false;\n        this._private__unsubscribeOutsideMouseEvents = null;\n        this._private__unsubscribeOutsideTouchEvents = null;\n        this._private__unsubscribeMobileSafariEvents = null;\n        this._private__unsubscribeMousemove = null;\n        this._private__unsubscribeRootMouseEvents = null;\n        this._private__unsubscribeRootTouchEvents = null;\n        this._private__startPinchMiddlePoint = null;\n        this._private__startPinchDistance = 0;\n        this._private__pinchPrevented = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__mousePressed = false;\n        this._private__lastTouchEventTimeStamp = 0;\n        // for touchstart/touchmove/touchend events we handle only first touch\n        // i.e. we don't support several active touches at the same time (except pinch event)\n        this._private__activeTouchId = null;\n        // accept all mouse leave events if it's not an iOS device\n        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler\n        this._private__acceptMouseLeave = !isIOS();\n        /**\n         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.\n         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.\n         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.\n         */ this._private__onFirefoxOutsideMouseUp = (mouseUpEvent)=>{\n            this._private__mouseUpHandler(mouseUpEvent);\n        };\n        /**\n         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.\n         * There are two possible solutions:\n         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.\n         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.\n         * https://developer.apple.com/forums/thread/125073\n         */ this._private__onMobileSafariDoubleClick = (dblClickEvent)=>{\n            if (this._private__firesTouchEvents(dblClickEvent)) {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__tapCount;\n                if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__tapPosition);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n                    if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */  && !this._private__cancelTap) {\n                        this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n                    }\n                    this._private__resetTapTimeout();\n                }\n            } else {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__clickCount;\n                if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__clickPosition);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n                    if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */  && !this._private__cancelClick) {\n                        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n                    }\n                    this._private__resetClickTimeout();\n                }\n            }\n        };\n        this._private__target = target;\n        this._private__handler = handler;\n        this._private__options = options;\n        this._private__init();\n    }\n}\nfunction getBoundingClientRect(element) {\n    return element.getBoundingClientRect() || {\n        left: 0,\n        top: 0\n    };\n}\nfunction getDistance(p1, p2) {\n    const xDiff = p1.clientX - p2.clientX;\n    const yDiff = p1.clientY - p2.clientY;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}\nfunction preventDefault(event) {\n    if (event.cancelable) {\n        event.preventDefault();\n    }\n}\nfunction getPosition(eventLike) {\n    return {\n        _internal_x: eventLike.pageX,\n        _internal_y: eventLike.pageY\n    };\n}\nfunction eventTimeStamp(e) {\n    // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback\n    return e.timeStamp || performance.now();\n}\nfunction touchWithId(touches, id) {\n    for(let i = 0; i < touches.length; ++i){\n        if (touches[i].identifier === id) {\n            return touches[i];\n        }\n    }\n    return null;\n}\nclass PaneSeparator {\n    _internal_destroy() {\n        if (this._private__mouseEventHandler !== null) {\n            this._private__mouseEventHandler._internal_destroy();\n        }\n    }\n    _internal_getElement() {\n        return this._private__rowElement;\n    }\n    _internal_getSize() {\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._private__topPane._internal_getSize().width,\n            height: 1 /* SeparatorConstants.SeparatorHeight */ \n        });\n    }\n    _internal_getBitmapSize() {\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._private__topPane._internal_getBitmapSize().width,\n            height: 1 /* SeparatorConstants.SeparatorHeight */  * window.devicePixelRatio\n        });\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        ctx.fillStyle = this._private__chartWidget._internal_options()['layout'].panes.separatorColor;\n        ctx.fillRect(x, y, bitmapSize.width, bitmapSize.height);\n    }\n    _internal_update() {\n        this._private__updateBorderColor();\n        if (this._private__chartWidget._internal_options()['layout'].panes.enableResize !== this._private__resizeEnabled) {\n            this._private__resizeEnabled = this._private__chartWidget._internal_options()['layout'].panes.enableResize;\n            if (this._private__resizeEnabled) {\n                this._private__addResizableHandle();\n            } else {\n                if (this._private__handle !== null) {\n                    this._private__cell.removeChild(this._private__handle._internal_backgroundElement);\n                    this._private__cell.removeChild(this._private__handle._internal_element);\n                    this._private__handle = null;\n                }\n                if (this._private__mouseEventHandler !== null) {\n                    this._private__mouseEventHandler._internal_destroy();\n                    this._private__mouseEventHandler = null;\n                }\n            }\n        }\n    }\n    _private__addResizableHandle() {\n        const backgroundElement = document.createElement('div');\n        const bgStyle = backgroundElement.style;\n        bgStyle.position = 'fixed';\n        bgStyle.display = 'none';\n        bgStyle.zIndex = '49';\n        bgStyle.top = '0';\n        bgStyle.left = '0';\n        bgStyle.width = '100%';\n        bgStyle.height = '100%';\n        bgStyle.cursor = 'row-resize';\n        this._private__cell.appendChild(backgroundElement);\n        const element = document.createElement('div');\n        const style = element.style;\n        style.position = 'absolute';\n        style.zIndex = '50';\n        style.top = '-4px';\n        style.height = '9px';\n        style.width = '100%';\n        style.backgroundColor = '';\n        style.cursor = 'row-resize';\n        this._private__cell.appendChild(element);\n        const handlers = {\n            _internal_mouseEnterEvent: this._private__mouseOverEvent.bind(this),\n            _internal_mouseLeaveEvent: this._private__mouseLeaveEvent.bind(this),\n            _internal_mouseDownEvent: this._private__mouseDownEvent.bind(this),\n            _internal_touchStartEvent: this._private__mouseDownEvent.bind(this),\n            _internal_pressedMouseMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_touchMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_mouseUpEvent: this._private__mouseUpEvent.bind(this),\n            _internal_touchEndEvent: this._private__mouseUpEvent.bind(this)\n        };\n        this._private__mouseEventHandler = new MouseEventHandler(element, handlers, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>false,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>true\n        });\n        this._private__handle = {\n            _internal_element: element,\n            _internal_backgroundElement: backgroundElement\n        };\n    }\n    _private__updateBorderColor() {\n        this._private__cell.style.background = this._private__chartWidget._internal_options()['layout'].panes.separatorColor;\n    }\n    _private__mouseOverEvent(event) {\n        if (this._private__handle !== null) {\n            this._private__handle._internal_element.style.backgroundColor = this._private__chartWidget._internal_options()['layout'].panes.separatorHoverColor;\n        }\n    }\n    _private__mouseLeaveEvent(event) {\n        if (this._private__handle !== null && this._private__resizeInfo === null) {\n            this._private__handle._internal_element.style.backgroundColor = '';\n        }\n    }\n    _private__mouseDownEvent(event) {\n        if (this._private__handle === null) {\n            return;\n        }\n        const totalStretch = this._private__topPane._internal_state()._internal_stretchFactor() + this._private__bottomPane._internal_state()._internal_stretchFactor();\n        const totalHeight = this._private__topPane._internal_getSize().height + this._private__bottomPane._internal_getSize().height;\n        const pixelStretchFactor = totalStretch / totalHeight;\n        const minPaneStretch = 30 /* SeparatorConstants.MinPaneHeight */  * pixelStretchFactor;\n        if (totalStretch <= minPaneStretch * 2) {\n            // cannot resize panes that already have less than minimal height\n            // that's possible if there are many panes on the chart\n            return;\n        }\n        this._private__resizeInfo = {\n            _internal_startY: event.pageY,\n            _internal_prevStretchTopPane: this._private__topPane._internal_state()._internal_stretchFactor(),\n            _internal_maxPaneStretch: totalStretch - minPaneStretch,\n            _internal_totalStretch: totalStretch,\n            _internal_pixelStretchFactor: pixelStretchFactor,\n            _internal_minPaneStretch: minPaneStretch\n        };\n        this._private__handle._internal_backgroundElement.style.display = 'block';\n    }\n    _private__pressedMouseMoveEvent(event) {\n        const resizeInfo = this._private__resizeInfo;\n        if (resizeInfo === null) {\n            return;\n        }\n        const deltaY = event.pageY - resizeInfo._internal_startY;\n        const deltaStretchFactor = deltaY * resizeInfo._internal_pixelStretchFactor;\n        const upperPaneNewStretch = clamp(resizeInfo._internal_prevStretchTopPane + deltaStretchFactor, resizeInfo._internal_minPaneStretch, resizeInfo._internal_maxPaneStretch);\n        this._private__topPane._internal_state()._internal_setStretchFactor(upperPaneNewStretch);\n        this._private__bottomPane._internal_state()._internal_setStretchFactor(resizeInfo._internal_totalStretch - upperPaneNewStretch);\n        this._private__chartWidget._internal_model()._internal_fullUpdate();\n    }\n    _private__mouseUpEvent(event) {\n        if (this._private__resizeInfo === null || this._private__handle === null) {\n            return;\n        }\n        this._private__resizeInfo = null;\n        this._private__handle._internal_backgroundElement.style.display = 'none';\n    }\n    constructor(chartWidget, topPaneIndex, bottomPaneIndex){\n        this._private__handle = null;\n        this._private__mouseEventHandler = null;\n        this._private__resizeEnabled = true;\n        this._private__resizeInfo = null;\n        this._private__chartWidget = chartWidget;\n        this._private__topPane = chartWidget._internal_paneWidgets()[topPaneIndex];\n        this._private__bottomPane = chartWidget._internal_paneWidgets()[bottomPaneIndex];\n        this._private__rowElement = document.createElement('tr');\n        this._private__rowElement.style.height = 1 /* SeparatorConstants.SeparatorHeight */  + 'px';\n        this._private__cell = document.createElement('td');\n        this._private__cell.style.position = 'relative';\n        this._private__cell.style.padding = '0';\n        this._private__cell.style.margin = '0';\n        this._private__cell.setAttribute('colspan', '3');\n        this._private__updateBorderColor();\n        this._private__rowElement.appendChild(this._private__cell);\n        this._private__resizeEnabled = this._private__chartWidget._internal_options()['layout'].panes.enableResize;\n        if (!this._private__resizeEnabled) {\n            this._private__handle = null;\n            this._private__mouseEventHandler = null;\n        } else {\n            this._private__addResizableHandle();\n        }\n    }\n}\nfunction distanceBetweenPoints(pos1, pos2) {\n    return pos1._internal_position - pos2._internal_position;\n}\nfunction speedPxPerMSec(pos1, pos2, maxSpeed) {\n    const speed = (pos1._internal_position - pos2._internal_position) / (pos1._internal_time - pos2._internal_time);\n    return Math.sign(speed) * Math.min(Math.abs(speed), maxSpeed);\n}\nfunction durationMSec(speed, dumpingCoeff) {\n    const lnDumpingCoeff = Math.log(dumpingCoeff);\n    return Math.log(1 /* Constants.EpsilonDistance */  * lnDumpingCoeff / -speed) / lnDumpingCoeff;\n}\nclass KineticAnimation {\n    _internal_addPosition(position, time) {\n        if (this._private__position1 !== null) {\n            if (this._private__position1._internal_time === time) {\n                this._private__position1._internal_position = position;\n                return;\n            }\n            if (Math.abs(this._private__position1._internal_position - position) < this._private__minMove) {\n                return;\n            }\n        }\n        this._private__position4 = this._private__position3;\n        this._private__position3 = this._private__position2;\n        this._private__position2 = this._private__position1;\n        this._private__position1 = {\n            _internal_time: time,\n            _internal_position: position\n        };\n    }\n    _internal_start(position, time) {\n        if (this._private__position1 === null || this._private__position2 === null) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (time - this._private__position1._internal_time > 50 /* Constants.MaxStartDelay */ ) {\n            return;\n        }\n        // To calculate all the rest parameters we should calculate the speed af first\n        let totalDistance = 0;\n        const speed1 = speedPxPerMSec(this._private__position1, this._private__position2, this._private__maxSpeed);\n        const distance1 = distanceBetweenPoints(this._private__position1, this._private__position2);\n        // We're calculating weighted average speed\n        // Than more distance for a segment, than more its weight\n        const speedItems = [\n            speed1\n        ];\n        const distanceItems = [\n            distance1\n        ];\n        totalDistance += distance1;\n        if (this._private__position3 !== null) {\n            const speed2 = speedPxPerMSec(this._private__position2, this._private__position3, this._private__maxSpeed);\n            // stop at this moment if direction of the segment is opposite\n            if (Math.sign(speed2) === Math.sign(speed1)) {\n                const distance2 = distanceBetweenPoints(this._private__position2, this._private__position3);\n                speedItems.push(speed2);\n                distanceItems.push(distance2);\n                totalDistance += distance2;\n                if (this._private__position4 !== null) {\n                    const speed3 = speedPxPerMSec(this._private__position3, this._private__position4, this._private__maxSpeed);\n                    if (Math.sign(speed3) === Math.sign(speed1)) {\n                        const distance3 = distanceBetweenPoints(this._private__position3, this._private__position4);\n                        speedItems.push(speed3);\n                        distanceItems.push(distance3);\n                        totalDistance += distance3;\n                    }\n                }\n            }\n        }\n        let resultSpeed = 0;\n        for(let i = 0; i < speedItems.length; ++i){\n            resultSpeed += distanceItems[i] / totalDistance * speedItems[i];\n        }\n        if (Math.abs(resultSpeed) < this._private__minSpeed) {\n            return;\n        }\n        this._private__animationStartPosition = {\n            _internal_position: position,\n            _internal_time: time\n        };\n        this._private__speedPxPerMsec = resultSpeed;\n        this._private__durationMsecs = durationMSec(Math.abs(resultSpeed), this._private__dumpingCoeff);\n    }\n    _internal_getPosition(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const durationMsecs = time - startPosition._internal_time;\n        return startPosition._internal_position + this._private__speedPxPerMsec * (Math.pow(this._private__dumpingCoeff, durationMsecs) - 1) / Math.log(this._private__dumpingCoeff);\n    }\n    _internal_finished(time) {\n        return this._private__animationStartPosition === null || this._private__progressDuration(time) === this._private__durationMsecs;\n    }\n    _private__progressDuration(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const progress = time - startPosition._internal_time;\n        return Math.min(progress, this._private__durationMsecs);\n    }\n    constructor(minSpeed, maxSpeed, dumpingCoeff, minMove){\n        this._private__position1 = null;\n        this._private__position2 = null;\n        this._private__position3 = null;\n        this._private__position4 = null;\n        this._private__animationStartPosition = null;\n        this._private__durationMsecs = 0;\n        this._private__speedPxPerMsec = 0;\n        this._private__minSpeed = minSpeed;\n        this._private__maxSpeed = maxSpeed;\n        this._private__dumpingCoeff = dumpingCoeff;\n        this._private__minMove = minMove;\n    }\n}\nconst svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"35\" height=\"19\" fill=\"none\"><g fill-rule=\"evenodd\" clip-path=\"url(#a)\" clip-rule=\"evenodd\"><path fill=\"var(--stroke)\" d=\"M2 0H0v10h6v9h21.4l.5-1.3 6-15 1-2.7H23.7l-.5 1.3-.2.6a5 5 0 0 0-7-.9V0H2Zm20 17h4l5.2-13 .8-2h-7l-1 2.5-.2.5-1.5 3.8-.3.7V17Zm-.8-10a3 3 0 0 0 .7-2.7A3 3 0 1 0 16.8 7h4.4ZM14 7V2H2v6h6v9h4V7h2Z\"/><path fill=\"var(--fill)\" d=\"M14 2H2v6h6v9h6V2Zm12 15h-7l6-15h7l-6 15Zm-7-9a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\"/></g><defs><clipPath id=\"a\"><path fill=\"var(--stroke)\" d=\"M0 0h35v19H0z\"/></clipPath></defs></svg>';\nconst css = \"a#tv-attr-logo{--fill:#131722;--stroke:#fff;position:absolute;left:10px;bottom:10px;height:19px;width:35px;margin:0;padding:0;border:0;z-index:3;}a#tv-attr-logo[data-dark]{--fill:#D1D4DC;--stroke:#131722;}\";\n// This widget doesn't support dynamically responding to options changes\n// because it is expected that the `attributionLogo` option won't be changed\n// and this saves some bundle size.\nclass AttributionLogoWidget {\n    _internal_update() {\n        this._private__render();\n    }\n    _internal_removeElement() {\n        if (this._private__element) {\n            this._private__container.removeChild(this._private__element);\n        }\n        if (this._private__cssElement) {\n            this._private__container.removeChild(this._private__cssElement);\n        }\n        this._private__element = undefined;\n        this._private__cssElement = undefined;\n    }\n    _private__shouldUpdate() {\n        return this._private__visible !== this._private__shouldBeVisible() || this._private__theme !== this._private__themeToUse();\n    }\n    _private__themeToUse() {\n        return this._private__chart._internal_model()._internal_colorParser()._internal_colorStringToGrayscale(this._private__chart._internal_options()['layout'].textColor) > 160 ? 'dark' : 'light';\n    }\n    _private__shouldBeVisible() {\n        return this._private__chart._internal_options()['layout'].attributionLogo;\n    }\n    _private__getUTMSource() {\n        const url = new URL(location.href);\n        if (!url.hostname) {\n            // ignore local testing\n            return '';\n        }\n        return '&utm_source=' + url.hostname + url.pathname;\n    }\n    _private__render() {\n        if (!this._private__shouldUpdate()) {\n            return;\n        }\n        this._internal_removeElement();\n        this._private__visible = this._private__shouldBeVisible();\n        if (this._private__visible) {\n            this._private__theme = this._private__themeToUse();\n            this._private__cssElement = document.createElement('style');\n            this._private__cssElement.innerText = css;\n            this._private__element = document.createElement('a');\n            this._private__element.href = \"https://www.tradingview.com/?utm_medium=lwc-link&utm_campaign=lwc-chart\".concat(this._private__getUTMSource());\n            this._private__element.title = 'Charting by TradingView';\n            this._private__element.id = 'tv-attr-logo';\n            this._private__element.target = '_blank';\n            this._private__element.innerHTML = svg;\n            this._private__element.toggleAttribute('data-dark', this._private__theme === 'dark');\n            this._private__container.appendChild(this._private__cssElement);\n            this._private__container.appendChild(this._private__element);\n        }\n    }\n    constructor(container, chart){\n        this._private__element = undefined;\n        this._private__cssElement = undefined;\n        this._private__theme = undefined;\n        this._private__visible = false;\n        this._private__container = container;\n        this._private__chart = chart;\n        this._private__render();\n    }\n}\nfunction createBoundCanvas(parentElement, size) {\n    const doc = ensureNotNull(parentElement.ownerDocument);\n    const canvas = doc.createElement('canvas');\n    parentElement.appendChild(canvas);\n    const binding = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.bindCanvasElementBitmapSizeTo)(canvas, {\n        type: 'device-pixel-content-box',\n        options: {\n            allowResizeObserver: true\n        },\n        transform: (bitmapSize, canvasElementClientSize)=>({\n                width: Math.max(bitmapSize.width, canvasElementClientSize.width),\n                height: Math.max(bitmapSize.height, canvasElementClientSize.height)\n            })\n    });\n    binding.resizeCanvasElement(size);\n    return binding;\n}\nfunction releaseCanvas(canvas) {\n    var _canvas_getContext;\n    // This function fixes the iOS Safari error \"Total canvas memory use exceeds the maximum limit\".\n    // Seems that iOS Safari stores canvas elements for some additional time internally.\n    // So if we create/destroy a lot of canvas elements in a short period of time we can get this error.\n    // We resize the canvas to 1x1 pixels to force it to release memmory resources.\n    canvas.width = 1;\n    canvas.height = 1;\n    (_canvas_getContext = canvas.getContext('2d')) === null || _canvas_getContext === void 0 ? void 0 : _canvas_getContext.clearRect(0, 0, 1, 1);\n}\nfunction drawBackground(renderer, target, isHovered, hitTestData) {\n    if (renderer._internal_drawBackground) {\n        renderer._internal_drawBackground(target, isHovered, hitTestData);\n    }\n}\nfunction drawForeground(renderer, target, isHovered, hitTestData) {\n    renderer._internal_draw(target, isHovered, hitTestData);\n}\nfunction drawSourceViews(paneViewsGetter, drawRendererFn, source, pane) {\n    const views = paneViewsGetter(source, pane);\n    for (const view of views){\n        const renderer = view._internal_renderer(pane);\n        if (renderer !== null) {\n            drawRendererFn(renderer);\n        }\n    }\n}\nfunction hasPriceScale(source) {\n    return source._internal_priceScale !== undefined;\n}\nfunction buildPriceAxisViewsGetter(zOrder, priceScaleId) {\n    return (source)=>{\n        var _source__internal_priceScale, _source__internal_pricePaneViews;\n        if (!hasPriceScale(source)) {\n            return [];\n        }\n        var _source__internal_priceScale__internal_id;\n        const psId = (_source__internal_priceScale__internal_id = (_source__internal_priceScale = source._internal_priceScale()) === null || _source__internal_priceScale === void 0 ? void 0 : _source__internal_priceScale._internal_id()) !== null && _source__internal_priceScale__internal_id !== void 0 ? _source__internal_priceScale__internal_id : '';\n        if (psId !== priceScaleId) {\n            // exclude if source is using a different price scale.\n            return [];\n        }\n        var _source__internal_pricePaneViews1;\n        return (_source__internal_pricePaneViews1 = (_source__internal_pricePaneViews = source._internal_pricePaneViews) === null || _source__internal_pricePaneViews === void 0 ? void 0 : _source__internal_pricePaneViews.call(source, zOrder)) !== null && _source__internal_pricePaneViews1 !== void 0 ? _source__internal_pricePaneViews1 : [];\n    };\n}\nfunction recalculateOverlapping(views, direction, scaleHeight, rendererOptions) {\n    if (!views.length) {\n        return;\n    }\n    let currentGroupStart = 0;\n    const initLabelHeight = views[0]._internal_height(rendererOptions, true);\n    let spaceBeforeCurrentGroup = direction === 1 ? scaleHeight / 2 - (views[0]._internal_getFixedCoordinate() - initLabelHeight / 2) : views[0]._internal_getFixedCoordinate() - initLabelHeight / 2 - scaleHeight / 2;\n    spaceBeforeCurrentGroup = Math.max(0, spaceBeforeCurrentGroup);\n    for(let i = 1; i < views.length; i++){\n        const view = views[i];\n        const prev = views[i - 1];\n        const height = prev._internal_height(rendererOptions, false);\n        const coordinate = view._internal_getFixedCoordinate();\n        const prevFixedCoordinate = prev._internal_getFixedCoordinate();\n        const overlap = direction === 1 ? coordinate > prevFixedCoordinate - height : coordinate < prevFixedCoordinate + height;\n        if (overlap) {\n            const fixedCoordinate = prevFixedCoordinate - height * direction;\n            view._internal_setFixedCoordinate(fixedCoordinate);\n            const edgePoint = fixedCoordinate - direction * height / 2;\n            const outOfViewport = direction === 1 ? edgePoint < 0 : edgePoint > scaleHeight;\n            if (outOfViewport && spaceBeforeCurrentGroup > 0) {\n                // shift the whole group up or down\n                const desiredGroupShift = direction === 1 ? -1 - edgePoint : edgePoint - scaleHeight;\n                const possibleShift = Math.min(desiredGroupShift, spaceBeforeCurrentGroup);\n                for(let k = currentGroupStart; k < views.length; k++){\n                    views[k]._internal_setFixedCoordinate(views[k]._internal_getFixedCoordinate() + direction * possibleShift);\n                }\n                spaceBeforeCurrentGroup -= possibleShift;\n            }\n        } else {\n            currentGroupStart = i;\n            spaceBeforeCurrentGroup = direction === 1 ? prevFixedCoordinate - height - coordinate : coordinate - (prevFixedCoordinate + height);\n        }\n    }\n}\nfunction priceScaleCrosshairLabelVisible(crosshair) {\n    return crosshair.mode !== 2 /* CrosshairMode.Hidden */  && crosshair.horzLine.visible && crosshair.horzLine.labelVisible;\n}\nclass PriceAxisWidget {\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = null;\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_rendererOptions() {\n        const options = this._private__rendererOptionsProvider._internal_options();\n        const isFontChanged = this._private__font !== options._internal_font;\n        if (isFontChanged) {\n            this._private__widthCache._internal_reset();\n            this._private__font = options._internal_font;\n        }\n        return options;\n    }\n    _internal_optimalWidth() {\n        if (this._private__priceScale === null) {\n            return 0;\n        }\n        let tickMarkMaxWidth = 0;\n        const rendererOptions = this._internal_rendererOptions();\n        const ctx = ensureNotNull(this._private__canvasBinding.canvasElement.getContext('2d', {\n            colorSpace: this._private__pane._internal_chart()._internal_options().layout.colorSpace\n        }));\n        ctx.save();\n        const tickMarks = this._private__priceScale._internal_marks();\n        ctx.font = this._private__baseFont();\n        if (tickMarks.length > 0) {\n            tickMarkMaxWidth = Math.max(this._private__widthCache._internal_measureText(ctx, tickMarks[0]._internal_label), this._private__widthCache._internal_measureText(ctx, tickMarks[tickMarks.length - 1]._internal_label));\n        }\n        const views = this._private__backLabels();\n        for(let j = views.length; j--;){\n            const width = this._private__widthCache._internal_measureText(ctx, views[j]._internal_text());\n            if (width > tickMarkMaxWidth) {\n                tickMarkMaxWidth = width;\n            }\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (firstValue !== null && this._private__size !== null && priceScaleCrosshairLabelVisible(this._private__options.crosshair)) {\n            const topValue = this._private__priceScale._internal_coordinateToPrice(1, firstValue);\n            const bottomValue = this._private__priceScale._internal_coordinateToPrice(this._private__size.height - 2, firstValue);\n            tickMarkMaxWidth = Math.max(tickMarkMaxWidth, this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.floor(Math.min(topValue, bottomValue)) + 0.11111111111111, firstValue)), this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.ceil(Math.max(topValue, bottomValue)) - 0.11111111111111, firstValue)));\n        }\n        ctx.restore();\n        const resultTickMarksMaxWidth = tickMarkMaxWidth || 34 /* Constants.DefaultOptimalWidth */ ;\n        const res = Math.ceil(rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingInner + rendererOptions._internal_paddingOuter + 5 /* Constants.LabelOffset */  + resultTickMarksMaxWidth);\n        // make it even, remove this after migration to perfect fancy canvas\n        return suggestPriceScaleWidth(res);\n    }\n    _internal_setSize(newSize) {\n        if (this._private__size === null || !(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__topCanvasBinding.resizeCanvasElement(newSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = \"\".concat(newSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(newSize.height, \"px\");\n        }\n    }\n    _internal_getWidth() {\n        return ensureNotNull(this._private__size).width;\n    }\n    _internal_setPriceScale(priceScale) {\n        if (this._private__priceScale === priceScale) {\n            return;\n        }\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = priceScale;\n        priceScale._internal_onMarksChanged()._internal_subscribe(this._private__onMarksChanged.bind(this), this);\n    }\n    _internal_priceScale() {\n        return this._private__priceScale;\n    }\n    _internal_reset() {\n        const pane = this._private__pane._internal_state();\n        const model = this._private__pane._internal_chart()._internal_model();\n        model._internal_resetPriceScale(pane, ensureNotNull(this._internal_priceScale()));\n    }\n    _internal_paint(type) {\n        if (this._private__size === null) {\n            return;\n        }\n        const canvasOptions = {\n            colorSpace: this._private__pane._internal_chart()._internal_options().layout.colorSpace\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__alignLabels();\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                });\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourceBottomPaneViews);\n                this._private__drawTickMarks(target);\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourcePaneViews);\n                this._private__drawBackLabels(target);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshairLabel(topTarget);\n            this._private__pane._internal_drawAdditionalSources(topTarget, this._private__sourceTopPaneViews);\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_update() {\n        var // this call has side-effect - it regenerates marks on the price scale\n        _this__private__priceScale;\n        (_this__private__priceScale = this._private__priceScale) === null || _this__private__priceScale === void 0 ? void 0 : _this__private__priceScale._internal_marks();\n    }\n    _private__mouseDownEvent(e) {\n        if (this._private__priceScale === null || this._private__priceScale._internal_isEmpty() || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = true;\n        model._internal_startScalePrice(pane, this._private__priceScale, e.localY);\n    }\n    _private__pressedMouseMoveEvent(e) {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        model._internal_scalePriceTo(pane, priceScale, e.localY);\n    }\n    _private__mouseDownOutsideEvent() {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        if (this._private__mousedown) {\n            this._private__mousedown = false;\n            model._internal_endScalePrice(pane, priceScale);\n        }\n    }\n    _private__mouseUpEvent(e) {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = false;\n        model._internal_endScalePrice(pane, this._private__priceScale);\n    }\n    _private__mouseDoubleClickEvent(e) {\n        if (this._private__options['handleScale'].axisDoubleClickReset.price) {\n            this._internal_reset();\n        }\n    }\n    _private__mouseEnterEvent(e) {\n        if (this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        if (model._internal_options()['handleScale'].axisPressedMouseMove.price && !this._private__priceScale._internal_isPercentage() && !this._private__priceScale._internal_isIndexedTo100()) {\n            this._private__setCursor(1 /* CursorType.NsResize */ );\n        }\n    }\n    _private__mouseLeaveEvent(e) {\n        this._private__setCursor(0 /* CursorType.Default */ );\n    }\n    _private__backLabels() {\n        const res = [];\n        const priceScale = this._private__priceScale === null ? undefined : this._private__priceScale;\n        const addViewsForSources = (sources)=>{\n            for(let i = 0; i < sources.length; ++i){\n                const source = sources[i];\n                const views = source._internal_priceAxisViews(this._private__pane._internal_state(), priceScale);\n                for(let j = 0; j < views.length; j++){\n                    res.push(views[j]);\n                }\n            }\n        };\n        // calculate max and min coordinates for views on selection\n        // crosshair individually\n        addViewsForSources(this._private__pane._internal_state()._internal_orderedSources());\n        return res;\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        const { width, height } = bitmapSize;\n        const model = this._private__pane._internal_state()._internal_model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, topColor);\n        } else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio } = param;\n        if (this._private__size === null || this._private__priceScale === null || !this._private__priceScale._internal_options().borderVisible) {\n            return;\n        }\n        ctx.fillStyle = this._private__priceScale._internal_options().borderColor;\n        const borderSize = Math.max(1, Math.floor(this._internal_rendererOptions()._internal_borderSize * horizontalPixelRatio));\n        let left;\n        if (this._private__isLeft) {\n            left = bitmapSize.width - borderSize;\n        } else {\n            left = 0;\n        }\n        ctx.fillRect(left, 0, borderSize, bitmapSize.height);\n    }\n    _private__drawTickMarks(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const tickMarks = this._private__priceScale._internal_marks();\n        const priceScaleOptions = this._private__priceScale._internal_options();\n        const rendererOptions = this._internal_rendererOptions();\n        const tickMarkLeftX = this._private__isLeft ? this._private__size.width - rendererOptions._internal_tickLength : 0;\n        if (priceScaleOptions.borderVisible && priceScaleOptions.ticksVisible) {\n            target.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n                ctx.fillStyle = priceScaleOptions.borderColor;\n                const tickHeight = Math.max(1, Math.floor(verticalPixelRatio));\n                const tickOffset = Math.floor(verticalPixelRatio * 0.5);\n                const tickLength = Math.round(rendererOptions._internal_tickLength * horizontalPixelRatio);\n                ctx.beginPath();\n                for (const tickMark of tickMarks){\n                    ctx.rect(Math.floor(tickMarkLeftX * horizontalPixelRatio), Math.round(tickMark._internal_coord * verticalPixelRatio) - tickOffset, tickLength, tickHeight);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            ctx.font = this._private__baseFont();\n            var _priceScaleOptions_textColor;\n            ctx.fillStyle = (_priceScaleOptions_textColor = priceScaleOptions.textColor) !== null && _priceScaleOptions_textColor !== void 0 ? _priceScaleOptions_textColor : this._private__layoutOptions.textColor;\n            ctx.textAlign = this._private__isLeft ? 'right' : 'left';\n            ctx.textBaseline = 'middle';\n            const textLeftX = this._private__isLeft ? Math.round(tickMarkLeftX - rendererOptions._internal_paddingInner) : Math.round(tickMarkLeftX + rendererOptions._internal_tickLength + rendererOptions._internal_paddingInner);\n            const yMidCorrections = tickMarks.map((mark)=>this._private__widthCache._internal_yMidCorrection(ctx, mark._internal_label));\n            for(let i = tickMarks.length; i--;){\n                const tickMark = tickMarks[i];\n                ctx.fillText(tickMark._internal_label, textLeftX, tickMark._internal_coord + yMidCorrections[i]);\n            }\n        });\n    }\n    _private__alignLabels() {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        let center = this._private__size.height / 2;\n        const views = [];\n        const orderedSources = this._private__priceScale._internal_orderedSources().slice(); // Copy of array\n        const pane = this._private__pane;\n        const paneState = pane._internal_state();\n        const rendererOptions = this._internal_rendererOptions();\n        // if we are default price scale, append labels from no-scale\n        const isDefault = this._private__priceScale === paneState._internal_defaultVisiblePriceScale();\n        if (isDefault) {\n            this._private__pane._internal_state()._internal_orderedSources().forEach((source)=>{\n                if (paneState._internal_isOverlay(source)) {\n                    orderedSources.push(source);\n                }\n            });\n        }\n        // we can use any, but let's use the first source as \"center\" one\n        const centerSource = this._private__priceScale._internal_dataSources()[0];\n        const priceScale = this._private__priceScale;\n        const updateForSources = (sources)=>{\n            sources.forEach((source)=>{\n                const sourceViews = source._internal_priceAxisViews(paneState, priceScale);\n                // never align selected sources\n                sourceViews.forEach((view)=>{\n                    view._internal_setFixedCoordinate(null);\n                    if (view._internal_isVisible()) {\n                        views.push(view);\n                    }\n                });\n                if (centerSource === source && sourceViews.length > 0) {\n                    center = sourceViews[0]._internal_coordinate();\n                }\n            });\n        };\n        // crosshair individually\n        updateForSources(orderedSources);\n        views.forEach((view)=>view._internal_setFixedCoordinate(view._internal_coordinate()));\n        const options = this._private__priceScale._internal_options();\n        if (!options.alignLabels) {\n            return;\n        }\n        this._private__fixLabelOverlap(views, rendererOptions, center);\n    }\n    _private__fixLabelOverlap(views, rendererOptions, center) {\n        if (this._private__size === null) {\n            return;\n        }\n        // split into two parts\n        const top = views.filter((view)=>view._internal_coordinate() <= center);\n        const bottom = views.filter((view)=>view._internal_coordinate() > center);\n        // sort top from center to top\n        top.sort((l, r)=>r._internal_coordinate() - l._internal_coordinate());\n        // share center label\n        if (top.length && bottom.length) {\n            bottom.push(top[0]);\n        }\n        bottom.sort((l, r)=>l._internal_coordinate() - r._internal_coordinate());\n        for (const view of views){\n            const halfHeight = Math.floor(view._internal_height(rendererOptions) / 2);\n            const coordinate = view._internal_coordinate();\n            if (coordinate > -halfHeight && coordinate < halfHeight) {\n                view._internal_setFixedCoordinate(halfHeight);\n            }\n            if (coordinate > this._private__size.height - halfHeight && coordinate < this._private__size.height + halfHeight) {\n                view._internal_setFixedCoordinate(this._private__size.height - halfHeight);\n            }\n        }\n        recalculateOverlapping(top, 1, this._private__size.height, rendererOptions);\n        recalculateOverlapping(bottom, -1, this._private__size.height, rendererOptions);\n    }\n    _private__drawBackLabels(target) {\n        if (this._private__size === null) {\n            return;\n        }\n        const views = this._private__backLabels();\n        const rendererOptions = this._internal_rendererOptions();\n        const align = this._private__isLeft ? 'right' : 'left';\n        views.forEach((view)=>{\n            if (view._internal_isAxisLabelVisible()) {\n                const renderer = view._internal_renderer(ensureNotNull(this._private__priceScale));\n                renderer._internal_draw(target, rendererOptions, this._private__widthCache, align);\n            }\n        });\n    }\n    _private__drawCrosshairLabel(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const views = []; // array of arrays\n        const pane = this._private__pane._internal_state();\n        const v = model._internal_crosshairSource()._internal_priceAxisViews(pane, this._private__priceScale);\n        if (v.length) {\n            views.push(v);\n        }\n        const ro = this._internal_rendererOptions();\n        const align = this._private__isLeft ? 'right' : 'left';\n        views.forEach((arr)=>{\n            arr.forEach((view)=>{\n                view._internal_renderer(ensureNotNull(this._private__priceScale))._internal_draw(target, ro, this._private__widthCache, align);\n            });\n        });\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.NsResize */  ? 'ns-resize' : 'default';\n    }\n    _private__onMarksChanged() {\n        const width = this._internal_optimalWidth();\n        // avoid price scale is shrunk\n        // using < instead !== to avoid infinite changes\n        if (this._private__prevOptimalWidth < width) {\n            this._private__pane._internal_chart()._internal_model()._internal_fullUpdate();\n        }\n        this._private__prevOptimalWidth = width;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__layoutOptions.fontSize, this._private__layoutOptions.fontFamily);\n    }\n    constructor(pane, options, rendererOptionsProvider, side){\n        this._private__priceScale = null;\n        this._private__size = null;\n        this._private__mousedown = false;\n        this._private__widthCache = new TextWidthCache(200);\n        this._private__font = null;\n        this._private__prevOptimalWidth = 0;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__pane = pane;\n        this._private__options = options;\n        this._private__layoutOptions = options['layout'];\n        this._private__rendererOptionsProvider = rendererOptionsProvider;\n        this._private__isLeft = side === 'left';\n        this._private__sourcePaneViews = buildPriceAxisViewsGetter('normal', side);\n        this._private__sourceTopPaneViews = buildPriceAxisViewsGetter('top', side);\n        this._private__sourceBottomPaneViews = buildPriceAxisViewsGetter('bottom', side);\n        this._private__cell = document.createElement('div');\n        this._private__cell.style.height = '100%';\n        this._private__cell.style.overflow = 'hidden';\n        this._private__cell.style.width = '25px';\n        this._private__cell.style.left = '0';\n        this._private__cell.style.position = 'relative';\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        const handler = {\n            _internal_mouseDownEvent: this._private__mouseDownEvent.bind(this),\n            _internal_touchStartEvent: this._private__mouseDownEvent.bind(this),\n            _internal_pressedMouseMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_touchMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_mouseDownOutsideEvent: this._private__mouseDownOutsideEvent.bind(this),\n            _internal_mouseUpEvent: this._private__mouseUpEvent.bind(this),\n            _internal_touchEndEvent: this._private__mouseUpEvent.bind(this),\n            _internal_mouseDoubleClickEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_doubleTapEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_mouseEnterEvent: this._private__mouseEnterEvent.bind(this),\n            _internal_mouseLeaveEvent: this._private__mouseLeaveEvent.bind(this)\n        };\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, handler, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>!this._private__options['handleScroll'].vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>true\n        });\n    }\n}\nfunction sourceBottomPaneViews$1(source, pane) {\n    var _source__internal_bottomPaneViews;\n    var _source__internal_bottomPaneViews1;\n    return (_source__internal_bottomPaneViews1 = (_source__internal_bottomPaneViews = source._internal_bottomPaneViews) === null || _source__internal_bottomPaneViews === void 0 ? void 0 : _source__internal_bottomPaneViews.call(source, pane)) !== null && _source__internal_bottomPaneViews1 !== void 0 ? _source__internal_bottomPaneViews1 : [];\n}\nfunction sourcePaneViews$1(source, pane) {\n    var _source__internal_paneViews;\n    var _source__internal_paneViews1;\n    return (_source__internal_paneViews1 = (_source__internal_paneViews = source._internal_paneViews) === null || _source__internal_paneViews === void 0 ? void 0 : _source__internal_paneViews.call(source, pane)) !== null && _source__internal_paneViews1 !== void 0 ? _source__internal_paneViews1 : [];\n}\nfunction sourceLabelPaneViews(source, pane) {\n    var _source__internal_labelPaneViews;\n    var _source__internal_labelPaneViews1;\n    return (_source__internal_labelPaneViews1 = (_source__internal_labelPaneViews = source._internal_labelPaneViews) === null || _source__internal_labelPaneViews === void 0 ? void 0 : _source__internal_labelPaneViews.call(source, pane)) !== null && _source__internal_labelPaneViews1 !== void 0 ? _source__internal_labelPaneViews1 : [];\n}\nfunction sourceTopPaneViews$1(source, pane) {\n    var _source__internal_topPaneViews;\n    var _source__internal_topPaneViews1;\n    return (_source__internal_topPaneViews1 = (_source__internal_topPaneViews = source._internal_topPaneViews) === null || _source__internal_topPaneViews === void 0 ? void 0 : _source__internal_topPaneViews.call(source, pane)) !== null && _source__internal_topPaneViews1 !== void 0 ? _source__internal_topPaneViews1 : [];\n}\nclass PaneWidget {\n    _internal_destroy() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_destroy();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_destroy();\n        }\n        this._private__attributionLogoWidget = null;\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n            this._private__state._internal_destroy();\n        }\n        this._private__mouseEventHandler._internal_destroy();\n    }\n    _internal_state() {\n        return ensureNotNull(this._private__state);\n    }\n    _internal_setState(pane) {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = pane;\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_subscribe(PaneWidget.prototype._private__onStateDestroyed.bind(this), this, true);\n        }\n        this._internal_updatePriceAxisWidgetsStates();\n        if (this._private__chart._internal_paneWidgets().indexOf(this) === this._private__chart._internal_paneWidgets().length - 1) {\n            var _this__private__attributionLogoWidget;\n            this._private__attributionLogoWidget = (_this__private__attributionLogoWidget = this._private__attributionLogoWidget) !== null && _this__private__attributionLogoWidget !== void 0 ? _this__private__attributionLogoWidget : new AttributionLogoWidget(this._private__paneCell, this._private__chart);\n            this._private__attributionLogoWidget._internal_update();\n        } else {\n            var _this__private__attributionLogoWidget1;\n            (_this__private__attributionLogoWidget1 = this._private__attributionLogoWidget) === null || _this__private__attributionLogoWidget1 === void 0 ? void 0 : _this__private__attributionLogoWidget1._internal_removeElement();\n            this._private__attributionLogoWidget = null;\n        }\n    }\n    _internal_chart() {\n        return this._private__chart;\n    }\n    _internal_getElement() {\n        return this._private__rowElement;\n    }\n    _internal_updatePriceAxisWidgetsStates() {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__recreatePriceAxisWidgets();\n        if (this._private__model()._internal_serieses().length === 0) {\n            return;\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            const leftPriceScale = this._private__state._internal_leftPriceScale();\n            this._private__leftPriceAxisWidget._internal_setPriceScale(ensureNotNull(leftPriceScale));\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            const rightPriceScale = this._private__state._internal_rightPriceScale();\n            this._private__rightPriceAxisWidget._internal_setPriceScale(ensureNotNull(rightPriceScale));\n        }\n    }\n    _internal_updatePriceAxisWidgets() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_update();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_update();\n        }\n    }\n    _internal_stretchFactor() {\n        return this._private__state !== null ? this._private__state._internal_stretchFactor() : 0;\n    }\n    _internal_setStretchFactor(stretchFactor) {\n        if (this._private__state) {\n            this._private__state._internal_setStretchFactor(stretchFactor);\n        }\n    }\n    _internal_mouseEnterEvent(event) {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n    }\n    _internal_mouseDownEvent(event) {\n        this._private__onMouseEvent();\n        this._private__mouseTouchDownEvent();\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseMoveEvent(event) {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n    }\n    _internal_mouseClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_mouseDoubleClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireMouseClickDelegate(this._private__dblClicked, event);\n    }\n    _internal_doubleTapEvent(event) {\n        this._internal_mouseDoubleClickEvent(event);\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        this._private__onMouseEvent();\n        this._private__pressedMouseTouchMoveEvent(event);\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseUpEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__longTap = false;\n        this._private__endScroll(event);\n    }\n    _internal_tapEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_longTapEvent(event) {\n        this._private__longTap = true;\n        if (this._private__startTrackPoint === null) {\n            const point = {\n                x: event.localX,\n                y: event.localY\n            };\n            this._private__startTrackingMode(point, point, event);\n        }\n    }\n    _internal_mouseLeaveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__state._internal_model()._internal_setHoveredSource(null);\n        this._private__clearCrosshairPosition();\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_pinchStartEvent() {\n        this._private__prevPinchScale = 1;\n        this._private__model()._internal_stopTimeScaleAnimation();\n    }\n    _internal_pinchEvent(middlePoint, scale) {\n        if (!this._private__chart._internal_options()['handleScale'].pinch) {\n            return;\n        }\n        const zoomScale = (scale - this._private__prevPinchScale) * 5;\n        this._private__prevPinchScale = scale;\n        this._private__model()._internal_zoomTime(middlePoint._internal_x, zoomScale);\n    }\n    _internal_touchStartEvent(event) {\n        this._private__longTap = false;\n        this._private__exitTrackingModeOnNextTry = this._private__startTrackPoint !== null;\n        this._private__mouseTouchDownEvent();\n        const crosshair = this._private__model()._internal_crosshairSource();\n        if (this._private__startTrackPoint !== null && crosshair._internal_visible()) {\n            this._private__initCrosshairPosition = {\n                x: crosshair._internal_appliedX(),\n                y: crosshair._internal_appliedY()\n            };\n            this._private__startTrackPoint = {\n                x: event.localX,\n                y: event.localY\n            };\n        }\n    }\n    _internal_touchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const x = event.localX;\n        const y = event.localY;\n        if (this._private__startTrackPoint !== null) {\n            // tracking mode: move crosshair\n            this._private__exitTrackingModeOnNextTry = false;\n            const origPoint = ensureNotNull(this._private__initCrosshairPosition);\n            const newX = origPoint.x + (x - this._private__startTrackPoint.x);\n            const newY = origPoint.y + (y - this._private__startTrackPoint.y);\n            this._private__setCrosshairPosition(newX, newY, event);\n            return;\n        }\n        this._private__pressedMouseTouchMoveEvent(event);\n    }\n    _internal_touchEndEvent(event) {\n        if (this._internal_chart()._internal_options().trackingMode.exitMode === 0 /* TrackingModeExitMode.OnTouchEnd */ ) {\n            this._private__exitTrackingModeOnNextTry = true;\n        }\n        this._private__tryExitTrackingMode();\n        this._private__endScroll(event);\n    }\n    _internal_hitTest(x, y) {\n        const state = this._private__state;\n        if (state === null) {\n            return null;\n        }\n        return hitTestPane(state, x, y);\n    }\n    _internal_setPriceAxisSize(width, position) {\n        const priceAxisWidget = position === 'left' ? this._private__leftPriceAxisWidget : this._private__rightPriceAxisWidget;\n        ensureNotNull(priceAxisWidget)._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width,\n            height: this._private__size.height\n        }));\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if ((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            return;\n        }\n        this._private__size = newSize;\n        this._private__isSettingSize = true;\n        this._private__canvasBinding.resizeCanvasElement(newSize);\n        this._private__topCanvasBinding.resizeCanvasElement(newSize);\n        this._private__isSettingSize = false;\n        this._private__paneCell.style.width = newSize.width + 'px';\n        this._private__paneCell.style.height = newSize.height + 'px';\n    }\n    _internal_recalculatePriceScales() {\n        const pane = ensureNotNull(this._private__state);\n        pane._internal_recalculatePriceScale(pane._internal_leftPriceScale());\n        pane._internal_recalculatePriceScale(pane._internal_rightPriceScale());\n        for (const source of pane._internal_dataSources()){\n            if (pane._internal_isOverlay(source)) {\n                const priceScale = source._internal_priceScale();\n                if (priceScale !== null) {\n                    pane._internal_recalculatePriceScale(priceScale);\n                }\n                // for overlay drawings price scale is owner's price scale\n                // however owner's price scale could not contain ds\n                source._internal_updateAllViews();\n            }\n        }\n        for (const primitive of pane._internal_primitives()){\n            primitive._internal_updateAllViews();\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */ ) {\n            return;\n        }\n        if (this._private__state === null) {\n            return;\n        }\n        if (type > 1 /* InvalidationLevel.Cursor */ ) {\n            this._internal_recalculatePriceScales();\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_paint(type);\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_paint(type);\n        }\n        const canvasOptions = {\n            colorSpace: this._private__chart._internal_options().layout.colorSpace\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                });\n                if (this._private__state) {\n                    this._private__drawSources(target, sourceBottomPaneViews$1);\n                    this._private__drawGrid(target);\n                    this._private__drawSources(target, sourcePaneViews$1);\n                    this._private__drawSources(target, sourceLabelPaneViews);\n                }\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshair(topTarget);\n            this._private__drawSources(topTarget, sourceTopPaneViews$1);\n            this._private__drawSources(topTarget, sourceLabelPaneViews);\n        }\n    }\n    _internal_leftPriceAxisWidget() {\n        return this._private__leftPriceAxisWidget;\n    }\n    _internal_rightPriceAxisWidget() {\n        return this._private__rightPriceAxisWidget;\n    }\n    _internal_drawAdditionalSources(target, paneViewsGetter) {\n        this._private__drawSources(target, paneViewsGetter);\n    }\n    _private__onStateDestroyed() {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = null;\n    }\n    _private__fireClickedDelegate(event) {\n        this._private__fireMouseClickDelegate(this._private__clicked, event);\n    }\n    _private__fireMouseClickDelegate(delegate, event) {\n        const x = event.localX;\n        const y = event.localY;\n        if (delegate._internal_hasListeners()) {\n            delegate._internal_fire(this._private__model()._internal_timeScale()._internal_coordinateToIndex(x), {\n                x,\n                y\n            }, event);\n        }\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        const { width, height } = bitmapSize;\n        const model = this._private__model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, bottomColor);\n        } else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawGrid(target) {\n        const state = ensureNotNull(this._private__state);\n        const paneView = state._internal_grid()._internal_paneView();\n        const renderer = paneView._internal_renderer(state);\n        if (renderer !== null) {\n            renderer._internal_draw(target, false);\n        }\n    }\n    _private__drawCrosshair(target) {\n        this._private__drawSourceImpl(target, sourcePaneViews$1, drawForeground, this._private__model()._internal_crosshairSource());\n    }\n    _private__drawSources(target, paneViewsGetter) {\n        const state = ensureNotNull(this._private__state);\n        const sources = state._internal_orderedSources();\n        const panePrimitives = state._internal_primitives();\n        for (const panePrimitive of panePrimitives){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawBackground, panePrimitive);\n        }\n        for (const source of sources){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawBackground, source);\n        }\n        for (const panePrimitive of panePrimitives){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawForeground, panePrimitive);\n        }\n        for (const source of sources){\n            this._private__drawSourceImpl(target, paneViewsGetter, drawForeground, source);\n        }\n    }\n    _private__drawSourceImpl(target, paneViewsGetter, drawFn, source) {\n        const state = ensureNotNull(this._private__state);\n        const hoveredSource = state._internal_model()._internal_hoveredSource();\n        const isHovered = hoveredSource !== null && hoveredSource._internal_source === source;\n        const objecId = hoveredSource !== null && isHovered && hoveredSource._internal_object !== undefined ? hoveredSource._internal_object._internal_hitTestData : undefined;\n        const drawRendererFn = (renderer)=>drawFn(renderer, target, isHovered, objecId);\n        drawSourceViews(paneViewsGetter, drawRendererFn, source, state);\n    }\n    _private__recreatePriceAxisWidgets() {\n        if (this._private__state === null) {\n            return;\n        }\n        const chart = this._private__chart;\n        const leftAxisVisible = this._private__state._internal_leftPriceScale()._internal_options().visible;\n        const rightAxisVisible = this._private__state._internal_rightPriceScale()._internal_options().visible;\n        if (!leftAxisVisible && this._private__leftPriceAxisWidget !== null) {\n            this._private__leftAxisCell.removeChild(this._private__leftPriceAxisWidget._internal_getElement());\n            this._private__leftPriceAxisWidget._internal_destroy();\n            this._private__leftPriceAxisWidget = null;\n        }\n        if (!rightAxisVisible && this._private__rightPriceAxisWidget !== null) {\n            this._private__rightAxisCell.removeChild(this._private__rightPriceAxisWidget._internal_getElement());\n            this._private__rightPriceAxisWidget._internal_destroy();\n            this._private__rightPriceAxisWidget = null;\n        }\n        const rendererOptionsProvider = chart._internal_model()._internal_rendererOptionsProvider();\n        if (leftAxisVisible && this._private__leftPriceAxisWidget === null) {\n            this._private__leftPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, 'left');\n            this._private__leftAxisCell.appendChild(this._private__leftPriceAxisWidget._internal_getElement());\n        }\n        if (rightAxisVisible && this._private__rightPriceAxisWidget === null) {\n            this._private__rightPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, 'right');\n            this._private__rightAxisCell.appendChild(this._private__rightPriceAxisWidget._internal_getElement());\n        }\n    }\n    _private__preventScroll(event) {\n        return event._internal_isTouch && this._private__longTap || this._private__startTrackPoint !== null;\n    }\n    _private__correctXCoord(x) {\n        return Math.max(0, Math.min(x, this._private__size.width - 1));\n    }\n    _private__correctYCoord(y) {\n        return Math.max(0, Math.min(y, this._private__size.height - 1));\n    }\n    _private__setCrosshairPosition(x, y, event) {\n        this._private__model()._internal_setAndSaveCurrentPosition(this._private__correctXCoord(x), this._private__correctYCoord(y), event, ensureNotNull(this._private__state));\n    }\n    _private__clearCrosshairPosition() {\n        this._private__model()._internal_clearCurrentPosition();\n    }\n    _private__tryExitTrackingMode() {\n        if (this._private__exitTrackingModeOnNextTry) {\n            this._private__startTrackPoint = null;\n            this._private__clearCrosshairPosition();\n        }\n    }\n    _private__startTrackingMode(startTrackPoint, crossHairPosition, event) {\n        this._private__startTrackPoint = startTrackPoint;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__setCrosshairPosition(crossHairPosition.x, crossHairPosition.y, event);\n        const crosshair = this._private__model()._internal_crosshairSource();\n        this._private__initCrosshairPosition = {\n            x: crosshair._internal_appliedX(),\n            y: crosshair._internal_appliedY()\n        };\n    }\n    _private__model() {\n        return this._private__chart._internal_model();\n    }\n    _private__endScroll(event) {\n        if (!this._private__isScrolling) {\n            return;\n        }\n        const model = this._private__model();\n        const state = this._internal_state();\n        model._internal_endScrollPrice(state, state._internal_defaultPriceScale());\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        model._internal_endScrollTime();\n        if (this._private__scrollXAnimation !== null) {\n            const startAnimationTime = performance.now();\n            const timeScale = model._internal_timeScale();\n            this._private__scrollXAnimation._internal_start(timeScale._internal_rightOffset(), startAnimationTime);\n            if (!this._private__scrollXAnimation._internal_finished(startAnimationTime)) {\n                model._internal_setTimeScaleAnimation(this._private__scrollXAnimation);\n            }\n        }\n    }\n    _private__onMouseEvent() {\n        this._private__startTrackPoint = null;\n    }\n    _private__mouseTouchDownEvent() {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__model()._internal_stopTimeScaleAnimation();\n        if (document.activeElement !== document.body && document.activeElement !== document.documentElement) {\n            // If any focusable element except the page itself is focused, remove the focus\n            ensureNotNull(document.activeElement).blur();\n        } else {\n            // Clear selection\n            const selection = document.getSelection();\n            if (selection !== null) {\n                selection.removeAllRanges();\n            }\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        if (priceScale._internal_isEmpty() || this._private__model()._internal_timeScale()._internal_isEmpty()) {\n            return;\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__pressedMouseTouchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const model = this._private__model();\n        const timeScale = model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        const chartOptions = this._private__chart._internal_options();\n        const scrollOptions = chartOptions['handleScroll'];\n        const kineticScrollOptions = chartOptions.kineticScroll;\n        if ((!scrollOptions.pressedMouseMove || event._internal_isTouch) && (!scrollOptions.horzTouchDrag && !scrollOptions.vertTouchDrag || !event._internal_isTouch)) {\n            return;\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        const now = performance.now();\n        if (this._private__startScrollingPos === null && !this._private__preventScroll(event)) {\n            this._private__startScrollingPos = {\n                x: event.clientX,\n                y: event.clientY,\n                _internal_timestamp: now,\n                _internal_localX: event.localX,\n                _internal_localY: event.localY\n            };\n        }\n        if (this._private__startScrollingPos !== null && !this._private__isScrolling && (this._private__startScrollingPos.x !== event.clientX || this._private__startScrollingPos.y !== event.clientY)) {\n            if (event._internal_isTouch && kineticScrollOptions.touch || !event._internal_isTouch && kineticScrollOptions.mouse) {\n                const barSpacing = timeScale._internal_barSpacing();\n                this._private__scrollXAnimation = new KineticAnimation(0.2 /* KineticScrollConstants.MinScrollSpeed */  / barSpacing, 7 /* KineticScrollConstants.MaxScrollSpeed */  / barSpacing, 0.997 /* KineticScrollConstants.DumpingCoeff */ , 15 /* KineticScrollConstants.ScrollMinMove */  / barSpacing);\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), this._private__startScrollingPos._internal_timestamp);\n            } else {\n                this._private__scrollXAnimation = null;\n            }\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_startScrollPrice(this._private__state, priceScale, event.localY);\n            }\n            model._internal_startScrollTime(event.localX);\n            this._private__isScrolling = true;\n        }\n        if (this._private__isScrolling) {\n            // this allows scrolling not default price scales\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_scrollPriceTo(this._private__state, priceScale, event.localY);\n            }\n            model._internal_scrollTimeTo(event.localX);\n            if (this._private__scrollXAnimation !== null) {\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), now);\n            }\n        }\n    }\n    constructor(chart, state){\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__leftPriceAxisWidget = null;\n        this._private__rightPriceAxisWidget = null;\n        this._private__attributionLogoWidget = null;\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__prevPinchScale = 0;\n        this._private__longTap = false;\n        this._private__startTrackPoint = null;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__initCrosshairPosition = null;\n        this._private__scrollXAnimation = null;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__chart = chart;\n        this._private__state = state;\n        this._private__state._internal_onDestroyed()._internal_subscribe(this._private__onStateDestroyed.bind(this), this, true);\n        this._private__paneCell = document.createElement('td');\n        this._private__paneCell.style.padding = '0';\n        this._private__paneCell.style.position = 'relative';\n        const paneWrapper = document.createElement('div');\n        paneWrapper.style.width = '100%';\n        paneWrapper.style.height = '100%';\n        paneWrapper.style.position = 'relative';\n        paneWrapper.style.overflow = 'hidden';\n        this._private__leftAxisCell = document.createElement('td');\n        this._private__leftAxisCell.style.padding = '0';\n        this._private__rightAxisCell = document.createElement('td');\n        this._private__rightAxisCell.style.padding = '0';\n        this._private__paneCell.appendChild(paneWrapper);\n        this._private__canvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        this._private__rowElement = document.createElement('tr');\n        this._private__rowElement.appendChild(this._private__leftAxisCell);\n        this._private__rowElement.appendChild(this._private__paneCell);\n        this._private__rowElement.appendChild(this._private__rightAxisCell);\n        this._internal_updatePriceAxisWidgetsStates();\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>this._private__startTrackPoint === null && !this._private__chart._internal_options()['handleScroll'].vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>this._private__startTrackPoint === null && !this._private__chart._internal_options()['handleScroll'].horzTouchDrag\n        });\n    }\n}\nclass PriceAxisStub {\n    _internal_destroy() {\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__cell.style.width = \"\".concat(newSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(newSize.height, \"px\");\n            this._private__invalidated = true;\n        }\n    }\n    _internal_paint(type) {\n        if (type < 3 /* InvalidationLevel.Full */  && !this._private__invalidated) {\n            return;\n        }\n        if (this._private__size.width === 0 || this._private__size.height === 0) {\n            return;\n        }\n        this._private__invalidated = false;\n        this._private__canvasBinding.applySuggestedBitmapSize();\n        const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, {\n            colorSpace: this._private__options.layout.colorSpace\n        });\n        if (target !== null) {\n            target.useBitmapCoordinateSpace((scope)=>{\n                this._private__drawBackground(scope);\n                this._private__drawBorder(scope);\n            });\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (!this._private__borderVisible()) {\n            return;\n        }\n        ctx.fillStyle = this._private__options.timeScale.borderColor;\n        const horzBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * horizontalPixelRatio);\n        const vertBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * verticalPixelRatio);\n        const left = this._private__isLeft ? bitmapSize.width - horzBorderSize : 0;\n        ctx.fillRect(left, 0, horzBorderSize, vertBorderSize);\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__bottomColor());\n    }\n    constructor(side, options, params, borderVisible, bottomColor){\n        this._private__invalidated = true;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>this._internal_paint(3 /* InvalidationLevel.Full */ );\n        this._private__isLeft = side === 'left';\n        this._private__rendererOptionsProvider = params._internal_rendererOptionsProvider;\n        this._private__options = options;\n        this._private__borderVisible = borderVisible;\n        this._private__bottomColor = bottomColor;\n        this._private__cell = document.createElement('div');\n        this._private__cell.style.width = '25px';\n        this._private__cell.style.height = '100%';\n        this._private__cell.style.overflow = 'hidden';\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n    }\n}\nfunction buildTimeAxisViewsGetter(zOrder) {\n    return (source)=>{\n        var _source__internal_timePaneViews;\n        var _source__internal_timePaneViews1;\n        return (_source__internal_timePaneViews1 = (_source__internal_timePaneViews = source._internal_timePaneViews) === null || _source__internal_timePaneViews === void 0 ? void 0 : _source__internal_timePaneViews.call(source, zOrder)) !== null && _source__internal_timePaneViews1 !== void 0 ? _source__internal_timePaneViews1 : [];\n    };\n}\nconst sourcePaneViews = buildTimeAxisViewsGetter('normal');\nconst sourceTopPaneViews = buildTimeAxisViewsGetter('top');\nconst sourceBottomPaneViews = buildTimeAxisViewsGetter('bottom');\nclass TimeAxisWidget {\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_destroy();\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_destroy();\n        }\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__element;\n    }\n    _internal_leftStub() {\n        return this._private__leftStub;\n    }\n    _internal_rightStub() {\n        return this._private__rightStub;\n    }\n    _internal_mouseDownEvent(event) {\n        if (this._private__mouseDown) {\n            return;\n        }\n        this._private__mouseDown = true;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_startScaleTime(event.localX);\n    }\n    _internal_touchStartEvent(event) {\n        this._internal_mouseDownEvent(event);\n    }\n    _internal_mouseDownOutsideEvent() {\n        const model = this._private__chart._internal_model();\n        if (!model._internal_timeScale()._internal_isEmpty() && this._private__mouseDown) {\n            this._private__mouseDown = false;\n            if (this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n                model._internal_endScaleTime();\n            }\n        }\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_scaleTimeTo(event.localX);\n    }\n    _internal_touchMoveEvent(event) {\n        this._internal_pressedMouseMoveEvent(event);\n    }\n    _internal_mouseUpEvent() {\n        this._private__mouseDown = false;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() && !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_endScaleTime();\n    }\n    _internal_touchEndEvent() {\n        this._internal_mouseUpEvent();\n    }\n    _internal_mouseDoubleClickEvent() {\n        if (this._private__chart._internal_options()['handleScale'].axisDoubleClickReset.time) {\n            this._private__chart._internal_model()._internal_resetTimeScale();\n        }\n    }\n    _internal_doubleTapEvent() {\n        this._internal_mouseDoubleClickEvent();\n    }\n    _internal_mouseEnterEvent() {\n        if (this._private__chart._internal_model()._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            this._private__setCursor(1 /* CursorType.EwResize */ );\n        }\n    }\n    _internal_mouseLeaveEvent() {\n        this._private__setCursor(0 /* CursorType.Default */ );\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_sizeChanged() {\n        return this._private__sizeChanged;\n    }\n    _internal_setSizes(timeAxisSize, leftStubWidth, rightStubWidth) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, timeAxisSize)) {\n            this._private__size = timeAxisSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__topCanvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = \"\".concat(timeAxisSize.width, \"px\");\n            this._private__cell.style.height = \"\".concat(timeAxisSize.height, \"px\");\n            this._private__sizeChanged._internal_fire(timeAxisSize);\n        }\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: leftStubWidth,\n                height: timeAxisSize.height\n            }));\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: rightStubWidth,\n                height: timeAxisSize.height\n            }));\n        }\n    }\n    _internal_optimalHeight() {\n        const rendererOptions = this._private__getRendererOptions();\n        return Math.ceil(// rendererOptions.offsetSize +\n        rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_fontSize + rendererOptions._internal_paddingTop + rendererOptions._internal_paddingBottom + rendererOptions._internal_labelBottomOffset);\n    }\n    _internal_update() {\n        // this call has side-effect - it regenerates marks on the time scale\n        this._private__chart._internal_model()._internal_timeScale()._internal_marks();\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */ ) {\n            return;\n        }\n        const canvasOptions = {\n            colorSpace: this._private__options.colorSpace\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */ ) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope)=>{\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                    this._private__drawAdditionalSources(target, sourceBottomPaneViews);\n                });\n                this._private__drawTickMarks(target);\n                this._private__drawAdditionalSources(target, sourcePaneViews);\n            // atm we don't have sources to be drawn on time axis except crosshair which is rendered on top level canvas\n            // so let's don't call this code at all for now\n            // this._drawLabels(this._chart.model().dataSources(), target);\n            }\n            if (this._private__leftStub !== null) {\n                this._private__leftStub._internal_paint(type);\n            }\n            if (this._private__rightStub !== null) {\n                this._private__rightStub._internal_paint(type);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, bitmapSize } = param;\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawLabels([\n                ...this._private__chart._internal_model()._internal_serieses(),\n                this._private__chart._internal_model()._internal_crosshairSource()\n            ], topTarget);\n            this._private__drawAdditionalSources(topTarget, sourceTopPaneViews);\n        }\n    }\n    _private__drawAdditionalSources(target, axisViewsGetter) {\n        const sources = this._private__chart._internal_model()._internal_serieses();\n        for (const source of sources){\n            drawSourceViews(axisViewsGetter, (renderer)=>drawBackground(renderer, target, false, undefined), source, undefined);\n        }\n        for (const source of sources){\n            drawSourceViews(axisViewsGetter, (renderer)=>drawForeground(renderer, target, false, undefined), source, undefined);\n        }\n    }\n    _private__drawBackground(param) {\n        let { context: ctx, bitmapSize } = param;\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__chart._internal_model()._internal_backgroundBottomColor());\n    }\n    _private__drawBorder(param) {\n        let { context: ctx, bitmapSize, verticalPixelRatio } = param;\n        if (this._private__chart._internal_options().timeScale.borderVisible) {\n            ctx.fillStyle = this._private__lineColor();\n            const borderSize = Math.max(1, Math.floor(this._private__getRendererOptions()._internal_borderSize * verticalPixelRatio));\n            ctx.fillRect(0, 0, bitmapSize.width, borderSize);\n        }\n    }\n    _private__drawTickMarks(target) {\n        const timeScale = this._private__chart._internal_model()._internal_timeScale();\n        const tickMarks = timeScale._internal_marks();\n        if (!tickMarks || tickMarks.length === 0) {\n            return;\n        }\n        const maxWeight = this._private__horzScaleBehavior.maxTickMarkWeight(tickMarks);\n        const rendererOptions = this._private__getRendererOptions();\n        const options = timeScale._internal_options();\n        if (options.borderVisible && options.ticksVisible) {\n            target.useBitmapCoordinateSpace((param)=>{\n                let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n                ctx.strokeStyle = this._private__lineColor();\n                ctx.fillStyle = this._private__lineColor();\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.beginPath();\n                const tickLen = Math.round(rendererOptions._internal_tickLength * verticalPixelRatio);\n                for(let index = tickMarks.length; index--;){\n                    const x = Math.round(tickMarks[index].coord * horizontalPixelRatio);\n                    ctx.rect(x - tickOffset, 0, tickWidth, tickLen);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace((param)=>{\n            let { context: ctx } = param;\n            const yText = rendererOptions._internal_borderSize + rendererOptions._internal_tickLength + rendererOptions._internal_paddingTop + rendererOptions._internal_fontSize / 2;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = this._private__textColor();\n            // draw base marks\n            ctx.font = this._private__baseFont();\n            for (const tickMark of tickMarks){\n                if (tickMark.weight < maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n            if (this._private__chart._internal_options().timeScale.allowBoldLabels) {\n                ctx.font = this._private__baseBoldFont();\n            }\n            for (const tickMark of tickMarks){\n                if (tickMark.weight >= maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n        });\n    }\n    _private__alignTickMarkLabelCoordinate(ctx, coordinate, labelText) {\n        const labelWidth = this._private__widthCache._internal_measureText(ctx, labelText);\n        const labelWidthHalf = labelWidth / 2;\n        const leftTextCoordinate = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (leftTextCoordinate < 0) {\n            coordinate = coordinate + Math.abs(0 - leftTextCoordinate);\n        } else if (leftTextCoordinate + labelWidth > this._private__size.width) {\n            coordinate = coordinate - Math.abs(this._private__size.width - (leftTextCoordinate + labelWidth));\n        }\n        return coordinate;\n    }\n    _private__drawLabels(sources, target) {\n        const rendererOptions = this._private__getRendererOptions();\n        for (const source of sources){\n            for (const view of source._internal_timeAxisViews()){\n                view._internal_renderer()._internal_draw(target, rendererOptions);\n            }\n        }\n    }\n    _private__lineColor() {\n        return this._private__chart._internal_options().timeScale.borderColor;\n    }\n    _private__textColor() {\n        return this._private__options.textColor;\n    }\n    _private__fontSize() {\n        return this._private__options.fontSize;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily);\n    }\n    _private__baseBoldFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily, 'bold');\n    }\n    _private__getRendererOptions() {\n        if (this._private__rendererOptions === null) {\n            this._private__rendererOptions = {\n                _internal_borderSize: 1 /* Constants.BorderSize */ ,\n                _internal_baselineOffset: NaN,\n                _internal_paddingTop: NaN,\n                _internal_paddingBottom: NaN,\n                _internal_paddingHorizontal: NaN,\n                _internal_tickLength: 5 /* Constants.TickLength */ ,\n                _internal_fontSize: NaN,\n                _internal_font: '',\n                _internal_widthCache: new TextWidthCache(),\n                _internal_labelBottomOffset: 0\n            };\n        }\n        const rendererOptions = this._private__rendererOptions;\n        const newFont = this._private__baseFont();\n        if (rendererOptions._internal_font !== newFont) {\n            const fontSize = this._private__fontSize();\n            rendererOptions._internal_fontSize = fontSize;\n            rendererOptions._internal_font = newFont;\n            rendererOptions._internal_paddingTop = 3 * fontSize / 12;\n            rendererOptions._internal_paddingBottom = 3 * fontSize / 12;\n            rendererOptions._internal_paddingHorizontal = 9 * fontSize / 12;\n            rendererOptions._internal_baselineOffset = 0;\n            rendererOptions._internal_labelBottomOffset = 4 * fontSize / 12;\n            rendererOptions._internal_widthCache._internal_reset();\n        }\n        return this._private__rendererOptions;\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.EwResize */  ? 'ew-resize' : 'default';\n    }\n    _private__recreateStubs() {\n        const model = this._private__chart._internal_model();\n        const options = model._internal_options();\n        if (!options.leftPriceScale.visible && this._private__leftStub !== null) {\n            this._private__leftStubCell.removeChild(this._private__leftStub._internal_getElement());\n            this._private__leftStub._internal_destroy();\n            this._private__leftStub = null;\n        }\n        if (!options.rightPriceScale.visible && this._private__rightStub !== null) {\n            this._private__rightStubCell.removeChild(this._private__rightStub._internal_getElement());\n            this._private__rightStub._internal_destroy();\n            this._private__rightStub = null;\n        }\n        const rendererOptionsProvider = this._private__chart._internal_model()._internal_rendererOptionsProvider();\n        const params = {\n            _internal_rendererOptionsProvider: rendererOptionsProvider\n        };\n        const borderVisibleGetter = ()=>{\n            return options.leftPriceScale.borderVisible && model._internal_timeScale()._internal_options().borderVisible;\n        };\n        const bottomColorGetter = ()=>model._internal_backgroundBottomColor();\n        if (options.leftPriceScale.visible && this._private__leftStub === null) {\n            this._private__leftStub = new PriceAxisStub('left', options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__leftStubCell.appendChild(this._private__leftStub._internal_getElement());\n        }\n        if (options.rightPriceScale.visible && this._private__rightStub === null) {\n            this._private__rightStub = new PriceAxisStub('right', options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__rightStubCell.appendChild(this._private__rightStub._internal_getElement());\n        }\n    }\n    constructor(chartWidget, horzScaleBehavior){\n        this._private__leftStub = null;\n        this._private__rightStub = null;\n        this._private__rendererOptions = null;\n        this._private__mouseDown = false;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 0,\n            height: 0\n        });\n        this._private__sizeChanged = new Delegate();\n        this._private__widthCache = new TextWidthCache(5);\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = ()=>{\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__chart = chartWidget;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__options = chartWidget._internal_options()['layout'];\n        this._private__element = document.createElement('tr');\n        this._private__leftStubCell = document.createElement('td');\n        this._private__leftStubCell.style.padding = '0';\n        this._private__rightStubCell = document.createElement('td');\n        this._private__rightStubCell.style.padding = '0';\n        this._private__cell = document.createElement('td');\n        this._private__cell.style.height = '25px';\n        this._private__cell.style.padding = '0';\n        this._private__dv = document.createElement('div');\n        this._private__dv.style.width = '100%';\n        this._private__dv.style.height = '100%';\n        this._private__dv.style.position = 'relative';\n        this._private__dv.style.overflow = 'hidden';\n        this._private__cell.appendChild(this._private__dv);\n        this._private__canvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: 16,\n            height: 16\n        }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        this._private__element.appendChild(this._private__leftStubCell);\n        this._private__element.appendChild(this._private__cell);\n        this._private__element.appendChild(this._private__rightStubCell);\n        this._private__recreateStubs();\n        this._private__chart._internal_model()._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__recreateStubs.bind(this), this);\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: ()=>true,\n            _internal_treatHorzTouchDragAsPageScroll: ()=>!this._private__chart._internal_options()['handleScroll'].horzTouchDrag\n        });\n    }\n}\nconst windowsChrome = isChromiumBased() && isWindows();\nclass ChartWidget {\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneWidgets() {\n        return this._private__paneWidgets;\n    }\n    _internal_timeAxisWidget() {\n        return this._private__timeAxisWidget;\n    }\n    _internal_destroy() {\n        this._private__setMouseWheelEventListener(false);\n        if (this._private__drawRafId !== 0) {\n            window.cancelAnimationFrame(this._private__drawRafId);\n        }\n        this._private__model._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_unsubscribeAll(this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__model._internal_destroy();\n        for (const paneWidget of this._private__paneWidgets){\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n        }\n        this._private__paneWidgets = [];\n        for (const paneSeparator of this._private__paneSeparators){\n            this._private__destroySeparator(paneSeparator);\n        }\n        this._private__paneSeparators = [];\n        ensureNotNull(this._private__timeAxisWidget)._internal_destroy();\n        if (this._private__element.parentElement !== null) {\n            this._private__element.parentElement.removeChild(this._private__element);\n        }\n        this._private__crosshairMoved._internal_destroy();\n        this._private__clicked._internal_destroy();\n        this._private__dblClicked._internal_destroy();\n        this._private__uninstallObserver();\n    }\n    _internal_resize(width, height) {\n        let forceRepaint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (this._private__height === height && this._private__width === width) {\n            return;\n        }\n        const sizeHint = suggestChartSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width,\n            height\n        }));\n        this._private__height = sizeHint.height;\n        this._private__width = sizeHint.width;\n        const heightStr = this._private__height + 'px';\n        const widthStr = this._private__width + 'px';\n        ensureNotNull(this._private__element).style.height = heightStr;\n        ensureNotNull(this._private__element).style.width = widthStr;\n        this._private__tableElement.style.height = heightStr;\n        this._private__tableElement.style.width = widthStr;\n        if (forceRepaint) {\n            this._private__drawImpl(InvalidateMask._internal_full(), performance.now());\n        } else {\n            this._private__model._internal_fullUpdate();\n        }\n    }\n    _internal_paint(invalidateMask) {\n        if (invalidateMask === undefined) {\n            invalidateMask = InvalidateMask._internal_full();\n        }\n        for(let i = 0; i < this._private__paneWidgets.length; i++){\n            this._private__paneWidgets[i]._internal_paint(invalidateMask._internal_invalidateForPane(i)._internal_level);\n        }\n        if (this._private__options.timeScale.visible) {\n            this._private__timeAxisWidget._internal_paint(invalidateMask._internal_fullInvalidation());\n        }\n    }\n    _internal_applyOptions(options) {\n        var _options_layout;\n        const currentlyHasMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        // we don't need to merge options here because it's done in chart model\n        // and since both model and widget share the same object it will be done automatically for widget as well\n        // not ideal solution for sure, but it work's for now ¯\\_(ツ)_/¯\n        this._private__model._internal_applyOptions(options);\n        const shouldHaveMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        if (shouldHaveMouseWheelListener !== currentlyHasMouseWheelListener) {\n            this._private__setMouseWheelEventListener(shouldHaveMouseWheelListener);\n        }\n        if ((_options_layout = options['layout']) === null || _options_layout === void 0 ? void 0 : _options_layout.panes) {\n            this._private__applyPanesOptions();\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__applyAutoSizeOptions(options);\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_takeScreenshot() {\n        if (this._private__invalidateMask !== null) {\n            this._private__drawImpl(this._private__invalidateMask, performance.now());\n            this._private__invalidateMask = null;\n        }\n        const screeshotBitmapSize = this._private__traverseLayout(null);\n        const screenshotCanvas = document.createElement('canvas');\n        screenshotCanvas.width = screeshotBitmapSize.width;\n        screenshotCanvas.height = screeshotBitmapSize.height;\n        const ctx = ensureNotNull(screenshotCanvas.getContext('2d'));\n        this._private__traverseLayout(ctx);\n        return screenshotCanvas;\n    }\n    _internal_getPriceAxisWidth(position) {\n        if (position === \"left\" /* DefaultPriceScaleId.Left */  && !this._private__isLeftAxisVisible()) {\n            return 0;\n        }\n        if (position === \"right\" /* DefaultPriceScaleId.Right */  && !this._private__isRightAxisVisible()) {\n            return 0;\n        }\n        if (this._private__paneWidgets.length === 0) {\n            return 0;\n        }\n        // we don't need to worry about exactly pane widget here\n        // because all pane widgets have the same width of price axis widget\n        // see _adjustSizeImpl\n        const priceAxisWidget = position === \"left\" /* DefaultPriceScaleId.Left */  ? this._private__paneWidgets[0]._internal_leftPriceAxisWidget() : this._private__paneWidgets[0]._internal_rightPriceAxisWidget();\n        return ensureNotNull(priceAxisWidget)._internal_getWidth();\n    }\n    _internal_autoSizeActive() {\n        return this._private__options.autoSize && this._private__observer !== null;\n    }\n    _internal_element() {\n        return this._private__element;\n    }\n    _internal_setCursorStyle(style) {\n        this._private__cursorStyleOverride = style;\n        if (this._private__cursorStyleOverride) {\n            this._internal_element().style.setProperty('cursor', style);\n        } else {\n            this._internal_element().style.removeProperty('cursor');\n        }\n    }\n    _internal_getCursorOverrideStyle() {\n        return this._private__cursorStyleOverride;\n    }\n    _internal_paneSize(paneIndex) {\n        return ensureDefined(this._private__paneWidgets[paneIndex])._internal_getSize();\n    }\n    _private__applyPanesOptions() {\n        this._private__paneSeparators.forEach((separator)=>{\n            separator._internal_update();\n        });\n    }\n    // eslint-disable-next-line complexity\n    _private__applyAutoSizeOptions(options) {\n        if (options.autoSize === undefined && this._private__observer && (options.width !== undefined || options.height !== undefined)) {\n            warn(\"You should turn autoSize off explicitly before specifying sizes; try adding options.autoSize: false to new options\");\n            return;\n        }\n        if (options.autoSize && !this._private__observer) {\n            // installing observer will override resize if successful\n            this._private__installObserver();\n        }\n        if (options.autoSize === false && this._private__observer !== null) {\n            this._private__uninstallObserver();\n        }\n        if (!options.autoSize && (options.width !== undefined || options.height !== undefined)) {\n            this._internal_resize(options.width || this._private__width, options.height || this._private__height);\n        }\n    }\n    /**\n     * Traverses the widget's layout (pane and axis child widgets),\n     * draws the screenshot (if rendering context is passed) and returns the screenshot bitmap size\n     *\n     * @param ctx - if passed, used to draw the screenshot of widget\n     * @returns screenshot bitmap size\n     */ _private__traverseLayout(ctx) {\n        let totalWidth = 0;\n        let totalHeight = 0;\n        const firstPane = this._private__paneWidgets[0];\n        const drawPriceAxises = (position, targetX)=>{\n            let targetY = 0;\n            for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++){\n                const paneWidget = this._private__paneWidgets[paneIndex];\n                const priceAxisWidget = ensureNotNull(position === 'left' ? paneWidget._internal_leftPriceAxisWidget() : paneWidget._internal_rightPriceAxisWidget());\n                const bitmapSize = priceAxisWidget._internal_getBitmapSize();\n                if (ctx !== null) {\n                    priceAxisWidget._internal_drawBitmap(ctx, targetX, targetY);\n                }\n                targetY += bitmapSize.height;\n                if (paneIndex < this._private__paneWidgets.length - 1) {\n                    const separator = this._private__paneSeparators[paneIndex];\n                    const separatorBitmapSize = separator._internal_getBitmapSize();\n                    if (ctx !== null) {\n                        separator._internal_drawBitmap(ctx, targetX, targetY);\n                    }\n                    targetY += separatorBitmapSize.height;\n                }\n            }\n        };\n        // draw left price scale if exists\n        if (this._private__isLeftAxisVisible()) {\n            drawPriceAxises('left', 0);\n            const leftAxisBitmapWidth = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += leftAxisBitmapWidth;\n        }\n        for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++){\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            const bitmapSize = paneWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                paneWidget._internal_drawBitmap(ctx, totalWidth, totalHeight);\n            }\n            totalHeight += bitmapSize.height;\n            if (paneIndex < this._private__paneWidgets.length - 1) {\n                const separator = this._private__paneSeparators[paneIndex];\n                const separatorBitmapSize = separator._internal_getBitmapSize();\n                if (ctx !== null) {\n                    separator._internal_drawBitmap(ctx, totalWidth, totalHeight);\n                }\n                totalHeight += separatorBitmapSize.height;\n            }\n        }\n        const firstPaneBitmapWidth = firstPane._internal_getBitmapSize().width;\n        totalWidth += firstPaneBitmapWidth;\n        // draw right price scale if exists\n        if (this._private__isRightAxisVisible()) {\n            drawPriceAxises('right', totalWidth);\n            const rightAxisBitmapWidth = ensureNotNull(firstPane._internal_rightPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += rightAxisBitmapWidth;\n        }\n        const drawStub = (position, targetX, targetY)=>{\n            const stub = ensureNotNull(position === 'left' ? this._private__timeAxisWidget._internal_leftStub() : this._private__timeAxisWidget._internal_rightStub());\n            stub._internal_drawBitmap(ensureNotNull(ctx), targetX, targetY);\n        };\n        // draw time scale and stubs\n        if (this._private__options.timeScale.visible) {\n            const timeAxisBitmapSize = this._private__timeAxisWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                let targetX = 0;\n                if (this._private__isLeftAxisVisible()) {\n                    drawStub('left', targetX, totalHeight);\n                    targetX = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n                }\n                this._private__timeAxisWidget._internal_drawBitmap(ctx, targetX, totalHeight);\n                targetX += timeAxisBitmapSize.width;\n                if (this._private__isRightAxisVisible()) {\n                    drawStub('right', targetX, totalHeight);\n                }\n            }\n            totalHeight += timeAxisBitmapSize.height;\n        }\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: totalWidth,\n            height: totalHeight\n        });\n    }\n    // eslint-disable-next-line complexity\n    _private__adjustSizeImpl() {\n        let totalStretch = 0;\n        let leftPriceAxisWidth = 0;\n        let rightPriceAxisWidth = 0;\n        for (const paneWidget of this._private__paneWidgets){\n            if (this._private__isLeftAxisVisible()) {\n                leftPriceAxisWidth = Math.max(leftPriceAxisWidth, ensureNotNull(paneWidget._internal_leftPriceAxisWidget())._internal_optimalWidth(), this._private__options.leftPriceScale.minimumWidth);\n            }\n            if (this._private__isRightAxisVisible()) {\n                rightPriceAxisWidth = Math.max(rightPriceAxisWidth, ensureNotNull(paneWidget._internal_rightPriceAxisWidget())._internal_optimalWidth(), this._private__options.rightPriceScale.minimumWidth);\n            }\n            totalStretch += paneWidget._internal_stretchFactor();\n        }\n        leftPriceAxisWidth = suggestPriceScaleWidth(leftPriceAxisWidth);\n        rightPriceAxisWidth = suggestPriceScaleWidth(rightPriceAxisWidth);\n        const width = this._private__width;\n        const height = this._private__height;\n        const paneWidth = Math.max(width - leftPriceAxisWidth - rightPriceAxisWidth, 0);\n        const separatorCount = this._private__paneSeparators.length;\n        const separatorHeight = 1 /* SeparatorConstants.SeparatorHeight */ ;\n        const separatorsHeight = separatorHeight * separatorCount;\n        const timeAxisVisible = this._private__options.timeScale.visible;\n        let timeAxisHeight = timeAxisVisible ? Math.max(this._private__timeAxisWidget._internal_optimalHeight(), this._private__options.timeScale.minimumHeight) : 0;\n        timeAxisHeight = suggestTimeScaleHeight(timeAxisHeight);\n        const otherWidgetHeight = separatorsHeight + timeAxisHeight;\n        const totalPaneHeight = height < otherWidgetHeight ? 0 : height - otherWidgetHeight;\n        const stretchPixels = totalPaneHeight / totalStretch;\n        let accumulatedHeight = 0;\n        const pixelRatio = window.devicePixelRatio || 1;\n        for(let paneIndex = 0; paneIndex < this._private__paneWidgets.length; ++paneIndex){\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            paneWidget._internal_setState(this._private__model._internal_panes()[paneIndex]);\n            let paneHeight = 0;\n            let calculatePaneHeight = 0;\n            if (paneIndex === this._private__paneWidgets.length - 1) {\n                calculatePaneHeight = Math.ceil((totalPaneHeight - accumulatedHeight) * pixelRatio) / pixelRatio;\n            } else {\n                calculatePaneHeight = Math.round(paneWidget._internal_stretchFactor() * stretchPixels * pixelRatio) / pixelRatio;\n            }\n            paneHeight = Math.max(calculatePaneHeight, 2);\n            accumulatedHeight += paneHeight;\n            paneWidget._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: paneWidth,\n                height: paneHeight\n            }));\n            if (this._private__isLeftAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(leftPriceAxisWidth, 'left');\n            }\n            if (this._private__isRightAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(rightPriceAxisWidth, 'right');\n            }\n            if (paneWidget._internal_state()) {\n                this._private__model._internal_setPaneHeight(paneWidget._internal_state(), paneHeight);\n            }\n        }\n        this._private__timeAxisWidget._internal_setSizes((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: timeAxisVisible ? paneWidth : 0,\n            height: timeAxisHeight\n        }), timeAxisVisible ? leftPriceAxisWidth : 0, timeAxisVisible ? rightPriceAxisWidth : 0);\n        this._private__model._internal_setWidth(paneWidth);\n        if (this._private__leftPriceAxisWidth !== leftPriceAxisWidth) {\n            this._private__leftPriceAxisWidth = leftPriceAxisWidth;\n        }\n        if (this._private__rightPriceAxisWidth !== rightPriceAxisWidth) {\n            this._private__rightPriceAxisWidth = rightPriceAxisWidth;\n        }\n    }\n    _private__setMouseWheelEventListener(add) {\n        if (add) {\n            this._private__element.addEventListener('wheel', this._private__onWheelBound, {\n                passive: false\n            });\n            return;\n        }\n        this._private__element.removeEventListener('wheel', this._private__onWheelBound);\n    }\n    _private__determineWheelSpeedAdjustment(event) {\n        switch(event.deltaMode){\n            case event.DOM_DELTA_PAGE:\n                // one screen at time scroll mode\n                return 120;\n            case event.DOM_DELTA_LINE:\n                // one line at time scroll mode\n                return 32;\n        }\n        if (!windowsChrome) {\n            return 1;\n        }\n        // Chromium on Windows has a bug where the scroll speed isn't correctly\n        // adjusted for high density displays. We need to correct for this so that\n        // scroll speed is consistent between browsers.\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1001735\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1207308\n        return 1 / window.devicePixelRatio;\n    }\n    _private__onMousewheel(event) {\n        if ((event.deltaX === 0 || !this._private__options['handleScroll'].mouseWheel) && (event.deltaY === 0 || !this._private__options['handleScale'].mouseWheel)) {\n            return;\n        }\n        const scrollSpeedAdjustment = this._private__determineWheelSpeedAdjustment(event);\n        const deltaX = scrollSpeedAdjustment * event.deltaX / 100;\n        const deltaY = -(scrollSpeedAdjustment * event.deltaY / 100);\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        if (deltaY !== 0 && this._private__options['handleScale'].mouseWheel) {\n            const zoomScale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));\n            const scrollPosition = event.clientX - this._private__element.getBoundingClientRect().left;\n            this._internal_model()._internal_zoomTime(scrollPosition, zoomScale);\n        }\n        if (deltaX !== 0 && this._private__options['handleScroll'].mouseWheel) {\n            this._internal_model()._internal_scrollChart(deltaX * -80); // 80 is a made up coefficient, and minus is for the \"natural\" scroll\n        }\n    }\n    _private__drawImpl(invalidateMask, time) {\n        const invalidationType = invalidateMask._internal_fullInvalidation();\n        // actions for full invalidation ONLY (not shared with light)\n        if (invalidationType === 3 /* InvalidationLevel.Full */ ) {\n            this._private__updateGui();\n        }\n        // light or full invalidate actions\n        if (invalidationType === 3 /* InvalidationLevel.Full */  || invalidationType === 2 /* InvalidationLevel.Light */ ) {\n            var _this__private__invalidateMask;\n            this._private__applyMomentaryAutoScale(invalidateMask);\n            this._private__applyTimeScaleInvalidations(invalidateMask, time);\n            this._private__timeAxisWidget._internal_update();\n            this._private__paneWidgets.forEach((pane)=>{\n                pane._internal_updatePriceAxisWidgets();\n            });\n            // In the case a full invalidation has been postponed during the draw, reapply\n            // the timescale invalidations. A full invalidation would mean there is a change\n            // in the timescale width (caused by price scale changes) that needs to be drawn\n            // right away to avoid flickering.\n            if (((_this__private__invalidateMask = this._private__invalidateMask) === null || _this__private__invalidateMask === void 0 ? void 0 : _this__private__invalidateMask._internal_fullInvalidation()) === 3 /* InvalidationLevel.Full */ ) {\n                this._private__invalidateMask._internal_merge(invalidateMask);\n                this._private__updateGui();\n                this._private__applyMomentaryAutoScale(this._private__invalidateMask);\n                this._private__applyTimeScaleInvalidations(this._private__invalidateMask, time);\n                invalidateMask = this._private__invalidateMask;\n                this._private__invalidateMask = null;\n            }\n        }\n        this._internal_paint(invalidateMask);\n    }\n    _private__applyTimeScaleInvalidations(invalidateMask, time) {\n        for (const tsInvalidation of invalidateMask._internal_timeScaleInvalidations()){\n            this._private__applyTimeScaleInvalidation(tsInvalidation, time);\n        }\n    }\n    _private__applyMomentaryAutoScale(invalidateMask) {\n        const panes = this._private__model._internal_panes();\n        for(let i = 0; i < panes.length; i++){\n            if (invalidateMask._internal_invalidateForPane(i)._internal_autoScale) {\n                panes[i]._internal_momentaryAutoScale();\n            }\n        }\n    }\n    _private__applyTimeScaleInvalidation(invalidation, time) {\n        const timeScale = this._private__model._internal_timeScale();\n        switch(invalidation._internal_type){\n            case 0 /* TimeScaleInvalidationType.FitContent */ :\n                timeScale._internal_fitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */ :\n                timeScale._internal_setLogicalRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */ :\n                timeScale._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */ :\n                timeScale._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */ :\n                timeScale._internal_restoreDefault();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */ :\n                if (!invalidation._internal_value._internal_finished(time)) {\n                    timeScale._internal_setRightOffset(invalidation._internal_value._internal_getPosition(time));\n                }\n                break;\n        }\n    }\n    _private__invalidateHandler(invalidateMask) {\n        if (this._private__invalidateMask !== null) {\n            this._private__invalidateMask._internal_merge(invalidateMask);\n        } else {\n            this._private__invalidateMask = invalidateMask;\n        }\n        if (!this._private__drawPlanned) {\n            this._private__drawPlanned = true;\n            this._private__drawRafId = window.requestAnimationFrame((time)=>{\n                this._private__drawPlanned = false;\n                this._private__drawRafId = 0;\n                if (this._private__invalidateMask !== null) {\n                    const mask = this._private__invalidateMask;\n                    this._private__invalidateMask = null;\n                    this._private__drawImpl(mask, time);\n                    for (const tsInvalidation of mask._internal_timeScaleInvalidations()){\n                        if (tsInvalidation._internal_type === 5 /* TimeScaleInvalidationType.Animation */  && !tsInvalidation._internal_value._internal_finished(time)) {\n                            this._internal_model()._internal_setTimeScaleAnimation(tsInvalidation._internal_value);\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n    }\n    _private__updateGui() {\n        this._private__syncGuiWithModel();\n    }\n    _private__destroySeparator(separator) {\n        this._private__tableElement.removeChild(separator._internal_getElement());\n        separator._internal_destroy();\n    }\n    _private__syncGuiWithModel() {\n        const panes = this._private__model._internal_panes();\n        const targetPaneWidgetsCount = panes.length;\n        const actualPaneWidgetsCount = this._private__paneWidgets.length;\n        // Remove (if needed) pane widgets and separators\n        for(let i = targetPaneWidgetsCount; i < actualPaneWidgetsCount; i++){\n            const paneWidget = ensureDefined(this._private__paneWidgets.pop());\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n            const paneSeparator = this._private__paneSeparators.pop();\n            if (paneSeparator !== undefined) {\n                this._private__destroySeparator(paneSeparator);\n            }\n        }\n        // Create (if needed) new pane widgets and separators\n        for(let i = actualPaneWidgetsCount; i < targetPaneWidgetsCount; i++){\n            const paneWidget = new PaneWidget(this, panes[i]);\n            paneWidget._internal_clicked()._internal_subscribe(this._private__onPaneWidgetClicked.bind(this, paneWidget), this);\n            paneWidget._internal_dblClicked()._internal_subscribe(this._private__onPaneWidgetDblClicked.bind(this, paneWidget), this);\n            this._private__paneWidgets.push(paneWidget);\n            // create and insert separator\n            if (i > 0) {\n                const paneSeparator = new PaneSeparator(this, i - 1, i);\n                this._private__paneSeparators.push(paneSeparator);\n                this._private__tableElement.insertBefore(paneSeparator._internal_getElement(), this._private__timeAxisWidget._internal_getElement());\n            }\n            // insert paneWidget\n            this._private__tableElement.insertBefore(paneWidget._internal_getElement(), this._private__timeAxisWidget._internal_getElement());\n        }\n        for(let i = 0; i < targetPaneWidgetsCount; i++){\n            const state = panes[i];\n            const paneWidget = this._private__paneWidgets[i];\n            if (paneWidget._internal_state() !== state) {\n                paneWidget._internal_setState(state);\n            } else {\n                paneWidget._internal_updatePriceAxisWidgetsStates();\n            }\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__adjustSizeImpl();\n    }\n    _private__getMouseEventParamsImpl(index, point, event, pane) {\n        const seriesData = new Map();\n        if (index !== null) {\n            const serieses = this._private__model._internal_serieses();\n            serieses.forEach((s)=>{\n                // TODO: replace with search left\n                const data = s._internal_bars()._internal_search(index);\n                if (data !== null) {\n                    seriesData.set(s, data);\n                }\n            });\n        }\n        let clientTime;\n        if (index !== null) {\n            var _this__private__model__internal_timeScale__internal_indexToTimeScalePoint;\n            const timePoint = (_this__private__model__internal_timeScale__internal_indexToTimeScalePoint = this._private__model._internal_timeScale()._internal_indexToTimeScalePoint(index)) === null || _this__private__model__internal_timeScale__internal_indexToTimeScalePoint === void 0 ? void 0 : _this__private__model__internal_timeScale__internal_indexToTimeScalePoint.originalTime;\n            if (timePoint !== undefined) {\n                clientTime = timePoint;\n            }\n        }\n        const hoveredSource = this._internal_model()._internal_hoveredSource();\n        const hoveredSeries = hoveredSource !== null && hoveredSource._internal_source instanceof Series ? hoveredSource._internal_source : undefined;\n        const hoveredObject = hoveredSource !== null && hoveredSource._internal_object !== undefined ? hoveredSource._internal_object._internal_externalId : undefined;\n        const paneIndex = this._private__getPaneIndex(pane);\n        return {\n            _internal_originalTime: clientTime,\n            _internal_index: index !== null && index !== void 0 ? index : undefined,\n            _internal_point: point !== null && point !== void 0 ? point : undefined,\n            _internal_paneIndex: paneIndex !== -1 ? paneIndex : undefined,\n            _internal_hoveredSeries: hoveredSeries,\n            _internal_seriesData: seriesData,\n            _internal_hoveredObject: hoveredObject,\n            _internal_touchMouseEventData: event !== null && event !== void 0 ? event : undefined\n        };\n    }\n    _private__getPaneIndex(pane) {\n        let paneIndex = -1;\n        if (pane) {\n            paneIndex = this._private__paneWidgets.indexOf(pane);\n        } else {\n            const crosshairPane = this._internal_model()._internal_crosshairSource()._internal_pane();\n            if (crosshairPane !== null) {\n                paneIndex = this._internal_model()._internal_panes().indexOf(crosshairPane);\n            }\n        }\n        return paneIndex;\n    }\n    _private__onPaneWidgetClicked(pane, time, point, event) {\n        this._private__clicked._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event, pane));\n    }\n    _private__onPaneWidgetDblClicked(pane, time, point, event) {\n        this._private__dblClicked._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event, pane));\n    }\n    _private__onPaneWidgetCrosshairMoved(time, point, event) {\n        var _this__internal_model__internal_hoveredSource;\n        var _this__internal_model__internal_hoveredSource__internal_cursorStyle;\n        this._internal_setCursorStyle((_this__internal_model__internal_hoveredSource__internal_cursorStyle = (_this__internal_model__internal_hoveredSource = this._internal_model()._internal_hoveredSource()) === null || _this__internal_model__internal_hoveredSource === void 0 ? void 0 : _this__internal_model__internal_hoveredSource._internal_cursorStyle) !== null && _this__internal_model__internal_hoveredSource__internal_cursorStyle !== void 0 ? _this__internal_model__internal_hoveredSource__internal_cursorStyle : null);\n        this._private__crosshairMoved._internal_fire(()=>this._private__getMouseEventParamsImpl(time, point, event));\n    }\n    _private__updateTimeAxisVisibility() {\n        const display = this._private__options.timeScale.visible ? '' : 'none';\n        this._private__timeAxisWidget._internal_getElement().style.display = display;\n    }\n    _private__isLeftAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_leftPriceScale()._internal_options().visible;\n    }\n    _private__isRightAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_rightPriceScale()._internal_options().visible;\n    }\n    _private__installObserver() {\n        // eslint-disable-next-line no-restricted-syntax\n        if (!('ResizeObserver' in window)) {\n            warn('Options contains \"autoSize\" flag, but the browser does not support ResizeObserver feature. Please provide polyfill.');\n            return false;\n        } else {\n            this._private__observer = new ResizeObserver((entries)=>{\n                // There is no need to check if entry.target === this._container since there is only\n                // a single element being observed.\n                // and we want to use the last entry (if multiple) because it would be most up to date\n                // (since the browser may batch multiple updates).\n                const containerEntry = entries[entries.length - 1];\n                if (!containerEntry) {\n                    // this may be undefined if the entries array was empty.\n                    return;\n                }\n                this._internal_resize(containerEntry.contentRect.width, containerEntry.contentRect.height);\n            });\n            this._private__observer.observe(this._private__container, {\n                box: 'border-box'\n            });\n            return true;\n        }\n    }\n    _private__uninstallObserver() {\n        if (this._private__observer !== null) {\n            this._private__observer.disconnect();\n        }\n        this._private__observer = null;\n    }\n    constructor(container, options, horzScaleBehavior){\n        this._private__paneWidgets = [];\n        this._private__paneSeparators = [];\n        this._private__drawRafId = 0;\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__leftPriceAxisWidth = 0;\n        this._private__rightPriceAxisWidth = 0;\n        this._private__invalidateMask = null;\n        this._private__drawPlanned = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__observer = null;\n        this._private__cursorStyleOverride = null;\n        this._private__container = container;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__element = document.createElement('div');\n        this._private__element.classList.add('tv-lightweight-charts');\n        this._private__element.style.overflow = 'hidden';\n        this._private__element.style.direction = 'ltr';\n        this._private__element.style.width = '100%';\n        this._private__element.style.height = '100%';\n        disableSelection(this._private__element);\n        this._private__tableElement = document.createElement('table');\n        this._private__tableElement.setAttribute('cellspacing', '0');\n        this._private__element.appendChild(this._private__tableElement);\n        this._private__onWheelBound = this._private__onMousewheel.bind(this);\n        if (shouldSubscribeMouseWheel(this._private__options)) {\n            this._private__setMouseWheelEventListener(true);\n        }\n        this._private__model = new ChartModel(this._private__invalidateHandler.bind(this), this._private__options, horzScaleBehavior);\n        this._internal_model()._internal_crosshairMoved()._internal_subscribe(this._private__onPaneWidgetCrosshairMoved.bind(this), this);\n        this._private__timeAxisWidget = new TimeAxisWidget(this, this._private__horzScaleBehavior);\n        this._private__tableElement.appendChild(this._private__timeAxisWidget._internal_getElement());\n        const usedObserver = options.autoSize && this._private__installObserver();\n        // observer could not fire event immediately for some cases\n        // so we have to set initial size manually\n        let width = this._private__options.width;\n        let height = this._private__options.height;\n        // ignore width/height options if observer has actually been used\n        // however respect options if installing resize observer failed\n        if (usedObserver || width === 0 || height === 0) {\n            const containerRect = container.getBoundingClientRect();\n            width = width || containerRect.width;\n            height = height || containerRect.height;\n        }\n        // BEWARE: resize must be called BEFORE _syncGuiWithModel (in constructor only)\n        // or after but with adjustSize to properly update time scale\n        this._internal_resize(width, height);\n        this._private__syncGuiWithModel();\n        container.appendChild(this._private__element);\n        this._private__updateTimeAxisVisibility();\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n    }\n}\nfunction disableSelection(element) {\n    element.style.userSelect = 'none';\n    // eslint-disable-next-line deprecation/deprecation\n    element.style.webkitUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.msUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.MozUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.webkitTapHighlightColor = 'transparent';\n}\nfunction shouldSubscribeMouseWheel(options) {\n    return Boolean(options['handleScroll'].mouseWheel || options['handleScale'].mouseWheel);\n}\nfunction isWhitespaceData(data) {\n    return data.open === undefined && data.value === undefined;\n}\nfunction isFulfilledData(data) {\n    return isFulfilledBarData(data) || isFulfilledLineData(data);\n}\nfunction isFulfilledBarData(data) {\n    return data.open !== undefined;\n}\nfunction isFulfilledLineData(data) {\n    return data.value !== undefined;\n}\nfunction getColoredLineBasedSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getAreaSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.lineColor !== undefined) {\n        res._internal_lineColor = item.lineColor;\n    }\n    if (item.topColor !== undefined) {\n        res._internal_topColor = item.topColor;\n    }\n    if (item.bottomColor !== undefined) {\n        res._internal_bottomColor = item.bottomColor;\n    }\n    return res;\n}\nfunction getBaselineSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            val,\n            val,\n            val,\n            val\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.topLineColor !== undefined) {\n        res._internal_topLineColor = item.topLineColor;\n    }\n    if (item.bottomLineColor !== undefined) {\n        res._internal_bottomLineColor = item.bottomLineColor;\n    }\n    if (item.topFillColor1 !== undefined) {\n        res._internal_topFillColor1 = item.topFillColor1;\n    }\n    if (item.topFillColor2 !== undefined) {\n        res._internal_topFillColor2 = item.topFillColor2;\n    }\n    if (item.bottomFillColor1 !== undefined) {\n        res._internal_bottomFillColor1 = item.bottomFillColor1;\n    }\n    if (item.bottomFillColor2 !== undefined) {\n        res._internal_bottomFillColor2 = item.bottomFillColor2;\n    }\n    return res;\n}\nfunction getBarSeriesPlotRow(time, index, item, originalTime) {\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            item.open,\n            item.high,\n            item.low,\n            item.close\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getCandlestickSeriesPlotRow(time, index, item, originalTime) {\n    const res = {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: [\n            item.open,\n            item.high,\n            item.low,\n            item.close\n        ],\n        _internal_originalTime: originalTime\n    };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    if (item.borderColor !== undefined) {\n        res._internal_borderColor = item.borderColor;\n    }\n    if (item.wickColor !== undefined) {\n        res._internal_wickColor = item.wickColor;\n    }\n    return res;\n}\nfunction getCustomSeriesPlotRow(time, index, item, originalTime, dataToPlotRow) {\n    const values = ensureDefined(dataToPlotRow)(item);\n    const max = Math.max(...values);\n    const min = Math.min(...values);\n    const last = values[values.length - 1];\n    const value = [\n        last,\n        max,\n        min,\n        last\n    ];\n    const { time: excludedTime, color, ...data } = item;\n    return {\n        _internal_index: index,\n        _internal_time: time,\n        _internal_value: value,\n        _internal_originalTime: originalTime,\n        _internal_data: data,\n        _internal_color: color\n    };\n}\nfunction isSeriesPlotRow(row) {\n    return row._internal_value !== undefined;\n}\nfunction wrapCustomValues(plotRow, bar) {\n    if (bar.customValues !== undefined) {\n        plotRow._internal_customValues = bar.customValues;\n    }\n    return plotRow;\n}\nfunction isWhitespaceDataWithCustomCheck(bar, customIsWhitespace) {\n    if (customIsWhitespace) {\n        return customIsWhitespace(bar);\n    }\n    return isWhitespaceData(bar);\n}\nfunction wrapWhitespaceData(createPlotRowFn) {\n    return (time, index, bar, originalTime, dataToPlotRow, customIsWhitespace)=>{\n        if (isWhitespaceDataWithCustomCheck(bar, customIsWhitespace)) {\n            return wrapCustomValues({\n                _internal_time: time,\n                _internal_index: index,\n                _internal_originalTime: originalTime\n            }, bar);\n        }\n        return wrapCustomValues(createPlotRowFn(time, index, bar, originalTime, dataToPlotRow), bar);\n    };\n}\nfunction getSeriesPlotRowCreator(seriesType) {\n    const seriesPlotRowFnMap = {\n        Candlestick: wrapWhitespaceData(getCandlestickSeriesPlotRow),\n        Bar: wrapWhitespaceData(getBarSeriesPlotRow),\n        Area: wrapWhitespaceData(getAreaSeriesPlotRow),\n        Baseline: wrapWhitespaceData(getBaselineSeriesPlotRow),\n        Histogram: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Line: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Custom: wrapWhitespaceData(getCustomSeriesPlotRow)\n    };\n    return seriesPlotRowFnMap[seriesType];\n}\n/// <reference types=\"_build-time-constants\" />\nfunction createEmptyTimePointData(timePoint) {\n    return {\n        _internal_index: 0,\n        _internal_mapping: new Map(),\n        _internal_timePoint: timePoint\n    };\n}\nfunction seriesRowsFirstAndLastTime(seriesRows, bh) {\n    if (seriesRows === undefined || seriesRows.length === 0) {\n        return undefined;\n    }\n    return {\n        _internal_firstTime: bh.key(seriesRows[0]._internal_time),\n        _internal_lastTime: bh.key(seriesRows[seriesRows.length - 1]._internal_time)\n    };\n}\nfunction seriesUpdateInfo(seriesRows, prevSeriesRows, bh) {\n    const firstAndLastTime = seriesRowsFirstAndLastTime(seriesRows, bh);\n    const prevFirstAndLastTime = seriesRowsFirstAndLastTime(prevSeriesRows, bh);\n    if (firstAndLastTime !== undefined && prevFirstAndLastTime !== undefined) {\n        return {\n            _internal_historicalUpdate: false,\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: firstAndLastTime._internal_lastTime >= prevFirstAndLastTime._internal_lastTime && firstAndLastTime._internal_firstTime >= prevFirstAndLastTime._internal_firstTime\n        };\n    }\n    return undefined;\n}\nfunction timeScalePointTime(mergedPointData) {\n    let result;\n    mergedPointData.forEach((v)=>{\n        if (result === undefined) {\n            result = v._internal_originalTime;\n        }\n    });\n    return ensureDefined(result);\n}\nfunction saveOriginalTime(data) {\n    if (data._internal_originalTime === undefined) {\n        data._internal_originalTime = data.time;\n    }\n}\nclass DataLayer {\n    _internal_destroy() {\n        this._private__pointDataByTimePoint.clear();\n        this._private__seriesRowsBySeries.clear();\n        this._private__seriesLastTimePoint.clear();\n        this._private__sortedTimePoints = [];\n    }\n    _internal_setSeriesData(series, data) {\n        let needCleanupPoints = this._private__pointDataByTimePoint.size !== 0;\n        let isTimeScaleAffected = false;\n        // save previous series rows data before it's replaced inside this._setRowsToSeries\n        const prevSeriesRows = this._private__seriesRowsBySeries.get(series);\n        if (prevSeriesRows !== undefined) {\n            if (this._private__seriesRowsBySeries.size === 1) {\n                needCleanupPoints = false;\n                isTimeScaleAffected = true;\n                // perf optimization - if there is only 1 series, then we can just clear and fill everything from scratch\n                this._private__pointDataByTimePoint.clear();\n            } else {\n                // perf optimization - actually we have to use this._pointDataByTimePoint for going through here\n                // but as soon as this._sortedTimePoints is just a different form of _pointDataByTimePoint we can use it as well\n                for (const point of this._private__sortedTimePoints){\n                    if (point.pointData._internal_mapping.delete(series)) {\n                        isTimeScaleAffected = true;\n                    }\n                }\n            }\n        }\n        let seriesRows = [];\n        if (data.length !== 0) {\n            const originalTimes = data.map((d)=>d.time);\n            const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj(data);\n            const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n            const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n            const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n            seriesRows = data.map((item, index)=>{\n                const time = timeConverter(item.time);\n                const horzItemKey = this._private__horzScaleBehavior.key(time);\n                let timePointData = this._private__pointDataByTimePoint.get(horzItemKey);\n                if (timePointData === undefined) {\n                    // the indexes will be sync later\n                    timePointData = createEmptyTimePointData(time);\n                    this._private__pointDataByTimePoint.set(horzItemKey, timePointData);\n                    isTimeScaleAffected = true;\n                }\n                const row = createPlotRow(time, timePointData._internal_index, item, originalTimes[index], dataToPlotRow, customWhitespaceChecker);\n                timePointData._internal_mapping.set(series, row);\n                return row;\n            });\n        }\n        if (needCleanupPoints) {\n            // we deleted the old data from mapping and added the new ones\n            // so there might be empty points now, let's remove them first\n            this._private__cleanupPointsData();\n        }\n        this._private__setRowsToSeries(series, seriesRows);\n        let firstChangedPointIndex = -1;\n        if (isTimeScaleAffected) {\n            // then generate the time scale points\n            // timeWeight will be updates in _updateTimeScalePoints later\n            const newTimeScalePoints = [];\n            this._private__pointDataByTimePoint.forEach((pointData)=>{\n                newTimeScalePoints.push({\n                    timeWeight: 0,\n                    time: pointData._internal_timePoint,\n                    pointData,\n                    originalTime: timeScalePointTime(pointData._internal_mapping)\n                });\n            });\n            newTimeScalePoints.sort((t1, t2)=>this._private__horzScaleBehavior.key(t1.time) - this._private__horzScaleBehavior.key(t2.time));\n            firstChangedPointIndex = this._private__replaceTimeScalePoints(newTimeScalePoints);\n        }\n        return this._private__getUpdateResponse(series, firstChangedPointIndex, seriesUpdateInfo(this._private__seriesRowsBySeries.get(series), prevSeriesRows, this._private__horzScaleBehavior));\n    }\n    _internal_removeSeries(series) {\n        return this._internal_setSeriesData(series, []);\n    }\n    _internal_updateSeriesData(series, data, historicalUpdate) {\n        const extendedData = data;\n        saveOriginalTime(extendedData);\n        // convertStringToBusinessDay(data);\n        this._private__horzScaleBehavior.preprocessData(data);\n        const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj([\n            data\n        ]);\n        const time = timeConverter(data.time);\n        const lastSeriesTime = this._private__seriesLastTimePoint.get(series);\n        if (!historicalUpdate && lastSeriesTime !== undefined && this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(lastSeriesTime)) {\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            throw new Error(\"Cannot update oldest data, last time=\".concat(lastSeriesTime, \", new time=\").concat(time));\n        }\n        let pointDataAtTime = this._private__pointDataByTimePoint.get(this._private__horzScaleBehavior.key(time));\n        if (historicalUpdate && pointDataAtTime === undefined) {\n            throw new Error('Cannot update non-existing data point when historicalUpdate is true');\n        }\n        // if no point data found for the new data item\n        // that means that we need to update scale\n        const affectsTimeScale = pointDataAtTime === undefined;\n        if (pointDataAtTime === undefined) {\n            // the indexes will be sync later\n            pointDataAtTime = createEmptyTimePointData(time);\n            this._private__pointDataByTimePoint.set(this._private__horzScaleBehavior.key(time), pointDataAtTime);\n        }\n        const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n        const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n        const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n        const plotRow = createPlotRow(time, pointDataAtTime._internal_index, data, extendedData._internal_originalTime, dataToPlotRow, customWhitespaceChecker);\n        pointDataAtTime._internal_mapping.set(series, plotRow);\n        if (historicalUpdate) {\n            this._private__updateHistoricalSeriesRow(series, plotRow, pointDataAtTime._internal_index);\n        } else {\n            this._private__updateLastSeriesRow(series, plotRow);\n        }\n        const info = {\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: isSeriesPlotRow(plotRow),\n            _internal_historicalUpdate: historicalUpdate\n        };\n        // if point already exist on the time scale - we don't need to make a full update and just make an incremental one\n        if (!affectsTimeScale) {\n            return this._private__getUpdateResponse(series, -1, info);\n        }\n        const newPoint = {\n            timeWeight: 0,\n            time: pointDataAtTime._internal_timePoint,\n            pointData: pointDataAtTime,\n            originalTime: timeScalePointTime(pointDataAtTime._internal_mapping)\n        };\n        const insertIndex = lowerBound(this._private__sortedTimePoints, this._private__horzScaleBehavior.key(newPoint.time), (a, b)=>this._private__horzScaleBehavior.key(a.time) < b);\n        // yes, I know that this array is readonly and this change is intended to make it performative\n        // we marked _sortedTimePoints array as readonly to avoid modifying this array anywhere else\n        // but this place is exceptional case due performance reasons, sorry\n        this._private__sortedTimePoints.splice(insertIndex, 0, newPoint);\n        for(let index = insertIndex; index < this._private__sortedTimePoints.length; ++index){\n            assignIndexToPointData(this._private__sortedTimePoints[index].pointData, index);\n        }\n        this._private__horzScaleBehavior.fillWeightsForPoints(this._private__sortedTimePoints, insertIndex);\n        return this._private__getUpdateResponse(series, insertIndex, info);\n    }\n    _private__updateLastSeriesRow(series, plotRow) {\n        let seriesData = this._private__seriesRowsBySeries.get(series);\n        if (seriesData === undefined) {\n            seriesData = [];\n            this._private__seriesRowsBySeries.set(series, seriesData);\n        }\n        const lastSeriesRow = seriesData.length !== 0 ? seriesData[seriesData.length - 1] : null;\n        if (lastSeriesRow === null || this._private__horzScaleBehavior.key(plotRow._internal_time) > this._private__horzScaleBehavior.key(lastSeriesRow._internal_time)) {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData.push(plotRow);\n            }\n        } else {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData[seriesData.length - 1] = plotRow;\n            } else {\n                seriesData.splice(-1, 1);\n            }\n        }\n        this._private__seriesLastTimePoint.set(series, plotRow._internal_time);\n    }\n    _private__updateHistoricalSeriesRow(series, plotRow, pointDataIndex) {\n        const seriesData = this._private__seriesRowsBySeries.get(series);\n        if (seriesData === undefined) {\n            return;\n        }\n        // binary search for actual index in array.\n        const index = lowerBound(seriesData, pointDataIndex, (row, currentIndex)=>row._internal_index < currentIndex);\n        if (isSeriesPlotRow(plotRow)) {\n            seriesData[index] = plotRow;\n        } else {\n            seriesData.splice(index, 1);\n        }\n    }\n    _private__setRowsToSeries(series, seriesRows) {\n        if (seriesRows.length !== 0) {\n            this._private__seriesRowsBySeries.set(series, seriesRows.filter(isSeriesPlotRow));\n            this._private__seriesLastTimePoint.set(series, seriesRows[seriesRows.length - 1]._internal_time);\n        } else {\n            this._private__seriesRowsBySeries.delete(series);\n            this._private__seriesLastTimePoint.delete(series);\n        }\n    }\n    _private__cleanupPointsData() {\n        // let's treat all current points as \"potentially removed\"\n        // we could create an array with actually potentially removed points\n        // but most likely this array will be similar to _sortedTimePoints so let's avoid using additional memory\n        // note that we can use _sortedTimePoints here since a point might be removed only it was here previously\n        for (const point of this._private__sortedTimePoints){\n            if (point.pointData._internal_mapping.size === 0) {\n                this._private__pointDataByTimePoint.delete(this._private__horzScaleBehavior.key(point.time));\n            }\n        }\n    }\n    /**\n     * Sets new time scale and make indexes valid for all series\n     *\n     * @returns The index of the first changed point or `-1` if there is no change.\n     */ _private__replaceTimeScalePoints(newTimePoints) {\n        let firstChangedPointIndex = -1;\n        // search the first different point and \"syncing\" time weight by the way\n        for(let index = 0; index < this._private__sortedTimePoints.length && index < newTimePoints.length; ++index){\n            const oldPoint = this._private__sortedTimePoints[index];\n            const newPoint = newTimePoints[index];\n            if (this._private__horzScaleBehavior.key(oldPoint.time) !== this._private__horzScaleBehavior.key(newPoint.time)) {\n                firstChangedPointIndex = index;\n                break;\n            }\n            // re-assign point's time weight for points if time is the same (and all prior times was the same)\n            newPoint.timeWeight = oldPoint.timeWeight;\n            assignIndexToPointData(newPoint.pointData, index);\n        }\n        if (firstChangedPointIndex === -1 && this._private__sortedTimePoints.length !== newTimePoints.length) {\n            // the common part of the prev and the new points are the same\n            // so the first changed point is the next after the common part\n            firstChangedPointIndex = Math.min(this._private__sortedTimePoints.length, newTimePoints.length);\n        }\n        if (firstChangedPointIndex === -1) {\n            // if no time scale changed, then do nothing\n            return -1;\n        }\n        // if time scale points are changed that means that we need to make full update to all series (with clearing points)\n        // but first we need to synchronize indexes and re-fill time weights\n        for(let index = firstChangedPointIndex; index < newTimePoints.length; ++index){\n            assignIndexToPointData(newTimePoints[index].pointData, index);\n        }\n        // re-fill time weights for point after the first changed one\n        this._private__horzScaleBehavior.fillWeightsForPoints(newTimePoints, firstChangedPointIndex);\n        this._private__sortedTimePoints = newTimePoints;\n        return firstChangedPointIndex;\n    }\n    _private__getBaseIndex() {\n        if (this._private__seriesRowsBySeries.size === 0) {\n            // if we have no data then 'reset' the base index to null\n            return null;\n        }\n        let baseIndex = 0;\n        this._private__seriesRowsBySeries.forEach((data)=>{\n            if (data.length !== 0) {\n                baseIndex = Math.max(baseIndex, data[data.length - 1]._internal_index);\n            }\n        });\n        return baseIndex;\n    }\n    _private__getUpdateResponse(updatedSeries, firstChangedPointIndex, info) {\n        const dataUpdateResponse = {\n            _internal_series: new Map(),\n            _internal_timeScale: {\n                _internal_baseIndex: this._private__getBaseIndex()\n            }\n        };\n        if (firstChangedPointIndex !== -1) {\n            // TODO: it's possible to make perf improvements by checking what series has data after firstChangedPointIndex\n            // but let's skip for now\n            this._private__seriesRowsBySeries.forEach((data, s)=>{\n                dataUpdateResponse._internal_series.set(s, {\n                    _internal_data: data,\n                    _internal_info: s === updatedSeries ? info : undefined\n                });\n            });\n            // if the series data was set to [] it will have already been removed from _seriesRowBySeries\n            // meaning the forEach above won't add the series to the data update response\n            // so we handle that case here\n            if (!this._private__seriesRowsBySeries.has(updatedSeries)) {\n                dataUpdateResponse._internal_series.set(updatedSeries, {\n                    _internal_data: [],\n                    _internal_info: info\n                });\n            }\n            dataUpdateResponse._internal_timeScale._internal_points = this._private__sortedTimePoints;\n            dataUpdateResponse._internal_timeScale._internal_firstChangedPointIndex = firstChangedPointIndex;\n        } else {\n            const seriesData = this._private__seriesRowsBySeries.get(updatedSeries);\n            // if no seriesData found that means that we just removed the series\n            dataUpdateResponse._internal_series.set(updatedSeries, {\n                _internal_data: seriesData || [],\n                _internal_info: info\n            });\n        }\n        return dataUpdateResponse;\n    }\n    constructor(horzScaleBehavior){\n        // note that _pointDataByTimePoint and _seriesRowsBySeries shares THE SAME objects in their values between each other\n        // it's just different kind of maps to make usages/perf better\n        this._private__pointDataByTimePoint = new Map();\n        this._private__seriesRowsBySeries = new Map();\n        this._private__seriesLastTimePoint = new Map();\n        // this is kind of \"dest\" values (in opposite to \"source\" ones) - we don't need to modify it manually, the only by calling _updateTimeScalePoints or updateSeriesData methods\n        this._private__sortedTimePoints = [];\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n}\nfunction assignIndexToPointData(pointData, index) {\n    // first, nevertheless update index of point data (\"make it valid\")\n    pointData._internal_index = index;\n    // and then we need to sync indexes for all series\n    pointData._internal_mapping.forEach((seriesRow)=>{\n        seriesRow._internal_index = index;\n    });\n}\nfunction lowerBoundItemsCompare(item, time) {\n    return item._internal_time < time;\n}\nfunction upperBoundItemsCompare(item, time) {\n    return time < item._internal_time;\n}\nfunction visibleTimedValues(items, range, extendedRange) {\n    const firstBar = range._internal_left();\n    const lastBar = range._internal_right();\n    const from = lowerBound(items, firstBar, lowerBoundItemsCompare);\n    const to = upperBound(items, lastBar, upperBoundItemsCompare);\n    if (!extendedRange) {\n        return {\n            from,\n            to\n        };\n    }\n    let extendedFrom = from;\n    let extendedTo = to;\n    if (from > 0 && from < items.length && items[from]._internal_time >= firstBar) {\n        extendedFrom = from - 1;\n    }\n    if (to > 0 && to < items.length && items[to - 1]._internal_time <= lastBar) {\n        extendedTo = to + 1;\n    }\n    return {\n        from: extendedFrom,\n        to: extendedTo\n    };\n}\nclass SeriesPaneViewBase {\n    _internal_update(updateType) {\n        this._internal__invalidated = true;\n        if (updateType === 'data') {\n            this._internal__dataInvalidated = true;\n        }\n        if (updateType === 'options') {\n            this._internal__optionsInvalidated = true;\n        }\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        this._private__makeValid();\n        return this._internal__itemsVisibleRange === null ? null : this._internal__renderer;\n    }\n    _internal__updateOptions() {\n        this._internal__items = this._internal__items.map((item)=>({\n                ...item,\n                ...this._internal__series._internal_barColorer()._internal_barStyle(item._internal_time)\n            }));\n    }\n    _internal__clearVisibleRange() {\n        this._internal__itemsVisibleRange = null;\n    }\n    _private__makeValid() {\n        if (this._internal__dataInvalidated) {\n            this._internal__fillRawPoints();\n            this._internal__dataInvalidated = false;\n        }\n        if (this._internal__optionsInvalidated) {\n            this._internal__updateOptions();\n            this._internal__optionsInvalidated = false;\n        }\n        if (this._internal__invalidated) {\n            this._private__makeValidImpl();\n            this._internal__invalidated = false;\n        }\n    }\n    _private__makeValidImpl() {\n        const priceScale = this._internal__series._internal_priceScale();\n        const timeScale = this._internal__model._internal_timeScale();\n        this._internal__clearVisibleRange();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return;\n        }\n        const visibleBars = timeScale._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return;\n        }\n        if (this._internal__series._internal_bars()._internal_size() === 0) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__itemsVisibleRange = visibleTimedValues(this._internal__items, visibleBars, this._private__extendedVisibleRange);\n        this._internal__convertToCoordinates(priceScale, timeScale, firstValue._internal_value);\n        this._internal__prepareRendererData();\n    }\n    constructor(series, model, extendedVisibleRange){\n        this._internal__invalidated = true;\n        this._internal__dataInvalidated = true;\n        this._internal__optionsInvalidated = true;\n        this._internal__items = [];\n        this._internal__itemsVisibleRange = null;\n        this._internal__series = series;\n        this._internal__model = model;\n        this._private__extendedVisibleRange = extendedVisibleRange;\n    }\n}\nclass CustomSeriesPaneRendererWrapper {\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__sourceRenderer.draw(target, this._private__priceScale, isHovered, hitTestData);\n    }\n    constructor(sourceRenderer, priceScale){\n        this._private__sourceRenderer = sourceRenderer;\n        this._private__priceScale = priceScale;\n    }\n}\nclass SeriesCustomPaneView extends SeriesPaneViewBase {\n    _internal_priceValueBuilder(plotRow) {\n        return this._private__paneView.priceValueBuilder(plotRow);\n    }\n    _internal_isWhitespace(data) {\n        return this._private__paneView.isWhitespace(data);\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>{\n            return {\n                _internal_time: row._internal_index,\n                _internal_x: NaN,\n                ...colorer._internal_barStyle(row._internal_index),\n                _internal_originalData: row._internal_data\n            };\n        });\n    }\n    _internal__convertToCoordinates(priceScale, timeScale) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__prepareRendererData() {\n        this._private__paneView.update({\n            bars: this._internal__items.map(unwrapItemData),\n            barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            visibleRange: this._internal__itemsVisibleRange\n        }, this._internal__series._internal_options());\n    }\n    constructor(series, model, paneView){\n        super(series, model, false);\n        this._private__paneView = paneView;\n        this._internal__renderer = new CustomSeriesPaneRendererWrapper(this._private__paneView.renderer(), (price)=>{\n            const firstValue = series._internal_firstValue();\n            if (firstValue === null) {\n                return null;\n            }\n            return series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n        });\n    }\n}\nfunction unwrapItemData(item) {\n    return {\n        x: item._internal_x,\n        time: item._internal_time,\n        originalData: item._internal_originalData,\n        barColor: item._internal_barColor\n    };\n}\nconst customStyleDefaults = {\n    color: '#2196f3'\n};\nconst createPaneView$6 = (series, model, customPaneView)=>{\n    const paneView = ensure(customPaneView);\n    return new SeriesCustomPaneView(series, model, paneView);\n};\nconst createCustomSeriesDefinition = (paneView)=>{\n    const definition = {\n        type: 'Custom',\n        isBuiltIn: false,\n        defaultOptions: {\n            ...customStyleDefaults,\n            ...paneView.defaultOptions()\n        },\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$6,\n        _internal_customPaneView: paneView\n    };\n    return definition;\n};\nconst isSeriesDefinition = (value)=>{\n    return value._internal_createPaneView !== undefined;\n};\nfunction singleValueData(plotRow) {\n    const data = {\n        value: plotRow._internal_value[3 /* PlotRowValueIndex.Close */ ],\n        time: plotRow._internal_originalTime\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction lineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction areaData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_lineColor !== undefined) {\n        result.lineColor = plotRow._internal_lineColor;\n    }\n    if (plotRow._internal_topColor !== undefined) {\n        result.topColor = plotRow._internal_topColor;\n    }\n    if (plotRow._internal_bottomColor !== undefined) {\n        result.bottomColor = plotRow._internal_bottomColor;\n    }\n    return result;\n}\nfunction baselineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_topLineColor !== undefined) {\n        result.topLineColor = plotRow._internal_topLineColor;\n    }\n    if (plotRow._internal_bottomLineColor !== undefined) {\n        result.bottomLineColor = plotRow._internal_bottomLineColor;\n    }\n    if (plotRow._internal_topFillColor1 !== undefined) {\n        result.topFillColor1 = plotRow._internal_topFillColor1;\n    }\n    if (plotRow._internal_topFillColor2 !== undefined) {\n        result.topFillColor2 = plotRow._internal_topFillColor2;\n    }\n    if (plotRow._internal_bottomFillColor1 !== undefined) {\n        result.bottomFillColor1 = plotRow._internal_bottomFillColor1;\n    }\n    if (plotRow._internal_bottomFillColor2 !== undefined) {\n        result.bottomFillColor2 = plotRow._internal_bottomFillColor2;\n    }\n    return result;\n}\nfunction ohlcData(plotRow) {\n    const data = {\n        open: plotRow._internal_value[0 /* PlotRowValueIndex.Open */ ],\n        high: plotRow._internal_value[1 /* PlotRowValueIndex.High */ ],\n        low: plotRow._internal_value[2 /* PlotRowValueIndex.Low */ ],\n        close: plotRow._internal_value[3 /* PlotRowValueIndex.Close */ ],\n        time: plotRow._internal_originalTime\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction barData(plotRow) {\n    const result = ohlcData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction candlestickData(plotRow) {\n    const result = ohlcData(plotRow);\n    const { _internal_color: color, _internal_borderColor: borderColor, _internal_wickColor: wickColor } = plotRow;\n    if (color !== undefined) {\n        result.color = color;\n    }\n    if (borderColor !== undefined) {\n        result.borderColor = borderColor;\n    }\n    if (wickColor !== undefined) {\n        result.wickColor = wickColor;\n    }\n    return result;\n}\nfunction getSeriesDataCreator(seriesType) {\n    const seriesPlotRowToDataMap = {\n        Area: areaData,\n        Line: lineData,\n        Baseline: baselineData,\n        Histogram: lineData,\n        Bar: barData,\n        Candlestick: candlestickData,\n        Custom: customData\n    };\n    return seriesPlotRowToDataMap[seriesType];\n}\nfunction customData(plotRow) {\n    const time = plotRow._internal_originalTime;\n    return {\n        ...plotRow._internal_data,\n        time\n    };\n}\nconst crosshairOptionsDefaults = {\n    vertLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */ ,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: '#131722'\n    },\n    horzLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */ ,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: '#131722'\n    },\n    mode: 1 /* CrosshairMode.Magnet */ \n};\nconst gridOptionsDefaults = {\n    vertLines: {\n        color: '#D6DCDE',\n        style: 0 /* LineStyle.Solid */ ,\n        visible: true\n    },\n    horzLines: {\n        color: '#D6DCDE',\n        style: 0 /* LineStyle.Solid */ ,\n        visible: true\n    }\n};\nconst layoutOptionsDefaults = {\n    background: {\n        type: \"solid\" /* ColorType.Solid */ ,\n        color: '#FFFFFF'\n    },\n    textColor: '#191919',\n    fontSize: 12,\n    fontFamily: defaultFontFamily,\n    panes: {\n        enableResize: true,\n        separatorColor: '#E0E3EB',\n        separatorHoverColor: 'rgba(178, 181, 189, 0.2)'\n    },\n    attributionLogo: true,\n    colorSpace: 'srgb',\n    colorParsers: []\n};\nconst priceScaleOptionsDefaults = {\n    autoScale: true,\n    mode: 0 /* PriceScaleMode.Normal */ ,\n    invertScale: false,\n    alignLabels: true,\n    borderVisible: true,\n    borderColor: '#2B2B43',\n    entireTextOnly: false,\n    visible: false,\n    ticksVisible: false,\n    scaleMargins: {\n        bottom: 0.1,\n        top: 0.2\n    },\n    minimumWidth: 0,\n    ensureEdgeTickMarksVisible: false\n};\nconst timeScaleOptionsDefaults = {\n    rightOffset: 0,\n    barSpacing: 6,\n    minBarSpacing: 0.5,\n    maxBarSpacing: 0,\n    fixLeftEdge: false,\n    fixRightEdge: false,\n    lockVisibleTimeRangeOnResize: false,\n    rightBarStaysOnScroll: false,\n    borderVisible: true,\n    borderColor: '#2B2B43',\n    visible: true,\n    timeVisible: false,\n    secondsVisible: true,\n    shiftVisibleRangeOnNewBar: true,\n    allowShiftVisibleRangeOnWhitespaceReplacement: false,\n    ticksVisible: false,\n    uniformDistribution: false,\n    minimumHeight: 0,\n    allowBoldLabels: true,\n    ignoreWhitespaceIndices: false\n};\nfunction chartOptionsDefaults() {\n    return {\n        width: 0,\n        height: 0,\n        autoSize: false,\n        layout: layoutOptionsDefaults,\n        crosshair: crosshairOptionsDefaults,\n        grid: gridOptionsDefaults,\n        overlayPriceScales: {\n            ...priceScaleOptionsDefaults\n        },\n        leftPriceScale: {\n            ...priceScaleOptionsDefaults,\n            visible: false\n        },\n        rightPriceScale: {\n            ...priceScaleOptionsDefaults,\n            visible: true\n        },\n        timeScale: timeScaleOptionsDefaults,\n        localization: {\n            locale: isRunningOnClientSide ? navigator.language : '',\n            dateFormat: 'dd MMM \\'yy'\n        },\n        handleScroll: {\n            mouseWheel: true,\n            pressedMouseMove: true,\n            horzTouchDrag: true,\n            vertTouchDrag: true\n        },\n        handleScale: {\n            axisPressedMouseMove: {\n                time: true,\n                price: true\n            },\n            axisDoubleClickReset: {\n                time: true,\n                price: true\n            },\n            mouseWheel: true,\n            pinch: true\n        },\n        kineticScroll: {\n            mouse: false,\n            touch: true\n        },\n        trackingMode: {\n            exitMode: 1 /* TrackingModeExitMode.OnNextTap */ \n        }\n    };\n}\nclass PriceScaleApi {\n    applyOptions(options) {\n        this._private__chartWidget._internal_model()._internal_applyPriceScaleOptions(this._private__priceScaleId, options, this._private__paneIndex);\n    }\n    options() {\n        return this._private__priceScale()._internal_options();\n    }\n    width() {\n        if (!isDefaultPriceScale(this._private__priceScaleId)) {\n            return 0;\n        }\n        return this._private__chartWidget._internal_getPriceAxisWidth(this._private__priceScaleId);\n    }\n    setVisibleRange(range) {\n        this.setAutoScale(false);\n        this._private__priceScale()._internal_setCustomPriceRange(new PriceRangeImpl(range.from, range.to));\n    }\n    getVisibleRange() {\n        const range = this._private__priceScale()._internal_priceRange();\n        return range === null ? null : {\n            from: range._internal_minValue(),\n            to: range._internal_maxValue()\n        };\n    }\n    setAutoScale(on) {\n        this.applyOptions({\n            autoScale: on\n        });\n    }\n    _private__priceScale() {\n        return ensureNotNull(this._private__chartWidget._internal_model()._internal_findPriceScale(this._private__priceScaleId, this._private__paneIndex))._internal_priceScale;\n    }\n    constructor(chartWidget, priceScaleId, paneIndex){\n        this._private__chartWidget = chartWidget;\n        this._private__priceScaleId = priceScaleId;\n        this._private__paneIndex = paneIndex !== null && paneIndex !== void 0 ? paneIndex : 0;\n    }\n}\nclass PaneApi {\n    getHeight() {\n        return this._private__pane._internal_height();\n    }\n    setHeight(height) {\n        const chartModel = this._private__chartWidget._internal_model();\n        const paneIndex = chartModel._internal_getPaneIndex(this._private__pane);\n        chartModel._internal_changePanesHeight(paneIndex, height);\n    }\n    paneIndex() {\n        return this._private__chartWidget._internal_model()._internal_getPaneIndex(this._private__pane);\n    }\n    moveTo(paneIndex) {\n        const currentIndex = this.paneIndex();\n        if (currentIndex === paneIndex) {\n            return;\n        }\n        assert(paneIndex >= 0 && paneIndex < this._private__chartWidget._internal_paneWidgets().length, 'Invalid pane index');\n        this._private__chartWidget._internal_model()._internal_swapPanes(currentIndex, paneIndex);\n    }\n    getSeries() {\n        var _this__private__pane__internal_series_map;\n        return (_this__private__pane__internal_series_map = this._private__pane._internal_series().map((source)=>this._private__seriesApiGetter(source))) !== null && _this__private__pane__internal_series_map !== void 0 ? _this__private__pane__internal_series_map : [];\n    }\n    getHTMLElement() {\n        return this._private__chartWidget._internal_paneWidgets()[this.paneIndex()]._internal_getElement();\n    }\n    attachPrimitive(primitive) {\n        this._private__pane._internal_attachPrimitive(primitive);\n        if (primitive.attached) {\n            primitive.attached({\n                chart: this._internal__chartApi,\n                requestUpdate: ()=>this._private__pane._internal_model()._internal_fullUpdate()\n            });\n        }\n    }\n    detachPrimitive(primitive) {\n        this._private__pane._internal_detachPrimitive(primitive);\n    }\n    priceScale(priceScaleId) {\n        const priceScale = this._private__pane._internal_priceScaleById(priceScaleId);\n        if (priceScale === null) {\n            throw new Error(\"Cannot find price scale with id: \".concat(priceScaleId));\n        }\n        return new PriceScaleApi(this._private__chartWidget, priceScaleId, this.paneIndex());\n    }\n    constructor(chartWidget, seriesApiGetter, pane, chartApi){\n        this._private__chartWidget = chartWidget;\n        this._private__pane = pane;\n        this._private__seriesApiGetter = seriesApiGetter;\n        this._internal__chartApi = chartApi;\n    }\n}\n/// <reference types=\"_build-time-constants\" />\nfunction checkPriceLineOptions(options) {\n    assert(typeof options.price === 'number', \"the type of 'price' price line's property must be a number, got '\".concat(typeof options.price, \"'\"));\n}\nfunction checkItemsAreOrdered(data, bh) {\n    let allowDuplicates = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    if (data.length === 0) {\n        return;\n    }\n    let prevTime = bh.key(data[0].time);\n    for(let i = 1; i < data.length; ++i){\n        const currentTime = bh.key(data[i].time);\n        const checkResult = allowDuplicates ? prevTime <= currentTime : prevTime < currentTime;\n        assert(checkResult, \"data must be asc ordered by time, index=\".concat(i, \", time=\").concat(currentTime, \", prev time=\").concat(prevTime));\n        prevTime = currentTime;\n    }\n}\nfunction checkSeriesValuesType(type, data) {\n    data.forEach(getChecker(type));\n}\nfunction getChecker(type) {\n    switch(type){\n        case 'Bar':\n        case 'Candlestick':\n            return checkBarItem.bind(null, type);\n        case 'Area':\n        case 'Baseline':\n        case 'Line':\n        case 'Histogram':\n            return checkLineItem.bind(null, type);\n        case 'Custom':\n            return checkCustomItem.bind(null);\n    }\n}\nfunction checkBarItem(type, barItem) {\n    if (!isFulfilledData(barItem)) {\n        return;\n    }\n    [\n        'open',\n        'high',\n        'low',\n        'close'\n    ].forEach((key)=>{\n        assert(typeof barItem[key] === 'number', \"\".concat(type, \" series item data value of \").concat(key, \" must be a number, got=\").concat(typeof barItem[key], \", value=\").concat(barItem[key]));\n        assert(isSafeValue(barItem[key]), \"\".concat(type, \" series item data value of \").concat(key, \" must be between \").concat(MIN_SAFE_VALUE.toPrecision(16), \" and \").concat(MAX_SAFE_VALUE.toPrecision(16), \", got=\").concat(typeof barItem[key], \", value=\").concat(barItem[key]));\n    });\n}\nfunction checkLineItem(type, lineItem) {\n    if (!isFulfilledData(lineItem)) {\n        return;\n    }\n    assert(typeof lineItem.value === 'number', \"\".concat(type, \" series item data value must be a number, got=\").concat(typeof lineItem.value, \", value=\").concat(lineItem.value));\n    assert(isSafeValue(lineItem.value), \"\".concat(type, \" series item data value must be between \").concat(MIN_SAFE_VALUE.toPrecision(16), \" and \").concat(MAX_SAFE_VALUE.toPrecision(16), \", got=\").concat(typeof lineItem.value, \", value=\").concat(lineItem.value));\n}\nfunction checkCustomItem() {\n    // Nothing to check yet...\n    return;\n}\nconst MIN_SAFE_VALUE = Number.MIN_SAFE_INTEGER / 100;\nconst MAX_SAFE_VALUE = Number.MAX_SAFE_INTEGER / 100;\nfunction isSafeValue(value) {\n    return value >= MIN_SAFE_VALUE && value <= MAX_SAFE_VALUE;\n}\nconst priceLineOptionsDefaults = {\n    color: '#FF0000',\n    price: 0,\n    lineStyle: 2 /* LineStyle.Dashed */ ,\n    lineWidth: 1,\n    lineVisible: true,\n    axisLabelVisible: true,\n    title: '',\n    axisLabelColor: '',\n    axisLabelTextColor: ''\n};\nclass PriceLine {\n    applyOptions(options) {\n        this._private__priceLine._internal_applyOptions(options);\n    }\n    options() {\n        return this._private__priceLine._internal_options();\n    }\n    _internal_priceLine() {\n        return this._private__priceLine;\n    }\n    constructor(priceLine){\n        this._private__priceLine = priceLine;\n    }\n}\nclass SeriesApi {\n    _internal_destroy() {\n        this._private__dataChangedDelegate._internal_destroy();\n    }\n    priceFormatter() {\n        return this._internal__series._internal_formatter();\n    }\n    priceToCoordinate(price) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n    }\n    coordinateToPrice(coordinate) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_coordinateToPrice(coordinate, firstValue._internal_value);\n    }\n    barsInLogicalRange(range) {\n        if (range === null) {\n            return null;\n        }\n        // we use TimeScaleVisibleRange here to convert LogicalRange to strict range properly\n        const correctedRange = new TimeScaleVisibleRange(new RangeImpl(range.from, range.to))._internal_strictRange();\n        const bars = this._internal__series._internal_bars();\n        if (bars._internal_isEmpty()) {\n            return null;\n        }\n        const dataFirstBarInRange = bars._internal_search(correctedRange._internal_left(), 1 /* MismatchDirection.NearestRight */ );\n        const dataLastBarInRange = bars._internal_search(correctedRange._internal_right(), -1 /* MismatchDirection.NearestLeft */ );\n        const dataFirstIndex = ensureNotNull(bars._internal_firstIndex());\n        const dataLastIndex = ensureNotNull(bars._internal_lastIndex());\n        // this means that we request data in the data gap\n        // e.g. let's say we have series with data [0..10, 30..60]\n        // and we request bars info in range [15, 25]\n        // thus, dataFirstBarInRange will be with index 30 and dataLastBarInRange with 10\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null && dataFirstBarInRange._internal_index > dataLastBarInRange._internal_index) {\n            return {\n                barsBefore: range.from - dataFirstIndex,\n                barsAfter: dataLastIndex - range.to\n            };\n        }\n        const barsBefore = dataFirstBarInRange === null || dataFirstBarInRange._internal_index === dataFirstIndex ? range.from - dataFirstIndex : dataFirstBarInRange._internal_index - dataFirstIndex;\n        const barsAfter = dataLastBarInRange === null || dataLastBarInRange._internal_index === dataLastIndex ? dataLastIndex - range.to : dataLastIndex - dataLastBarInRange._internal_index;\n        const result = {\n            barsBefore,\n            barsAfter\n        };\n        // actually they can't exist separately\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null) {\n            result.from = dataFirstBarInRange._internal_originalTime;\n            result.to = dataLastBarInRange._internal_originalTime;\n        }\n        return result;\n    }\n    setData(data) {\n        checkItemsAreOrdered(data, this._private__horzScaleBehavior);\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), data);\n        this._internal__dataUpdatesConsumer._internal_applyNewData(this._internal__series, data);\n        this._private__onDataChanged('full');\n    }\n    update(bar) {\n        let historicalUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), [\n            bar\n        ]);\n        this._internal__dataUpdatesConsumer._internal_updateData(this._internal__series, bar, historicalUpdate);\n        this._private__onDataChanged('update');\n    }\n    dataByIndex(logicalIndex, mismatchDirection) {\n        const data = this._internal__series._internal_bars()._internal_search(logicalIndex, mismatchDirection);\n        if (data === null) {\n            // actually it can be a whitespace\n            return null;\n        }\n        const creator = getSeriesDataCreator(this.seriesType());\n        return creator(data);\n    }\n    data() {\n        const seriesCreator = getSeriesDataCreator(this.seriesType());\n        const rows = this._internal__series._internal_bars()._internal_rows();\n        return rows.map((row)=>seriesCreator(row));\n    }\n    subscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_unsubscribe(handler);\n    }\n    applyOptions(options) {\n        this._internal__series._internal_applyOptions(options);\n    }\n    options() {\n        return clone(this._internal__series._internal_options());\n    }\n    priceScale() {\n        return this._private__priceScaleApiProvider.priceScale(this._internal__series._internal_priceScale()._internal_id(), this.getPane().paneIndex());\n    }\n    createPriceLine(options) {\n        checkPriceLineOptions(options);\n        const strictOptions = merge(clone(priceLineOptionsDefaults), options);\n        const priceLine = this._internal__series._internal_createPriceLine(strictOptions);\n        return new PriceLine(priceLine);\n    }\n    removePriceLine(line) {\n        this._internal__series._internal_removePriceLine(line._internal_priceLine());\n    }\n    priceLines() {\n        return this._internal__series._internal_priceLines().map((priceLine)=>new PriceLine(priceLine));\n    }\n    seriesType() {\n        return this._internal__series._internal_seriesType();\n    }\n    attachPrimitive(primitive) {\n        // at this point we cast the generic to unknown because we\n        // don't want the model to know the types of the API (◑_◑)\n        this._internal__series._internal_attachPrimitive(primitive);\n        if (primitive.attached) {\n            primitive.attached({\n                chart: this._internal__chartApi,\n                series: this,\n                requestUpdate: ()=>this._internal__series._internal_model()._internal_fullUpdate(),\n                horzScaleBehavior: this._private__horzScaleBehavior\n            });\n        }\n    }\n    detachPrimitive(primitive) {\n        this._internal__series._internal_detachPrimitive(primitive);\n        if (primitive.detached) {\n            primitive.detached();\n        }\n        this._internal__series._internal_model()._internal_fullUpdate();\n    }\n    getPane() {\n        const series = this._internal__series;\n        const pane = ensureNotNull(this._internal__series._internal_model()._internal_paneForSource(series));\n        return this._private__paneApiGetter(pane);\n    }\n    moveToPane(paneIndex) {\n        this._internal__series._internal_model()._internal_moveSeriesToPane(this._internal__series, paneIndex);\n    }\n    seriesOrder() {\n        const pane = this._internal__series._internal_model()._internal_paneForSource(this._internal__series);\n        if (pane === null) {\n            return -1;\n        }\n        return pane._internal_series().indexOf(this._internal__series);\n    }\n    setSeriesOrder(order) {\n        const pane = this._internal__series._internal_model()._internal_paneForSource(this._internal__series);\n        if (pane === null) {\n            return;\n        }\n        pane._internal_setSeriesOrder(this._internal__series, order);\n    }\n    _private__onDataChanged(scope) {\n        if (this._private__dataChangedDelegate._internal_hasListeners()) {\n            this._private__dataChangedDelegate._internal_fire(scope);\n        }\n    }\n    constructor(series, dataUpdatesConsumer, priceScaleApiProvider, chartApi, horzScaleBehavior, paneApiGetter){\n        this._private__dataChangedDelegate = new Delegate();\n        this._internal__series = series;\n        this._internal__dataUpdatesConsumer = dataUpdatesConsumer;\n        this._private__priceScaleApiProvider = priceScaleApiProvider;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._internal__chartApi = chartApi;\n        this._private__paneApiGetter = paneApiGetter;\n    }\n}\nclass TimeScaleApi {\n    _internal_destroy() {\n        this._private__timeScale._internal_visibleBarsChanged()._internal_unsubscribeAll(this);\n        this._private__timeScale._internal_logicalRangeChanged()._internal_unsubscribeAll(this);\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_unsubscribeAll(this);\n        this._private__timeRangeChanged._internal_destroy();\n        this._private__logicalRangeChanged._internal_destroy();\n        this._private__sizeChanged._internal_destroy();\n    }\n    scrollPosition() {\n        return this._private__timeScale._internal_rightOffset();\n    }\n    scrollToPosition(position, animated) {\n        if (!animated) {\n            this._private__model._internal_setRightOffset(position);\n            return;\n        }\n        this._private__timeScale._internal_scrollToOffsetAnimated(position, 1000 /* Constants.AnimationDurationMs */ );\n    }\n    scrollToRealTime() {\n        this._private__timeScale._internal_scrollToRealTime();\n    }\n    getVisibleRange() {\n        const timeRange = this._private__timeScale._internal_visibleTimeRange();\n        if (timeRange === null) {\n            return null;\n        }\n        return {\n            from: timeRange.from.originalTime,\n            to: timeRange.to.originalTime\n        };\n    }\n    setVisibleRange(range) {\n        const convertedRange = {\n            from: this._private__horzScaleBehavior.convertHorzItemToInternal(range.from),\n            to: this._private__horzScaleBehavior.convertHorzItemToInternal(range.to)\n        };\n        const logicalRange = this._private__timeScale._internal_logicalRangeForTimeRange(convertedRange);\n        this._private__model._internal_setTargetLogicalRange(logicalRange);\n    }\n    getVisibleLogicalRange() {\n        const logicalRange = this._private__timeScale._internal_visibleLogicalRange();\n        if (logicalRange === null) {\n            return null;\n        }\n        return {\n            from: logicalRange._internal_left(),\n            to: logicalRange._internal_right()\n        };\n    }\n    setVisibleLogicalRange(range) {\n        assert(range.from <= range.to, 'The from index cannot be after the to index.');\n        this._private__model._internal_setTargetLogicalRange(range);\n    }\n    resetTimeScale() {\n        this._private__model._internal_resetTimeScale();\n    }\n    fitContent() {\n        this._private__model._internal_fitContent();\n    }\n    logicalToCoordinate(logical) {\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return null;\n        } else {\n            return timeScale._internal_indexToCoordinate(logical);\n        }\n    }\n    coordinateToLogical(x) {\n        if (this._private__timeScale._internal_isEmpty()) {\n            return null;\n        } else {\n            return this._private__timeScale._internal_coordinateToIndex(x);\n        }\n    }\n    timeToIndex(time, findNearest) {\n        const timePoint = this._private__horzScaleBehavior.convertHorzItemToInternal(time);\n        return this._private__timeScale._internal_timeToIndex(timePoint, findNearest);\n    }\n    timeToCoordinate(time) {\n        const timePointIndex = this.timeToIndex(time, false);\n        if (timePointIndex === null) {\n            return null;\n        }\n        return this._private__timeScale._internal_indexToCoordinate(timePointIndex);\n    }\n    coordinateToTime(x) {\n        const timeScale = this._private__model._internal_timeScale();\n        const timePointIndex = timeScale._internal_coordinateToIndex(x);\n        const timePoint = timeScale._internal_indexToTimeScalePoint(timePointIndex);\n        if (timePoint === null) {\n            return null;\n        }\n        return timePoint.originalTime;\n    }\n    width() {\n        return this._private__timeAxisWidget._internal_getSize().width;\n    }\n    height() {\n        return this._private__timeAxisWidget._internal_getSize().height;\n    }\n    subscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_subscribe(handler);\n    }\n    unsubscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_unsubscribe(handler);\n    }\n    applyOptions(options) {\n        this._private__timeScale._internal_applyOptions(options);\n    }\n    options() {\n        return {\n            ...clone(this._private__timeScale._internal_options()),\n            barSpacing: this._private__timeScale._internal_barSpacing()\n        };\n    }\n    _private__onVisibleBarsChanged() {\n        if (this._private__timeRangeChanged._internal_hasListeners()) {\n            this._private__timeRangeChanged._internal_fire(this.getVisibleRange());\n        }\n    }\n    _private__onVisibleLogicalRangeChanged() {\n        if (this._private__logicalRangeChanged._internal_hasListeners()) {\n            this._private__logicalRangeChanged._internal_fire(this.getVisibleLogicalRange());\n        }\n    }\n    _private__onSizeChanged(size) {\n        this._private__sizeChanged._internal_fire(size.width, size.height);\n    }\n    constructor(model, timeAxisWidget, horzScaleBehavior){\n        this._private__timeRangeChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__sizeChanged = new Delegate();\n        this._private__model = model;\n        this._private__timeScale = model._internal_timeScale();\n        this._private__timeAxisWidget = timeAxisWidget;\n        this._private__timeScale._internal_visibleBarsChanged()._internal_subscribe(this._private__onVisibleBarsChanged.bind(this));\n        this._private__timeScale._internal_logicalRangeChanged()._internal_subscribe(this._private__onVisibleLogicalRangeChanged.bind(this));\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_subscribe(this._private__onSizeChanged.bind(this));\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n}\n/// <reference types=\"_build-time-constants\" />\nfunction patchPriceFormat(priceFormat) {\n    if (priceFormat === undefined || priceFormat.type === 'custom') {\n        return;\n    }\n    const priceFormatBuiltIn = priceFormat;\n    if (priceFormatBuiltIn.minMove !== undefined && priceFormatBuiltIn.precision === undefined) {\n        priceFormatBuiltIn.precision = precisionByMinMove(priceFormatBuiltIn.minMove);\n    }\n}\nfunction migrateHandleScaleScrollOptions(options) {\n    if (isBoolean(options['handleScale'])) {\n        const handleScale = options['handleScale'];\n        options['handleScale'] = {\n            axisDoubleClickReset: {\n                time: handleScale,\n                price: handleScale\n            },\n            axisPressedMouseMove: {\n                time: handleScale,\n                price: handleScale\n            },\n            mouseWheel: handleScale,\n            pinch: handleScale\n        };\n    } else if (options['handleScale'] !== undefined) {\n        const { axisPressedMouseMove, axisDoubleClickReset } = options['handleScale'];\n        if (isBoolean(axisPressedMouseMove)) {\n            options['handleScale'].axisPressedMouseMove = {\n                time: axisPressedMouseMove,\n                price: axisPressedMouseMove\n            };\n        }\n        if (isBoolean(axisDoubleClickReset)) {\n            options['handleScale'].axisDoubleClickReset = {\n                time: axisDoubleClickReset,\n                price: axisDoubleClickReset\n            };\n        }\n    }\n    const handleScroll = options['handleScroll'];\n    if (isBoolean(handleScroll)) {\n        options['handleScroll'] = {\n            horzTouchDrag: handleScroll,\n            vertTouchDrag: handleScroll,\n            mouseWheel: handleScroll,\n            pressedMouseMove: handleScroll\n        };\n    }\n}\nfunction toInternalOptions(options) {\n    migrateHandleScaleScrollOptions(options);\n    return options;\n}\nclass ChartApi {\n    remove() {\n        this._private__chartWidget._internal_clicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__timeScaleApi._internal_destroy();\n        this._private__chartWidget._internal_destroy();\n        this._private__seriesMap.clear();\n        this._private__seriesMapReversed.clear();\n        this._private__clickedDelegate._internal_destroy();\n        this._private__dblClickedDelegate._internal_destroy();\n        this._private__crosshairMovedDelegate._internal_destroy();\n        this._private__dataLayer._internal_destroy();\n    }\n    resize(width, height, forceRepaint) {\n        if (this.autoSizeActive()) {\n            // We return early here instead of checking this within the actual _chartWidget.resize method\n            // because this should only apply to external resize requests.\n            warn(\"Height and width values ignored because 'autoSize' option is enabled.\");\n            return;\n        }\n        this._private__chartWidget._internal_resize(width, height, forceRepaint);\n    }\n    addCustomSeries(customPaneView) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, paneIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const paneView = ensure(customPaneView);\n        const definition = createCustomSeriesDefinition(paneView);\n        return this._private__addSeriesImpl(definition, options, paneIndex);\n    }\n    addSeries(definition) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, paneIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        return this._private__addSeriesImpl(definition, options, paneIndex);\n    }\n    removeSeries(seriesApi) {\n        const series = ensureDefined(this._private__seriesMap.get(seriesApi));\n        const update = this._private__dataLayer._internal_removeSeries(series);\n        const model = this._private__chartWidget._internal_model();\n        model._internal_removeSeries(series);\n        this._private__sendUpdateToChart(update);\n        this._private__seriesMap.delete(seriesApi);\n        this._private__seriesMapReversed.delete(series);\n    }\n    _internal_applyNewData(series, data) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_setSeriesData(series, data));\n    }\n    _internal_updateData(series, data, historicalUpdate) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_updateSeriesData(series, data, historicalUpdate));\n    }\n    subscribeClick(handler) {\n        this._private__clickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeClick(handler) {\n        this._private__clickedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_unsubscribe(handler);\n    }\n    priceScale(priceScaleId) {\n        let paneIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        return new PriceScaleApi(this._private__chartWidget, priceScaleId, paneIndex);\n    }\n    timeScale() {\n        return this._private__timeScaleApi;\n    }\n    applyOptions(options) {\n        {\n            var _options_layout, _options_layout1;\n            const colorSpace = (_options_layout = options.layout) === null || _options_layout === void 0 ? void 0 : _options_layout.colorSpace;\n            if (colorSpace !== undefined && colorSpace !== this.options().layout.colorSpace) {\n                throw new Error(\"colorSpace option should not be changed once the chart has been created.\");\n            }\n            const colorParsers = (_options_layout1 = options.layout) === null || _options_layout1 === void 0 ? void 0 : _options_layout1.colorParsers;\n            if (colorParsers !== undefined && colorParsers !== this.options().layout.colorParsers) {\n                throw new Error(\"colorParsers option should not be changed once the chart has been created.\");\n            }\n        }\n        this._private__chartWidget._internal_applyOptions(toInternalOptions(options));\n    }\n    options() {\n        return this._private__chartWidget._internal_options();\n    }\n    takeScreenshot() {\n        return this._private__chartWidget._internal_takeScreenshot();\n    }\n    removePane(index) {\n        this._private__chartWidget._internal_model()._internal_removePane(index);\n    }\n    swapPanes(first, second) {\n        this._private__chartWidget._internal_model()._internal_swapPanes(first, second);\n    }\n    autoSizeActive() {\n        return this._private__chartWidget._internal_autoSizeActive();\n    }\n    chartElement() {\n        return this._private__chartWidget._internal_element();\n    }\n    panes() {\n        return this._private__chartWidget._internal_model()._internal_panes().map((pane)=>this._private__getPaneApi(pane));\n    }\n    paneSize() {\n        let paneIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        const size = this._private__chartWidget._internal_paneSize(paneIndex);\n        return {\n            height: size.height,\n            width: size.width\n        };\n    }\n    setCrosshairPosition(price, horizontalPosition, seriesApi) {\n        const series = this._private__seriesMap.get(seriesApi);\n        if (series === undefined) {\n            return;\n        }\n        const pane = this._private__chartWidget._internal_model()._internal_paneForSource(series);\n        if (pane === null) {\n            return;\n        }\n        this._private__chartWidget._internal_model()._internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane);\n    }\n    clearCrosshairPosition() {\n        this._private__chartWidget._internal_model()._internal_clearCurrentPosition(true);\n    }\n    horzBehaviour() {\n        return this._internal__horzScaleBehavior;\n    }\n    _private__addSeriesImpl(definition) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, paneIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        assert(isSeriesDefinition(definition));\n        patchPriceFormat(options.priceFormat);\n        if (definition.type === 'Candlestick') {\n            fillUpDownCandlesticksColors(options);\n        }\n        const strictOptions = merge(clone(seriesOptionsDefaults), clone(definition.defaultOptions), options);\n        const createPaneView = definition._internal_createPaneView;\n        const series = new Series(this._private__chartWidget._internal_model(), definition.type, strictOptions, createPaneView, definition._internal_customPaneView);\n        this._private__chartWidget._internal_model()._internal_addSeriesToPane(series, paneIndex);\n        const res = new SeriesApi(series, this, this, this, this._internal__horzScaleBehavior, (pane)=>this._private__getPaneApi(pane));\n        this._private__seriesMap.set(res, series);\n        this._private__seriesMapReversed.set(series, res);\n        return res;\n    }\n    _private__sendUpdateToChart(update) {\n        const model = this._private__chartWidget._internal_model();\n        model._internal_updateTimeScale(update._internal_timeScale._internal_baseIndex, update._internal_timeScale._internal_points, update._internal_timeScale._internal_firstChangedPointIndex);\n        update._internal_series.forEach((value, series)=>series._internal_setData(value._internal_data, value._internal_info));\n        model._internal_timeScale()._internal_recalculateIndicesWithData();\n        model._internal_recalculateAllPanes();\n    }\n    _private__mapSeriesToApi(series) {\n        return ensureDefined(this._private__seriesMapReversed.get(series));\n    }\n    _private__convertMouseParams(param) {\n        const seriesData = new Map();\n        param._internal_seriesData.forEach((plotRow, series)=>{\n            const seriesType = series._internal_seriesType();\n            const data = getSeriesDataCreator(seriesType)(plotRow);\n            if (seriesType !== 'Custom') {\n                assert(isFulfilledData(data));\n            } else {\n                const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n                assert(!customWhitespaceChecker || customWhitespaceChecker(data) === false);\n            }\n            seriesData.set(this._private__mapSeriesToApi(series), data);\n        });\n        const hoveredSeries = param._internal_hoveredSeries === undefined || !this._private__seriesMapReversed.has(param._internal_hoveredSeries) ? undefined : this._private__mapSeriesToApi(param._internal_hoveredSeries);\n        return {\n            time: param._internal_originalTime,\n            logical: param._internal_index,\n            point: param._internal_point,\n            paneIndex: param._internal_paneIndex,\n            hoveredSeries,\n            hoveredObjectId: param._internal_hoveredObject,\n            seriesData,\n            sourceEvent: param._internal_touchMouseEventData\n        };\n    }\n    _private__getPaneApi(pane) {\n        let result = this._private__panes.get(pane);\n        if (!result) {\n            result = new PaneApi(this._private__chartWidget, (series)=>this._private__mapSeriesToApi(series), pane, this);\n            this._private__panes.set(pane, result);\n        }\n        return result;\n    }\n    constructor(container, horzScaleBehavior, options){\n        this._private__seriesMap = new Map();\n        this._private__seriesMapReversed = new Map();\n        this._private__clickedDelegate = new Delegate();\n        this._private__dblClickedDelegate = new Delegate();\n        this._private__crosshairMovedDelegate = new Delegate();\n        this._private__panes = new WeakMap();\n        this._private__dataLayer = new DataLayer(horzScaleBehavior);\n        const internalOptions = options === undefined ? clone(chartOptionsDefaults()) : merge(clone(chartOptionsDefaults()), toInternalOptions(options));\n        this._internal__horzScaleBehavior = horzScaleBehavior;\n        this._private__chartWidget = new ChartWidget(container, internalOptions, horzScaleBehavior);\n        this._private__chartWidget._internal_clicked()._internal_subscribe((paramSupplier)=>{\n            if (this._private__clickedDelegate._internal_hasListeners()) {\n                this._private__clickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_dblClicked()._internal_subscribe((paramSupplier)=>{\n            if (this._private__dblClickedDelegate._internal_hasListeners()) {\n                this._private__dblClickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_subscribe((paramSupplier)=>{\n            if (this._private__crosshairMovedDelegate._internal_hasListeners()) {\n                this._private__crosshairMovedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        const model = this._private__chartWidget._internal_model();\n        this._private__timeScaleApi = new TimeScaleApi(model, this._private__chartWidget._internal_timeAxisWidget(), this._internal__horzScaleBehavior);\n    }\n}\nfunction fetchHtmlElement(container) {\n    if (isString(container)) {\n        const element = document.getElementById(container);\n        assert(element !== null, \"Cannot find element in DOM with id=\".concat(container));\n        return element;\n    }\n    return container;\n}\n/**\n * This function is the main entry point of the Lightweight Charting Library. If you are using time values\n * for the horizontal scale then it is recommended that you rather use the {@link createChart} function.\n *\n * @template HorzScaleItem - type of points on the horizontal scale\n * @template THorzScaleBehavior - type of horizontal axis strategy that encapsulate all the specific behaviors of the horizontal scale type\n *\n * @param container - ID of HTML element or element itself\n * @param horzScaleBehavior - Horizontal scale behavior\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */ function createChartEx(container, horzScaleBehavior, options) {\n    const htmlElement = fetchHtmlElement(container);\n    const res = new ChartApi(htmlElement, horzScaleBehavior, options);\n    horzScaleBehavior.setOptions(res.options());\n    return res;\n}\n/**\n * This function is the simplified main entry point of the Lightweight Charting Library with time points for the horizontal scale.\n *\n * @param container - ID of HTML element or element itself\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */ function createChart(container, options) {\n    return createChartEx(container, new HorzScaleBehaviorTime(), HorzScaleBehaviorTime._internal_applyDefaults(options));\n}\n/**\n * Provides the default implementation of the horizontal scale (time-based) that can be used as a base for extending the horizontal scale with custom behavior.\n * This allows for the introduction of custom functionality without re-implementing the entire {@link IHorzScaleBehavior}&lt;{@link Time}&gt; interface.\n *\n * For further details, refer to the {@link createChartEx} chart constructor method.\n *\n * @returns An uninitialized class implementing the {@link IHorzScaleBehavior}&lt;{@link Time}&gt; interface\n */ function defaultHorzScaleBehavior() {\n    return HorzScaleBehaviorTime;\n}\nclass LinePaneViewBase extends SeriesPaneViewBase {\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_pointsArrayToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createRawItemBase(time, price) {\n        return {\n            _internal_time: time,\n            _internal_price: price,\n            _internal_x: NaN,\n            _internal_y: NaN\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>{\n            const value = row._internal_value[3 /* PlotRowValueIndex.Close */ ];\n            return this._internal__createRawItem(row._internal_index, value, colorer);\n        });\n    }\n    constructor(series, model){\n        super(series, model, true);\n    }\n}\nfunction drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, // the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter) {\n    if (visibleRange.to - visibleRange.from <= 0) {\n        return;\n    }\n    const { horizontalPixelRatio, verticalPixelRatio, context } = renderingScope;\n    let prevStyle = null;\n    const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n    const correction = tickWidth % 2 / 2;\n    const radius = pointMarkersRadius * verticalPixelRatio + correction;\n    for(let i = visibleRange.to - 1; i >= visibleRange.from; --i){\n        const point = items[i];\n        if (point) {\n            const style = styleGetter(renderingScope, point);\n            if (style !== prevStyle) {\n                context.beginPath();\n                if (prevStyle !== null) {\n                    context.fill();\n                }\n                context.fillStyle = style;\n                prevStyle = style;\n            }\n            const centerX = Math.round(point._internal_x * horizontalPixelRatio) + correction; // correct x coordinate only\n            const centerY = point._internal_y * verticalPixelRatio;\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        }\n    }\n    context.fill();\n}\n// eslint-disable-next-line max-params, complexity\nfunction walkLine(renderingScope, items, lineType, visibleRange, barWidth, // the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter, finishStyledArea) {\n    if (items.length === 0 || visibleRange.from >= items.length || visibleRange.to <= 0) {\n        return;\n    }\n    const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n    const firstItem = items[visibleRange.from];\n    let currentStyle = styleGetter(renderingScope, firstItem);\n    let currentStyleFirstItem = firstItem;\n    if (visibleRange.to - visibleRange.from < 2) {\n        const halfBarWidth = barWidth / 2;\n        ctx.beginPath();\n        const item1 = {\n            _internal_x: firstItem._internal_x - halfBarWidth,\n            _internal_y: firstItem._internal_y\n        };\n        const item2 = {\n            _internal_x: firstItem._internal_x + halfBarWidth,\n            _internal_y: firstItem._internal_y\n        };\n        ctx.moveTo(item1._internal_x * horizontalPixelRatio, item1._internal_y * verticalPixelRatio);\n        ctx.lineTo(item2._internal_x * horizontalPixelRatio, item2._internal_y * verticalPixelRatio);\n        finishStyledArea(renderingScope, currentStyle, item1, item2);\n    } else {\n        const changeStyle = (newStyle, currentItem)=>{\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n            ctx.beginPath();\n            currentStyle = newStyle;\n            currentStyleFirstItem = currentItem;\n        };\n        let currentItem = currentStyleFirstItem;\n        ctx.beginPath();\n        ctx.moveTo(firstItem._internal_x * horizontalPixelRatio, firstItem._internal_y * verticalPixelRatio);\n        for(let i = visibleRange.from + 1; i < visibleRange.to; ++i){\n            currentItem = items[i];\n            const itemStyle = styleGetter(renderingScope, currentItem);\n            switch(lineType){\n                case 0 /* LineType.Simple */ :\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 1 /* LineType.WithSteps */ :\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    if (itemStyle !== currentStyle) {\n                        changeStyle(itemStyle, currentItem);\n                        ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    }\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 2 /* LineType.Curved */ :\n                    {\n                        const [cp1, cp2] = getControlPoints(items, i - 1, i);\n                        ctx.bezierCurveTo(cp1._internal_x * horizontalPixelRatio, cp1._internal_y * verticalPixelRatio, cp2._internal_x * horizontalPixelRatio, cp2._internal_y * verticalPixelRatio, currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                        break;\n                    }\n            }\n            if (lineType !== 1 /* LineType.WithSteps */  && itemStyle !== currentStyle) {\n                changeStyle(itemStyle, currentItem);\n                ctx.moveTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n            }\n        }\n        if (currentStyleFirstItem !== currentItem || currentStyleFirstItem === currentItem && lineType === 1 /* LineType.WithSteps */ ) {\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n        }\n    }\n}\nconst curveTension = 6;\nfunction subtract(p1, p2) {\n    return {\n        _internal_x: p1._internal_x - p2._internal_x,\n        _internal_y: p1._internal_y - p2._internal_y\n    };\n}\nfunction add(p1, p2) {\n    return {\n        _internal_x: p1._internal_x + p2._internal_x,\n        _internal_y: p1._internal_y + p2._internal_y\n    };\n}\nfunction divide(p1, n) {\n    return {\n        _internal_x: p1._internal_x / n,\n        _internal_y: p1._internal_y / n\n    };\n}\n/**\n * @returns Two control points that can be used as arguments to {@link CanvasRenderingContext2D.bezierCurveTo} to draw a curved line between `points[fromPointIndex]` and `points[toPointIndex]`.\n */ function getControlPoints(points, fromPointIndex, toPointIndex) {\n    const beforeFromPointIndex = Math.max(0, fromPointIndex - 1);\n    const afterToPointIndex = Math.min(points.length - 1, toPointIndex + 1);\n    const cp1 = add(points[fromPointIndex], divide(subtract(points[toPointIndex], points[beforeFromPointIndex]), curveTension));\n    const cp2 = subtract(points[toPointIndex], divide(subtract(points[afterToPointIndex], points[fromPointIndex]), curveTension));\n    return [\n        cp1,\n        cp2\n    ];\n}\nfunction finishStyledArea$1(scope, style) {\n    const ctx = scope.context;\n    ctx.strokeStyle = style;\n    ctx.stroke();\n}\nclass PaneRendererLineBase extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineType: lineType, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_pointMarkersRadius: pointMarkersRadius } = this._internal__data;\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = 'butt';\n        ctx.lineWidth = lineWidth * renderingScope.verticalPixelRatio;\n        setLineStyle(ctx, lineStyle);\n        ctx.lineJoin = 'round';\n        const styleGetter = this._internal__strokeStyle.bind(this);\n        if (lineType !== undefined) {\n            walkLine(renderingScope, items, lineType, visibleRange, barWidth, styleGetter, finishStyledArea$1);\n        }\n        if (pointMarkersRadius) {\n            drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, styleGetter);\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nclass PaneRendererLine extends PaneRendererLineBase {\n    _internal__strokeStyle(renderingScope, item) {\n        return item._internal_lineColor;\n    }\n}\nclass SeriesLinePaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_lineWidth: options.lineWidth,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing()\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererLine();\n    }\n}\nconst lineStyleDefaults = {\n    color: '#2196f3',\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst createPaneView$5 = (series, model)=>new SeriesLinePaneView(series, model);\nconst createLineSeries = ()=>{\n    const definition = {\n        type: 'Line',\n        isBuiltIn: true,\n        defaultOptions: lineStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$5\n    };\n    return definition;\n};\nconst lineSeries = createLineSeries();\nfunction createDebouncedMicroTaskHandler(callback) {\n    let scheduled = false;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!scheduled) {\n            scheduled = true;\n            queueMicrotask(()=>{\n                callback(...args);\n                scheduled = false;\n            });\n        }\n    };\n}\nfunction markWithGreaterWeight$1(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nfunction toInternalHorzScaleItem(item) {\n    return item;\n}\nfunction fromInternalHorzScaleItem(item) {\n    return item;\n}\nclass YieldCurveHorzScaleBehavior {\n    /** Data changes might require that the whitespace be generated again */ _internal_whitespaceInvalidated() {\n        return this._private__pointsChangedDelegate;\n    }\n    _internal_destroy() {\n        this._private__pointsChangedDelegate._internal_destroy();\n    }\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n    }\n    preprocessData(data) {\n    // No preprocessing needed for yield curve data\n    }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        this._private__options.localization = options;\n    }\n    createConverterToInternalObj(data) {\n        this._private__invalidateWhitespace();\n        return (time)=>{\n            if (time > this._private__largestIndex) {\n                this._private__largestIndex = time;\n            }\n            return toInternalHorzScaleItem(time);\n        };\n    }\n    key(internalItem) {\n        return internalItem;\n    }\n    cacheKey(internalItem) {\n        return fromInternalHorzScaleItem(internalItem);\n    }\n    convertHorzItemToInternal(item) {\n        return toInternalHorzScaleItem(item);\n    }\n    formatHorzItem(item) {\n        return this._private__formatTime(item);\n    }\n    formatTickmark(item) {\n        return this._private__formatTime(item.time);\n    }\n    maxTickMarkWeight(marks) {\n        return marks.reduce(markWithGreaterWeight$1, marks[0]).weight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        const timeWeight = (time)=>{\n            if (time % 120 === 0) {\n                return 10;\n            }\n            if (time % 60 === 0) {\n                return 9;\n            }\n            if (time % 36 === 0) {\n                return 8;\n            }\n            if (time % 12 === 0) {\n                return 7;\n            }\n            if (time % 6 === 0) {\n                return 6;\n            }\n            if (time % 3 === 0) {\n                return 5;\n            }\n            if (time % 1 === 0) {\n                return 4;\n            }\n            return 0;\n        };\n        for(let index = startIndex; index < sortedTimePoints.length; ++index){\n            sortedTimePoints[index].timeWeight = timeWeight(fromInternalHorzScaleItem(sortedTimePoints[index].time));\n        }\n        this._private__largestIndex = fromInternalHorzScaleItem(sortedTimePoints[sortedTimePoints.length - 1].time);\n        this._private__invalidateWhitespace();\n    }\n    _private__formatTime(months) {\n        var _this__private__options_localization;\n        if ((_this__private__options_localization = this._private__options.localization) === null || _this__private__options_localization === void 0 ? void 0 : _this__private__options_localization.timeFormatter) {\n            return this._private__options.localization.timeFormatter(months);\n        }\n        if (months < 12) {\n            return \"\".concat(months, \"M\");\n        }\n        const years = Math.floor(months / 12);\n        const remainingMonths = months % 12;\n        if (remainingMonths === 0) {\n            return \"\".concat(years, \"Y\");\n        }\n        return \"\".concat(years, \"Y\").concat(remainingMonths, \"M\");\n    }\n    constructor(){\n        this._private__pointsChangedDelegate = new Delegate();\n        this._private__invalidateWhitespace = createDebouncedMicroTaskHandler(()=>this._private__pointsChangedDelegate._internal_fire(this._private__largestIndex));\n        this._private__largestIndex = 0;\n    }\n}\nconst yieldChartOptionsDefaults = {\n    baseResolution: 1,\n    minimumTimeRange: 120,\n    startTimeRange: 0\n};\nfunction generateWhitespaceData(param) {\n    let { _internal_start: start, _internal_end: end, _internal_resolution: resolution } = param;\n    return Array.from({\n        length: Math.floor((end - start) / resolution) + 1\n    }, // eslint-disable-next-line quote-props\n    (item, i)=>({\n            'time': start + i * resolution\n        }));\n}\nfunction buildWhitespaceState(options, lastIndex) {\n    return {\n        _internal_start: Math.max(0, options.startTimeRange),\n        _internal_end: Math.max(0, options.minimumTimeRange, lastIndex || 0),\n        _internal_resolution: Math.max(1, options.baseResolution)\n    };\n}\nconst generateWhitespaceHash = (param)=>{\n    let { _internal_start: start, _internal_end: end, _internal_resolution: resolution } = param;\n    return \"\".concat(start, \"~\").concat(end, \"~\").concat(resolution);\n};\nconst defaultOptions = {\n    yieldCurve: yieldChartOptionsDefaults,\n    // and add sensible default options for yield charts which\n    // are different from the usual defaults.\n    timeScale: {\n        ignoreWhitespaceIndices: true\n    },\n    leftPriceScale: {\n        visible: true\n    },\n    rightPriceScale: {\n        visible: false\n    },\n    localization: {\n        priceFormatter: (value)=>{\n            return value.toFixed(3) + '%';\n        }\n    }\n};\nconst lineStyleDefaultOptionOverrides = {\n    lastValueVisible: false,\n    priceLineVisible: false\n};\nclass YieldChartApi extends ChartApi {\n    addSeries(definition) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, paneIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        if (definition.isBuiltIn && [\n            'Area',\n            'Line'\n        ].includes(definition.type) === false) {\n            throw new Error('Yield curve only support Area and Line series');\n        }\n        const optionOverrides = {\n            ...lineStyleDefaultOptionOverrides,\n            ...options\n        };\n        return super.addSeries(definition, optionOverrides, paneIndex);\n    }\n    _initWhitespaceSeries() {\n        const horzBehaviour = this.horzBehaviour();\n        const whiteSpaceSeries = this.addSeries(lineSeries);\n        let currentWhitespaceHash;\n        function updateWhitespace(lastIndex) {\n            const newWhitespaceState = buildWhitespaceState(horzBehaviour.options().yieldCurve, lastIndex);\n            const newWhitespaceHash = generateWhitespaceHash(newWhitespaceState);\n            if (newWhitespaceHash !== currentWhitespaceHash) {\n                currentWhitespaceHash = newWhitespaceHash;\n                whiteSpaceSeries.setData(generateWhitespaceData(newWhitespaceState));\n            }\n        }\n        updateWhitespace(0);\n        horzBehaviour._internal_whitespaceInvalidated()._internal_subscribe(updateWhitespace);\n    }\n    constructor(container, options){\n        const fullOptions = merge(defaultOptions, options || {});\n        const horzBehaviour = new YieldCurveHorzScaleBehavior();\n        super(container, horzBehaviour, fullOptions);\n        horzBehaviour.setOptions(this.options());\n        this._initWhitespaceSeries();\n    }\n}\n/**\n * Creates a yield curve chart with the specified options.\n *\n * A yield curve chart differs from the default chart type\n * in the following ways:\n * - Horizontal scale is linearly spaced, and defined in monthly\n * time duration units\n * - Whitespace is ignored for the crosshair and grid lines\n *\n * @param container - ID of HTML element or element itself\n * @param options - The yield chart options.\n * @returns An interface to the created chart\n */ function createYieldCurveChart(container, options) {\n    const htmlElement = fetchHtmlElement(container);\n    const chartApi = new YieldChartApi(htmlElement, options);\n    return chartApi;\n}\nfunction markWithGreaterWeight(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nclass HorzScaleBehaviorPrice {\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n    }\n    preprocessData(data) {}\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        this._private__options.localization = options;\n    }\n    createConverterToInternalObj(data) {\n        return (price)=>price;\n    }\n    key(internalItem) {\n        return internalItem;\n    }\n    cacheKey(internalItem) {\n        return internalItem;\n    }\n    convertHorzItemToInternal(item) {\n        return item;\n    }\n    formatHorzItem(item) {\n        return item.toFixed(this._private__precision());\n    }\n    formatTickmark(item, localizationOptions) {\n        return item.time.toFixed(this._private__precision());\n    }\n    maxTickMarkWeight(marks) {\n        return marks.reduce(markWithGreaterWeight, marks[0]).weight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        const priceWeight = (price)=>{\n            if (price === Math.ceil(price / 100) * 100) {\n                return 8;\n            }\n            if (price === Math.ceil(price / 50) * 50) {\n                return 7;\n            }\n            if (price === Math.ceil(price / 25) * 25) {\n                return 6;\n            }\n            if (price === Math.ceil(price / 10) * 10) {\n                return 5;\n            }\n            if (price === Math.ceil(price / 5) * 5) {\n                return 4;\n            }\n            if (price === Math.ceil(price)) {\n                return 3;\n            }\n            if (price * 2 === Math.ceil(price * 2)) {\n                return 1;\n            }\n            return 0;\n        };\n        for(let index = startIndex; index < sortedTimePoints.length; ++index){\n            sortedTimePoints[index].timeWeight = priceWeight(sortedTimePoints[index].time);\n        }\n    }\n    _private__precision() {\n        return this._private__options.localization.precision;\n    }\n}\n/**\n * Creates an 'options' chart with price values on the horizontal scale.\n *\n * This function is used to create a specialized chart type where the horizontal scale\n * represents price values instead of time. It's particularly useful for visualizing\n * option chains, price distributions, or any data where price is the primary x-axis metric.\n *\n * @param container - The DOM element or its id where the chart will be rendered.\n * @param options - Optional configuration options for the price chart.\n * @returns An instance of IChartApiBase configured for price-based horizontal scaling.\n */ function createOptionsChart(container, options) {\n    return createChartEx(container, new HorzScaleBehaviorPrice(), options);\n}\nfunction finishStyledArea(baseLevelCoordinate, scope, style, areaFirstItem, newAreaFirstItem) {\n    const { context, horizontalPixelRatio, verticalPixelRatio } = scope;\n    context.lineTo(newAreaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.lineTo(areaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.closePath();\n    context.fillStyle = style;\n    context.fill();\n}\nclass PaneRendererAreaBase extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_lineType: lineType } = this._internal__data;\n        var _this__internal__data__internal_baseLevelCoordinate;\n        const baseLevelCoordinate = (_this__internal__data__internal_baseLevelCoordinate = this._internal__data._internal_baseLevelCoordinate) !== null && _this__internal__data__internal_baseLevelCoordinate !== void 0 ? _this__internal__data__internal_baseLevelCoordinate : this._internal__data._internal_invertFilledArea ? 0 : renderingScope.mediaSize.height;\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = 'butt';\n        ctx.lineJoin = 'round';\n        ctx.lineWidth = lineWidth;\n        setLineStyle(ctx, lineStyle);\n        // walk lines with width=1 to have more accurate gradient's filling\n        ctx.lineWidth = 1;\n        walkLine(renderingScope, items, lineType, visibleRange, barWidth, this._internal__fillStyle.bind(this), finishStyledArea.bind(null, baseLevelCoordinate));\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__data = null;\n    }\n}\nclass GradientStyleCache {\n    // eslint-disable-next-line complexity\n    _internal_get(scope, params) {\n        const cachedParams = this._private__params;\n        const { _internal_topColor1: topColor1, _internal_topColor2: topColor2, _internal_bottomColor1: bottomColor1, _internal_bottomColor2: bottomColor2, _internal_baseLevelCoordinate: baseLevelCoordinate, _internal_topCoordinate: topCoordinate, _internal_bottomCoordinate: bottomCoordinate } = params;\n        if (this._private__cachedValue === undefined || cachedParams === undefined || cachedParams._internal_topColor1 !== topColor1 || cachedParams._internal_topColor2 !== topColor2 || cachedParams._internal_bottomColor1 !== bottomColor1 || cachedParams._internal_bottomColor2 !== bottomColor2 || cachedParams._internal_baseLevelCoordinate !== baseLevelCoordinate || cachedParams._internal_topCoordinate !== topCoordinate || cachedParams._internal_bottomCoordinate !== bottomCoordinate) {\n            const { verticalPixelRatio } = scope;\n            const multiplier = baseLevelCoordinate || topCoordinate > 0 ? verticalPixelRatio : 1;\n            const top = topCoordinate * multiplier;\n            const bottom = bottomCoordinate === scope.bitmapSize.height ? bottomCoordinate : bottomCoordinate * multiplier;\n            const baseline = (baseLevelCoordinate !== null && baseLevelCoordinate !== void 0 ? baseLevelCoordinate : 0) * multiplier;\n            const gradient = scope.context.createLinearGradient(0, top, 0, bottom);\n            gradient.addColorStop(0, topColor1);\n            if (baseLevelCoordinate !== null && baseLevelCoordinate !== undefined) {\n                const range = bottom - top;\n                const baselineRatio = clamp((baseline - top) / range, 0, 1);\n                gradient.addColorStop(baselineRatio, topColor2);\n                gradient.addColorStop(baselineRatio, bottomColor1);\n            }\n            gradient.addColorStop(1, bottomColor2);\n            this._private__cachedValue = gradient;\n            this._private__params = params;\n        }\n        return this._private__cachedValue;\n    }\n}\nclass PaneRendererBaselineArea extends PaneRendererAreaBase {\n    _internal__fillStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        var _data__internal_topCoordinate, _data__internal_bottomCoordinate;\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topFillColor1,\n            _internal_topColor2: item._internal_topFillColor2,\n            _internal_bottomColor1: item._internal_bottomFillColor1,\n            _internal_bottomColor2: item._internal_bottomFillColor2,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate,\n            _internal_topCoordinate: (_data__internal_topCoordinate = data._internal_topCoordinate) !== null && _data__internal_topCoordinate !== void 0 ? _data__internal_topCoordinate : 0,\n            _internal_bottomCoordinate: (_data__internal_bottomCoordinate = data._internal_bottomCoordinate) !== null && _data__internal_bottomCoordinate !== void 0 ? _data__internal_bottomCoordinate : renderingScope.bitmapSize.height\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n}\nclass PaneRendererBaselineLine extends PaneRendererLineBase {\n    _internal__strokeStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        var _data__internal_topCoordinate, _data__internal_bottomCoordinate;\n        return this._private__strokeCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topLineColor,\n            _internal_topColor2: item._internal_topLineColor,\n            _internal_bottomColor1: item._internal_bottomLineColor,\n            _internal_bottomColor2: item._internal_bottomLineColor,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate,\n            _internal_topCoordinate: (_data__internal_topCoordinate = data._internal_topCoordinate) !== null && _data__internal_topCoordinate !== void 0 ? _data__internal_topCoordinate : 0,\n            _internal_bottomCoordinate: (_data__internal_bottomCoordinate = data._internal_bottomCoordinate) !== null && _data__internal_bottomCoordinate !== void 0 ? _data__internal_bottomCoordinate : renderingScope.bitmapSize.height\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__strokeCache = new GradientStyleCache();\n    }\n}\nclass SeriesBaselinePaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        const options = this._internal__series._internal_options();\n        const baseLevelCoordinate = this._internal__series._internal_priceScale()._internal_priceToCoordinate(options.baseValue.price, firstValue._internal_value);\n        const barWidth = this._internal__model._internal_timeScale()._internal_barSpacing();\n        if (this._internal__itemsVisibleRange === null || this._internal__items.length === 0) {\n            return;\n        }\n        let topCoordinate;\n        let bottomCoordinate;\n        if (options.relativeGradient) {\n            topCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            bottomCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            for(let i = this._internal__itemsVisibleRange.from; i < this._internal__itemsVisibleRange.to; i++){\n                const item = this._internal__items[i];\n                if (item._internal_y < topCoordinate) {\n                    topCoordinate = item._internal_y;\n                }\n                if (item._internal_y > bottomCoordinate) {\n                    bottomCoordinate = item._internal_y;\n                }\n            }\n        }\n        this._private__baselineAreaRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineType,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_topCoordinate: topCoordinate,\n            _internal_bottomCoordinate: bottomCoordinate,\n            _internal_invertFilledArea: false,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth\n        });\n        this._private__baselineLineRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_topCoordinate: topCoordinate,\n            _internal_bottomCoordinate: bottomCoordinate,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth\n        });\n    }\n    constructor(series, model){\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__baselineAreaRenderer = new PaneRendererBaselineArea();\n        this._private__baselineLineRenderer = new PaneRendererBaselineLine();\n        this._internal__renderer._internal_setRenderers([\n            this._private__baselineAreaRenderer,\n            this._private__baselineLineRenderer\n        ]);\n    }\n}\nconst baselineStyleDefaults = {\n    baseValue: {\n        type: 'price',\n        price: 0\n    },\n    relativeGradient: false,\n    topFillColor1: 'rgba(38, 166, 154, 0.28)',\n    topFillColor2: 'rgba(38, 166, 154, 0.05)',\n    topLineColor: 'rgba(38, 166, 154, 1)',\n    bottomFillColor1: 'rgba(239, 83, 80, 0.05)',\n    bottomFillColor2: 'rgba(239, 83, 80, 0.28)',\n    bottomLineColor: 'rgba(239, 83, 80, 1)',\n    lineWidth: 3,\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst createPaneView$4 = (series, model)=>new SeriesBaselinePaneView(series, model);\nconst createSeries$4 = ()=>{\n    const definition = {\n        type: 'Baseline',\n        isBuiltIn: true,\n        defaultOptions: baselineStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$4\n    };\n    return definition;\n};\nconst baselineSeries = createSeries$4();\nclass PaneRendererArea extends PaneRendererAreaBase {\n    _internal__fillStyle(renderingScope, item) {\n        var _this__internal__data;\n        var _this__internal__data__internal_topCoordinate;\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topColor,\n            _internal_topColor2: '',\n            _internal_bottomColor1: '',\n            _internal_bottomColor2: item._internal_bottomColor,\n            _internal_topCoordinate: (_this__internal__data__internal_topCoordinate = (_this__internal__data = this._internal__data) === null || _this__internal__data === void 0 ? void 0 : _this__internal__data._internal_topCoordinate) !== null && _this__internal__data__internal_topCoordinate !== void 0 ? _this__internal__data__internal_topCoordinate : 0,\n            _internal_bottomCoordinate: renderingScope.bitmapSize.height\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n}\nclass SeriesAreaPaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        if (this._internal__itemsVisibleRange === null || this._internal__items.length === 0) {\n            return;\n        }\n        let topCoordinate;\n        if (options.relativeGradient) {\n            topCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            for(let i = this._internal__itemsVisibleRange.from; i < this._internal__itemsVisibleRange.to; i++){\n                const item = this._internal__items[i];\n                if (item._internal_y < topCoordinate) {\n                    topCoordinate = item._internal_y;\n                }\n            }\n        }\n        this._private__areaRenderer._internal_setData({\n            _internal_lineType: options.lineType,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_baseLevelCoordinate: null,\n            _internal_topCoordinate: topCoordinate,\n            _internal_invertFilledArea: options.invertFilledArea,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing()\n        });\n        this._private__lineRenderer._internal_setData({\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? options.pointMarkersRadius || options.lineWidth / 2 + 2 : undefined\n        });\n    }\n    constructor(series, model){\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__areaRenderer = new PaneRendererArea();\n        this._private__lineRenderer = new PaneRendererLine();\n        this._internal__renderer._internal_setRenderers([\n            this._private__areaRenderer,\n            this._private__lineRenderer\n        ]);\n    }\n}\nconst areaStyleDefaults = {\n    topColor: 'rgba( 46, 220, 135, 0.4)',\n    bottomColor: 'rgba( 40, 221, 100, 0)',\n    invertFilledArea: false,\n    relativeGradient: false,\n    lineColor: '#33D778',\n    lineStyle: 0 /* LineStyle.Solid */ ,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */ ,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */ ,\n    pointMarkersVisible: false\n};\nconst createPaneView$3 = (series, model)=>new SeriesAreaPaneView(series, model);\nconst createSeries$3 = ()=>{\n    const definition = {\n        type: 'Area',\n        isBuiltIn: true,\n        defaultOptions: areaStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$3\n    };\n    return definition;\n};\nconst areaSeries = createSeries$3();\nfunction optimalBarWidth(barSpacing, pixelRatio) {\n    return Math.floor(barSpacing * 0.3 * pixelRatio);\n}\nfunction optimalCandlestickWidth(barSpacing, pixelRatio) {\n    const barSpacingSpecialCaseFrom = 2.5;\n    const barSpacingSpecialCaseTo = 4;\n    const barSpacingSpecialCaseCoeff = 3;\n    if (barSpacing >= barSpacingSpecialCaseFrom && barSpacing <= barSpacingSpecialCaseTo) {\n        return Math.floor(barSpacingSpecialCaseCoeff * pixelRatio);\n    }\n    // coeff should be 1 on small barspacing and go to 0.8 while groing bar spacing\n    const barSpacingReducingCoeff = 0.2;\n    const coeff = 1 - barSpacingReducingCoeff * Math.atan(Math.max(barSpacingSpecialCaseTo, barSpacing) - barSpacingSpecialCaseTo) / (Math.PI * 0.5);\n    const res = Math.floor(barSpacing * coeff * pixelRatio);\n    const scaledBarSpacing = Math.floor(barSpacing * pixelRatio);\n    const optimal = Math.min(res, scaledBarSpacing);\n    return Math.max(Math.floor(pixelRatio), optimal);\n}\nclass PaneRendererBars extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    // eslint-disable-next-line complexity\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        this._private__barWidth = this._private__calcBarWidth(horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make bars' width odd\n        // if this value is even, we have to make bars' width even\n        // in order of keeping crosshair-over-bar drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n            if (lineWidth % 2 !== this._private__barWidth % 2) {\n                this._private__barWidth--;\n            }\n        }\n        // if scale is compressed, bar could become less than 1 CSS pixel\n        this._private__barLineWidth = this._private__data._internal_thinBars ? Math.min(this._private__barWidth, Math.floor(horizontalPixelRatio)) : this._private__barWidth;\n        let prevColor = null;\n        const drawOpenClose = this._private__barLineWidth <= this._private__barWidth && this._private__data._internal_barSpacing >= Math.floor(1.5 * horizontalPixelRatio);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; ++i){\n            const bar = this._private__data._internal_bars[i];\n            if (prevColor !== bar._internal_barColor) {\n                ctx.fillStyle = bar._internal_barColor;\n                prevColor = bar._internal_barColor;\n            }\n            const bodyWidthHalf = Math.floor(this._private__barLineWidth * 0.5);\n            const bodyCenter = Math.round(bar._internal_x * horizontalPixelRatio);\n            const bodyLeft = bodyCenter - bodyWidthHalf;\n            const bodyWidth = this._private__barLineWidth;\n            const bodyRight = bodyLeft + bodyWidth - 1;\n            const high = Math.min(bar._internal_highY, bar._internal_lowY);\n            const low = Math.max(bar._internal_highY, bar._internal_lowY);\n            const bodyTop = Math.round(high * verticalPixelRatio) - bodyWidthHalf;\n            const bodyBottom = Math.round(low * verticalPixelRatio) + bodyWidthHalf;\n            const bodyHeight = Math.max(bodyBottom - bodyTop, this._private__barLineWidth);\n            ctx.fillRect(bodyLeft, bodyTop, bodyWidth, bodyHeight);\n            const sideWidth = Math.ceil(this._private__barWidth * 1.5);\n            if (drawOpenClose) {\n                if (this._private__data._internal_openVisible) {\n                    const openLeft = bodyCenter - sideWidth;\n                    let openTop = Math.max(bodyTop, Math.round(bar._internal_openY * verticalPixelRatio) - bodyWidthHalf);\n                    let openBottom = openTop + bodyWidth - 1;\n                    if (openBottom > bodyTop + bodyHeight - 1) {\n                        openBottom = bodyTop + bodyHeight - 1;\n                        openTop = openBottom - bodyWidth + 1;\n                    }\n                    ctx.fillRect(openLeft, openTop, bodyLeft - openLeft, openBottom - openTop + 1);\n                }\n                const closeRight = bodyCenter + sideWidth;\n                let closeTop = Math.max(bodyTop, Math.round(bar._internal_closeY * verticalPixelRatio) - bodyWidthHalf);\n                let closeBottom = closeTop + bodyWidth - 1;\n                if (closeBottom > bodyTop + bodyHeight - 1) {\n                    closeBottom = bodyTop + bodyHeight - 1;\n                    closeTop = closeBottom - bodyWidth + 1;\n                }\n                ctx.fillRect(bodyRight + 1, closeTop, closeRight - bodyRight, closeBottom - closeTop + 1);\n            }\n        }\n    }\n    _private__calcBarWidth(pixelRatio) {\n        const limit = Math.floor(pixelRatio);\n        return Math.max(limit, Math.floor(optimalBarWidth(ensureNotNull(this._private__data)._internal_barSpacing, pixelRatio)));\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        this._private__barWidth = 0;\n        this._private__barLineWidth = 0;\n    }\n}\nclass BarsPaneViewBase extends SeriesPaneViewBase {\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_barPricesToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createDefaultItem(time, bar, colorer) {\n        return {\n            _internal_time: time,\n            _internal_open: bar._internal_value[0 /* PlotRowValueIndex.Open */ ],\n            _internal_high: bar._internal_value[1 /* PlotRowValueIndex.High */ ],\n            _internal_low: bar._internal_value[2 /* PlotRowValueIndex.Low */ ],\n            _internal_close: bar._internal_value[3 /* PlotRowValueIndex.Close */ ],\n            _internal_x: NaN,\n            _internal_openY: NaN,\n            _internal_highY: NaN,\n            _internal_lowY: NaN,\n            _internal_closeY: NaN\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row)=>this._internal__createRawItem(row._internal_index, row, colorer));\n    }\n    constructor(series, model){\n        super(series, model, false);\n    }\n}\nclass SeriesBarsPaneView extends BarsPaneViewBase {\n    _internal__createRawItem(time, bar, colorer) {\n        return {\n            ...this._internal__createDefaultItem(time, bar, colorer),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const barStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_openVisible: barStyleProps.openVisible,\n            _internal_thinBars: barStyleProps.thinBars,\n            _internal_visibleRange: this._internal__itemsVisibleRange\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererBars();\n    }\n}\nconst barStyleDefaults = {\n    upColor: '#26a69a',\n    downColor: '#ef5350',\n    openVisible: true,\n    thinBars: true\n};\nconst createPaneView$2 = (series, model)=>new SeriesBarsPaneView(series, model);\nconst createSeries$2 = ()=>{\n    const definition = {\n        type: 'Bar',\n        isBuiltIn: true,\n        defaultOptions: barStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$2\n    };\n    return definition;\n};\nconst barSeries = createSeries$2();\nclass PaneRendererCandlesticks extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        const { horizontalPixelRatio } = renderingScope;\n        // now we know pixelRatio and we could calculate barWidth effectively\n        this._private__barWidth = optimalCandlestickWidth(this._private__data._internal_barSpacing, horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make candlesticks' width odd\n        // if this value is even, we have to make candlesticks' width even\n        // in order of keeping crosshair-over-candlesticks drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const wickWidth = Math.floor(horizontalPixelRatio);\n            if (wickWidth % 2 !== this._private__barWidth % 2) {\n                this._private__barWidth--;\n            }\n        }\n        const bars = this._private__data._internal_bars;\n        if (this._private__data._internal_wickVisible) {\n            this._private__drawWicks(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        if (this._private__data._internal_borderVisible) {\n            this._private__drawBorder(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        if (!this._private__data._internal_borderVisible || this._private__barWidth > borderWidth * 2) {\n            this._private__drawCandles(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n    }\n    _private__drawWicks(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevWickColor = '';\n        let wickWidth = Math.min(Math.floor(horizontalPixelRatio), Math.floor(this._private__data._internal_barSpacing * horizontalPixelRatio));\n        wickWidth = Math.max(Math.floor(horizontalPixelRatio), Math.min(wickWidth, this._private__barWidth));\n        const wickOffset = Math.floor(wickWidth * 0.5);\n        let prevEdge = null;\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            if (bar._internal_barWickColor !== prevWickColor) {\n                ctx.fillStyle = bar._internal_barWickColor;\n                prevWickColor = bar._internal_barWickColor;\n            }\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const high = Math.round(bar._internal_highY * verticalPixelRatio);\n            const low = Math.round(bar._internal_lowY * verticalPixelRatio);\n            const scaledX = Math.round(horizontalPixelRatio * bar._internal_x);\n            let left = scaledX - wickOffset;\n            const right = left + wickWidth - 1;\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            const width = right - left + 1;\n            ctx.fillRect(left, high, width, top - high);\n            ctx.fillRect(left, bottom + 1, width, low - bottom);\n            prevEdge = right;\n        }\n    }\n    _private__calculateBorderWidth(pixelRatio) {\n        let borderWidth = Math.floor(1 /* Constants.BarBorderWidth */  * pixelRatio);\n        if (this._private__barWidth <= 2 * borderWidth) {\n            borderWidth = Math.floor((this._private__barWidth - 1) * 0.5);\n        }\n        const res = Math.max(Math.floor(pixelRatio), borderWidth);\n        if (this._private__barWidth <= res * 2) {\n            // do not draw bodies, restore original value\n            return Math.max(Math.floor(pixelRatio), Math.floor(1 /* Constants.BarBorderWidth */  * pixelRatio));\n        }\n        return res;\n    }\n    _private__drawBorder(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBorderColor = '';\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        let prevEdge = null;\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            if (bar._internal_barBorderColor !== prevBorderColor) {\n                ctx.fillStyle = bar._internal_barBorderColor;\n                prevBorderColor = bar._internal_barBorderColor;\n            }\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            // this is important to calculate right before patching left\n            const right = left + this._private__barWidth - 1;\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            if (this._private__data._internal_barSpacing * horizontalPixelRatio > 2 * borderWidth) {\n                fillRectInnerBorder(ctx, left, top, right - left + 1, bottom - top + 1, borderWidth);\n            } else {\n                const width = right - left + 1;\n                ctx.fillRect(left, top, width, bottom - top + 1);\n            }\n            prevEdge = right;\n        }\n    }\n    _private__drawCandles(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBarColor = '';\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        for(let i = visibleRange.from; i < visibleRange.to; i++){\n            const bar = bars[i];\n            let top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            let right = left + this._private__barWidth - 1;\n            if (bar._internal_barColor !== prevBarColor) {\n                const barColor = bar._internal_barColor;\n                ctx.fillStyle = barColor;\n                prevBarColor = barColor;\n            }\n            if (this._private__data._internal_borderVisible) {\n                left += borderWidth;\n                top += borderWidth;\n                right -= borderWidth;\n                bottom -= borderWidth;\n            }\n            if (top > bottom) {\n                continue;\n            }\n            ctx.fillRect(left, top, right - left + 1, bottom - top + 1);\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        // scaled with pixelRatio\n        this._private__barWidth = 0;\n    }\n}\nclass SeriesCandlesticksPaneView extends BarsPaneViewBase {\n    _internal__createRawItem(time, bar, colorer) {\n        return {\n            ...this._internal__createDefaultItem(time, bar, colorer),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const candlestickStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_wickVisible: candlestickStyleProps.wickVisible,\n            _internal_borderVisible: candlestickStyleProps.borderVisible,\n            _internal_visibleRange: this._internal__itemsVisibleRange\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererCandlesticks();\n    }\n}\nconst candlestickStyleDefaults = {\n    upColor: '#26a69a',\n    downColor: '#ef5350',\n    wickVisible: true,\n    borderVisible: true,\n    borderColor: '#378658',\n    borderUpColor: '#26a69a',\n    borderDownColor: '#ef5350',\n    wickColor: '#737375',\n    wickUpColor: '#26a69a',\n    wickDownColor: '#ef5350'\n};\nconst createPaneView$1 = (series, model)=>new SeriesCandlesticksPaneView(series, model);\nconst createSeries$1 = ()=>{\n    const definition = {\n        type: 'Candlestick',\n        isBuiltIn: true,\n        defaultOptions: candlestickStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView$1\n    };\n    return definition;\n};\nconst candlestickSeries = createSeries$1();\nconst showSpacingMinimalBarWidth = 1;\nconst alignToMinimalWidthLimit = 4;\nclass PaneRendererHistogram extends BitmapCoordinatesPaneRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n        this._private__precalculatedCache = [];\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        if (!this._private__precalculatedCache.length) {\n            this._private__fillPrecalculatedCache(horizontalPixelRatio);\n        }\n        const tickWidth = Math.max(1, Math.floor(verticalPixelRatio));\n        const histogramBase = Math.round(this._private__data._internal_histogramBase * verticalPixelRatio);\n        const topHistogramBase = histogramBase - Math.floor(tickWidth / 2);\n        const bottomHistogramBase = topHistogramBase + tickWidth;\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const y = Math.round(item._internal_y * verticalPixelRatio);\n            ctx.fillStyle = item._internal_barColor;\n            let top;\n            let bottom;\n            if (y <= topHistogramBase) {\n                top = y;\n                bottom = bottomHistogramBase;\n            } else {\n                top = topHistogramBase;\n                bottom = y - Math.floor(tickWidth / 2) + tickWidth;\n            }\n            ctx.fillRect(current._internal_left, top, current._internal_right - current._internal_left + 1, bottom - top);\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__fillPrecalculatedCache(pixelRatio) {\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            this._private__precalculatedCache = [];\n            return;\n        }\n        const spacing = Math.ceil(this._private__data._internal_barSpacing * pixelRatio) <= showSpacingMinimalBarWidth ? 0 : Math.max(1, Math.floor(pixelRatio));\n        const columnWidth = Math.round(this._private__data._internal_barSpacing * pixelRatio) - spacing;\n        this._private__precalculatedCache = new Array(this._private__data._internal_visibleRange.to - this._private__data._internal_visibleRange.from);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            // force cast to avoid ensureDefined call\n            const x = Math.round(item._internal_x * pixelRatio);\n            let left;\n            let right;\n            if (columnWidth % 2) {\n                const halfWidth = (columnWidth - 1) / 2;\n                left = x - halfWidth;\n                right = x + halfWidth;\n            } else {\n                // shift pixel to left\n                const halfWidth = columnWidth / 2;\n                left = x - halfWidth;\n                right = x + halfWidth - 1;\n            }\n            this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from] = {\n                _internal_left: left,\n                _internal_right: right,\n                _internal_roundedCenter: x,\n                _internal_center: item._internal_x * pixelRatio,\n                _internal_time: item._internal_time\n            };\n        }\n        // correct positions\n        for(let i = this._private__data._internal_visibleRange.from + 1; i < this._private__data._internal_visibleRange.to; i++){\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const prev = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from - 1];\n            if (current._internal_time !== prev._internal_time + 1) {\n                continue;\n            }\n            if (current._internal_left - prev._internal_right !== spacing + 1) {\n                // have to align\n                if (prev._internal_roundedCenter > prev._internal_center) {\n                    // prev wasshifted to left, so add pixel to right\n                    prev._internal_right = current._internal_left - spacing - 1;\n                } else {\n                    // extend current to left\n                    current._internal_left = prev._internal_right + spacing + 1;\n                }\n            }\n        }\n        let minWidth = Math.ceil(this._private__data._internal_barSpacing * pixelRatio);\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            // this could happen if barspacing < 1\n            if (current._internal_right < current._internal_left) {\n                current._internal_right = current._internal_left;\n            }\n            const width = current._internal_right - current._internal_left + 1;\n            minWidth = Math.min(width, minWidth);\n        }\n        if (spacing > 0 && minWidth < alignToMinimalWidthLimit) {\n            for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n                const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n                const width = current._internal_right - current._internal_left + 1;\n                if (width > minWidth) {\n                    if (current._internal_roundedCenter > current._internal_center) {\n                        current._internal_right -= 1;\n                    } else {\n                        current._internal_left += 1;\n                    }\n                }\n            }\n        }\n    }\n    constructor(){\n        super(...arguments);\n        this._private__data = null;\n        this._private__precalculatedCache = [];\n    }\n}\nclass SeriesHistogramPaneView extends LinePaneViewBase {\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time)\n        };\n    }\n    _internal__prepareRendererData() {\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_histogramBase: this._internal__series._internal_priceScale()._internal_priceToCoordinate(this._internal__series._internal_options().base, ensureNotNull(this._internal__series._internal_firstValue())._internal_value)\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n    constructor(){\n        super(...arguments);\n        this._internal__renderer = new PaneRendererHistogram();\n    }\n}\nconst histogramStyleDefaults = {\n    color: '#26a69a',\n    base: 0\n};\nconst createPaneView = (series, model)=>new SeriesHistogramPaneView(series, model);\nconst createSeries = ()=>{\n    const definition = {\n        type: 'Histogram',\n        isBuiltIn: true,\n        defaultOptions: histogramStyleDefaults,\n        /**\n         * @internal\n         */ _internal_createPaneView: createPaneView\n    };\n    return definition;\n};\nconst histogramSeries = createSeries();\nclass PanePrimitiveWrapper {\n    detach() {\n        this._private__pane.detachPrimitive(this._private__primitive);\n    }\n    getPane() {\n        return this._private__pane;\n    }\n    applyOptions(options) {\n        var _this__private__primitive__internal_applyOptions, _this__private__primitive;\n        (_this__private__primitive__internal_applyOptions = (_this__private__primitive = this._private__primitive)._internal_applyOptions) === null || _this__private__primitive__internal_applyOptions === void 0 ? void 0 : _this__private__primitive__internal_applyOptions.call(_this__private__primitive, options);\n    }\n    _private__attach() {\n        this._private__pane.attachPrimitive(this._private__primitive);\n    }\n    constructor(pane, primitive){\n        this._private__pane = pane;\n        this._private__primitive = primitive;\n        this._private__attach();\n    }\n}\nconst textWatermarkOptionsDefaults = {\n    visible: true,\n    horzAlign: 'center',\n    vertAlign: 'center',\n    lines: []\n};\nconst textWatermarkLineOptionsDefaults = {\n    color: 'rgba(0, 0, 0, 0.5)',\n    fontSize: 48,\n    fontFamily: defaultFontFamily,\n    fontStyle: '',\n    text: ''\n};\nclass TextWatermarkRenderer {\n    draw(target) {\n        target.useMediaCoordinateSpace((scope)=>{\n            if (!this._private__data.visible) {\n                return;\n            }\n            const { context: ctx, mediaSize } = scope;\n            let textHeight = 0;\n            for (const line of this._private__data.lines){\n                if (line.text.length === 0) {\n                    continue;\n                }\n                ctx.font = line._internal_font;\n                const textWidth = this._private__metrics(ctx, line.text);\n                if (textWidth > mediaSize.width) {\n                    line._internal_zoom = mediaSize.width / textWidth;\n                } else {\n                    line._internal_zoom = 1;\n                }\n                textHeight += line.lineHeight * line._internal_zoom;\n            }\n            let vertOffset = 0;\n            switch(this._private__data.vertAlign){\n                case 'top':\n                    vertOffset = 0;\n                    break;\n                case 'center':\n                    vertOffset = Math.max((mediaSize.height - textHeight) / 2, 0);\n                    break;\n                case 'bottom':\n                    vertOffset = Math.max(mediaSize.height - textHeight, 0);\n                    break;\n            }\n            for (const line of this._private__data.lines){\n                ctx.save();\n                ctx.fillStyle = line.color;\n                let horzOffset = 0;\n                switch(this._private__data.horzAlign){\n                    case 'left':\n                        ctx.textAlign = 'left';\n                        horzOffset = line.lineHeight / 2;\n                        break;\n                    case 'center':\n                        ctx.textAlign = 'center';\n                        horzOffset = mediaSize.width / 2;\n                        break;\n                    case 'right':\n                        ctx.textAlign = 'right';\n                        horzOffset = mediaSize.width - 1 - line.lineHeight / 2;\n                        break;\n                }\n                ctx.translate(horzOffset, vertOffset);\n                ctx.textBaseline = 'top';\n                ctx.font = line._internal_font;\n                ctx.scale(line._internal_zoom, line._internal_zoom);\n                ctx.fillText(line.text, 0, line._internal_vertOffset);\n                ctx.restore();\n                vertOffset += line.lineHeight * line._internal_zoom;\n            }\n        });\n    }\n    _private__metrics(ctx, text) {\n        const fontCache = this._private__fontCache(ctx.font);\n        let result = fontCache.get(text);\n        if (result === undefined) {\n            result = ctx.measureText(text).width;\n            fontCache.set(text, result);\n        }\n        return result;\n    }\n    _private__fontCache(font) {\n        let fontCache = this._private__metricsCache.get(font);\n        if (fontCache === undefined) {\n            fontCache = new Map();\n            this._private__metricsCache.set(font, fontCache);\n        }\n        return fontCache;\n    }\n    constructor(options){\n        this._private__metricsCache = new Map();\n        this._private__data = options;\n    }\n}\nclass TextWatermarkPaneView {\n    _internal_update(options) {\n        this._private__options = buildRendererOptions$1(options);\n    }\n    renderer() {\n        return new TextWatermarkRenderer(this._private__options);\n    }\n    constructor(options){\n        this._private__options = buildRendererOptions$1(options);\n    }\n}\nfunction buildRendererLineOptions(lineOption) {\n    return {\n        ...lineOption,\n        _internal_font: makeFont(lineOption.fontSize, lineOption.fontFamily, lineOption.fontStyle),\n        lineHeight: lineOption.lineHeight || lineOption.fontSize * 1.2,\n        _internal_vertOffset: 0,\n        _internal_zoom: 0\n    };\n}\nfunction buildRendererOptions$1(options) {\n    return {\n        ...options,\n        lines: options.lines.map(buildRendererLineOptions)\n    };\n}\nfunction mergeLineOptionsWithDefaults(options) {\n    return {\n        ...textWatermarkLineOptionsDefaults,\n        ...options\n    };\n}\nfunction mergeOptionsWithDefaults$2(options) {\n    var _options_lines;\n    var _options_lines_map;\n    return {\n        ...textWatermarkOptionsDefaults,\n        ...options,\n        lines: (_options_lines_map = (_options_lines = options.lines) === null || _options_lines === void 0 ? void 0 : _options_lines.map(mergeLineOptionsWithDefaults)) !== null && _options_lines_map !== void 0 ? _options_lines_map : []\n    };\n}\nclass TextWatermark {\n    updateAllViews() {\n        this._private__paneViews.forEach((pw)=>pw._internal_update(this._private__options));\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    attached(param) {\n        let { requestUpdate } = param;\n        this._internal_requestUpdate = requestUpdate;\n    }\n    detached() {\n        this._internal_requestUpdate = undefined;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults$2({\n            ...this._private__options,\n            ...options\n        });\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n    constructor(options){\n        this._private__options = mergeOptionsWithDefaults$2(options);\n        this._private__paneViews = [\n            new TextWatermarkPaneView(this._private__options)\n        ];\n    }\n}\n/**\n * Creates an image watermark.\n *\n * @param pane - Target pane.\n * @param options - Watermark options.\n *\n * @returns Image watermark wrapper.\n *\n * @example\n * ```js\n * import { createTextWatermark } from 'lightweight-charts';\n *\n * const firstPane = chart.panes()[0];\n * const textWatermark = createTextWatermark(firstPane, {\n * \t  horzAlign: 'center',\n * \t  vertAlign: 'center',\n * \t  lines: [\n * \t    {\n * \t      text: 'Hello',\n * \t      color: 'rgba(255,0,0,0.5)',\n * \t      fontSize: 100,\n * \t      fontStyle: 'bold',\n * \t    },\n * \t    {\n * \t      text: 'This is a text watermark',\n * \t      color: 'rgba(0,0,255,0.5)',\n * \t      fontSize: 50,\n * \t      fontStyle: 'italic',\n * \t      fontFamily: 'monospace',\n * \t    },\n * \t  ],\n * });\n * // to change options\n * textWatermark.applyOptions({ horzAlign: 'left' });\n * // to remove watermark from the pane\n * textWatermark.detach();\n * ```\n */ function createTextWatermark(pane, options) {\n    return new PanePrimitiveWrapper(pane, new TextWatermark(options));\n}\nconst imageWatermarkOptionsDefaults = {\n    alpha: 1,\n    padding: 0\n};\nclass ImageWatermarkRenderer {\n    draw(target) {\n        target.useMediaCoordinateSpace((scope)=>{\n            const ctx = scope.context;\n            const pos = this._private__determinePlacement(this._private__data, scope.mediaSize);\n            if (!pos || !this._private__data._internal_imgElement) {\n                return;\n            }\n            var _this__private__data_alpha;\n            ctx.globalAlpha = (_this__private__data_alpha = this._private__data.alpha) !== null && _this__private__data_alpha !== void 0 ? _this__private__data_alpha : 1;\n            ctx.drawImage(this._private__data._internal_imgElement, pos._internal_x, pos._internal_y, pos._internal_width, pos._internal_height);\n        });\n    }\n    _private__determinePlacement(data, paneSize) {\n        const { maxHeight, maxWidth, _internal_imgHeight: imgHeight, _internal_imgWidth: imgWidth, padding } = data;\n        const plotCentreX = Math.round(paneSize.width / 2);\n        const plotCentreY = Math.round(paneSize.height / 2);\n        const paddingSize = padding !== null && padding !== void 0 ? padding : 0;\n        let availableWidth = paneSize.width - 2 * paddingSize;\n        let availableHeight = paneSize.height - 2 * paddingSize;\n        if (maxHeight) {\n            availableHeight = Math.min(availableHeight, maxHeight);\n        }\n        if (maxWidth) {\n            availableWidth = Math.min(availableWidth, maxWidth);\n        }\n        const scaleX = availableWidth / imgWidth;\n        const scaleY = availableHeight / imgHeight;\n        const scaleToUse = Math.min(scaleX, scaleY);\n        const drawWidth = imgWidth * scaleToUse;\n        const drawHeight = imgHeight * scaleToUse;\n        const x = plotCentreX - 0.5 * drawWidth;\n        const y = plotCentreY - 0.5 * drawHeight;\n        return {\n            _internal_x: x,\n            _internal_y: y,\n            _internal_height: drawHeight,\n            _internal_width: drawWidth\n        };\n    }\n    constructor(data){\n        this._private__data = data;\n    }\n}\nclass ImageWatermarkPaneView {\n    _internal_stateUpdate(state) {\n        if (state._internal_imageWidth !== undefined) {\n            this._private__imageWidth = state._internal_imageWidth;\n        }\n        if (state._internal_imageHeight !== undefined) {\n            this._private__imageHeight = state._internal_imageHeight;\n        }\n        if (state._internal_image !== undefined) {\n            this._private__image = state._internal_image;\n        }\n        this._internal_update();\n    }\n    _internal_optionsUpdate(options) {\n        this._private__options = options;\n        this._internal_update();\n    }\n    zOrder() {\n        return 'bottom';\n    }\n    _internal_update() {\n        this._private__rendererOptions = buildRendererOptions(this._private__options, this._private__image, this._private__imageWidth, this._private__imageHeight);\n    }\n    renderer() {\n        return new ImageWatermarkRenderer(this._private__rendererOptions);\n    }\n    constructor(options){\n        this._private__image = null;\n        this._private__imageWidth = 0; // don't draw until loaded\n        this._private__imageHeight = 0;\n        this._private__options = options;\n        this._private__rendererOptions = buildRendererOptions(this._private__options, this._private__image, this._private__imageWidth, this._private__imageHeight);\n    }\n}\nfunction buildRendererOptions(options, imgElement, imgWidth, imgHeight) {\n    return {\n        ...options,\n        _internal_imgElement: imgElement,\n        _internal_imgWidth: imgWidth,\n        _internal_imgHeight: imgHeight\n    };\n}\nfunction mergeOptionsWithDefaults$1(options) {\n    return {\n        ...imageWatermarkOptionsDefaults,\n        ...options\n    };\n}\nclass ImageWatermark {\n    updateAllViews() {\n        this._private__paneViews.forEach((pw)=>pw._internal_update());\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    attached(attachedParams) {\n        const { requestUpdate } = attachedParams;\n        this._private__requestUpdate = requestUpdate;\n        this._private__imgElement = new Image();\n        this._private__imgElement.onload = ()=>{\n            var _this__private__imgElement, _this__private__imgElement1;\n            var _this__private__imgElement_naturalHeight;\n            const imageHeight = (_this__private__imgElement_naturalHeight = (_this__private__imgElement = this._private__imgElement) === null || _this__private__imgElement === void 0 ? void 0 : _this__private__imgElement.naturalHeight) !== null && _this__private__imgElement_naturalHeight !== void 0 ? _this__private__imgElement_naturalHeight : 1;\n            var _this__private__imgElement_naturalWidth;\n            const imageWidth = (_this__private__imgElement_naturalWidth = (_this__private__imgElement1 = this._private__imgElement) === null || _this__private__imgElement1 === void 0 ? void 0 : _this__private__imgElement1.naturalWidth) !== null && _this__private__imgElement_naturalWidth !== void 0 ? _this__private__imgElement_naturalWidth : 1;\n            this._private__paneViews.forEach((pv)=>pv._internal_stateUpdate({\n                    _internal_imageHeight: imageHeight,\n                    _internal_imageWidth: imageWidth,\n                    _internal_image: this._private__imgElement\n                }));\n            if (this._private__requestUpdate) {\n                this._private__requestUpdate();\n            }\n        };\n        this._private__imgElement.src = this._private__imageUrl;\n    }\n    detached() {\n        this._private__requestUpdate = undefined;\n        this._private__imgElement = null;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults$1({\n            ...this._private__options,\n            ...options\n        });\n        this._private__updateOptions();\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n    _internal_requestUpdate() {\n        if (this._private__requestUpdate) {\n            this._private__requestUpdate();\n        }\n    }\n    _private__updateOptions() {\n        this._private__paneViews.forEach((pw)=>pw._internal_optionsUpdate(this._private__options));\n    }\n    constructor(imageUrl, options){\n        this._private__imgElement = null;\n        this._private__imageUrl = imageUrl;\n        this._private__options = mergeOptionsWithDefaults$1(options);\n        this._private__paneViews = [\n            new ImageWatermarkPaneView(this._private__options)\n        ];\n    }\n}\n/**\n * Creates an image watermark.\n *\n * @param pane - Target pane.\n * @param imageUrl - Image URL.\n * @param options - Watermark options.\n *\n * @returns Image watermark wrapper.\n *\n * @example\n * ```js\n * import { createImageWatermark } from 'lightweight-charts';\n *\n * const firstPane = chart.panes()[0];\n * const imageWatermark = createImageWatermark(firstPane, '/images/my-image.png', {\n *   alpha: 0.5,\n *   padding: 20,\n * });\n * // to change options\n * imageWatermark.applyOptions({ padding: 10 });\n * // to remove watermark from the pane\n * imageWatermark.detach();\n * ```\n */ function createImageWatermark(pane, imageUrl, options) {\n    return new PanePrimitiveWrapper(pane, new ImageWatermark(imageUrl, options));\n}\nclass SeriesPrimitiveAdapter {\n    detach() {\n        this._internal__series.detachPrimitive(this._internal__primitive);\n    }\n    getSeries() {\n        return this._internal__series;\n    }\n    applyOptions(options) {\n        if (this._internal__primitive && this._internal__primitive._internal_applyOptions) {\n            this._internal__primitive._internal_applyOptions(options);\n        }\n    }\n    _private__attach() {\n        this._internal__series.attachPrimitive(this._internal__primitive);\n    }\n    constructor(series, primitive){\n        this._internal__series = series;\n        this._internal__primitive = primitive;\n        this._private__attach();\n    }\n}\nconst seriesMarkerOptionsDefaults = {\n    zOrder: 'normal'\n};\nfunction size(barSpacing, coeff) {\n    const result = Math.min(Math.max(barSpacing, 12 /* Constants.MinShapeSize */ ), 30 /* Constants.MaxShapeSize */ ) * coeff;\n    return ceiledOdd(result);\n}\nfunction shapeSize(shape, originalSize) {\n    switch(shape){\n        case 'arrowDown':\n        case 'arrowUp':\n            return size(originalSize, 1);\n        case 'circle':\n            return size(originalSize, 0.8);\n        case 'square':\n            return size(originalSize, 0.7);\n    }\n}\nfunction calculateShapeHeight(barSpacing) {\n    return ceiledEven(size(barSpacing, 1));\n}\nfunction shapeMargin(barSpacing) {\n    return Math.max(size(barSpacing, 0.1), 3 /* Constants.MinShapeMargin */ );\n}\nfunction calculateAdjustedMargin(margin, hasSide, hasInBar) {\n    if (hasSide) {\n        return margin;\n    } else if (hasInBar) {\n        return Math.ceil(margin / 2);\n    }\n    return 0;\n}\nfunction drawArrow(up, ctx, coords, size) {\n    const arrowSize = shapeSize('arrowUp', size);\n    const halfArrowSize = (arrowSize - 1) / 2 * coords._internal_pixelRatio;\n    const baseSize = ceiledOdd(size / 2);\n    const halfBaseSize = (baseSize - 1) / 2 * coords._internal_pixelRatio;\n    ctx.beginPath();\n    if (up) {\n        ctx.moveTo(coords._internal_x - halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x + halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y);\n    } else {\n        ctx.moveTo(coords._internal_x - halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x + halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y);\n    }\n    ctx.fill();\n}\nfunction hitTestArrow(up, centerX, centerY, size, x, y) {\n    const arrowSize = shapeSize('arrowUp', size);\n    const halfArrowSize = (arrowSize - 1) / 2;\n    const baseSize = ceiledOdd(size / 2);\n    const halfBaseSize = (baseSize - 1) / 2;\n    const triangleTolerance = 3;\n    const rectTolerance = 2;\n    const baseLeft = centerX - halfBaseSize - rectTolerance;\n    const baseRight = centerX + halfBaseSize + rectTolerance;\n    const baseTop = up ? centerY : centerY - halfArrowSize;\n    const baseBottom = up ? centerY + halfArrowSize : centerY;\n    if (x >= baseLeft && x <= baseRight && y >= baseTop - rectTolerance && y <= baseBottom + rectTolerance) {\n        return true;\n    }\n    const isInTriangleBounds = ()=>{\n        const headLeft = centerX - halfArrowSize - triangleTolerance;\n        const headRight = centerX + halfArrowSize + triangleTolerance;\n        const headTop = up ? centerY - halfArrowSize - triangleTolerance : centerY;\n        const headBottom = up ? centerY : centerY + halfArrowSize + triangleTolerance;\n        if (x < headLeft || x > headRight || y < headTop || y > headBottom) {\n            return false;\n        }\n        const dx = Math.abs(x - centerX);\n        const dy = up ? Math.abs(y - centerY) // up arrow\n         : Math.abs(y - centerY); // down arrow\n        return dy + triangleTolerance >= dx / 2;\n    };\n    return isInTriangleBounds();\n}\nfunction drawCircle(ctx, coords, size) {\n    const circleSize = shapeSize('circle', size);\n    const halfSize = (circleSize - 1) / 2;\n    ctx.beginPath();\n    ctx.arc(coords._internal_x, coords._internal_y, halfSize * coords._internal_pixelRatio, 0, 2 * Math.PI, false);\n    ctx.fill();\n}\nfunction hitTestCircle(centerX, centerY, size, x, y) {\n    const circleSize = shapeSize('circle', size);\n    const tolerance = 2 + circleSize / 2;\n    const xOffset = centerX - x;\n    const yOffset = centerY - y;\n    const dist = Math.sqrt(xOffset * xOffset + yOffset * yOffset);\n    return dist <= tolerance;\n}\nfunction drawSquare(ctx, coords, size) {\n    const squareSize = shapeSize('square', size);\n    const halfSize = (squareSize - 1) * coords._internal_pixelRatio / 2;\n    const left = coords._internal_x - halfSize;\n    const top = coords._internal_y - halfSize;\n    ctx.fillRect(left, top, squareSize * coords._internal_pixelRatio, squareSize * coords._internal_pixelRatio);\n}\nfunction hitTestSquare(centerX, centerY, size, x, y) {\n    const squareSize = shapeSize('square', size);\n    const halfSize = (squareSize - 1) / 2;\n    const left = centerX - halfSize;\n    const top = centerY - halfSize;\n    return x >= left && x <= left + squareSize && y >= top && y <= top + squareSize;\n}\nfunction drawText(ctx, text, x, y, horizontalPixelRatio, verticalPixelRatio) {\n    ctx.save();\n    ctx.scale(horizontalPixelRatio, verticalPixelRatio);\n    ctx.fillText(text, x, y);\n    ctx.restore();\n}\nfunction hitTestText(textX, textY, textWidth, textHeight, x, y) {\n    const halfHeight = textHeight / 2;\n    return x >= textX && x <= textX + textWidth && y >= textY - halfHeight && y <= textY + halfHeight;\n}\nclass SeriesMarkersRenderer {\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_setParams(fontSize, fontFamily, zOrder) {\n        if (this._private__fontSize !== fontSize || this._private__fontFamily !== fontFamily) {\n            this._private__fontSize = fontSize;\n            this._private__fontFamily = fontFamily;\n            this._private__font = makeFont(fontSize, fontFamily);\n            this._private__textWidthCache._internal_reset();\n        }\n        this._private__zOrder = zOrder;\n    }\n    _internal_hitTest(x, y) {\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return null;\n        }\n        for(let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++){\n            const item = this._private__data._internal_items[i];\n            if (item && hitTestItem(item, x, y)) {\n                var _item__internal_externalId;\n                return {\n                    zOrder: 'normal',\n                    externalId: (_item__internal_externalId = item._internal_externalId) !== null && _item__internal_externalId !== void 0 ? _item__internal_externalId : ''\n                };\n            }\n        }\n        return null;\n    }\n    draw(target) {\n        if (this._private__zOrder === 'aboveSeries') {\n            return;\n        }\n        target.useBitmapCoordinateSpace((scope)=>{\n            this._internal__drawImpl(scope);\n        });\n    }\n    drawBackground(target) {\n        if (this._private__zOrder !== 'aboveSeries') {\n            return;\n        }\n        target.useBitmapCoordinateSpace((scope)=>{\n            this._internal__drawImpl(scope);\n        });\n    }\n    _internal__drawImpl(param) {\n        let { context: ctx, horizontalPixelRatio, verticalPixelRatio } = param;\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        ctx.textBaseline = 'middle';\n        ctx.font = this._private__font;\n        for(let index = this._private__data._internal_visibleRange.from; index < this._private__data._internal_visibleRange.to; index++){\n            const item = this._private__data._internal_items[index];\n            if (item._internal_text !== undefined) {\n                item._internal_text._internal_width = this._private__textWidthCache._internal_measureText(ctx, item._internal_text._internal_content);\n                item._internal_text._internal_height = this._private__fontSize;\n                item._internal_text._internal_x = item._internal_x - item._internal_text._internal_width / 2;\n            }\n            drawItem(item, ctx, horizontalPixelRatio, verticalPixelRatio);\n        }\n    }\n    constructor(){\n        this._private__data = null;\n        this._private__textWidthCache = new TextWidthCache();\n        this._private__fontSize = -1;\n        this._private__fontFamily = '';\n        this._private__font = '';\n        this._private__zOrder = 'normal';\n    }\n}\nfunction bitmapShapeItemCoordinates(item, horizontalPixelRatio, verticalPixelRatio) {\n    const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n    const correction = tickWidth % 2 / 2;\n    return {\n        _internal_x: Math.round(item._internal_x * horizontalPixelRatio) + correction,\n        _internal_y: item._internal_y * verticalPixelRatio,\n        _internal_pixelRatio: horizontalPixelRatio\n    };\n}\nfunction drawItem(item, ctx, horizontalPixelRatio, verticalPixelRatio) {\n    ctx.fillStyle = item._internal_color;\n    if (item._internal_text !== undefined) {\n        drawText(ctx, item._internal_text._internal_content, item._internal_text._internal_x, item._internal_text._internal_y, horizontalPixelRatio, verticalPixelRatio);\n    }\n    drawShape(item, ctx, bitmapShapeItemCoordinates(item, horizontalPixelRatio, verticalPixelRatio));\n}\nfunction drawShape(item, ctx, coordinates) {\n    if (item._internal_size === 0) {\n        return;\n    }\n    switch(item._internal_shape){\n        case 'arrowDown':\n            drawArrow(false, ctx, coordinates, item._internal_size);\n            return;\n        case 'arrowUp':\n            drawArrow(true, ctx, coordinates, item._internal_size);\n            return;\n        case 'circle':\n            drawCircle(ctx, coordinates, item._internal_size);\n            return;\n        case 'square':\n            drawSquare(ctx, coordinates, item._internal_size);\n            return;\n    }\n    ensureNever(item._internal_shape);\n}\nfunction hitTestItem(item, x, y) {\n    if (item._internal_text !== undefined && hitTestText(item._internal_text._internal_x, item._internal_text._internal_y, item._internal_text._internal_width, item._internal_text._internal_height, x, y)) {\n        return true;\n    }\n    return hitTestShape(item, x, y);\n}\nfunction hitTestShape(item, x, y) {\n    if (item._internal_size === 0) {\n        return false;\n    }\n    switch(item._internal_shape){\n        case 'arrowDown':\n            return hitTestArrow(true, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'arrowUp':\n            return hitTestArrow(false, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'circle':\n            return hitTestCircle(item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'square':\n            return hitTestSquare(item._internal_x, item._internal_y, item._internal_size, x, y);\n    }\n}\nfunction isPriceMarker(position) {\n    return position === 'atPriceTop' || position === 'atPriceBottom' || position === 'atPriceMiddle';\n}\nfunction getPrice(seriesData, marker) {\n    if (isPriceMarker(marker.position) && marker.price !== undefined) {\n        return marker.price;\n    }\n    if (isValueData(seriesData)) {\n        return seriesData.value;\n    }\n    if (isOhlcData(seriesData)) {\n        if (marker.position === 'inBar') {\n            return seriesData.close;\n        }\n        if (marker.position === 'aboveBar') {\n            return seriesData.high;\n        }\n        if (marker.position === 'belowBar') {\n            return seriesData.low;\n        }\n    }\n    return;\n}\n// eslint-disable-next-line max-params, complexity\nfunction fillSizeAndY(rendererItem, marker, seriesData, offsets, textHeight, shapeMargin, series, chart) {\n    const price = getPrice(seriesData, marker);\n    if (price === undefined) {\n        return;\n    }\n    const ignoreOffset = isPriceMarker(marker.position);\n    const timeScale = chart.timeScale();\n    const sizeMultiplier = isNumber(marker.size) ? Math.max(marker.size, 0) : 1;\n    const shapeSize = calculateShapeHeight(timeScale.options().barSpacing) * sizeMultiplier;\n    const halfSize = shapeSize / 2;\n    rendererItem._internal_size = shapeSize;\n    const position = marker.position;\n    switch(position){\n        case 'inBar':\n        case 'atPriceMiddle':\n            {\n                rendererItem._internal_y = ensureNotNull(series.priceToCoordinate(price));\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                }\n                return;\n            }\n        case 'aboveBar':\n        case 'atPriceTop':\n            {\n                const offset = ignoreOffset ? 0 : offsets._internal_aboveBar;\n                rendererItem._internal_y = ensureNotNull(series.priceToCoordinate(price)) - halfSize - offset;\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y - halfSize - textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                    offsets._internal_aboveBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */ );\n                }\n                if (!ignoreOffset) {\n                    offsets._internal_aboveBar += shapeSize + shapeMargin;\n                }\n                return;\n            }\n        case 'belowBar':\n        case 'atPriceBottom':\n            {\n                const offset = ignoreOffset ? 0 : offsets._internal_belowBar;\n                rendererItem._internal_y = ensureNotNull(series.priceToCoordinate(price)) + halfSize + offset;\n                if (rendererItem._internal_text !== undefined) {\n                    rendererItem._internal_text._internal_y = rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */ );\n                    offsets._internal_belowBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */ );\n                }\n                if (!ignoreOffset) {\n                    offsets._internal_belowBar += shapeSize + shapeMargin;\n                }\n                return;\n            }\n    }\n}\nfunction isValueData(data) {\n    // eslint-disable-next-line no-restricted-syntax\n    return 'value' in data && typeof data.value === 'number';\n}\nfunction isOhlcData(data) {\n    // eslint-disable-next-line no-restricted-syntax\n    return 'open' in data && 'high' in data && 'low' in data && 'close' in data;\n}\nclass SeriesMarkersPaneView {\n    renderer() {\n        if (!this._private__series.options().visible) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__makeValid();\n        }\n        const layout = this._private__chart.options()['layout'];\n        this._private__renderer._internal_setParams(layout.fontSize, layout.fontFamily, this._private__options.zOrder);\n        this._private__renderer._internal_setData(this._private__data);\n        return this._private__renderer;\n    }\n    _internal_setMarkers(markers) {\n        this._private__markers = markers;\n        this._internal_update('data');\n    }\n    _internal_update(updateType) {\n        this._private__invalidated = true;\n        if (updateType === 'data') {\n            this._private__dataInvalidated = true;\n        }\n    }\n    _internal_updateOptions(options) {\n        this._private__invalidated = true;\n        this._private__options = options;\n    }\n    zOrder() {\n        return this._private__options.zOrder === 'aboveSeries' ? 'top' : this._private__options.zOrder;\n    }\n    _internal__makeValid() {\n        const timeScale = this._private__chart.timeScale();\n        const seriesMarkers = this._private__markers;\n        if (this._private__dataInvalidated) {\n            this._private__data._internal_items = seriesMarkers.map((marker)=>({\n                    _internal_time: marker.time,\n                    _internal_x: 0,\n                    _internal_y: 0,\n                    _internal_size: 0,\n                    _internal_shape: marker.shape,\n                    _internal_color: marker.color,\n                    _internal_externalId: marker.id,\n                    _internal_internalId: marker._internal_internalId,\n                    _internal_text: undefined\n                }));\n            this._private__dataInvalidated = false;\n        }\n        const layoutOptions = this._private__chart.options()['layout'];\n        this._private__data._internal_visibleRange = null;\n        const visibleBars = timeScale.getVisibleLogicalRange();\n        if (visibleBars === null) {\n            return;\n        }\n        const visibleBarsRange = new RangeImpl(Math.floor(visibleBars.from), Math.ceil(visibleBars.to));\n        const firstValue = this._private__series.data()[0];\n        if (firstValue === null) {\n            return;\n        }\n        if (this._private__data._internal_items.length === 0) {\n            return;\n        }\n        let prevTimeIndex = NaN;\n        const shapeMargin$1 = shapeMargin(timeScale.options().barSpacing);\n        const offsets = {\n            _internal_aboveBar: shapeMargin$1,\n            _internal_belowBar: shapeMargin$1\n        };\n        this._private__data._internal_visibleRange = visibleTimedValues(this._private__data._internal_items, visibleBarsRange, true);\n        for(let index = this._private__data._internal_visibleRange.from; index < this._private__data._internal_visibleRange.to; index++){\n            const marker = seriesMarkers[index];\n            if (marker.time !== prevTimeIndex) {\n                // new bar, reset stack counter\n                offsets._internal_aboveBar = shapeMargin$1;\n                offsets._internal_belowBar = shapeMargin$1;\n                prevTimeIndex = marker.time;\n            }\n            const rendererItem = this._private__data._internal_items[index];\n            rendererItem._internal_x = ensureNotNull(timeScale.logicalToCoordinate(marker.time));\n            if (marker.text !== undefined && marker.text.length > 0) {\n                rendererItem._internal_text = {\n                    _internal_content: marker.text,\n                    _internal_x: 0,\n                    _internal_y: 0,\n                    _internal_width: 0,\n                    _internal_height: 0\n                };\n            }\n            const dataAt = this._private__series.dataByIndex(marker.time, 0 /* MismatchDirection.None */ );\n            if (dataAt === null) {\n                continue;\n            }\n            fillSizeAndY(rendererItem, marker, dataAt, offsets, layoutOptions.fontSize, shapeMargin$1, this._private__series, this._private__chart);\n        }\n        this._private__invalidated = false;\n    }\n    constructor(series, chart, options){\n        this._private__markers = [];\n        this._private__invalidated = true;\n        this._private__dataInvalidated = true;\n        this._private__renderer = new SeriesMarkersRenderer();\n        this._private__series = series;\n        this._private__chart = chart;\n        this._private__data = {\n            _internal_items: [],\n            _internal_visibleRange: null\n        };\n        this._private__options = options;\n    }\n}\nfunction mergeOptionsWithDefaults(options) {\n    return {\n        ...seriesMarkerOptionsDefaults,\n        ...options\n    };\n}\nclass SeriesMarkersPrimitive {\n    attached(param) {\n        this._private__recalculateMarkers();\n        this._private__chart = param.chart;\n        this._private__series = param.series;\n        this._private__paneView = new SeriesMarkersPaneView(this._private__series, ensureNotNull(this._private__chart), this._private__options);\n        this._private__requestUpdate = param.requestUpdate;\n        this._private__series.subscribeDataChanged((scope)=>this._private__onDataChanged(scope));\n        this._private__recalculationRequired = true;\n        this._internal_requestUpdate();\n    }\n    _internal_requestUpdate() {\n        if (this._private__requestUpdate) {\n            this._private__requestUpdate();\n        }\n    }\n    detached() {\n        if (this._private__series && this._private__dataChangedHandler) {\n            this._private__series.unsubscribeDataChanged(this._private__dataChangedHandler);\n        }\n        this._private__chart = null;\n        this._private__series = null;\n        this._private__paneView = null;\n        this._private__dataChangedHandler = null;\n    }\n    _internal_setMarkers(markers) {\n        this._private__recalculationRequired = true;\n        this._private__markers = markers;\n        this._private__recalculateMarkers();\n        this._private__autoScaleMarginsInvalidated = true;\n        this._private__markersPositions = null;\n        this._internal_requestUpdate();\n    }\n    _internal_markers() {\n        return this._private__markers;\n    }\n    paneViews() {\n        return this._private__paneView ? [\n            this._private__paneView\n        ] : [];\n    }\n    updateAllViews() {\n        this._private__updateAllViews();\n    }\n    hitTest(x, y) {\n        if (this._private__paneView) {\n            var _this__private__paneView_renderer;\n            var _this__private__paneView_renderer__internal_hitTest;\n            return (_this__private__paneView_renderer__internal_hitTest = (_this__private__paneView_renderer = this._private__paneView.renderer()) === null || _this__private__paneView_renderer === void 0 ? void 0 : _this__private__paneView_renderer._internal_hitTest(x, y)) !== null && _this__private__paneView_renderer__internal_hitTest !== void 0 ? _this__private__paneView_renderer__internal_hitTest : null;\n        }\n        return null;\n    }\n    autoscaleInfo(startTimePoint, endTimePoint) {\n        if (this._private__paneView) {\n            const margins = this._private__getAutoScaleMargins();\n            if (margins) {\n                return {\n                    priceRange: null,\n                    margins: margins\n                };\n            }\n        }\n        return null;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults({\n            ...this._private__options,\n            ...options\n        });\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n    _private__getAutoScaleMargins() {\n        const chart = ensureNotNull(this._private__chart);\n        const barSpacing = chart.timeScale().options().barSpacing;\n        if (this._private__autoScaleMarginsInvalidated || barSpacing !== this._private__cachedBarSpacing) {\n            this._private__cachedBarSpacing = barSpacing;\n            if (this._private__markers.length > 0) {\n                const shapeMargin$1 = shapeMargin(barSpacing);\n                const marginValue = calculateShapeHeight(barSpacing) * 1.5 + shapeMargin$1 * 2;\n                const positions = this._private__getMarkerPositions();\n                this._private__autoScaleMargins = {\n                    above: calculateAdjustedMargin(marginValue, positions.aboveBar, positions.inBar),\n                    below: calculateAdjustedMargin(marginValue, positions.belowBar, positions.inBar)\n                };\n            } else {\n                this._private__autoScaleMargins = null;\n            }\n            this._private__autoScaleMarginsInvalidated = false;\n        }\n        return this._private__autoScaleMargins;\n    }\n    _private__getMarkerPositions() {\n        if (this._private__markersPositions === null) {\n            this._private__markersPositions = this._private__markers.reduce((acc, marker)=>{\n                if (!acc[marker.position]) {\n                    acc[marker.position] = true;\n                }\n                return acc;\n            }, {\n                inBar: false,\n                aboveBar: false,\n                belowBar: false,\n                atPriceTop: false,\n                atPriceBottom: false,\n                atPriceMiddle: false\n            });\n        }\n        return this._private__markersPositions;\n    }\n    _private__recalculateMarkers() {\n        var _this__private__series;\n        if (!this._private__recalculationRequired || !this._private__chart || !this._private__series) {\n            return;\n        }\n        const timeScale = this._private__chart.timeScale();\n        const seriesData = (_this__private__series = this._private__series) === null || _this__private__series === void 0 ? void 0 : _this__private__series.data();\n        if (timeScale.getVisibleLogicalRange() == null || !this._private__series || seriesData.length === 0) {\n            this._private__indexedMarkers = [];\n            return;\n        }\n        const firstDataIndex = timeScale.timeToIndex(ensureNotNull(seriesData[0].time), true);\n        this._private__indexedMarkers = this._private__markers.map((marker, index)=>{\n            const timePointIndex = timeScale.timeToIndex(marker.time, true);\n            const searchMode = timePointIndex < firstDataIndex ? 1 /* MismatchDirection.NearestRight */  : -1 /* MismatchDirection.NearestLeft */ ;\n            const seriesDataByIndex = ensureNotNull(this._private__series).dataByIndex(timePointIndex, searchMode);\n            const finalIndex = timeScale.timeToIndex(ensureNotNull(seriesDataByIndex).time, false);\n            // You must explicitly define the types so that the minification build processes the field names correctly\n            const baseMarker = {\n                time: finalIndex,\n                position: marker.position,\n                shape: marker.shape,\n                color: marker.color,\n                id: marker.id,\n                _internal_internalId: index,\n                text: marker.text,\n                size: marker.size,\n                price: marker.price,\n                _internal_originalTime: marker.time\n            };\n            if (marker.position === 'atPriceTop' || marker.position === 'atPriceBottom' || marker.position === 'atPriceMiddle') {\n                if (marker.price === undefined) {\n                    throw new Error(\"Price is required for position \".concat(marker.position));\n                }\n                return {\n                    ...baseMarker,\n                    position: marker.position,\n                    price: marker.price\n                };\n            } else {\n                return {\n                    ...baseMarker,\n                    position: marker.position,\n                    price: marker.price\n                };\n            }\n        });\n        this._private__recalculationRequired = false;\n    }\n    _private__updateAllViews(updateType) {\n        if (this._private__paneView) {\n            this._private__recalculateMarkers();\n            this._private__paneView._internal_setMarkers(this._private__indexedMarkers);\n            this._private__paneView._internal_updateOptions(this._private__options);\n            this._private__paneView._internal_update(updateType);\n        }\n    }\n    _private__onDataChanged(scope) {\n        this._private__recalculationRequired = true;\n        this._internal_requestUpdate();\n    }\n    constructor(options){\n        this._private__paneView = null;\n        this._private__markers = [];\n        this._private__indexedMarkers = [];\n        this._private__dataChangedHandler = null;\n        this._private__series = null;\n        this._private__chart = null;\n        this._private__autoScaleMarginsInvalidated = true;\n        this._private__autoScaleMargins = null;\n        this._private__markersPositions = null;\n        this._private__cachedBarSpacing = null;\n        this._private__recalculationRequired = true;\n        this._private__options = mergeOptionsWithDefaults(options);\n    }\n}\nclass SeriesMarkersPrimitiveWrapper extends SeriesPrimitiveAdapter {\n    setMarkers(markers) {\n        this._internal__primitive._internal_setMarkers(markers);\n    }\n    markers() {\n        return this._internal__primitive._internal_markers();\n    }\n    constructor(series, primitive, markers){\n        super(series, primitive);\n        if (markers) {\n            this.setMarkers(markers);\n        }\n    }\n}\n/**\n * A function to create a series markers primitive.\n *\n * @param series - The series to which the primitive will be attached.\n *\n * @param markers - An array of markers to be displayed on the series.\n *\n * @param options - Options for the series markers plugin.\n *\n * @example\n * ```js\n * import { createSeriesMarkers } from 'lightweight-charts';\n *\n *\tconst seriesMarkers = createSeriesMarkers(\n *\t\tseries,\n *\t\t[\n *\t\t\t{\n *\t\t\t\tcolor: 'green',\n *\t\t\t\tposition: 'inBar',\n * \t\t\t\tshape: 'arrowDown',\n *\t\t\t\ttime: 1556880900,\n *\t\t\t},\n *\t\t]\n *\t);\n *  // and then you can modify the markers\n *  // set it to empty array to remove all markers\n *  seriesMarkers.setMarkers([]);\n *\n *  // `seriesMarkers.markers()` returns current markers\n * ```\n */ function createSeriesMarkers(series, markers, options) {\n    const wrapper = new SeriesMarkersPrimitiveWrapper(series, new SeriesMarkersPrimitive(options !== null && options !== void 0 ? options : {}));\n    if (markers) {\n        wrapper.setMarkers(markers);\n    }\n    return wrapper;\n}\nclass ExpiringMarkerManager {\n    _internal_setMarker(marker, key, timeout) {\n        this._internal_clearMarker(key);\n        if (timeout !== undefined) {\n            const timeoutId = window.setTimeout(()=>{\n                this._private__markers.delete(key);\n                this._private__triggerUpdate();\n            }, timeout);\n            const markerWithTimeout = {\n                ...marker,\n                _internal_timeoutId: timeoutId,\n                _internal_expiresAt: Date.now() + timeout\n            };\n            this._private__markers.set(key, markerWithTimeout);\n        } else {\n            // For markers without timeout, we set timeoutId and expiresAt to undefined\n            this._private__markers.set(key, {\n                ...marker,\n                _internal_timeoutId: undefined,\n                _internal_expiresAt: undefined\n            });\n        }\n        this._private__triggerUpdate();\n    }\n    _internal_clearMarker(key) {\n        const marker = this._private__markers.get(key);\n        if (marker && marker._internal_timeoutId !== undefined) {\n            window.clearTimeout(marker._internal_timeoutId);\n        }\n        this._private__markers.delete(key);\n        this._private__triggerUpdate();\n    }\n    _internal_clearAllMarkers() {\n        for (const [point] of this._private__markers){\n            this._internal_clearMarker(point);\n        }\n    }\n    _internal_getMarkers() {\n        const now = Date.now();\n        const activeMarkers = [];\n        for (const [time, marker] of this._private__markers){\n            if (!marker._internal_expiresAt || marker._internal_expiresAt > now) {\n                activeMarkers.push({\n                    time: marker.time,\n                    sign: marker.sign,\n                    value: marker.value\n                });\n            } else {\n                this._internal_clearMarker(time);\n            }\n        }\n        return activeMarkers;\n    }\n    _internal_setUpdateCallback(callback) {\n        this._private__updateCallback = callback;\n    }\n    _private__triggerUpdate() {\n        if (this._private__updateCallback) {\n            this._private__updateCallback();\n        }\n    }\n    constructor(updateCallback){\n        this._private__markers = new Map();\n        this._private__updateCallback = updateCallback;\n    }\n}\nconst upDownMarkersPluginOptionDefaults = {\n    positiveColor: '#22AB94',\n    negativeColor: '#F7525F',\n    updateVisibilityDuration: 5000\n};\nclass MarkersPrimitiveRenderer {\n    draw(target) {\n        target.useBitmapCoordinateSpace((scope)=>{\n            const ctx = scope.context;\n            const tickWidth = Math.max(1, Math.floor(scope.horizontalPixelRatio));\n            const correction = tickWidth % 2 / 2;\n            const rad = 4 /* Constants.Radius */  * scope.verticalPixelRatio + correction;\n            this._private__data.forEach((item)=>{\n                const centreX = Math.round(item._internal_x * scope.horizontalPixelRatio) + correction;\n                ctx.beginPath();\n                const color = this._private__getColor(item._internal_sign);\n                ctx.fillStyle = color;\n                ctx.arc(centreX, item._internal_y * scope.verticalPixelRatio, rad, 0, 2 * Math.PI, false);\n                ctx.fill();\n                if (item._internal_sign) {\n                    ctx.strokeStyle = color;\n                    ctx.lineWidth = Math.floor(2 /* Constants.ArrowLineWidth */  * scope.horizontalPixelRatio);\n                    ctx.beginPath();\n                    ctx.moveTo((item._internal_x - 4.7 /* Constants.ArrowSize */ ) * scope.horizontalPixelRatio + correction, (item._internal_y - 7 /* Constants.ArrowOffset */  * item._internal_sign) * scope.verticalPixelRatio);\n                    ctx.lineTo(item._internal_x * scope.horizontalPixelRatio + correction, (item._internal_y - 7 /* Constants.ArrowOffset */  * item._internal_sign - 7 /* Constants.ArrowOffset */  * item._internal_sign * 0.5 /* Constants.VerticalScale */ ) * scope.verticalPixelRatio);\n                    ctx.lineTo((item._internal_x + 4.7 /* Constants.ArrowSize */ ) * scope.horizontalPixelRatio + correction, (item._internal_y - 7 /* Constants.ArrowOffset */  * item._internal_sign) * scope.verticalPixelRatio);\n                    ctx.stroke();\n                }\n            });\n        });\n    }\n    _private__getColor(sign) {\n        if (sign === 0) {\n            return this._private__neutralColor;\n        }\n        return sign > 0 ? this._private__positiveColor : this._private__negativeColor;\n    }\n    constructor(data, neutralColor, negativeColor, positiveColor){\n        this._private__data = data;\n        this._private__neutralColor = neutralColor;\n        this._private__negativeColor = negativeColor;\n        this._private__positiveColor = positiveColor;\n    }\n}\nfunction isAreaStyleOptions(opts, seriesType) {\n    return seriesType === 'Area';\n}\nfunction getNeutralColor(opts, seriesType) {\n    if (isAreaStyleOptions(opts, seriesType)) {\n        return opts.lineColor;\n    }\n    return opts.color;\n}\nclass MarkersPrimitivePaneView {\n    _internal_update(markers) {\n        this._private__data = markers.map((marker)=>{\n            const y = this._private__series.priceToCoordinate(marker.value);\n            if (y === null) {\n                return null;\n            }\n            const x = ensureNotNull(this._private__timeScale.timeToCoordinate(marker.time));\n            return {\n                _internal_x: x,\n                _internal_y: y,\n                _internal_sign: marker.sign\n            };\n        }).filter(notNull);\n    }\n    renderer() {\n        const options = this._private__series.options();\n        const seriesType = this._private__series.seriesType();\n        const neutralColor = getNeutralColor(options, seriesType);\n        return new MarkersPrimitiveRenderer(this._private__data, neutralColor, this._private__options.negativeColor, this._private__options.positiveColor);\n    }\n    constructor(series, timeScale, options){\n        this._private__data = [];\n        this._private__series = series;\n        this._private__timeScale = timeScale;\n        this._private__options = options;\n    }\n}\nfunction isLineData(item, type) {\n    return type === 'Line' || type === 'Area';\n}\nclass UpDownMarkersPrimitive {\n    _internal_applyOptions(options) {\n        this._private__options = {\n            ...this._private__options,\n            ...options\n        };\n        this._internal_requestUpdate();\n    }\n    _internal_setMarkers(markers) {\n        this._private__markersManager._internal_clearAllMarkers();\n        const horzBehaviour = this._private__horzScaleBehavior;\n        if (!horzBehaviour) {\n            return;\n        }\n        markers.forEach((marker)=>{\n            this._private__markersManager._internal_setMarker(marker, horzBehaviour.key(marker.time));\n        });\n    }\n    _internal_markers() {\n        return this._private__markersManager._internal_getMarkers();\n    }\n    _internal_requestUpdate() {\n        var _this__private__requestUpdate, _this;\n        (_this__private__requestUpdate = (_this = this)._private__requestUpdate) === null || _this__private__requestUpdate === void 0 ? void 0 : _this__private__requestUpdate.call(_this);\n    }\n    attached(params) {\n        const { chart, series, requestUpdate, horzScaleBehavior } = params;\n        this._private__chart = chart;\n        this._private__series = series;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        const seriesType = this._private__series.seriesType();\n        if (seriesType !== 'Area' && seriesType !== 'Line') {\n            throw new Error('UpDownMarkersPrimitive is only supported for Area and Line series types');\n        }\n        this._private__paneViews = [\n            new MarkersPrimitivePaneView(this._private__series, this._private__chart.timeScale(), this._private__options)\n        ];\n        this._private__requestUpdate = requestUpdate;\n        this._internal_requestUpdate();\n    }\n    detached() {\n        this._private__chart = undefined;\n        this._private__series = undefined;\n        this._private__requestUpdate = undefined;\n    }\n    _internal_chart() {\n        return ensureDefined(this._private__chart);\n    }\n    _internal_series() {\n        return ensureDefined(this._private__series);\n    }\n    updateAllViews() {\n        this._private__paneViews.forEach((pw)=>pw._internal_update(this._internal_markers()));\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    _internal_setData(data) {\n        if (!this._private__series) {\n            throw new Error('Primitive not attached to series');\n        }\n        const seriesType = this._private__series.seriesType();\n        this._private__managedDataPoints.clear();\n        const horzBehaviour = this._private__horzScaleBehavior;\n        if (horzBehaviour) {\n            data.forEach((d)=>{\n                if (isFulfilledData(d) && isLineData(d, seriesType)) {\n                    this._private__managedDataPoints.set(horzBehaviour.key(d.time), d.value);\n                }\n            });\n        }\n        ensureDefined(this._private__series).setData(data);\n    }\n    _internal_update(data, historicalUpdate) {\n        if (!this._private__series || !this._private__horzScaleBehavior) {\n            throw new Error('Primitive not attached to series');\n        }\n        const seriesType = this._private__series.seriesType();\n        const horzKey = this._private__horzScaleBehavior.key(data.time);\n        if (isWhitespaceData(data)) {\n            this._private__managedDataPoints.delete(horzKey);\n        }\n        if (isFulfilledData(data) && isLineData(data, seriesType)) {\n            const existingPrice = this._private__managedDataPoints.get(horzKey);\n            if (existingPrice) {\n                this._private__markersManager._internal_setMarker({\n                    time: data.time,\n                    value: data.value,\n                    sign: getSign(data.value, existingPrice)\n                }, horzKey, this._private__options.updateVisibilityDuration);\n            }\n        }\n        ensureDefined(this._private__series).update(data, historicalUpdate);\n    }\n    _internal_clearMarkers() {\n        this._private__markersManager._internal_clearAllMarkers();\n    }\n    constructor(options){\n        this._private__chart = undefined;\n        this._private__series = undefined;\n        this._private__paneViews = [];\n        this._private__horzScaleBehavior = null;\n        this._private__managedDataPoints = new Map();\n        this._private__markersManager = new ExpiringMarkerManager(()=>this._internal_requestUpdate());\n        this._private__options = {\n            ...upDownMarkersPluginOptionDefaults,\n            ...options\n        };\n    }\n}\nfunction getSign(newValue, oldValue) {\n    if (newValue === oldValue) {\n        return 0;\n    }\n    return newValue - oldValue > 0 ? 1 : -1;\n}\nclass SeriesUpDownMarkerPrimitiveWrapper extends SeriesPrimitiveAdapter {\n    setData(data) {\n        return this._internal__primitive._internal_setData(data);\n    }\n    update(data, historicalUpdate) {\n        return this._internal__primitive._internal_update(data, historicalUpdate);\n    }\n    markers() {\n        return this._internal__primitive._internal_markers();\n    }\n    setMarkers(markers) {\n        return this._internal__primitive._internal_setMarkers(markers);\n    }\n    clearMarkers() {\n        return this._internal__primitive._internal_clearMarkers();\n    }\n}\n/**\n * Creates and attaches the Series Up Down Markers Plugin.\n *\n * @param series - Series to which attach the Up Down Markers Plugin\n * @param options - options for the Up Down Markers Plugin\n *\n * @returns Api for Series Up Down Marker Plugin. {@link ISeriesUpDownMarkerPluginApi}\n *\n * @example\n * ```js\n * import { createUpDownMarkers, createChart, LineSeries } from 'lightweight-charts';\n *\n * const chart = createChart('container');\n * const lineSeries = chart.addSeries(LineSeries);\n * const upDownMarkers = createUpDownMarkers(lineSeries, {\n *     positiveColor: '#22AB94',\n *     negativeColor: '#F7525F',\n *     updateVisibilityDuration: 5000,\n * });\n * // to add some data\n * upDownMarkers.setData(\n *     [\n *         { time: '2020-02-02', value: 12.34 },\n *         //... more line series data\n *     ]\n * );\n * // ... Update some values\n * upDownMarkers.update({ time: '2020-02-02', value: 13.54 }, true);\n * // to remove plugin from the series\n * upDownMarkers.detach();\n * ```\n */ function createUpDownMarkers(series) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const wrapper = new SeriesUpDownMarkerPrimitiveWrapper(series, new UpDownMarkersPrimitive(options));\n    return wrapper;\n}\n/// <reference types=\"_build-time-constants\" />\nconst customSeriesDefaultOptions = {\n    ...seriesOptionsDefaults,\n    ...customStyleDefaults$1\n};\n/**\n * Returns the current version as a string. For example `'3.3.0'`.\n */ function version() {\n    return \"5.0.7\";\n}\n\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"MMMM\");\n$RefreshReg$(_c1, \"MMM\");\n$RefreshReg$(_c2, \"MM\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbGlnaHR3ZWlnaHQtY2hhcnRzL2Rpc3QvbGlnaHR3ZWlnaHQtY2hhcnRzLmRldmVsb3BtZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUMwSDtBQUUzSCxNQUFNSyx3QkFBd0I7SUFDMUJDLE9BQU87QUFDWDtBQUNBLE1BQU1DLHdCQUF3QjtJQUMxQkMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxpQkFBaUIsRUFBRSwyQkFBMkI7SUFDOUNDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0IsRUFBRSxvQkFBb0I7SUFDdENDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxlQUFlO0lBQ2ZDLGVBQWUsRUFBRSxtQkFBbUI7SUFDcENDLGFBQWE7UUFDVEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxJQUFJQztBQUNILFVBQVVBLFFBQVE7SUFDZjs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ25DOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDdEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUN2QyxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUI7O0NBRUMsR0FDRCxJQUFJQztBQUNILFVBQVVBLFNBQVM7SUFDaEI7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNwQzs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3JDOztLQUVDLEdB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LE9BQU8sSUFBSSxDQUFDb3RCLG9CQUFvQixDQUFDcnRCLGlCQUFpQixDQUFDQztJQUN2RDtJQUNBazBFLE9BQU9sMEUsSUFBSSxFQUFFOHdFLGdCQUFnQixFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDMWpELG9CQUFvQixDQUFDbHJCLGdCQUFnQixDQUFDbEMsTUFBTTh3RTtJQUM1RDtJQUNBdWxCLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ2pwRSxvQkFBb0IsQ0FBQ2txRSxpQkFBaUI7SUFDdEQ7SUFDQW9CLFdBQVdyQyxPQUFPLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNqcEUsb0JBQW9CLENBQUNncEUsb0JBQW9CLENBQUNDO0lBQzFEO0lBQ0FpRixlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUNsdUUsb0JBQW9CLENBQUMrdEUsc0JBQXNCO0lBQzNEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNELFNBQVNJLG9CQUFvQm4vRSxNQUFNO1FBQUU3TyxVQUFBQSxpRUFBVSxDQUFDO0lBQzVDLE1BQU11ZixVQUFVLElBQUl1dUUsbUNBQW1Dai9FLFFBQVEsSUFBSXkrRSx1QkFBdUJ0dEY7SUFDMUYsT0FBT3VmO0FBQ1g7QUFFQSwrQ0FBK0M7QUFDL0MsTUFBTTB1RSw2QkFBNkI7SUFDL0IsR0FBRy9vRyxxQkFBcUI7SUFDeEIsR0FBR0YscUJBQXFCO0FBQzVCO0FBQ0E7O0NBRUMsR0FDRCxTQUFTa3BHO0lBQ0wsT0FBTztBQUNYO0FBRTZsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FiaGFza3VtYXJyci9Eb2N1bWVudHMvR2l0SHViL1NtYXJ0TWFya2V0T09QUy9ub2RlX21vZHVsZXMvbGlnaHR3ZWlnaHQtY2hhcnRzL2Rpc3QvbGlnaHR3ZWlnaHQtY2hhcnRzLmRldmVsb3BtZW50Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBUcmFkaW5nVmlldyBMaWdodHdlaWdodCBDaGFydHPihKIgdjUuMC43XG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUgVHJhZGluZ1ZpZXcsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIEFwYWNoZSBMaWNlbnNlIDIuMCBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbmltcG9ydCB7IHNpemUgYXMgc2l6ZSQxLCBiaW5kQ2FudmFzRWxlbWVudEJpdG1hcFNpemVUbywgZXF1YWxTaXplcywgdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQgfSBmcm9tICdmYW5jeS1jYW52YXMnO1xuXG5jb25zdCBjdXN0b21TdHlsZURlZmF1bHRzJDEgPSB7XG4gICAgY29sb3I6ICcjMjE5NmYzJyxcbn07XG5jb25zdCBzZXJpZXNPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgdGl0bGU6ICcnLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgbGFzdFZhbHVlVmlzaWJsZTogdHJ1ZSxcbiAgICBwcmljZUxpbmVWaXNpYmxlOiB0cnVlLFxuICAgIHByaWNlTGluZVNvdXJjZTogMCAvKiBQcmljZUxpbmVTb3VyY2UuTGFzdEJhciAqLyxcbiAgICBwcmljZUxpbmVXaWR0aDogMSxcbiAgICBwcmljZUxpbmVDb2xvcjogJycsXG4gICAgcHJpY2VMaW5lU3R5bGU6IDIgLyogTGluZVN0eWxlLkRhc2hlZCAqLyxcbiAgICBiYXNlTGluZVZpc2libGU6IHRydWUsXG4gICAgYmFzZUxpbmVXaWR0aDogMSxcbiAgICBiYXNlTGluZUNvbG9yOiAnI0IyQjVCRScsXG4gICAgYmFzZUxpbmVTdHlsZTogMCAvKiBMaW5lU3R5bGUuU29saWQgKi8sXG4gICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgcHJlY2lzaW9uOiAyLFxuICAgICAgICBtaW5Nb3ZlOiAwLjAxLFxuICAgIH0sXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHBvc3NpYmxlIGxpbmUgdHlwZXMuXG4gKi9cbnZhciBMaW5lVHlwZTtcbihmdW5jdGlvbiAoTGluZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIGxpbmUuXG4gICAgICovXG4gICAgTGluZVR5cGVbTGluZVR5cGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgLyoqXG4gICAgICogQSBzdGVwcGVkIGxpbmUuXG4gICAgICovXG4gICAgTGluZVR5cGVbTGluZVR5cGVbXCJXaXRoU3RlcHNcIl0gPSAxXSA9IFwiV2l0aFN0ZXBzXCI7XG4gICAgLyoqXG4gICAgICogQSBjdXJ2ZWQgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lVHlwZVtMaW5lVHlwZVtcIkN1cnZlZFwiXSA9IDJdID0gXCJDdXJ2ZWRcIjtcbn0pKExpbmVUeXBlIHx8IChMaW5lVHlwZSA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHBvc3NpYmxlIGxpbmUgc3R5bGVzLlxuICovXG52YXIgTGluZVN0eWxlO1xuKGZ1bmN0aW9uIChMaW5lU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHNvbGlkIGxpbmUuXG4gICAgICovXG4gICAgTGluZVN0eWxlW0xpbmVTdHlsZVtcIlNvbGlkXCJdID0gMF0gPSBcIlNvbGlkXCI7XG4gICAgLyoqXG4gICAgICogQSBkb3R0ZWQgbGluZS5cbiAgICAgKi9cbiAgICBMaW5lU3R5bGVbTGluZVN0eWxlW1wiRG90dGVkXCJdID0gMV0gPSBcIkRvdHRlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgZGFzaGVkIGxpbmUuXG4gICAgICovXG4gICAgTGluZVN0eWxlW0xpbmVTdHlsZVtcIkRhc2hlZFwiXSA9IDJdID0gXCJEYXNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGRhc2hlZCBsaW5lIHdpdGggYmlnZ2VyIGRhc2hlcy5cbiAgICAgKi9cbiAgICBMaW5lU3R5bGVbTGluZVN0eWxlW1wiTGFyZ2VEYXNoZWRcIl0gPSAzXSA9IFwiTGFyZ2VEYXNoZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGRvdHRlZCBsaW5lIHdpdGggbW9yZSBzcGFjZSBiZXR3ZWVuIGRvdHMuXG4gICAgICovXG4gICAgTGluZVN0eWxlW0xpbmVTdHlsZVtcIlNwYXJzZURvdHRlZFwiXSA9IDRdID0gXCJTcGFyc2VEb3R0ZWRcIjtcbn0pKExpbmVTdHlsZSB8fCAoTGluZVN0eWxlID0ge30pKTtcbmZ1bmN0aW9uIHNldExpbmVTdHlsZShjdHgsIHN0eWxlKSB7XG4gICAgY29uc3QgZGFzaFBhdHRlcm5zID0ge1xuICAgICAgICBbMCAvKiBMaW5lU3R5bGUuU29saWQgKi9dOiBbXSxcbiAgICAgICAgWzEgLyogTGluZVN0eWxlLkRvdHRlZCAqL106IFtjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoXSxcbiAgICAgICAgWzIgLyogTGluZVN0eWxlLkRhc2hlZCAqL106IFsyICogY3R4LmxpbmVXaWR0aCwgMiAqIGN0eC5saW5lV2lkdGhdLFxuICAgICAgICBbMyAvKiBMaW5lU3R5bGUuTGFyZ2VEYXNoZWQgKi9dOiBbNiAqIGN0eC5saW5lV2lkdGgsIDYgKiBjdHgubGluZVdpZHRoXSxcbiAgICAgICAgWzQgLyogTGluZVN0eWxlLlNwYXJzZURvdHRlZCAqL106IFtjdHgubGluZVdpZHRoLCA0ICogY3R4LmxpbmVXaWR0aF0sXG4gICAgfTtcbiAgICBjb25zdCBkYXNoUGF0dGVybiA9IGRhc2hQYXR0ZXJuc1tzdHlsZV07XG4gICAgY3R4LnNldExpbmVEYXNoKGRhc2hQYXR0ZXJuKTtcbn1cbmZ1bmN0aW9uIGRyYXdIb3Jpem9udGFsTGluZShjdHgsIHksIGxlZnQsIHJpZ2h0KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGNvcnJlY3Rpb24gPSAoY3R4LmxpbmVXaWR0aCAlIDIpID8gMC41IDogMDtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHkgKyBjb3JyZWN0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5ICsgY29ycmVjdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuZnVuY3Rpb24gZHJhd1ZlcnRpY2FsTGluZShjdHgsIHgsIHRvcCwgYm90dG9tKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGNvcnJlY3Rpb24gPSAoY3R4LmxpbmVXaWR0aCAlIDIpID8gMC41IDogMDtcbiAgICBjdHgubW92ZVRvKHggKyBjb3JyZWN0aW9uLCB0b3ApO1xuICAgIGN0eC5saW5lVG8oeCArIGNvcnJlY3Rpb24sIGJvdHRvbSk7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlSW5QaXhlbChjdHgsIGRyYXdGdW5jdGlvbikge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKGN0eC5saW5lV2lkdGggJSAyKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgIH1cbiAgICBkcmF3RnVuY3Rpb24oKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBhbiBhc3NlcnRpb24uIFRocm93cyBpZiB0aGUgYXNzZXJ0aW9uIGlzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0gY29uZGl0aW9uIC0gUmVzdWx0IG9mIHRoZSBhc3NlcnRpb24gZXZhbHVhdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBUZXh0IHRvIGluY2x1ZGUgaW4gdGhlIGV4Y2VwdGlvbiBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQnICsgKG1lc3NhZ2UgPyAnOiAnICsgbWVzc2FnZSA6ICcnKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5zdXJlRGVmaW5lZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZU5vdE51bGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBpcyBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZSh2YWx1ZSkge1xuICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKGVuc3VyZURlZmluZWQodmFsdWUpKTtcbn1cbi8qKlxuICogQ29tcGlsZSB0aW1lIGNoZWNrIGZvciBuZXZlclxuICovXG5mdW5jdGlvbiBlbnN1cmVOZXZlcih2YWx1ZSkgeyB9XG5cbmNsYXNzIERlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdWJzY3JpYmUoY2FsbGJhY2ssIGxpbmtlZE9iamVjdCwgc2luZ2xlc2hvdCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGlua2VkT2JqZWN0OiBsaW5rZWRPYmplY3QsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2luZ2xlc2hvdDogc2luZ2xlc2hvdCA9PT0gdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdW5zdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuZmluZEluZGV4KChsaXN0ZW5lcikgPT4gY2FsbGJhY2sgPT09IGxpc3RlbmVyLl9pbnRlcm5hbF9jYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwobGlua2VkT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5maWx0ZXIoKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5faW50ZXJuYWxfbGlua2VkT2JqZWN0ICE9PSBsaW5rZWRPYmplY3QpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyZShwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyc1NuYXBzaG90ID0gWy4uLnRoaXMuX3ByaXZhdGVfX2xpc3RlbmVyc107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5maWx0ZXIoKGxpc3RlbmVyKSA9PiAhbGlzdGVuZXIuX2ludGVybmFsX3NpbmdsZXNob3QpO1xuICAgICAgICBsaXN0ZW5lcnNTbmFwc2hvdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuX2ludGVybmFsX2NhbGxiYWNrKHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hhc0xpc3RlbmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzID0gW107XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gbWVyZ2UoZHN0LCAuLi5zb3VyY2VzKSB7XG4gICAgZm9yIChjb25zdCBzcmMgb2Ygc291cmNlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHNyY1tpXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIGkpIHx8XG4gICAgICAgICAgICAgICAgWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ10uaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnb2JqZWN0JyAhPT0gdHlwZW9mIHNyY1tpXSB8fCBkc3RbaV0gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KHNyY1tpXSkpIHtcbiAgICAgICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIG1lcmdlKGRzdFtpXSwgc3JjW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpICYmIChpc0Zpbml0ZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSAmJiAoKHZhbHVlICUgMSkgPT09IDApO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgbyA9IG9iamVjdDtcbiAgICBpZiAoIW8gfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgYztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICBjID0gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjID0ge307XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGxldCB2O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgdiA9IG9bcF07XG4gICAgICAgICAgICBpZiAodiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgY1twXSA9IGNsb25lKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNbcF0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gbm90TnVsbCh0KSB7XG4gICAgcmV0dXJuIHQgIT09IG51bGw7XG59XG5mdW5jdGlvbiB1bmRlZmluZWRJZk51bGwodCkge1xuICAgIHJldHVybiAodCA9PT0gbnVsbCkgPyB1bmRlZmluZWQgOiB0O1xufVxuXG4vKipcbiAqIERlZmF1bHQgZm9udCBmYW1pbHkuXG4gKiBNdXN0IGJlIHVzZWQgdG8gZ2VuZXJhdGUgZm9udCBzdHJpbmcgd2hlbiBmb250IGlzIG5vdCBzcGVjaWZpZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRGb250RmFtaWx5ID0gYC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1RyZWJ1Y2hldCBNUycsIFJvYm90bywgVWJ1bnR1LCBzYW5zLXNlcmlmYDtcbi8qKlxuICogR2VuZXJhdGVzIGEgZm9udCBzdHJpbmcsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHNldCBpbiBjYW52YXMnIGZvbnQgcHJvcGVydHkuXG4gKiBJZiBubyBmYW1pbHkgcHJvdmlkZWQsIHtAbGluayBkZWZhdWx0Rm9udEZhbWlseX0gd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBzaXplIC0gRm9udCBzaXplIGluIHBpeGVscy5cbiAqIEBwYXJhbSBmYW1pbHkgLSBPcHRpb25hbCBmb250IGZhbWlseS5cbiAqIEBwYXJhbSBzdHlsZSAtIE9wdGlvbmFsIGZvbnQgc3R5bGUuXG4gKiBAcmV0dXJucyBUaGUgZm9udCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG1ha2VGb250KHNpemUsIGZhbWlseSwgc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZSA9IGAke3N0eWxlfSBgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSAnJztcbiAgICB9XG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZhbWlseSA9IGRlZmF1bHRGb250RmFtaWx5O1xuICAgIH1cbiAgICByZXR1cm4gYCR7c3R5bGV9JHtzaXplfXB4ICR7ZmFtaWx5fWA7XG59XG5cbmNsYXNzIFByaWNlQXhpc1JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydE1vZGVsKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJTaXplOiAxIC8qIFJlbmRlcmVyQ29uc3RhbnRzLkJvcmRlclNpemUgKi8sXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGlja0xlbmd0aDogNSAvKiBSZW5kZXJlckNvbnN0YW50cy5UaWNrTGVuZ3RoICovLFxuICAgICAgICAgICAgX2ludGVybmFsX2ZvbnRTaXplOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfZm9udDogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfZm9udEZhbWlseTogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX3BhbmVCYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdCb3R0b206IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ0lubmVyOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdPdXRlcjogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nVG9wOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VsaW5lT2Zmc2V0OiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsID0gY2hhcnRNb2RlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgY3VycmVudEZvbnRTaXplID0gdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEZvbnRGYW1pbHkgPSB0aGlzLl9wcml2YXRlX19mb250RmFtaWx5KCk7XG4gICAgICAgIGlmIChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplICE9PSBjdXJyZW50Rm9udFNpemUgfHwgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250RmFtaWx5ICE9PSBjdXJyZW50Rm9udEZhbWlseSkge1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSA9IGN1cnJlbnRGb250U2l6ZTtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udEZhbWlseSA9IGN1cnJlbnRGb250RmFtaWx5O1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250ID0gbWFrZUZvbnQoY3VycmVudEZvbnRTaXplLCBjdXJyZW50Rm9udEZhbWlseSk7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgPSAyLjUgLyAxMiAqIGN1cnJlbnRGb250U2l6ZTsgLy8gMi41IHB4IGZvciAxMnB4IGZvbnRcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0lubmVyID0gY3VycmVudEZvbnRTaXplIC8gMTIgKiByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGg7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdPdXRlciA9IGN1cnJlbnRGb250U2l6ZSAvIDEyICogcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9iYXNlbGluZU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9jb2xvciA9IHRoaXMuX3ByaXZhdGVfX3RleHRDb2xvcigpO1xuICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhbmVCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9wcml2YXRlX19wYW5lQmFja2dyb3VuZENvbG9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnM7XG4gICAgfVxuICAgIF9wcml2YXRlX190ZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLnRleHRDb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3BhbmVCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5mb250U2l6ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRGYW1pbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLmZvbnRGYW1pbHk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZ2JDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKGNvbXBvbmVudCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnQgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuIDI1NTtcbiAgICB9XG4gICAgLy8gTmFOIHZhbHVlcyBhcmUgdHJlYXRlZCBhcyAwXG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKGNvbXBvbmVudCkgfHwgMCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbHBoYUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBpZiAoY29tcG9uZW50IDw9IDAgfHwgY29tcG9uZW50ID4gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoY29tcG9uZW50LCAwKSwgMSk7XG4gICAgfVxuICAgIC8vIGxpbWl0IHRoZSBwcmVjaXNpb24gb2YgYWxsIG51bWJlcnMgdG8gYXQgbW9zdCA0IGRpZ2l0cyBpbiBmcmFjdGlvbmFsIHBhcnRcbiAgICByZXR1cm4gKE1hdGgucm91bmQoY29tcG9uZW50ICogMTAwMDApIC8gMTAwMDApO1xufVxuZnVuY3Rpb24gcmdiYVRvR3JheXNjYWxlKHJnYlZhbHVlKSB7XG4gICAgLy8gT3JpZ2luYWxseSwgdGhlIE5UU0MgUkdCIHRvIFlVViBmb3JtdWxhXG4gICAgLy8gcGVyZmVjdGVkIGJ5IEBldWdlbmUta29yb2JrbydzIGJsYWNrIG1hZ2ljXG4gICAgY29uc3QgcmVkQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ID0gMC4xOTk7XG4gICAgY29uc3QgZ3JlZW5Db21wb25lbnRHcmF5c2NhbGVXZWlnaHQgPSAwLjY4NztcbiAgICBjb25zdCBibHVlQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ID0gMC4xMTQ7XG4gICAgcmV0dXJuIChyZWRDb21wb25lbnRHcmF5c2NhbGVXZWlnaHQgKiByZ2JWYWx1ZVswXSArXG4gICAgICAgIGdyZWVuQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ICogcmdiVmFsdWVbMV0gK1xuICAgICAgICBibHVlQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ICogcmdiVmFsdWVbMl0pO1xufVxuLyoqXG4gKiBGb3IgY29sb3JzIHdoaWNoIGZhbGwgd2l0aGluIHRoZSBzUkdCIHNwYWNlLCB0aGUgYnJvd3NlciBjYW5cbiAqIGJlIHVzZWQgdG8gY29udmVydCB0aGUgY29sb3Igc3RyaW5nIGludG8gYSByZ2IgL3JnYmEgc3RyaW5nLlxuICpcbiAqIEZvciBvdGhlciBjb2xvcnMsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgc3BlY2lmaWVkIChpLmUuIGZvclxuICogbmV3ZXIgZm9ybWF0cyBsaWtlIGRpc3BsYXktcDMpXG4gKlxuICogU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTQvI3NlcmlhbGl6aW5nLXNSR0ItdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdldFJnYlN0cmluZ1ZpYUJyb3dzZXIoY29sb3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIC8vIFdlIGFwcGVuZCB0byB0aGUgYm9keSBhcyBpdCBpcyB0aGUgbW9zdCByZWxpYWJsZSB3YXkgdG8gZ2V0IGEgY29sb3IgcmVhZGluZ1xuICAgIC8vIGFwcGVuZGluZyB0byB0aGUgY2hhcnQgY29udGFpbmVyIG9yIHNpbWlsYXIgZWxlbWVudCBjYW4gcmVzdWx0IGluIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybmluZyBlbXB0eSBzdHJpbmdzIG9uIGVhY2ggY2hlY2suXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgY29uc3QgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5jb2xvcjtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiBjb21wdXRlZDtcbn1cbmNsYXNzIENvbG9yUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjdXN0b21QYXJzZXJzLCBpbml0aWFsQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmdiYUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jdXN0b21QYXJzZXJzID0gY3VzdG9tUGFyc2VycztcbiAgICAgICAgaWYgKGluaXRpYWxDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmdiYUNhY2hlID0gaW5pdGlhbENhY2hlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIGZhbGxiYWNrIHRvIFJHQkEgaGVyZSBzaW5jZSBzdXBwb3J0aW5nIGFscGhhIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIG9uIHdpZGVyIGNvbG9yIGdhbXV0cyB3b3VsZCBjdXJyZW50bHkgYmUgYSBsb3Qgb2YgZXh0cmEgY29kZVxuICAgICAqIGZvciB2ZXJ5IGxpdHRsZSBiZW5lZml0IGR1ZSB0byBhY3R1YWwgdXNhZ2UuXG4gICAgICovXG4gICAgX2ludGVybmFsX2FwcGx5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvcHRpbWl6YXRpb25cbiAgICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luUmdiYSA9IHRoaXMuX3ByaXZhdGVfX3BhcnNlQ29sb3IoY29sb3IpO1xuICAgICAgICBjb25zdCBvcmlnaW5BbHBoYSA9IG9yaWdpblJnYmFbM107XG4gICAgICAgIHJldHVybiBgcmdiYSgke29yaWdpblJnYmFbMF19LCAke29yaWdpblJnYmFbMV19LCAke29yaWdpblJnYmFbMl19LCAke2FscGhhICogb3JpZ2luQWxwaGF9KWA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKGJhY2tncm91bmQpIHtcbiAgICAgICAgY29uc3QgcmdiYSA9IHRoaXMuX3ByaXZhdGVfX3BhcnNlQ29sb3IoYmFja2dyb3VuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFja2dyb3VuZDogYHJnYigke3JnYmFbMF19LCAke3JnYmFbMV19LCAke3JnYmFbMl19KWAsIC8vIG5vIGFscGhhXG4gICAgICAgICAgICBfaW50ZXJuYWxfZm9yZWdyb3VuZDogcmdiYVRvR3JheXNjYWxlKHJnYmEpID4gMTYwID8gJ2JsYWNrJyA6ICd3aGl0ZScsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb2xvclN0cmluZ1RvR3JheXNjYWxlKGJhY2tncm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHJnYmFUb0dyYXlzY2FsZSh0aGlzLl9wcml2YXRlX19wYXJzZUNvbG9yKGJhY2tncm91bmQpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dyYWRpZW50Q29sb3JBdFBlcmNlbnQodG9wQ29sb3IsIGJvdHRvbUNvbG9yLCBwZXJjZW50KSB7XG4gICAgICAgIGNvbnN0IFt0b3BSLCB0b3BHLCB0b3BCLCB0b3BBXSA9IHRoaXMuX3ByaXZhdGVfX3BhcnNlQ29sb3IodG9wQ29sb3IpO1xuICAgICAgICBjb25zdCBbYm90dG9tUiwgYm90dG9tRywgYm90dG9tQiwgYm90dG9tQV0gPSB0aGlzLl9wcml2YXRlX19wYXJzZUNvbG9yKGJvdHRvbUNvbG9yKTtcbiAgICAgICAgY29uc3QgcmVzdWx0UmdiYSA9IFtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudCgodG9wUiArIHBlcmNlbnQgKiAoYm90dG9tUiAtIHRvcFIpKSksXG4gICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQoKHRvcEcgKyBwZXJjZW50ICogKGJvdHRvbUcgLSB0b3BHKSkpLFxuICAgICAgICAgICAgbm9ybWFsaXplUmdiQ29tcG9uZW50KCh0b3BCICsgcGVyY2VudCAqIChib3R0b21CIC0gdG9wQikpKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZUFscGhhQ29tcG9uZW50KCh0b3BBICsgcGVyY2VudCAqIChib3R0b21BIC0gdG9wQSkpKSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGByZ2JhKCR7cmVzdWx0UmdiYVswXX0sICR7cmVzdWx0UmdiYVsxXX0sICR7cmVzdWx0UmdiYVsyXX0sICR7cmVzdWx0UmdiYVszXX0pYDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3BhcnNlQ29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fcHJpdmF0ZV9fcmdiYUNhY2hlLmdldChjb2xvcik7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBnZXRSZ2JTdHJpbmdWaWFCcm93c2VyKGNvbG9yKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb21wdXRlZC5tYXRjaCgvXnJnYmE/XFxzKlxcKChcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKykoPzosXFxzKihcXGQqXFwuP1xcZCspKT9cXCkkLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jdXN0b21QYXJzZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFyc2VyIG9mIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVBhcnNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmdiYUNhY2hlLnNldChjb2xvciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBjb2xvcjogJHtjb2xvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZ2JhID0gW1xuICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoWzJdLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtYXRjaFszXSwgMTApLFxuICAgICAgICAgICAgKG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxKSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmdiYUNhY2hlLnNldChjb2xvciwgcmdiYSk7XG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cbn1cblxuY2xhc3MgQ29tcG9zaXRlUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlcnMgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFJlbmRlcmVycyhyZW5kZXJlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJzID0gcmVuZGVyZXJzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgIHIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB0aGlzLl9pbnRlcm5hbF9fZHJhd0ltcGwoc2NvcGUsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpKTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlck1hcmtzIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19kYXRhID09PSBudWxsIHx8IHRoaXMuX2ludGVybmFsX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB0aGlzLl9pbnRlcm5hbF9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgY29uc3QgY29ycmVjdGlvbiA9ICh0aWNrV2lkdGggJSAyKSAvIDI7XG4gICAgICAgIGNvbnN0IGRyYXcgPSAocmFkaXVzTWVkaWEpID0+IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlUmFuZ2UudG8gLSAxOyBpID49IHZpc2libGVSYW5nZS5mcm9tOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGRhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBNYXRoLnJvdW5kKHBvaW50Ll9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pICsgY29ycmVjdGlvbjsgLy8gY29ycmVjdCB4IGNvb3JkaW5hdGUgb25seVxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSBwb2ludC5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNNZWRpYSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyArIGNvcnJlY3Rpb247XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9iYWNrQ29sb3I7XG4gICAgICAgICAgICBkcmF3KGRhdGEuX2ludGVybmFsX3JhZGl1cyArIGRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX2xpbmVDb2xvcjtcbiAgICAgICAgZHJhdyhkYXRhLl9pbnRlcm5hbF9yYWRpdXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlNYXJrZXJEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9pdGVtczogW3tcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeDogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeTogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcHJpY2U6IDAsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgX2ludGVybmFsX2xpbmVDb2xvcjogJycsXG4gICAgICAgIF9pbnRlcm5hbF9iYWNrQ29sb3I6ICcnLFxuICAgICAgICBfaW50ZXJuYWxfcmFkaXVzOiAwLFxuICAgICAgICBfaW50ZXJuYWxfbGluZVdpZHRoOiAwLFxuICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiBudWxsLFxuICAgIH07XG59XG5jb25zdCByYW5nZUZvclNpbmdsZVBvaW50ID0geyBmcm9tOiAwLCB0bzogMSB9O1xuY2xhc3MgQ3Jvc3NoYWlyTWFya3NQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3IoY2hhcnRNb2RlbCwgY3Jvc3NoYWlyLCBwYW5lKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyID0gbmV3IENvbXBvc2l0ZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNSZW5kZXJlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc0RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsID0gY2hhcnRNb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyID0gY3Jvc3NoYWlyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gcGFuZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tcG9zaXRlUmVuZGVyZXIuX2ludGVybmFsX3NldFJlbmRlcmVycyh0aGlzLl9wcml2YXRlX19tYXJrZXJzUmVuZGVyZXJzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSh1cGRhdGVUeXBlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NyZWF0ZU1hcmtlclJlbmRlcmVyc0lmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY3JlYXRlTWFya2VyUmVuZGVyZXJzSWZOZWVkZWQoKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc2VzID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKTtcbiAgICAgICAgaWYgKHNlcmllc2VzLmxlbmd0aCAhPT0gdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNEYXRhID0gc2VyaWVzZXMubWFwKGNyZWF0ZUVtcHR5TWFya2VyRGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUmVuZGVyZXJzID0gdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc0RhdGEubWFwKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFBhbmVSZW5kZXJlck1hcmtzKCk7XG4gICAgICAgICAgICAgICAgcmVzLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXRSZW5kZXJlcnModGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlSGlkZGVuID0gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9vcHRpb25zKCkubW9kZSA9PT0gMiAvKiBDcm9zc2hhaXJNb2RlLkhpZGRlbiAqLyB8fCAhdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF92aXNpYmxlKCk7XG4gICAgICAgIGNvbnN0IHNlcmllc2VzID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfb3JkZXJlZFNlcmllcygpO1xuICAgICAgICBjb25zdCB0aW1lUG9pbnRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcmVhdGVNYXJrZXJSZW5kZXJlcnNJZk5lZWRlZCgpO1xuICAgICAgICBzZXJpZXNlcy5mb3JFYWNoKChzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNEYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBzLl9pbnRlcm5hbF9tYXJrZXJEYXRhQXRJbmRleCh0aW1lUG9pbnRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZvcmNlSGlkZGVuIHx8IHNlcmllc0RhdGEgPT09IG51bGwgfHwgIXMuX2ludGVybmFsX3Zpc2libGUoKSB8fCBmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lQ29sb3IgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9yYWRpdXM7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF9wcmljZSA9IHNlcmllc0RhdGEuX2ludGVybmFsX3ByaWNlO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfaXRlbXNbMF0uX2ludGVybmFsX3kgPSBzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHNlcmllc0RhdGEuX2ludGVybmFsX3ByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9iYWNrQ29sb3IgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA/PyB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3JBdFlQZXJjZW50RnJvbVRvcChkYXRhLl9pbnRlcm5hbF9pdGVtc1swXS5faW50ZXJuYWxfeSAvIHMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaGVpZ2h0KCkpO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfaXRlbXNbMF0uX2ludGVybmFsX3RpbWUgPSB0aW1lUG9pbnRJbmRleDtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF94ID0gdGltZVNjYWxlLl9pbnRlcm5hbF9pbmRleFRvQ29vcmRpbmF0ZSh0aW1lUG9pbnRJbmRleCk7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPSByYW5nZUZvclNpbmdsZVBvaW50O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIENyb3NzaGFpclJlbmRlcmVyIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnRMaW5lc1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfdmlzaWJsZTtcbiAgICAgICAgY29uc3QgaG9yekxpbmVzVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgICAgICBpZiAoIXZlcnRMaW5lc1Zpc2libGUgJiYgIWhvcnpMaW5lc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGlmICh2ZXJ0TGluZXNWaXNpYmxlICYmIHggPj0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2xpbmVXaWR0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgICAgIGRyYXdWZXJ0aWNhbExpbmUoY3R4LCB4LCAwLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcnpMaW5lc1Zpc2libGUgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVdpZHRoICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBzZXRMaW5lU3R5bGUoY3R4LCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgICAgIGRyYXdIb3Jpem9udGFsTGluZShjdHgsIHksIDAsIGJpdG1hcFNpemUud2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDcm9zc2hhaXJQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBwYW5lKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRMaW5lOiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogMSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJycsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6TGluZToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcnLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlciA9IG5ldyBDcm9zc2hhaXJSZW5kZXJlcih0aGlzLl9wcml2YXRlX19yZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBwYW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcihwYW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVJbXBsKCkge1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF92aXNpYmxlKCk7XG4gICAgICAgIGNvbnN0IGNyb3NzaGFpck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9vcHRpb25zKCkuY3Jvc3NoYWlyO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhO1xuICAgICAgICBpZiAoY3Jvc3NoYWlyT3B0aW9ucy5tb2RlID09PSAyIC8qIENyb3NzaGFpck1vZGUuSGlkZGVuICovKSB7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfdmlzaWJsZSA9IHZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9ob3J6TGluZVZpc2libGUodGhpcy5fcHJpdmF0ZV9fcGFuZSk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF92aXNpYmxlID0gdmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3ZlcnRMaW5lVmlzaWJsZSgpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfbGluZVdpZHRoID0gY3Jvc3NoYWlyT3B0aW9ucy5ob3J6TGluZS53aWR0aDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2xpbmVTdHlsZSA9IGNyb3NzaGFpck9wdGlvbnMuaG9yekxpbmUuc3R5bGU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF9jb2xvciA9IGNyb3NzaGFpck9wdGlvbnMuaG9yekxpbmUuY29sb3I7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9saW5lV2lkdGggPSBjcm9zc2hhaXJPcHRpb25zLnZlcnRMaW5lLndpZHRoO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfbGluZVN0eWxlID0gY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0TGluZS5zdHlsZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2NvbG9yID0gY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0TGluZS5jb2xvcjtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeCA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfYXBwbGllZFgoKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfYXBwbGllZFkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogRmlsbHMgcmVjdGFuZ2xlJ3MgaW5uZXIgYm9yZGVyIChzbywgYWxsIHRoZSBmaWxsZWQgYXJlYSBpcyBsaW1pdGVkIGJ5IHRoZSBbeCwgeCArIHdpZHRoXSpbeSwgeSArIGhlaWdodF0gcmVnaW9uKVxuICogYGBgXG4gKiAoeCwgeSlcbiAqIE8qKioqKioqKioqKioqKioqKioqKioqKnwqKioqKlxuICogfCAgICAgICAgYm9yZGVyICAgICAgICAgfCAgXlxuICogfCAgICoqKioqKioqKioqKioqKioqICAgfCAgfFxuICogfCAgIHwgICAgICAgICAgICAgICB8ICAgfCAgfFxuICogfCBiIHwgICAgICAgICAgICAgICB8IGIgfCAgaFxuICogfCBvIHwgICAgICAgICAgICAgICB8IG8gfCAgZVxuICogfCByIHwgICAgICAgICAgICAgICB8IHIgfCAgaVxuICogfCBkIHwgICAgICAgICAgICAgICB8IGQgfCAgZ1xuICogfCBlIHwgICAgICAgICAgICAgICB8IGUgfCAgaFxuICogfCByIHwgICAgICAgICAgICAgICB8IHIgfCAgdFxuICogfCAgIHwgICAgICAgICAgICAgICB8ICAgfCAgfFxuICogfCAgICoqKioqKioqKioqKioqKioqICAgfCAgfFxuICogfCAgICAgICAgYm9yZGVyICAgICAgICAgfCAgdlxuICogfCoqKioqKioqKioqKioqKioqKioqKioqfCoqKioqXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8PC0tLS0tLS0gd2lkdGggLS0tLS0tLT58XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dCB0byBkcmF3IG9uXG4gKiBAcGFyYW0geCAtIExlZnQgc2lkZSBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZVxuICogQHBhcmFtIHkgLSBUb3Agc2lkZSBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSBib3JkZXJXaWR0aCAtIFdpZHRoIG9mIGJvcmRlciB0byBmaWxsLCBtdXN0IGJlIGxlc3MgdGhhbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGZpbGxSZWN0SW5uZXJCb3JkZXIoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXJXaWR0aCkge1xuICAgIC8vIGhvcml6b250YWwgKHRvcCBhbmQgYm90dG9tKSBlZGdlc1xuICAgIGN0eC5maWxsUmVjdCh4ICsgYm9yZGVyV2lkdGgsIHksIHdpZHRoIC0gYm9yZGVyV2lkdGggKiAyLCBib3JkZXJXaWR0aCk7XG4gICAgY3R4LmZpbGxSZWN0KHggKyBib3JkZXJXaWR0aCwgeSArIGhlaWdodCAtIGJvcmRlcldpZHRoLCB3aWR0aCAtIGJvcmRlcldpZHRoICogMiwgYm9yZGVyV2lkdGgpO1xuICAgIC8vIHZlcnRpY2FsIChsZWZ0IGFuZCByaWdodCkgZWRnZXNcbiAgICBjdHguZmlsbFJlY3QoeCwgeSwgYm9yZGVyV2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmZpbGxSZWN0KHggKyB3aWR0aCAtIGJvcmRlcldpZHRoLCB5LCBib3JkZXJXaWR0aCwgaGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyUmVjdChjdHgsIHgsIHksIHcsIGgsIGNsZWFyQ29sb3IpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjaGFuZ2VCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYm9yZGVyUmFkaXVzLm1hcCgoeCkgPT4geCA9PT0gMCA/IHggOiB4ICsgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGRyYXdSb3VuZFJlY3QoXG4vLyBlc2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LXBhcmFtc1xuY3R4LCB4LCB5LCB3LCBoLCByYWRpaSkge1xuICAgIC8qKlxuICAgICAqIEFzIG9mIE1heSAyMDIzLCBhbGwgb2YgdGhlIG1ham9yIGJyb3dzZXJzIG5vdyBzdXBwb3J0IGN0eC5yb3VuZFJlY3QoKSBzbyB3ZSBzaG91bGRcbiAgICAgKiBiZSBhYmxlIHRvIHN3aXRjaCB0byB0aGUgbmF0aXZlIHZlcnNpb24gc29vbi5cbiAgICAgKi9cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKGN0eC5yb3VuZFJlY3QpIHtcbiAgICAgICAgY3R4LnJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpaSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLypcbiAgICAgKiBEZXByZWNhdGUgdGhlIHJlc3QgaW4gdjUuXG4gICAgICovXG4gICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGlpWzFdLCB5KTtcbiAgICBpZiAocmFkaWlbMV0gIT09IDApIHtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHJhZGlpWzFdLCByYWRpaVsxXSk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcmFkaWlbMl0pO1xuICAgIGlmIChyYWRpaVsyXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHJhZGlpWzJdLCB5ICsgaCwgcmFkaWlbMl0pO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyByYWRpaVszXSwgeSArIGgpO1xuICAgIGlmIChyYWRpaVszXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcmFkaWlbM10sIHJhZGlpWzNdKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaWlbMF0pO1xuICAgIGlmIChyYWRpaVswXSAhPT0gMCkge1xuICAgICAgICBjdHguYXJjVG8oeCwgeSwgeCArIHJhZGlpWzBdLCB5LCByYWRpaVswXSk7XG4gICAgfVxufVxuLyoqXG4gKiBEcmF3cyBhIHJvdW5kZWQgcmVjdCB3aXRoIGEgYm9yZGVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZSBjb2xvcnMgd2lsbCBiZSBzb2xpZCwgd2l0aG91dFxuICogYW55IGFscGhhLiAoVGhpcyBhbGxvd3MgdXMgdG8gZml4IGEgcmVuZGVyaW5nIGFydGVmYWN0LilcbiAqXG4gKiBAcGFyYW0gb3V0ZXJCb3JkZXJSYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBib3JkZXIgKG91dGVyIGVkZ2UpXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5mdW5jdGlvbiBkcmF3Um91bmRSZWN0V2l0aEJvcmRlcihjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZENvbG9yLCBib3JkZXJXaWR0aCA9IDAsIG91dGVyQm9yZGVyUmFkaXVzID0gWzAsIDAsIDAsIDBdLCBib3JkZXJDb2xvciA9ICcnKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoIWJvcmRlcldpZHRoIHx8ICFib3JkZXJDb2xvciB8fCBib3JkZXJDb2xvciA9PT0gYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGRyYXdSb3VuZFJlY3QoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIG91dGVyQm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgY29uc3QgcmFkaWkgPSBjaGFuZ2VCb3JkZXJSYWRpdXMob3V0ZXJCb3JkZXJSYWRpdXMsIC1oYWxmQm9yZGVyV2lkdGgpO1xuICAgIGRyYXdSb3VuZFJlY3QoY3R4LCBsZWZ0ICsgaGFsZkJvcmRlcldpZHRoLCB0b3AgKyBoYWxmQm9yZGVyV2lkdGgsIHdpZHRoIC0gYm9yZGVyV2lkdGgsIGhlaWdodCAtIGJvcmRlcldpZHRoLCByYWRpaSk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyQ29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gY2xlYXJSZWN0V2l0aEdyYWRpZW50KGN0eCwgeCwgeSwgdywgaCwgdG9wQ29sb3IsIGJvdHRvbUNvbG9yKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGgpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0b3BDb2xvcik7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGJvdHRvbUNvbG9yKTtcbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5cbmNsYXNzIFByaWNlQXhpc1ZpZXdSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgY29tbW9uRGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEsIGNvbW1vbkRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhLCBjb21tb25EYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhID0gY29tbW9uRGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHVzZVNlY29uZExpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcCArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMsIHRleHRXaWR0aENhY2hlLCBhbGlnbikge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGUgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gc2NvcGUuY29udGV4dDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgY29uc3QgZ2VvbSA9IHRoaXMuX3ByaXZhdGVfX2NhbGN1bGF0ZUdlb21ldHJ5KHNjb3BlLCByZW5kZXJlck9wdGlvbnMsIHRleHRXaWR0aENhY2hlLCBhbGlnbik7XG4gICAgICAgICAgICBjb25zdCBnYiA9IGdlb20uX2ludGVybmFsX2JpdG1hcDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgZHJhdyBsYWJlbC4gYmFja2dyb3VuZENvbG9yIHdpbGwgYWx3YXlzIGJlIGEgc29saWQgY29sb3IgKG5vIGFscGhhKSBbc2VlIGdlbmVyYXRlQ29udHJhc3RDb2xvcnMgaW4gY29sb3IudHNdLlxuICAgICAgICAgICAgIFRoZXJlZm9yZSB3ZSBjYW4gZHJhdyB0aGUgcm91bmRlZCBsYWJlbCB1c2luZyBzaW1wbGlmaWVkIGNvZGUgKGRyYXdSb3VuZFJlY3RXaXRoQm9yZGVyKSB0aGF0IGRvZXNuJ3QgbmVlZCB0byBlbnN1cmUgdGhlIGJhY2tncm91bmQgYW5kIHRoZSBib3JkZXIgZG9uJ3Qgb3ZlcmxhcC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZ2VvbS5faW50ZXJuYWxfYWxpZ25SaWdodCkge1xuICAgICAgICAgICAgICAgIGRyYXdSb3VuZFJlY3RXaXRoQm9yZGVyKGN0eCwgZ2IuX2ludGVybmFsX3hPdXRzaWRlLCBnYi5faW50ZXJuYWxfeVRvcCwgZ2IuX2ludGVybmFsX3RvdGFsV2lkdGgsIGdiLl9pbnRlcm5hbF90b3RhbEhlaWdodCwgYmFja2dyb3VuZENvbG9yLCBnYi5faW50ZXJuYWxfaG9yekJvcmRlciwgW2diLl9pbnRlcm5hbF9yYWRpdXMsIDAsIDAsIGdiLl9pbnRlcm5hbF9yYWRpdXNdLCBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhd1JvdW5kUmVjdFdpdGhCb3JkZXIoY3R4LCBnYi5faW50ZXJuYWxfeEluc2lkZSwgZ2IuX2ludGVybmFsX3lUb3AsIGdiLl9pbnRlcm5hbF90b3RhbFdpZHRoLCBnYi5faW50ZXJuYWxfdG90YWxIZWlnaHQsIGJhY2tncm91bmRDb2xvciwgZ2IuX2ludGVybmFsX2hvcnpCb3JkZXIsIFswLCBnYi5faW50ZXJuYWxfcmFkaXVzLCBnYi5faW50ZXJuYWxfcmFkaXVzLCAwXSwgYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgdGlja1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZ2IuX2ludGVybmFsX3hJbnNpZGUsIGdiLl9pbnRlcm5hbF95TWlkLCBnYi5faW50ZXJuYWxfeFRpY2sgLSBnYi5faW50ZXJuYWxfeEluc2lkZSwgZ2IuX2ludGVybmFsX3RpY2tIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZHJhdyBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFuZUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZ2VvbS5faW50ZXJuYWxfYWxpZ25SaWdodCA/IGdiLl9pbnRlcm5hbF9yaWdodCAtIGdiLl9pbnRlcm5hbF9ob3J6Qm9yZGVyIDogMCwgZ2IuX2ludGVybmFsX3lUb3AsIGdiLl9pbnRlcm5hbF9ob3J6Qm9yZGVyLCBnYi5faW50ZXJuYWxfeUJvdHRvbSAtIGdiLl9pbnRlcm5hbF95VG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZW9tO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnbSA9IGdlb21ldHJ5Ll9pbnRlcm5hbF9tZWRpYTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IGdlb21ldHJ5Ll9pbnRlcm5hbF9hbGlnblJpZ2h0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dCwgZ20uX2ludGVybmFsX3hUZXh0LCAoZ20uX2ludGVybmFsX3lUb3AgKyBnbS5faW50ZXJuYWxfeUJvdHRvbSkgLyAyICsgZ20uX2ludGVybmFsX3RleHRNaWRDb3JyZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jYWxjdWxhdGVHZW9tZXRyeShzY29wZSwgcmVuZGVyZXJPcHRpb25zLCB0ZXh0V2lkdGhDYWNoZSwgYWxpZ24pIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIG1lZGlhU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gc2NvcGU7XG4gICAgICAgIGNvbnN0IHRpY2tTaXplID0gKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlIHx8ICF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9tb3ZlVGV4dFRvSW52aXNpYmxlVGljaykgPyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggOiAwO1xuICAgICAgICBjb25zdCBob3J6Qm9yZGVyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfc2VwYXJhdG9yVmlzaWJsZSA/IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSA6IDA7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgKyB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ1RvcDtcbiAgICAgICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSArIHRoaXMuX3ByaXZhdGVfX2NvbW1vbkRhdGEuX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nQm90dG9tO1xuICAgICAgICBjb25zdCBwYWRkaW5nSW5uZXIgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdJbm5lcjtcbiAgICAgICAgY29uc3QgcGFkZGluZ091dGVyID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nT3V0ZXI7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90ZXh0O1xuICAgICAgICBjb25zdCBhY3R1YWxUZXh0SGVpZ2h0ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZTtcbiAgICAgICAgY29uc3QgdGV4dE1pZENvcnJlY3Rpb24gPSB0ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCB0ZXh0KTtcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gTWF0aC5jZWlsKHRleHRXaWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRleHQpKTtcbiAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSBhY3R1YWxUZXh0SGVpZ2h0ICsgcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgKyBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKyB0ZXh0V2lkdGggKyB0aWNrU2l6ZTtcbiAgICAgICAgY29uc3QgdGlja0hlaWdodEJpdG1hcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGxldCB0b3RhbEhlaWdodEJpdG1hcCA9IE1hdGgucm91bmQodG90YWxIZWlnaHQgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBpZiAodG90YWxIZWlnaHRCaXRtYXAgJSAyICE9PSB0aWNrSGVpZ2h0Qml0bWFwICUgMikge1xuICAgICAgICAgICAgdG90YWxIZWlnaHRCaXRtYXAgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3J6Qm9yZGVyQml0bWFwID0gaG9yekJvcmRlciA+IDAgPyBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcnpCb3JkZXIgKiBob3Jpem9udGFsUGl4ZWxSYXRpbykpIDogMDtcbiAgICAgICAgY29uc3QgdG90YWxXaWR0aEJpdG1hcCA9IE1hdGgucm91bmQodG90YWxXaWR0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gdGljayBvdmVybGFwcyBzY2FsZSBib3JkZXJcbiAgICAgICAgY29uc3QgdGlja1NpemVCaXRtYXAgPSBNYXRoLnJvdW5kKHRpY2tTaXplICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCB5TWlkID0gdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfZml4ZWRDb29yZGluYXRlID8/IHRoaXMuX3ByaXZhdGVfX2NvbW1vbkRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGNvbnN0IHlNaWRCaXRtYXAgPSBNYXRoLnJvdW5kKHlNaWQgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pIC0gTWF0aC5mbG9vcih2ZXJ0aWNhbFBpeGVsUmF0aW8gKiAwLjUpO1xuICAgICAgICBjb25zdCB5VG9wQml0bWFwID0gTWF0aC5mbG9vcih5TWlkQml0bWFwICsgdGlja0hlaWdodEJpdG1hcCAvIDIgLSB0b3RhbEhlaWdodEJpdG1hcCAvIDIpO1xuICAgICAgICBjb25zdCB5Qm90dG9tQml0bWFwID0geVRvcEJpdG1hcCArIHRvdGFsSGVpZ2h0Qml0bWFwO1xuICAgICAgICBjb25zdCBhbGlnblJpZ2h0ID0gYWxpZ24gPT09ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IHhJbnNpZGUgPSBhbGlnblJpZ2h0ID8gbWVkaWFTaXplLndpZHRoIC0gaG9yekJvcmRlciA6IGhvcnpCb3JkZXI7XG4gICAgICAgIGNvbnN0IHhJbnNpZGVCaXRtYXAgPSBhbGlnblJpZ2h0ID8gYml0bWFwU2l6ZS53aWR0aCAtIGhvcnpCb3JkZXJCaXRtYXAgOiBob3J6Qm9yZGVyQml0bWFwO1xuICAgICAgICBsZXQgeE91dHNpZGVCaXRtYXA7XG4gICAgICAgIGxldCB4VGlja0JpdG1hcDtcbiAgICAgICAgbGV0IHhUZXh0O1xuICAgICAgICBpZiAoYWxpZ25SaWdodCkge1xuICAgICAgICAgICAgLy8gMiAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgNiAgNVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDMgICAgICAgICAgICAgICA0XG4gICAgICAgICAgICB4T3V0c2lkZUJpdG1hcCA9IHhJbnNpZGVCaXRtYXAgLSB0b3RhbFdpZHRoQml0bWFwO1xuICAgICAgICAgICAgeFRpY2tCaXRtYXAgPSB4SW5zaWRlQml0bWFwIC0gdGlja1NpemVCaXRtYXA7XG4gICAgICAgICAgICB4VGV4dCA9IHhJbnNpZGUgLSB0aWNrU2l6ZSAtIHBhZGRpbmdJbm5lciAtIGhvcnpCb3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAxICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDYgIDVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA0ICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgeE91dHNpZGVCaXRtYXAgPSB4SW5zaWRlQml0bWFwICsgdG90YWxXaWR0aEJpdG1hcDtcbiAgICAgICAgICAgIHhUaWNrQml0bWFwID0geEluc2lkZUJpdG1hcCArIHRpY2tTaXplQml0bWFwO1xuICAgICAgICAgICAgeFRleHQgPSB4SW5zaWRlICsgdGlja1NpemUgKyBwYWRkaW5nSW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hbGlnblJpZ2h0OiBhbGlnblJpZ2h0LFxuICAgICAgICAgICAgX2ludGVybmFsX2JpdG1hcDoge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95VG9wOiB5VG9wQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95TWlkOiB5TWlkQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95Qm90dG9tOiB5Qm90dG9tQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90b3RhbFdpZHRoOiB0b3RhbFdpZHRoQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90b3RhbEhlaWdodDogdG90YWxIZWlnaHRCaXRtYXAsXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXQgaXMgYmV0dGVyIHRvIGhhdmUgZGlmZmVyZW50IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHJhZGlpXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3JhZGl1czogMiAqIGhvcml6b250YWxQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6Qm9yZGVyOiBob3J6Qm9yZGVyQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94T3V0c2lkZTogeE91dHNpZGVCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3hJbnNpZGU6IHhJbnNpZGVCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3hUaWNrOiB4VGlja0JpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGlja0hlaWdodDogdGlja0hlaWdodEJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcmlnaHQ6IGJpdG1hcFNpemUud2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ludGVybmFsX21lZGlhOiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3lUb3A6IHlUb3BCaXRtYXAgLyB2ZXJ0aWNhbFBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3lCb3R0b206IHlCb3R0b21CaXRtYXAgLyB2ZXJ0aWNhbFBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3hUZXh0OiB4VGV4dCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGV4dE1pZENvcnJlY3Rpb246IHRleHRNaWRDb3JyZWN0aW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGN0b3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Nvb3JkaW5hdGU6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFja2dyb3VuZDogJyMwMDAnLFxuICAgICAgICAgICAgX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nQm90dG9tOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nVG9wOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3RleHQ6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpY2tWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdmVUZXh0VG9JbnZpc2libGVUaWNrOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXBhcmF0b3JWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aWNrVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW92ZVRleHRUb0ludmlzaWJsZVRpY2s6IHRydWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnI0ZGRicsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXBhcmF0b3JWaXNpYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlciA9IG5ldyAoY3RvciB8fCBQcmljZUF4aXNWaWV3UmVuZGVyZXIpKHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlciA9IG5ldyAoY3RvciB8fCBQcmljZUF4aXNWaWV3UmVuZGVyZXIpKHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90ZXh0KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Nvb3JkaW5hdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHVzZVNlY29uZExpbmUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyLl9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCB1c2VTZWNvbmRMaW5lKSwgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyLl9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCB1c2VTZWNvbmRMaW5lKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSB8fCAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfZml4ZWRDb29yZGluYXRlID0gdmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc1Zpc2libGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlIHx8IHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0F4aXNMYWJlbFZpc2libGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIocHJpY2VTY2FsZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICAvLyBmb3JjZSB1cGRhdGUgdGlja1Zpc2libGUgc3RhdGUgZnJvbSBwcmljZSBzY2FsZSBvcHRpb25zXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbmQgd2UgY2FuJ3QgaGF2ZSBwcmljZSBheGlzIGluIG90aGVyIG1ldGhvZHNcbiAgICAgICAgLy8gKGxpa2UgcGFuZVJlbmRlcmVyIG9yIGFueSBvdGhlciB3aG8gY2FsbCBfdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQpXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgJiYgcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLnRpY2tzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSAmJiBwcmljZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkudGlja3NWaXNpYmxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lUmVuZGVyZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fdXBkYXRlUmVuZGVyZXJEYXRhKHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENyb3NzaGFpclByaWNlQXhpc1ZpZXcgZXh0ZW5kcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHByaWNlU2NhbGUsIHZhbHVlUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmFsdWVQcm92aWRlciA9IHZhbHVlUHJvdmlkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlUmVuZGVyZXJEYXRhKGF4aXNSZW5kZXJlckRhdGEsIHBhbmVSZW5kZXJlckRhdGEsIGNvbW1vblJlbmRlcmVyRGF0YSkge1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX29wdGlvbnMoKS5tb2RlID09PSAyIC8qIENyb3NzaGFpck1vZGUuSGlkZGVuICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfb3B0aW9ucygpLmhvcnpMaW5lO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGFiZWxWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3Zpc2libGUoKSB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgKGZpcnN0VmFsdWUgPT09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfY29sb3JQYXJzZXIoKS5faW50ZXJuYWxfZ2VuZXJhdGVDb250cmFzdENvbG9ycyhvcHRpb25zLmxhYmVsQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kID0gY29sb3JzLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFBhZGRpbmcgPSAyIC8gMTIgKiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb250U2l6ZSgpO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nVG9wID0gYWRkaXRpb25hbFBhZGRpbmc7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdCb3R0b20gPSBhZGRpdGlvbmFsUGFkZGluZztcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9wcml2YXRlX192YWx1ZVByb3ZpZGVyKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUpO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSB2YWx1ZS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlKHZhbHVlLl9pbnRlcm5hbF9wcmljZSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgIH1cbn1cblxuY29uc3Qgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSA9IC9bMS05XS9nO1xuY29uc3QgcmFkaXVzJDEgPSAyO1xuY2xhc3MgVGltZUF4aXNWaWV3UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF93aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZGF0YSkuX2ludGVybmFsX3RleHQsIG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZXh0V2lkdGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvcnpNYXJnaW4gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdIb3Jpem9udGFsO1xuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGV4dFdpZHRoICsgMiAqIGhvcnpNYXJnaW47XG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGhIYWxmID0gbGFiZWxXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZVdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfd2lkdGg7XG4gICAgICAgIGxldCBjb29yZGluYXRlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5mbG9vcihjb29yZGluYXRlIC0gbGFiZWxXaWR0aEhhbGYpICsgMC41O1xuICAgICAgICBpZiAoeDEgPCAwKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZSArIE1hdGguYWJzKDAgLSB4MSk7XG4gICAgICAgICAgICB4MSA9IE1hdGguZmxvb3IoY29vcmRpbmF0ZSAtIGxhYmVsV2lkdGhIYWxmKSArIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4MSArIGxhYmVsV2lkdGggPiB0aW1lU2NhbGVXaWR0aCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgLSBNYXRoLmFicyh0aW1lU2NhbGVXaWR0aCAtICh4MSArIGxhYmVsV2lkdGgpKTtcbiAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcihjb29yZGluYXRlIC0gbGFiZWxXaWR0aEhhbGYpICsgMC41O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHgyID0geDEgKyBsYWJlbFdpZHRoO1xuICAgICAgICBjb25zdCB5MSA9IDA7XG4gICAgICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKHkxICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZGF0YSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgICAgIGNvbnN0IHgxc2NhbGVkID0gTWF0aC5yb3VuZCh4MSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IHkxc2NhbGVkID0gTWF0aC5yb3VuZCh5MSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCB4MnNjYWxlZCA9IE1hdGgucm91bmQoeDIgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCB5MnNjYWxlZCA9IE1hdGgucm91bmQoeTIgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzU2NhbGVkID0gTWF0aC5yb3VuZChyYWRpdXMkMSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDFzY2FsZWQsIHkxc2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDFzY2FsZWQsIHkyc2NhbGVkIC0gcmFkaXVzU2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5hcmNUbyh4MXNjYWxlZCwgeTJzY2FsZWQsIHgxc2NhbGVkICsgcmFkaXVzU2NhbGVkLCB5MnNjYWxlZCwgcmFkaXVzU2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDJzY2FsZWQgLSByYWRpdXNTY2FsZWQsIHkyc2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5hcmNUbyh4MnNjYWxlZCwgeTJzY2FsZWQsIHgyc2NhbGVkLCB5MnNjYWxlZCAtIHJhZGl1c1NjYWxlZCwgcmFkaXVzU2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDJzY2FsZWQsIHkxc2NhbGVkKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBpZiAoZGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrWCA9IE1hdGgucm91bmQoZGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrVG9wID0geTFzY2FsZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0JvdHRvbSA9IE1hdGgucm91bmQoKHRpY2tUb3AgKyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGgpICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja1dpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tPZmZzZXQgPSBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvICogMC41KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGlja1ggLSB0aWNrT2Zmc2V0LCB0aWNrVG9wLCB0aWNrV2lkdGgsIHRpY2tCb3R0b20gLSB0aWNrVG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB5VGV4dCA9IHkxICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplIC8gMjtcbiAgICAgICAgICAgIGN0eC5mb250ID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IHRleHRZQ29ycmVjdGlvbiA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfd2lkdGhDYWNoZS5faW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCAnQXByMCcpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4MSArIGhvcnpNYXJnaW4sIHlUZXh0ICsgdGV4dFlDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChkYXRhLl9pbnRlcm5hbF90ZXh0LCAwLCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBDcm9zc2hhaXJUaW1lQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNyb3NzaGFpciwgbW9kZWwsIHZhbHVlUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlciA9IG5ldyBUaW1lQXhpc1ZpZXdSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFja2dyb3VuZDogJyM0YzUyNWUnLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgX2ludGVybmFsX3RleHQ6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX3dpZHRoOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2Nvb3JkaW5hdGU6IE5hTixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aWNrVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyID0gY3Jvc3NoYWlyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192YWx1ZVByb3ZpZGVyID0gdmFsdWVQcm92aWRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh0aGlzLl9wcml2YXRlX19yZW5kZXJlckRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVJbXBsKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX29wdGlvbnMoKS5tb2RlID09PSAyIC8qIENyb3NzaGFpck1vZGUuSGlkZGVuICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3B0aW9ucygpLnZlcnRMaW5lO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGFiZWxWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF93aWR0aCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfd2lkdGgoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9wcml2YXRlX192YWx1ZVByb3ZpZGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSB2YWx1ZS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludCh0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRJbmRleCgpKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdGV4dCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfZm9ybWF0RGF0ZVRpbWUoZW5zdXJlTm90TnVsbChjdXJyZW50VGltZSkpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkuX2ludGVybmFsX2dlbmVyYXRlQ29udHJhc3RDb2xvcnMob3B0aW9ucy5sYWJlbEJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2JhY2tncm91bmQgPSBjb2xvcnMuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2NvbG9yID0gY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IHRpbWVTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLnRpY2tzVmlzaWJsZTtcbiAgICB9XG59XG5cbmNsYXNzIERhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3pvcmRlciA9IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF96b3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX196b3JkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRab3JkZXIoem9yZGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3pvcmRlciA9IHpvcmRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFByaWNlU2NhbGUocHJpY2VTY2FsZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sYWJlbFBhbmVWaWV3cyhwYW5lKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjcm9zc2hhaXIgbW9kZS5cbiAqL1xudmFyIENyb3NzaGFpck1vZGU7XG4oZnVuY3Rpb24gKENyb3NzaGFpck1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgYWxsb3dzIGNyb3NzaGFpciB0byBtb3ZlIGZyZWVseSBvbiB0aGUgY2hhcnQuXG4gICAgICovXG4gICAgQ3Jvc3NoYWlyTW9kZVtDcm9zc2hhaXJNb2RlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kZSBzdGlja3MgY3Jvc3NoYWlyJ3MgaG9yaXpvbnRhbCBsaW5lIHRvIHRoZSBwcmljZSB2YWx1ZSBvZiBhIHNpbmdsZS12YWx1ZSBzZXJpZXMgb3IgdG8gdGhlIGNsb3NlIHByaWNlIG9mIE9ITEMtYmFzZWQgc2VyaWVzLlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIk1hZ25ldFwiXSA9IDFdID0gXCJNYWduZXRcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgZGlzYWJsZXMgcmVuZGVyaW5nIG9mIHRoZSBjcm9zc2hhaXIuXG4gICAgICovXG4gICAgQ3Jvc3NoYWlyTW9kZVtDcm9zc2hhaXJNb2RlW1wiSGlkZGVuXCJdID0gMl0gPSBcIkhpZGRlblwiO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kZSBzdGlja3MgY3Jvc3NoYWlyJ3MgaG9yaXpvbnRhbCBsaW5lIHRvIHRoZSBwcmljZSB2YWx1ZSBvZiBhIHNpbmdsZS12YWx1ZSBzZXJpZXMgb3IgdG8gdGhlIG9wZW4vaGlnaC9sb3cvY2xvc2UgcHJpY2Ugb2YgT0hMQy1iYXNlZCBzZXJpZXMuXG4gICAgICovXG4gICAgQ3Jvc3NoYWlyTW9kZVtDcm9zc2hhaXJNb2RlW1wiTWFnbmV0T0hMQ1wiXSA9IDNdID0gXCJNYWduZXRPSExDXCI7XG59KShDcm9zc2hhaXJNb2RlIHx8IChDcm9zc2hhaXJNb2RlID0ge30pKTtcbmNsYXNzIENyb3NzaGFpciBleHRlbmRzIERhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlID0gZmFsc2U7IC8vIGluaXRpYWxseSB0aGUgY3Jvc3NoYWlyIHNob3VsZCBub3QgYmUgdmlzaWJsZSwgdW50aWwgdGhlIHVzZXIgaW50ZXJhY3RzLlxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJQYW5lVmlld0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX194ID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5ZID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdmFsdWVQcmljZVByb3ZpZGVyID0gKHJhd1ByaWNlUHJvdmlkZXIsIHJhd0Nvb3JkaW5hdGVQcm92aWRlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChwcmljZVNjYWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHJhd0Nvb3JkaW5hdGVQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ByaWNlID0gcmF3UHJpY2VQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVNjYWxlID09PSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3BhbmUpLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaWNlIG11c3QgYmUgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfcHJpY2U6IHJhd1ByaWNlLCBfaW50ZXJuYWxfY29vcmRpbmF0ZTogY29vcmRpbmF0ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIGNvbnZlcnQgZnJvbSBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBlbnN1cmVOb3ROdWxsKHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UoY29vcmRpbmF0ZSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9wcmljZTogcHJpY2UsIF9pbnRlcm5hbF9jb29yZGluYXRlOiBjb29yZGluYXRlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsdWVUaW1lUHJvdmlkZXIgPSAocmF3SW5kZXhQcm92aWRlciwgcmF3Q29vcmRpbmF0ZVByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2luZGV4VG9UaW1lKHJhd0luZGV4UHJvdmlkZXIoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHJhd0Nvb3JkaW5hdGVQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGltZSB8fCAhTnVtYmVyLmlzRmluaXRlKGNvb3JkaW5hdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2Nvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBjdXJyZW50IHBvc2l0aW9uIGFsd2F5cyByZXR1cm4gYm90aCBwcmljZSBhbmQgY29vcmRpbmF0ZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jdXJyZW50UG9zUHJpY2VQcm92aWRlciA9IHZhbHVlUHJpY2VQcm92aWRlcigoKSA9PiB0aGlzLl9wcml2YXRlX19wcmljZSwgKCkgPT4gdGhpcy5fcHJpdmF0ZV9feSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb3NUaW1lUHJvdmlkZXIgPSB2YWx1ZVRpbWVQcm92aWRlcigoKSA9PiB0aGlzLl9wcml2YXRlX19pbmRleCwgKCkgPT4gdGhpcy5faW50ZXJuYWxfYXBwbGllZFgoKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzVmlldyA9IG5ldyBDcm9zc2hhaXJUaW1lQXhpc1ZpZXcodGhpcywgbW9kZWwsIGN1cnJlbnRQb3NUaW1lUHJvdmlkZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zYXZlT3JpZ2luQ29vcmQoeCwgeSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0geDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWSA9IHk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbGVhck9yaWdpbkNvb3JkKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5YID0gTmFOO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcmlnaW5ZID0gTmFOO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3JpZ2luQ29vcmRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWDtcbiAgICB9XG4gICAgX2ludGVybmFsX29yaWdpbkNvb3JkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29yaWdpblk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQb3NpdGlvbihpbmRleCwgcHJpY2UsIHBhbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyhpbmRleCwgcHJpY2UsIHBhbmUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbGllZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faW5kZXg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBsaWVkWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3g7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBsaWVkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3k7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0SW5kZXhUb0xhc3RTZXJpZXNCYXJJbmRleCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2NsZWFyT3JpZ2luQ29vcmQoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVWaWV3cyhwYW5lKSB7XG4gICAgICAgIGxldCBjcm9zc2hhaXJQYW5lVmlldyA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpclBhbmVWaWV3Q2FjaGUuZ2V0KHBhbmUpO1xuICAgICAgICBpZiAoIWNyb3NzaGFpclBhbmVWaWV3KSB7XG4gICAgICAgICAgICBjcm9zc2hhaXJQYW5lVmlldyA9IG5ldyBDcm9zc2hhaXJQYW5lVmlldyh0aGlzLCBwYW5lKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpclBhbmVWaWV3Q2FjaGUuc2V0KHBhbmUsIGNyb3NzaGFpclBhbmVWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2Vyc1BhbmVWaWV3ID0gdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3Q2FjaGUuZ2V0KHBhbmUpO1xuICAgICAgICBpZiAoIW1hcmtlcnNQYW5lVmlldykge1xuICAgICAgICAgICAgbWFya2Vyc1BhbmVWaWV3ID0gbmV3IENyb3NzaGFpck1hcmtzUGFuZVZpZXcodGhpcy5fcHJpdmF0ZV9fbW9kZWwsIHRoaXMsIHBhbmUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3Q2FjaGUuc2V0KHBhbmUsIG1hcmtlcnNQYW5lVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjcm9zc2hhaXJQYW5lVmlldywgbWFya2Vyc1BhbmVWaWV3XTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hvcnpMaW5lVmlzaWJsZShwYW5lKSB7XG4gICAgICAgIHJldHVybiBwYW5lID09PSB0aGlzLl9wcml2YXRlX19wYW5lICYmIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaG9yekxpbmUudmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ZlcnRMaW5lVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudmVydExpbmUudmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX192aXNpYmxlIHx8IHRoaXMuX3ByaXZhdGVfX3BhbmUgIT09IHBhbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3MgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmUgPT09IHBhbmUpIHtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godGhpcy5fcHJpdmF0ZV9fY3JlYXRlUHJpY2VBeGlzVmlld09uRGVtYW5kKHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzLCBwcmljZVNjYWxlLCB0aGlzLl9wcml2YXRlX19jdXJyZW50UG9zUHJpY2VQcm92aWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX192aXNpYmxlID8gW3RoaXMuX3ByaXZhdGVfX3RpbWVBeGlzVmlld10gOiBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9wYW5lcygpLmZvckVhY2goKHBhbmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpclBhbmVWaWV3Q2FjaGUuZ2V0KHBhbmUpPy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUGFuZVZpZXdDYWNoZS5nZXQocGFuZSk/Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzLmZvckVhY2goKHZhbHVlKSA9PiB2YWx1ZS5faW50ZXJuYWxfdXBkYXRlKCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJpY2VTY2FsZUJ5UGFuZShwYW5lKSB7XG4gICAgICAgIGlmIChwYW5lICYmICFwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyhpbmRleCwgcHJpY2UsIHBhbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RyeVRvVXBkYXRlRGF0YShpbmRleCwgcHJpY2UsIHBhbmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX190cnlUb1VwZGF0ZURhdGEobmV3SW5kZXgsIG5ld1ByaWNlLCBuZXdQYW5lKSB7XG4gICAgICAgIGNvbnN0IG9sZFggPSB0aGlzLl9wcml2YXRlX194O1xuICAgICAgICBjb25zdCBvbGRZID0gdGhpcy5fcHJpdmF0ZV9feTtcbiAgICAgICAgY29uc3Qgb2xkUHJpY2UgPSB0aGlzLl9wcml2YXRlX19wcmljZTtcbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLl9wcml2YXRlX19pbmRleDtcbiAgICAgICAgY29uc3Qgb2xkUGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmU7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlQnlQYW5lKG5ld1BhbmUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX194ID0gaXNOYU4obmV3SW5kZXgpID8gTmFOIDogdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pbmRleFRvQ29vcmRpbmF0ZShuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBuZXdQYW5lO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJpY2VTY2FsZSAhPT0gbnVsbCA/IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSA6IG51bGw7XG4gICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsICYmIGZpcnN0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlID0gbmV3UHJpY2U7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUobmV3UHJpY2UsIGZpcnN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2UgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX195ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob2xkWCAhPT0gdGhpcy5fcHJpdmF0ZV9feCB8fCBvbGRZICE9PSB0aGlzLl9wcml2YXRlX195IHx8IG9sZEluZGV4ICE9PSB0aGlzLl9wcml2YXRlX19pbmRleCB8fFxuICAgICAgICAgICAgb2xkUHJpY2UgIT09IHRoaXMuX3ByaXZhdGVfX3ByaWNlIHx8IG9sZFBhbmUgIT09IHRoaXMuX3ByaXZhdGVfX3BhbmUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0SW5kZXhUb0xhc3RTZXJpZXNCYXJJbmRleCgpIHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2VyaWVzZXMoKVxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9sYXN0SW5kZXgoKSlcbiAgICAgICAgICAgIC5maWx0ZXIobm90TnVsbCk7XG4gICAgICAgIGNvbnN0IGxhc3RCYXJJbmRleCA9IChsYXN0SW5kZXhlcy5sZW5ndGggPT09IDApID8gbnVsbCA6IE1hdGgubWF4KC4uLmxhc3RJbmRleGVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXggPSBsYXN0QmFySW5kZXggIT09IG51bGwgPyBsYXN0QmFySW5kZXggOiBOYU47XG4gICAgfVxuICAgIF9wcml2YXRlX19jcmVhdGVQcmljZUF4aXNWaWV3T25EZW1hbmQobWFwLCBwcmljZVNjYWxlLCB2YWx1ZVByb3ZpZGVyKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbWFwLmdldChwcmljZVNjYWxlKTtcbiAgICAgICAgaWYgKHZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmlldyA9IG5ldyBDcm9zc2hhaXJQcmljZUF4aXNWaWV3KHRoaXMsIHByaWNlU2NhbGUsIHZhbHVlUHJvdmlkZXIpO1xuICAgICAgICAgICAgbWFwLnNldChwcmljZVNjYWxlLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByaWNlU2NhbGUocHJpY2VTY2FsZUlkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgcmV0dXJuIHByaWNlU2NhbGVJZCA9PT0gXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovIHx8IHByaWNlU2NhbGVJZCA9PT0gXCJyaWdodFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuUmlnaHQgKi87XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFuZUludmFsaWRhdGlvbihiZWZvcmVWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYmVmb3JlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gTWF0aC5tYXgoYmVmb3JlVmFsdWUuX2ludGVybmFsX2xldmVsLCBuZXdWYWx1ZS5faW50ZXJuYWxfbGV2ZWwpO1xuICAgIGNvbnN0IGF1dG9TY2FsZSA9IGJlZm9yZVZhbHVlLl9pbnRlcm5hbF9hdXRvU2NhbGUgfHwgbmV3VmFsdWUuX2ludGVybmFsX2F1dG9TY2FsZTtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfbGV2ZWw6IGxldmVsLCBfaW50ZXJuYWxfYXV0b1NjYWxlOiBhdXRvU2NhbGUgfTtcbn1cbmNsYXNzIEludmFsaWRhdGVNYXNrIHtcbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxMZXZlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsID0gZ2xvYmFsTGV2ZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZShwYW5lSW5kZXgsIGludmFsaWRhdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLmdldChwYW5lSW5kZXgpO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1lcmdlUGFuZUludmFsaWRhdGlvbihwcmV2VmFsdWUsIGludmFsaWRhdGlvbik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkUGFuZXMuc2V0KHBhbmVJbmRleCwgbmV3VmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZnVsbEludmFsaWRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUocGFuZUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhbmVJbnZhbGlkYXRpb24gPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLmdldChwYW5lSW5kZXgpO1xuICAgICAgICBpZiAocGFuZUludmFsaWRhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sZXZlbDogdGhpcy5fcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGV2ZWw6IE1hdGgubWF4KHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsLCBwYW5lSW52YWxpZGF0aW9uLl9pbnRlcm5hbF9sZXZlbCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiBwYW5lSW52YWxpZGF0aW9uLl9pbnRlcm5hbF9hdXRvU2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRGaXRDb250ZW50KCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDAgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5GaXRDb250ZW50ICovIH1dO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDEgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJhbmdlICovLCBfaW50ZXJuYWxfdmFsdWU6IHJhbmdlIH1dO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW1vdmVUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucy5wdXNoKHsgX2ludGVybmFsX3R5cGU6IDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi8sIF9pbnRlcm5hbF92YWx1ZTogYW5pbWF0aW9uIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMucHVzaCh7IF9pbnRlcm5hbF90eXBlOiA2IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuU3RvcEFuaW1hdGlvbiAqLyB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2V0VGltZVNjYWxlKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIG1vZGlmaWVzIGJvdGggYmFyIHNwYWNpbmcgYW5kIHJpZ2h0IG9mZnNldFxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zID0gW3sgX2ludGVybmFsX3R5cGU6IDQgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5SZXNldCAqLyB9XTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcoYmFyU3BhY2luZykge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMucHVzaCh7IF9pbnRlcm5hbF90eXBlOiAyIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlCYXJTcGFjaW5nICovLCBfaW50ZXJuYWxfdmFsdWU6IGJhclNwYWNpbmcgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnB1c2goeyBfaW50ZXJuYWxfdHlwZTogMyAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmlnaHRPZmZzZXQgKi8sIF9pbnRlcm5hbF92YWx1ZTogb2Zmc2V0IH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVNjYWxlSW52YWxpZGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IHRzSW52YWxpZGF0aW9uIG9mIG90aGVyLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbih0c0ludmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwgPSBNYXRoLm1heCh0aGlzLl9wcml2YXRlX19nbG9iYWxMZXZlbCwgb3RoZXIuX3ByaXZhdGVfX2dsb2JhbExldmVsKTtcbiAgICAgICAgb3RoZXIuX3ByaXZhdGVfX2ludmFsaWRhdGVkUGFuZXMuZm9yRWFjaCgoaW52YWxpZGF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfaW52YWxpZGF0ZVBhbmUoaW5kZXgsIGludmFsaWRhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2xpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRhdGVNYXNrKDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2Z1bGwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52YWxpZGF0ZU1hc2soMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9uKGludmFsaWRhdGlvbikge1xuICAgICAgICBzd2l0Y2ggKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuRml0Q29udGVudCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRGaXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJhbmdlICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2FwcGx5UmFuZ2UoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseUJhclNwYWNpbmcgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmlnaHRPZmZzZXQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5SZXNldCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbihpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNiAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLlN0b3BBbmltYXRpb24gKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlbW92ZVRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLmZpbmRJbmRleCgoaW52KSA9PiBpbnYuX2ludGVybmFsX3R5cGUgPT09IDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi8pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgX2ludGVybmFsX2RlY2ltYWxTaWduOiAnLid9O1xuLyoqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9mIGNvbnZlcnQuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aC4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDE2IGluY2x1c2l2ZS5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8odmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnbi9hJztcbiAgICB9XG4gICAgaWYgKCFpc0ludGVnZXIobGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBkdW1teVN0cmluZyA9ICcwMDAwMDAwMDAwMDAwMDAwJztcbiAgICByZXR1cm4gKGR1bW15U3RyaW5nICsgdmFsdWUudG9TdHJpbmcoKSkuc2xpY2UoLWxlbmd0aCk7XG59XG5jbGFzcyBQcmljZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocHJpY2VTY2FsZSwgbWluTW92ZSkge1xuICAgICAgICBpZiAoIW1pbk1vdmUpIHtcbiAgICAgICAgICAgIG1pbk1vdmUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdW1iZXIocHJpY2VTY2FsZSkgfHwgIWlzSW50ZWdlcihwcmljZVNjYWxlKSkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpY2VTY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5Nb3ZlID0gbWluTW92ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlRGVjaW1hbCgpO1xuICAgIH1cbiAgICBmb3JtYXQocHJpY2UpIHtcbiAgICAgICAgLy8gXFx1MjIxMiBpcyB1bmljb2RlJ3MgbWludXMgc2lnbiBodHRwczovL3d3dy5maWxlZm9ybWF0LmluZm8vaW5mby91bmljb2RlL2NoYXIvMjIxMi9pbmRleC5odG1cbiAgICAgICAgLy8gd2Ugc2hvdWxkIHVzZSBpdCBiZWNhdXNlIGl0IGhhcyB0aGUgc2FtZSB3aWR0aCBhcyBwbHVzIHNpZ24gK1xuICAgICAgICBjb25zdCBzaWduID0gcHJpY2UgPCAwID8gJ1xcdTIyMTInIDogJyc7XG4gICAgICAgIHByaWNlID0gTWF0aC5hYnMocHJpY2UpO1xuICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbChwcmljZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jYWxjdWxhdGVEZWNpbWFsKCkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGlzLl9iYXNlIGlzIHBvd2VyIG9mIDEwXG4gICAgICAgIC8vIGZvciBkb3VibGUgZnJhY3Rpb25hbCBfZnJhY3Rpb25hbExlbmd0aCBpZiBmb3IgdGhlIG1haW4gZnJhY3Rpb25hbCBvbmx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPiAwICYmIHRoaXMuX3ByaXZhdGVfX21pbk1vdmUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgICAgICB3aGlsZSAoYmFzZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBiYXNlIC89IDEwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbChwcmljZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSAvIHRoaXMuX3ByaXZhdGVfX21pbk1vdmU7XG4gICAgICAgIGxldCBpbnRQYXJ0ID0gTWF0aC5mbG9vcihwcmljZSk7XG4gICAgICAgIGxldCBmcmFjU3RyaW5nID0gJyc7XG4gICAgICAgIGNvbnN0IGZyYWNMZW5ndGggPSB0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGggOiBOYU47XG4gICAgICAgIGlmIChiYXNlID4gMSkge1xuICAgICAgICAgICAgbGV0IGZyYWNQYXJ0ID0gKyhNYXRoLnJvdW5kKHByaWNlICogYmFzZSkgLSBpbnRQYXJ0ICogYmFzZSkudG9GaXhlZCh0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZnJhY1BhcnQgPj0gYmFzZSkge1xuICAgICAgICAgICAgICAgIGZyYWNQYXJ0IC09IGJhc2U7XG4gICAgICAgICAgICAgICAgaW50UGFydCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhY1N0cmluZyA9IGZvcm1hdHRlck9wdGlvbnMuX2ludGVybmFsX2RlY2ltYWxTaWduICsgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oK2ZyYWNQYXJ0LnRvRml4ZWQodGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGgpICogdGhpcy5fcHJpdmF0ZV9fbWluTW92ZSwgZnJhY0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgcm91bmQgaW50IHBhcnQgdG8gbWluIG1vdmVcbiAgICAgICAgICAgIGludFBhcnQgPSBNYXRoLnJvdW5kKGludFBhcnQgKiBiYXNlKSAvIGJhc2U7XG4gICAgICAgICAgICAvLyBpZiBtaW4gbW92ZSA+IDEsIGZyYWN0aW9uYWwgcGFydCBpcyBhbHdheXMgPSAwXG4gICAgICAgICAgICBpZiAoZnJhY0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmcmFjU3RyaW5nID0gZm9ybWF0dGVyT3B0aW9ucy5faW50ZXJuYWxfZGVjaW1hbFNpZ24gKyBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybygwLCBmcmFjTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50UGFydC50b0ZpeGVkKDApICsgZnJhY1N0cmluZztcbiAgICB9XG59XG5cbmNsYXNzIFBlcmNlbnRhZ2VGb3JtYXR0ZXIgZXh0ZW5kcyBQcmljZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocHJpY2VTY2FsZSA9IDEwMCkge1xuICAgICAgICBzdXBlcihwcmljZVNjYWxlKTtcbiAgICB9XG4gICAgZm9ybWF0KHByaWNlKSB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci5mb3JtYXQocHJpY2UpfSVgO1xuICAgIH1cbn1cblxuY2xhc3MgVm9sdW1lRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVjaXNpb24pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIH1cbiAgICBmb3JtYXQodm9sKSB7XG4gICAgICAgIGxldCBzaWduID0gJyc7XG4gICAgICAgIGlmICh2b2wgPCAwKSB7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgdm9sID0gLXZvbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm9sIDwgOTk1KSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2b2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZvbCA8IDk5OTk5NSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB0aGlzLl9wcml2YXRlX19mb3JtYXROdW1iZXIodm9sIC8gMTAwMCkgKyAnSyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm9sIDwgOTk5OTk5OTk1KSB7XG4gICAgICAgICAgICB2b2wgPSAxMDAwICogTWF0aC5yb3VuZCh2b2wgLyAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduICsgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TnVtYmVyKHZvbCAvIDEwMDAwMDApICsgJ00nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm9sID0gMTAwMDAwMCAqIE1hdGgucm91bmQodm9sIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2b2wgLyAxMDAwMDAwMDAwKSArICdCJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0TnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBNYXRoLnBvdygxMCwgdGhpcy5fcHJpdmF0ZV9fcHJlY2lzaW9uKTtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcHJpY2VTY2FsZSkgLyBwcmljZVNjYWxlO1xuICAgICAgICBpZiAodmFsdWUgPj0gMWUtMTUgJiYgdmFsdWUgPCAxKSB7XG4gICAgICAgICAgICByZXMgPSB2YWx1ZS50b0ZpeGVkKHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbikucmVwbGFjZSgvXFwuPzArJC8sICcnKTsgLy8gcmVnZXggcmVtb3ZlcyB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC8oXFwuWzEtOV0qKTArJC8sIChlLCBwMSkgPT4gcDEpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFJlcGxhY2VtZW50UmUgPSAvWzItOV0vZztcbmNsYXNzIFRleHRXaWR0aENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplID0gNTApIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljayA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscyA9IHt9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljayA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscyA9IHt9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19nZXRNZXRyaWNzKGN0eCwgdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSkud2lkdGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF95TWlkQ29ycmVjdGlvbihjdHgsIHRleHQsIG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUpIHtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX3ByaXZhdGVfX2dldE1ldHJpY3MoY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKTtcbiAgICAgICAgLy8gaWYgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQvYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IGFyZSBub3Qgc3VwcG9ydGVkIHdlIHVzZSAwIGFzIGEgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuICgobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCB8fCAwKSAtIChtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCB8fCAwKSkgLyAyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0TWV0cmljcyhjdHgsIHRleHQsIG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUpIHtcbiAgICAgICAgY29uc3QgcmUgPSBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlIHx8IGRlZmF1bHRSZXBsYWNlbWVudFJlO1xuICAgICAgICBjb25zdCBjYWNoZVN0cmluZyA9IFN0cmluZyh0ZXh0KS5yZXBsYWNlKHJlLCAnMCcpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGUuaGFzKGNhY2hlU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fY2FjaGUuZ2V0KGNhY2hlU3RyaW5nKSkuX2ludGVybmFsX21ldHJpY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPT09IHRoaXMuX3ByaXZhdGVfX21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZGVzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHNbdGhpcy5fcHJpdmF0ZV9fb2xkZXN0VGlja107XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHNbdGhpcy5fcHJpdmF0ZV9fb2xkZXN0VGlja107XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5kZWxldGUob2xkZXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2xkZXN0VGljaysrO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChjYWNoZVN0cmluZyk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChtZXRyaWNzLndpZHRoID09PSAwICYmICEhdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IGNhbiByZXR1cm4gMCBpbiBGRiBkZXBlbmRpbmcgb24gYSBjYW52YXMgc2l6ZSwgZG9uJ3QgY2FjaGUgaXRcbiAgICAgICAgICAgIHJldHVybiBtZXRyaWNzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlLnNldChjYWNoZVN0cmluZywgeyBfaW50ZXJuYWxfbWV0cmljczogbWV0cmljcywgX2ludGVybmFsX3RpY2s6IHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljayB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHNbdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrXSA9IGNhY2hlU3RyaW5nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplKys7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljaysrO1xuICAgICAgICByZXR1cm4gbWV0cmljcztcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVQcmljZUF4aXNWaWV3UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHRXaWR0aENhY2hlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGV4dFdpZHRoQ2FjaGUgPSB0ZXh0V2lkdGhDYWNoZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFBhcmFtcyhwcmljZUF4aXNWaWV3UmVuZGVyZXIsIHJlbmRlcmVyT3B0aW9ucywgYWxpZ24pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld1JlbmRlcmVyID0gcHJpY2VBeGlzVmlld1JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSByZW5kZXJlck9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FsaWduID0gYWxpZ247XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdSZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdSZW5kZXJlci5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucywgdGhpcy5fcHJpdmF0ZV9fdGV4dFdpZHRoQ2FjaGUsIHRoaXMuX3ByaXZhdGVfX2FsaWduKTtcbiAgICB9XG59XG5jbGFzcyBQYW5lUHJpY2VBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3IocHJpY2VBeGlzVmlldywgZGF0YVNvdXJjZSwgY2hhcnRNb2RlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3ID0gcHJpY2VBeGlzVmlldztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGV4dFdpZHRoQ2FjaGUgPSBuZXcgVGV4dFdpZHRoQ2FjaGUoNTApOyAvLyB3aGVuIHNob3VsZCB3ZSBjbGVhciBjYWNoZT9cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwgPSBjaGFydE1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb250U2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlciA9IG5ldyBQYW5lUHJpY2VBeGlzVmlld1JlbmRlcmVyKHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfcGFuZUZvclNvdXJjZSh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlKTtcbiAgICAgICAgaWYgKHBhbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgcHJpY2Ugc2NhbGUgd2lsbCBiZSB1c2VkIHRvIGZpbmQgbGFiZWwgcGxhY2VtZW50IG9ubHkgKGxlZnQsIHJpZ2h0LCBub25lKVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfaXNPdmVybGF5KHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2UpID8gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFZpc2libGVQcmljZVNjYWxlKCkgOiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBhbmUuX2ludGVybmFsX3ByaWNlU2NhbGVQb3NpdGlvbihwcmljZVNjYWxlKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnb3ZlcmxheScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF9wcmljZUF4aXNSZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplICE9PSB0aGlzLl9wcml2YXRlX19mb250U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgPSBvcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXRQYXJhbXModGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlldy5faW50ZXJuYWxfcGFuZVJlbmRlcmVyKCksIG9wdGlvbnMsIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbn1cblxuY2xhc3MgSG9yaXpvbnRhbExpbmVSZW5kZXJlciBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhPy5faW50ZXJuYWxfdmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfeTogaXRlbVksIF9pbnRlcm5hbF9saW5lV2lkdGg6IGxpbmVXaWR0aCwgX2ludGVybmFsX2V4dGVybmFsSWQ6IGV4dGVybmFsSWQgfSA9IHRoaXMuX3ByaXZhdGVfX2RhdGE7XG4gICAgICAgIC8vIGFkZCBhIGZpeGVkIGFyZWEgdGhyZXNob2xkIGFyb3VuZCBsaW5lIChZICsgd2lkdGgpIGZvciBoaXQgdGVzdFxuICAgICAgICBpZiAoeSA+PSBpdGVtWSAtIGxpbmVXaWR0aCAtIDcgLyogQ29uc3RhbnRzLkhpdFRlc3RUaHJlc2hvbGQgKi8gJiYgeSA8PSBpdGVtWSArIGxpbmVXaWR0aCArIDcgLyogQ29uc3RhbnRzLkhpdFRlc3RUaHJlc2hvbGQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hpdFRlc3REYXRhOiB0aGlzLl9wcml2YXRlX19kYXRhLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9leHRlcm5hbElkOiBleHRlcm5hbElkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGlmICh5IDwgMCB8fCB5ID4gYml0bWFwU2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2xpbmVXaWR0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbGluZVN0eWxlKTtcbiAgICAgICAgZHJhd0hvcml6b250YWxMaW5lKGN0eCwgeSwgMCwgYml0bWFwU2l6ZS53aWR0aCk7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfeTogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyID0gbmV3IEhvcml6b250YWxMaW5lUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbW9kZWwgPSBzZXJpZXMuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNIb3Jpem9udGFsQmFzZUxpbmVQYW5lVmlldyBleHRlbmRzIFNlcmllc0hvcml6b250YWxMaW5lUGFuZVZpZXcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgbW9kZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX21vZGUoKS5faW50ZXJuYWxfbW9kZTtcbiAgICAgICAgaWYgKG1vZGUgIT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLyAmJiBtb2RlICE9PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICghc2VyaWVzT3B0aW9ucy5iYXNlTGluZVZpc2libGUgfHwgIXRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfeSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVDb2xvcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX2xpbmVTdHlsZSA9IHNlcmllc09wdGlvbnMuYmFzZUxpbmVTdHlsZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblJlbmRlcmVyIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX2RhdGE7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja1dpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gKHRpY2tXaWR0aCAlIDIpIC8gMjtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IE1hdGgucm91bmQoZGF0YS5faW50ZXJuYWxfY2VudGVyLnggKiBob3Jpem9udGFsUGl4ZWxSYXRpbykgKyBjb3JyZWN0aW9uOyAvLyBjb3JyZWN0IHggY29vcmRpbmF0ZSBvbmx5XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBkYXRhLl9pbnRlcm5hbF9jZW50ZXIueSAqIHZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX3Nlcmllc0xpbmVDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyBUT0RPOiBpdCBpcyBiZXR0ZXIgdG8gaGF2ZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcmFkaWlcbiAgICAgICAgY29uc3QgY2VudGVyUG9pbnRSYWRpdXMgPSBNYXRoLm1heCgyLCBkYXRhLl9pbnRlcm5hbF9zZXJpZXNMaW5lV2lkdGggKiAxLjUpICogaG9yaXpvbnRhbFBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgY2VudGVyUG9pbnRSYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9maWxsQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRpY2tXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGF0YS5faW50ZXJuYWxfc3Ryb2tlQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBkYXRhLl9pbnRlcm5hbF9yYWRpdXMgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyArIHRpY2tXaWR0aCAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5cbmNvbnN0IGFuaW1hdGlvblN0YWdlc0RhdGEgPSBbXG4gICAge1xuICAgICAgICBfaW50ZXJuYWxfc3RhcnQ6IDAsXG4gICAgICAgIF9pbnRlcm5hbF9lbmQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0UmFkaXVzOiA0IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTAgLyogQ29uc3RhbnRzLlN0YWdlMUVuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UxRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMC40IC8qIENvbnN0YW50cy5TdGFnZTFTdGFydFN0cm9rZUFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGE6IDAuOCAvKiBDb25zdGFudHMuU3RhZ2UxRW5kU3Ryb2tlQWxwaGEgKi8sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIF9pbnRlcm5hbF9zdGFydDogMC4yNSAvKiBDb25zdGFudHMuU3RhZ2UxUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFQZXJpb2QgKi8gKyAwLjI3NSAvKiBDb25zdGFudHMuU3RhZ2UyUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRSYWRpdXM6IDEwIC8qIENvbnN0YW50cy5TdGFnZTJTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTQgLyogQ29uc3RhbnRzLlN0YWdlMkVuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTJTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UyRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMC44IC8qIENvbnN0YW50cy5TdGFnZTJTdGFydFN0cm9rZUFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlMkVuZFN0cm9rZUFscGhhICovLFxuICAgIH0sXG4gICAge1xuICAgICAgICBfaW50ZXJuYWxfc3RhcnQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyArIDAuMjc1IC8qIENvbnN0YW50cy5TdGFnZTJQZXJpb2QgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyArIDAuMjc1IC8qIENvbnN0YW50cy5TdGFnZTJQZXJpb2QgKi8gKyAwLjQ3NSAvKiBDb25zdGFudHMuU3RhZ2UzUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRSYWRpdXM6IDE0IC8qIENvbnN0YW50cy5TdGFnZTNTdGFydENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFJhZGl1czogMTQgLyogQ29uc3RhbnRzLlN0YWdlM0VuZENpcmNsZVJhZGl1cyAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTNTdGFydEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzRW5kRmlsbEFscGhhICovLFxuICAgICAgICBfaW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzU3RhcnRTdHJva2VBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFN0cm9rZUFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTNFbmRTdHJva2VBbHBoYSAqLyxcbiAgICB9LFxuXTtcbmZ1bmN0aW9uIHJhZGl1cyhzdGFnZSwgc3RhcnRSYWRpdXMsIGVuZFJhZGl1cykge1xuICAgIHJldHVybiBzdGFydFJhZGl1cyArIChlbmRSYWRpdXMgLSBzdGFydFJhZGl1cykgKiBzdGFnZTtcbn1cbmNsYXNzIFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgU2VyaWVzTGFzdFByaWNlQW5pbWF0aW9uUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFRpbWUgPSB0aGlzLl9wcml2YXRlX19zdGFydFRpbWUgLSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vbkRhdGFDbGVhcmVkKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbmRUaW1lID0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lIC0gMTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vbk5ld1JlYWx0aW1lRGF0YVJlY2VpdmVkKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLmxhc3RQcmljZUFuaW1hdGlvbiA9PT0gMiAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLk9uRGF0YVVwZGF0ZSAqLykge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lVG9BbmltYXRpb25FbmQgPSB0aGlzLl9wcml2YXRlX19lbmRUaW1lIC0gbm93O1xuICAgICAgICAgICAgaWYgKHRpbWVUb0FuaW1hdGlvbkVuZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZVRvQW5pbWF0aW9uRW5kIDwgMjYwMCAvKiBDb25zdGFudHMuQW5pbWF0aW9uUGVyaW9kICovIC8gNCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbmRUaW1lICs9IDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSA9IG5vdyArIDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbnZhbGlkYXRlU3RhZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YWdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZSgpIHtcbiAgICAgICAgLy8gY2VudGVyIHBvaW50IGlzIGFsd2F5cyB2aXNpYmxlIGlmIGxhc3RQcmljZUFuaW1hdGlvbiBpcyBub3QgTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5EaXNhYmxlZFxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkubGFzdFByaWNlQW5pbWF0aW9uICE9PSAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi87XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hbmltYXRpb25BY3RpdmUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkubGFzdFByaWNlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5EaXNhYmxlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDEgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5Db250aW51b3VzICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAyIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuT25EYXRhVXBkYXRlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKSA8PSB0aGlzLl9wcml2YXRlX19lbmRUaW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YWdlSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVJlbmRlcmVyRGF0YVN0YWdlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEobnVsbCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHZpc2libGVSYW5nZSA9IHRpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZpc2libGVSYW5nZSA9PT0gbnVsbCB8fCBmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9sYXN0VmFsdWVEYXRhKHRydWUpO1xuICAgICAgICBpZiAobGFzdFZhbHVlLl9pbnRlcm5hbF9ub0RhdGEgfHwgIXZpc2libGVSYW5nZS5faW50ZXJuYWxfY29udGFpbnMobGFzdFZhbHVlLl9pbnRlcm5hbF9pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0VmFsdWVQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUobGFzdFZhbHVlLl9pbnRlcm5hbF9pbmRleCksXG4gICAgICAgICAgICB5OiB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUobGFzdFZhbHVlLl9pbnRlcm5hbF9wcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXJpZXNMaW5lQ29sb3IgPSBsYXN0VmFsdWUuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICBjb25zdCBzZXJpZXNMaW5lV2lkdGggPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5saW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wcml2YXRlX19hbmltYXRpb25EYXRhKHRoaXMuX3ByaXZhdGVfX2R1cmF0aW9uKCksIHNlcmllc0xpbmVDb2xvcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXJpZXNMaW5lQ29sb3I6IHNlcmllc0xpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXJpZXNMaW5lV2lkdGg6IHNlcmllc0xpbmVXaWR0aCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9maWxsQ29sb3I6IGRhdGEuX2ludGVybmFsX2ZpbGxDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zdHJva2VDb2xvcjogZGF0YS5faW50ZXJuYWxfc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcmFkaXVzOiBkYXRhLl9pbnRlcm5hbF9yYWRpdXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY2VudGVyOiBsYXN0VmFsdWVQb2ludCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFTdGFnZSgpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJEYXRhID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX2RhdGEoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvbkRhdGEodGhpcy5fcHJpdmF0ZV9fZHVyYXRpb24oKSwgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9zZXJpZXNMaW5lQ29sb3IpO1xuICAgICAgICAgICAgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9maWxsQ29sb3IgPSBkYXRhLl9pbnRlcm5hbF9maWxsQ29sb3I7XG4gICAgICAgICAgICByZW5kZXJlckRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yID0gZGF0YS5faW50ZXJuYWxfc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICByZW5kZXJlckRhdGEuX2ludGVybmFsX3JhZGl1cyA9IGRhdGEuX2ludGVybmFsX3JhZGl1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9hbmltYXRpb25BY3RpdmUoKSA/IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lIDogMjYwMCAvKiBDb25zdGFudHMuQW5pbWF0aW9uUGVyaW9kICovIC0gMTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvbG9yKHNlcmllc0xpbmVDb2xvciwgc3RhZ2UsIHN0YXJ0QWxwaGEsIGVuZEFscGhhKSB7XG4gICAgICAgIGNvbnN0IGFscGhhID0gc3RhcnRBbHBoYSArIChlbmRBbHBoYSAtIHN0YXJ0QWxwaGEpICogc3RhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkuX2ludGVybmFsX2FwcGx5QWxwaGEoc2VyaWVzTGluZUNvbG9yLCBhbHBoYSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hbmltYXRpb25EYXRhKGR1cmF0aW9uU2luY2VTdGFydCwgbGluZUNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbFN0YWdlID0gKGR1cmF0aW9uU2luY2VTdGFydCAlIDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLykgLyAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi87XG4gICAgICAgIGxldCBjdXJyZW50U3RhZ2VEYXRhO1xuICAgICAgICBmb3IgKGNvbnN0IHN0YWdlRGF0YSBvZiBhbmltYXRpb25TdGFnZXNEYXRhKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU3RhZ2UgPj0gc3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydCAmJiBnbG9iYWxTdGFnZSA8PSBzdGFnZURhdGEuX2ludGVybmFsX2VuZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGFnZURhdGEgPSBzdGFnZURhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRTdGFnZURhdGEgIT09IHVuZGVmaW5lZCwgJ0xhc3QgcHJpY2UgYW5pbWF0aW9uIGludGVybmFsIGxvZ2ljIGVycm9yJyk7XG4gICAgICAgIGNvbnN0IHN1YlN0YWdlID0gKGdsb2JhbFN0YWdlIC0gY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnQpIC8gKGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX2VuZCAtIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9maWxsQ29sb3I6IHRoaXMuX3ByaXZhdGVfX2NvbG9yKGxpbmVDb2xvciwgc3ViU3RhZ2UsIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0RmlsbEFscGhhLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmRGaWxsQWxwaGEpLFxuICAgICAgICAgICAgX2ludGVybmFsX3N0cm9rZUNvbG9yOiB0aGlzLl9wcml2YXRlX19jb2xvcihsaW5lQ29sb3IsIHN1YlN0YWdlLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydFN0cm9rZUFscGhhLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmRTdHJva2VBbHBoYSksXG4gICAgICAgICAgICBfaW50ZXJuYWxfcmFkaXVzOiByYWRpdXMoc3ViU3RhZ2UsIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0UmFkaXVzLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmRSYWRpdXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzUHJpY2VMaW5lUGFuZVZpZXcgZXh0ZW5kcyBTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yKHNlcmllcykge1xuICAgICAgICBzdXBlcihzZXJpZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIXNlcmllc09wdGlvbnMucHJpY2VMaW5lVmlzaWJsZSB8fCAhdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFZhbHVlRGF0YSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2xhc3RWYWx1ZURhdGEoc2VyaWVzT3B0aW9ucy5wcmljZUxpbmVTb3VyY2UgPT09IDAgLyogUHJpY2VMaW5lU291cmNlLkxhc3RCYXIgKi8pO1xuICAgICAgICBpZiAobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfbm9EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3kgPSBsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9jb2xvciA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlTGluZUNvbG9yKGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2NvbG9yKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZVdpZHRoID0gc2VyaWVzT3B0aW9ucy5wcmljZUxpbmVXaWR0aDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZVN0eWxlID0gc2VyaWVzT3B0aW9ucy5wcmljZUxpbmVTdHlsZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc1ByaWNlQXhpc1ZpZXcgZXh0ZW5kcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZVJlbmRlcmVyRGF0YShheGlzUmVuZGVyZXJEYXRhLCBwYW5lUmVuZGVyZXJEYXRhLCBjb21tb25SZW5kZXJlckRhdGEpIHtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZTtcbiAgICAgICAgaWYgKCFzb3VyY2UuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSBzb3VyY2UuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgc2hvd1Nlcmllc0xhc3RWYWx1ZSA9IHNlcmllc09wdGlvbnMubGFzdFZhbHVlVmlzaWJsZTtcbiAgICAgICAgY29uc3Qgc2hvd1N5bWJvbExhYmVsID0gc291cmNlLl9pbnRlcm5hbF90aXRsZSgpICE9PSAnJztcbiAgICAgICAgY29uc3Qgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSA9IHNlcmllc09wdGlvbnMuc2VyaWVzTGFzdFZhbHVlTW9kZSA9PT0gMCAvKiBQcmljZUF4aXNMYXN0VmFsdWVNb2RlLkxhc3RQcmljZUFuZFBlcmNlbnRhZ2VWYWx1ZSAqLztcbiAgICAgICAgY29uc3QgbGFzdFZhbHVlRGF0YSA9IHNvdXJjZS5faW50ZXJuYWxfbGFzdFZhbHVlRGF0YShmYWxzZSk7XG4gICAgICAgIGlmIChsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9ub0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd1Nlcmllc0xhc3RWYWx1ZSkge1xuICAgICAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IHRoaXMuX2ludGVybmFsX19heGlzVGV4dChsYXN0VmFsdWVEYXRhLCBzaG93U2VyaWVzTGFzdFZhbHVlLCBzaG93UHJpY2VBbmRQZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0Lmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd1N5bWJvbExhYmVsIHx8IHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQgPSB0aGlzLl9pbnRlcm5hbF9fcGFuZVRleHQobGFzdFZhbHVlRGF0YSwgc2hvd1Nlcmllc0xhc3RWYWx1ZSwgc2hvd1N5bWJvbExhYmVsLCBzaG93UHJpY2VBbmRQZXJjZW50YWdlKTtcbiAgICAgICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0Lmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFZhbHVlQ29sb3IgPSBzb3VyY2UuX2ludGVybmFsX3ByaWNlTGluZUNvbG9yKGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2NvbG9yKTtcbiAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jb2xvclBhcnNlcigpLl9pbnRlcm5hbF9nZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKGxhc3RWYWx1ZUNvbG9yKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kID0gY29sb3JzLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSBsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA9IHNvdXJjZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSAvIHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9oZWlnaHQoKSk7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2JvcmRlckNvbG9yID0gbGFzdFZhbHVlQ29sb3I7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2NvbG9yID0gY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgX2ludGVybmFsX19wYW5lVGV4dChsYXN0VmFsdWUsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dTeW1ib2xMYWJlbCwgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF90aXRsZSgpO1xuICAgICAgICBpZiAoc2hvd1N5bWJvbExhYmVsICYmIHRpdGxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAke3RpdGxlfSBgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93U2VyaWVzTGFzdFZhbHVlICYmIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgP1xuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZS5faW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VBYnNvbHV0ZSA6IGxhc3RWYWx1ZS5faW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VQZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2F4aXNUZXh0KGxhc3RWYWx1ZURhdGEsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgaWYgKCFzaG93U2VyaWVzTGFzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaG93UHJpY2VBbmRQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpID9cbiAgICAgICAgICAgIGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlUGVyY2VudGFnZSA6IGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlRmluaXRlUmVzdWx0KG1ldGhvZCwgdmFsdWVPbmUsIHZhbHVlVHdvLCBmYWxsYmFjaykge1xuICAgIGNvbnN0IGZpcnN0RmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlT25lKTtcbiAgICBjb25zdCBzZWNvbmRGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUodmFsdWVUd28pO1xuICAgIGlmIChmaXJzdEZpbml0ZSAmJiBzZWNvbmRGaW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCh2YWx1ZU9uZSwgdmFsdWVUd28pO1xuICAgIH1cbiAgICByZXR1cm4gIWZpcnN0RmluaXRlICYmICFzZWNvbmRGaW5pdGUgPyBmYWxsYmFjayA6IChmaXJzdEZpbml0ZSA/IHZhbHVlT25lIDogdmFsdWVUd28pO1xufVxuY2xhc3MgUHJpY2VSYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9IG1heFZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZXF1YWxzKHByKSB7XG4gICAgICAgIGlmIChwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9PT0gcHIuX3ByaXZhdGVfX21pblZhbHVlICYmIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlID09PSBwci5fcHJpdmF0ZV9fbWF4VmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbCh0aGlzLl9wcml2YXRlX19taW5WYWx1ZSwgdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWluVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX21heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSAtIHRoaXMuX3ByaXZhdGVfX21pblZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlID09PSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSB8fCBOdW1iZXIuaXNOYU4odGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUpIHx8IE51bWJlci5pc05hTih0aGlzLl9wcml2YXRlX19taW5WYWx1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tZXJnZShhbm90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKGFub3RoZXJSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChjb21wdXRlRmluaXRlUmVzdWx0KE1hdGgubWluLCB0aGlzLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBhbm90aGVyUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIC1JbmZpbml0eSksIGNvbXB1dGVGaW5pdGVSZXN1bHQoTWF0aC5tYXgsIHRoaXMuX2ludGVybmFsX21heFZhbHVlKCksIGFub3RoZXJSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgSW5maW5pdHkpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlQXJvdW5kQ2VudGVyKGNvZWZmKSB7XG4gICAgICAgIGlmICghaXNOdW1iZXIoY29lZmYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSAtIHRoaXMuX3ByaXZhdGVfX21pblZhbHVlO1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZW50ZXIgPSAodGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgKyB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSkgKiAwLjU7XG4gICAgICAgIGxldCBtYXhEZWx0YSA9IHRoaXMuX3ByaXZhdGVfX21heFZhbHVlIC0gY2VudGVyO1xuICAgICAgICBsZXQgbWluRGVsdGEgPSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSAtIGNlbnRlcjtcbiAgICAgICAgbWF4RGVsdGEgKj0gY29lZmY7XG4gICAgICAgIG1pbkRlbHRhICo9IGNvZWZmO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9IGNlbnRlciArIG1heERlbHRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSA9IGNlbnRlciArIG1pbkRlbHRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2hpZnQoZGVsdGEpIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihkZWx0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgKz0gZGVsdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzLl9wcml2YXRlX19taW5WYWx1ZSxcbiAgICAgICAgICAgIG1heFZhbHVlOiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIF9pbnRlcm5hbF9mcm9tUmF3KHJhdykge1xuICAgICAgICByZXR1cm4gKHJhdyA9PT0gbnVsbCkgPyBudWxsIDogbmV3IFByaWNlUmFuZ2VJbXBsKHJhdy5taW5WYWx1ZSwgcmF3Lm1heFZhbHVlKTtcbiAgICB9XG59XG5cbmNsYXNzIEF1dG9zY2FsZUluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwcmljZVJhbmdlLCBtYXJnaW5zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgPSBwcmljZVJhbmdlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJnaW5zID0gbWFyZ2lucyB8fCBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tYXJnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFyZ2lucztcbiAgICB9XG4gICAgX2ludGVybmFsX3RvUmF3KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpY2VSYW5nZTogdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlLl9pbnRlcm5hbF90b1JhdygpLFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5fcHJpdmF0ZV9fbWFyZ2lucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfaW50ZXJuYWxfZnJvbVJhdyhyYXcpIHtcbiAgICAgICAgcmV0dXJuIChyYXcgPT09IG51bGwpID8gbnVsbCA6IG5ldyBBdXRvc2NhbGVJbmZvSW1wbChQcmljZVJhbmdlSW1wbC5faW50ZXJuYWxfZnJvbVJhdyhyYXcucHJpY2VSYW5nZSksIHJhdy5tYXJnaW5zKTtcbiAgICB9XG59XG5cbmNsYXNzIEN1c3RvbVByaWNlTGluZVBhbmVWaWV3IGV4dGVuZHMgU2VyaWVzSG9yaXpvbnRhbExpbmVQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBwcmljZUxpbmUpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lID0gcHJpY2VMaW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBsaW5lT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIXRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSB8fCAhbGluZU9wdGlvbnMubGluZVZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF95Q29vcmQoKTtcbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfeSA9IHk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2NvbG9yID0gbGluZU9wdGlvbnMuY29sb3I7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCA9IGxpbmVPcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZVN0eWxlID0gbGluZU9wdGlvbnMubGluZVN0eWxlO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9leHRlcm5hbElkID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF9vcHRpb25zKCkuaWQ7XG4gICAgfVxufVxuXG5jbGFzcyBDdXN0b21QcmljZUxpbmVQcmljZUF4aXNWaWV3IGV4dGVuZHMgUHJpY2VBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBwcmljZUxpbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUgPSBwcmljZUxpbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fdXBkYXRlUmVuZGVyZXJEYXRhKGF4aXNSZW5kZXJlckRhdGEsIHBhbmVSZW5kZXJlckRhdGEsIGNvbW1vbkRhdGEpIHtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgbGFiZWxWaXNpYmxlID0gb3B0aW9ucy5heGlzTGFiZWxWaXNpYmxlO1xuICAgICAgICBjb25zdCBzaG93UGFuZUxhYmVsID0gb3B0aW9ucy50aXRsZSAhPT0gJyc7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuX3ByaXZhdGVfX3NlcmllcztcbiAgICAgICAgaWYgKCFsYWJlbFZpc2libGUgfHwgIXNlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfeUNvb3JkKCk7XG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dQYW5lTGFiZWwpIHtcbiAgICAgICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYm9yZGVyQ29sb3IgPSBzZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2JhY2tncm91bmRDb2xvckF0WVBlcmNlbnRGcm9tVG9wKHkgLyBzZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaGVpZ2h0KCkpO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0UHJpY2Uob3B0aW9ucy5wcmljZSk7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBjb2xvcnMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkuX2ludGVybmFsX2dlbmVyYXRlQ29udHJhc3RDb2xvcnMob3B0aW9ucy5heGlzTGFiZWxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcbiAgICAgICAgY29tbW9uRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZCA9IGNvbG9ycy5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gb3B0aW9ucy5heGlzTGFiZWxUZXh0Q29sb3IgfHwgY29sb3JzLl9pbnRlcm5hbF9mb3JlZ3JvdW5kO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHRleHRDb2xvcjsgLy8gcHJpY2UgdGV4dFxuICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IHRleHRDb2xvcjsgLy8gdGl0bGUgdGV4dFxuICAgICAgICBjb21tb25EYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlID0geTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdFByaWNlKHByaWNlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2Zvcm1hdFByaWNlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBDdXN0b21QcmljZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3ID0gbmV3IEN1c3RvbVByaWNlTGluZVBhbmVWaWV3KHNlcmllcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXcgPSBuZXcgQ3VzdG9tUHJpY2VMaW5lUHJpY2VBeGlzVmlldyhzZXJpZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUHJpY2VBeGlzVmlldyA9IG5ldyBQYW5lUHJpY2VBeGlzVmlldyh0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3LCBzZXJpZXMsIHNlcmllcy5faW50ZXJuYWxfbW9kZWwoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVQcmljZUF4aXNWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3lDb29yZCgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHNlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCBwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBzZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBQcmljZURhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlbDtcbiAgICB9XG59XG5cbmNvbnN0IGJhclN0eWxlRm5NYXAgPSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEJhcjogKGZpbmRCYXIsIGJhclN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwQ29sb3IgPSBiYXJTdHlsZS51cENvbG9yO1xuICAgICAgICBjb25zdCBkb3duQ29sb3IgPSBiYXJTdHlsZS5kb3duQ29sb3I7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXIgPSBlbnN1cmVOb3ROdWxsKGZpbmRCYXIoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykpO1xuICAgICAgICBjb25zdCBpc1VwID0gZW5zdXJlKGN1cnJlbnRCYXIuX2ludGVybmFsX3ZhbHVlWzAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqL10pIDw9IGVuc3VyZShjdXJyZW50QmFyLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX2NvbG9yID8/IChpc1VwID8gdXBDb2xvciA6IGRvd25Db2xvciksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQ2FuZGxlc3RpY2s6IChmaW5kQmFyLCBjYW5kbGVzdGlja1N0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwQ29sb3IgPSBjYW5kbGVzdGlja1N0eWxlLnVwQ29sb3I7XG4gICAgICAgIGNvbnN0IGRvd25Db2xvciA9IGNhbmRsZXN0aWNrU3R5bGUuZG93bkNvbG9yO1xuICAgICAgICBjb25zdCBib3JkZXJVcENvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS5ib3JkZXJVcENvbG9yO1xuICAgICAgICBjb25zdCBib3JkZXJEb3duQ29sb3IgPSBjYW5kbGVzdGlja1N0eWxlLmJvcmRlckRvd25Db2xvcjtcbiAgICAgICAgY29uc3Qgd2lja1VwQ29sb3IgPSBjYW5kbGVzdGlja1N0eWxlLndpY2tVcENvbG9yO1xuICAgICAgICBjb25zdCB3aWNrRG93bkNvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS53aWNrRG93bkNvbG9yO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgY29uc3QgaXNVcCA9IGVuc3VyZShjdXJyZW50QmFyLl9pbnRlcm5hbF92YWx1ZVswIC8qIFBsb3RSb3dWYWx1ZUluZGV4Lk9wZW4gKi9dKSA8PSBlbnN1cmUoY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhckNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvciA/PyAoaXNVcCA/IHVwQ29sb3IgOiBkb3duQ29sb3IpLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhckJvcmRlckNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA/PyAoaXNVcCA/IGJvcmRlclVwQ29sb3IgOiBib3JkZXJEb3duQ29sb3IpLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpY2tDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfd2lja0NvbG9yID8/IChpc1VwID8gd2lja1VwQ29sb3IgOiB3aWNrRG93bkNvbG9yKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBDdXN0b206IChmaW5kQmFyLCBjdXN0b21TdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IgPz8gY3VzdG9tU3R5bGUuY29sb3IsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQXJlYTogKGZpbmRCYXIsIGFyZWFTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfbGluZUNvbG9yID8/IGFyZWFTdHlsZS5saW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZUNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9saW5lQ29sb3IgPz8gYXJlYVN0eWxlLmxpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfdG9wQ29sb3IgPz8gYXJlYVN0eWxlLnRvcENvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21Db2xvciA/PyBhcmVhU3R5bGUuYm90dG9tQ29sb3IsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQmFzZWxpbmU6IChmaW5kQmFyLCBiYXNlbGluZVN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXIgPSBlbnN1cmVOb3ROdWxsKGZpbmRCYXIoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykpO1xuICAgICAgICBjb25zdCBpc0Fib3ZlQmFzZWxpbmUgPSBjdXJyZW50QmFyLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSA+PSBiYXNlbGluZVN0eWxlLmJhc2VWYWx1ZS5wcmljZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogaXNBYm92ZUJhc2VsaW5lID8gYmFzZWxpbmVTdHlsZS50b3BMaW5lQ29sb3IgOiBiYXNlbGluZVN0eWxlLmJvdHRvbUxpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BMaW5lQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX3RvcExpbmVDb2xvciA/PyBiYXNlbGluZVN0eWxlLnRvcExpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvciA/PyBiYXNlbGluZVN0eWxlLmJvdHRvbUxpbmVDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BGaWxsQ29sb3IxOiBjdXJyZW50QmFyLl9pbnRlcm5hbF90b3BGaWxsQ29sb3IxID8/IGJhc2VsaW5lU3R5bGUudG9wRmlsbENvbG9yMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BGaWxsQ29sb3IyOiBjdXJyZW50QmFyLl9pbnRlcm5hbF90b3BGaWxsQ29sb3IyID8/IGJhc2VsaW5lU3R5bGUudG9wRmlsbENvbG9yMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxID8/IGJhc2VsaW5lU3R5bGUuYm90dG9tRmlsbENvbG9yMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyID8/IGJhc2VsaW5lU3R5bGUuYm90dG9tRmlsbENvbG9yMixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBMaW5lOiAoZmluZEJhciwgbGluZVN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXIgPSBlbnN1cmVOb3ROdWxsKGZpbmRCYXIoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhckNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvciA/PyBsaW5lU3R5bGUuY29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZUNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvciA/PyBsaW5lU3R5bGUuY29sb3IsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgSGlzdG9ncmFtOiAoZmluZEJhciwgaGlzdG9ncmFtU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX2NvbG9yID8/IGhpc3RvZ3JhbVN0eWxlLmNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuY2xhc3MgU2VyaWVzQmFyQ29sb3JlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpbmRCYXIgPSAoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICAgICAgaWYgKHByZWNvbXB1dGVkQmFycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNvbXB1dGVkQmFycy5faW50ZXJuYWxfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3ZhbHVlQXQoYmFySW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0eWxlR2V0dGVyID0gYmFyU3R5bGVGbk1hcFtzZXJpZXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKV07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJTdHlsZShiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSB7XG4gICAgICAgIC8vIHByZWNvbXB1dGVkQmFyczoge3ZhbHVlOiBbQXJyYXkgQmFyVmFsdWVzXSwgcHJldmlvdXNWYWx1ZTogW0FycmF5IEJhclZhbHVlc10gfCB1bmRlZmluZWR9XG4gICAgICAgIC8vIFVzZWQgdG8gYXZvaWQgYmluYXJ5IHNlYXJjaCBpZiBiYXJzIGFyZSBhbHJlYWR5IGtub3duXG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zdHlsZUdldHRlcih0aGlzLl9wcml2YXRlX19maW5kQmFyLCB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJpbmFyeSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdHdvIGFyZ3VtZW50cyAodGhlIGZpcnN0IG9mIHRoZSB0eXBlIG9mIGFycmF5IGVsZW1lbnRzLCBhbmQgdGhlIHNlY29uZCBpcyBhbHdheXMgdmFsKSwgYW5kIHJldHVybnMgYSB2YWx1ZSBjb252ZXJ0aWJsZSB0byBib29sLlxuICogVGhlIHZhbHVlIHJldHVybmVkIGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBjb25zaWRlcmVkIHRvIGdvIGJlZm9yZSB0aGUgc2Vjb25kLlxuICogVGhlIGZ1bmN0aW9uIHNoYWxsIG5vdCBtb2RpZnkgYW55IG9mIGl0cyBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGJvdW5kQ29tcGFyZShsb3dlciwgYXJyLCB2YWx1ZSwgY29tcGFyZSwgc3RhcnQgPSAwLCB0byA9IGFyci5sZW5ndGgpIHtcbiAgICBsZXQgY291bnQgPSB0byAtIHN0YXJ0O1xuICAgIHdoaWxlICgwIDwgY291bnQpIHtcbiAgICAgICAgY29uc3QgY291bnQyID0gKGNvdW50ID4+IDEpO1xuICAgICAgICBjb25zdCBtaWQgPSBzdGFydCArIGNvdW50MjtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW21pZF0sIHZhbHVlKSA9PT0gbG93ZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGNvdW50IC09IGNvdW50MiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50MjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59XG5jb25zdCBsb3dlckJvdW5kID0gYm91bmRDb21wYXJlLmJpbmQobnVsbCwgdHJ1ZSk7XG5jb25zdCB1cHBlckJvdW5kID0gYm91bmRDb21wYXJlLmJpbmQobnVsbCwgZmFsc2UpO1xuXG4vKipcbiAqIFNlYXJjaCBkaXJlY3Rpb24gaWYgbm8gZGF0YSBmb3VuZCBhdCBwcm92aWRlZCBpbmRleFxuICovXG52YXIgTWlzbWF0Y2hEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1pc21hdGNoRGlyZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRoZSBuZWFyZXN0IGxlZnQgaXRlbVxuICAgICAqL1xuICAgIE1pc21hdGNoRGlyZWN0aW9uW01pc21hdGNoRGlyZWN0aW9uW1wiTmVhcmVzdExlZnRcIl0gPSAtMV0gPSBcIk5lYXJlc3RMZWZ0XCI7XG4gICAgLyoqXG4gICAgICogRG8gbm90IHNlYXJjaFxuICAgICAqL1xuICAgIE1pc21hdGNoRGlyZWN0aW9uW01pc21hdGNoRGlyZWN0aW9uW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRoZSBuZWFyZXN0IHJpZ2h0IGl0ZW1cbiAgICAgKi9cbiAgICBNaXNtYXRjaERpcmVjdGlvbltNaXNtYXRjaERpcmVjdGlvbltcIk5lYXJlc3RSaWdodFwiXSA9IDFdID0gXCJOZWFyZXN0UmlnaHRcIjtcbn0pKE1pc21hdGNoRGlyZWN0aW9uIHx8IChNaXNtYXRjaERpcmVjdGlvbiA9IHt9KSk7XG4vLyBUT0RPOiB0aGluayBhYm91dCBjaGFuZ2luZyBpdCBkeW5hbWljYWxseVxuY29uc3QgQ0hVTktfU0laRSA9IDMwO1xuLyoqXG4gKiBQbG90TGlzdCBpcyBhbiBhcnJheSBvZiBwbG90IHJvd3NcbiAqIGVhY2ggcGxvdCByb3cgY29uc2lzdHMgb2Yga2V5IChpbmRleCBpbiB0aW1lc2NhbGUpIGFuZCBwbG90IHZhbHVlIG1hcFxuICovXG5jbGFzcyBQbG90TGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21pbk1heENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dTZWFyY2hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBAcmV0dXJucyBMYXN0IHJvd1xuICAgIF9pbnRlcm5hbF9sYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2l6ZSgpID4gMCA/IHRoaXMuX3ByaXZhdGVfX2l0ZW1zW3RoaXMuX3ByaXZhdGVfX2l0ZW1zLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpcnN0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zaXplKCkgPiAwID8gdGhpcy5fcHJpdmF0ZV9faW5kZXhBdCgwKSA6IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sYXN0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zaXplKCkgPiAwID8gdGhpcy5fcHJpdmF0ZV9faW5kZXhBdCgodGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoIC0gMSkpIDogbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2l6ZSgpID09PSAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29udGFpbnMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NlYXJjaChpbmRleCwgMCAvKiBNaXNtYXRjaERpcmVjdGlvbi5Ob25lICovKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3ZhbHVlQXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NlYXJjaChpbmRleCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZWFyY2goaW5kZXgsIHNlYXJjaE1vZGUgPSAwIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5vbmUgKi8pIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fcHJpdmF0ZV9fc2VhcmNoKGluZGV4LCBzZWFyY2hNb2RlKTtcbiAgICAgICAgaWYgKHBvcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX3ByaXZhdGVfX3ZhbHVlQXQocG9zKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbmRleDogdGhpcy5fcHJpdmF0ZV9faW5kZXhBdChwb3MpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2l0ZW1zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWluTWF4T25SYW5nZUNhY2hlZChzdGFydCwgZW5kLCBwbG90cykge1xuICAgICAgICAvLyB0aGlzIGNvZGUgd29ya3MgZm9yIHNpbmdsZSBzZXJpZXMgb25seVxuICAgICAgICAvLyBjb3VsZCBmYWlsIGFmdGVyIHdoaXRlc3BhY2VzIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsb3Qgb2YgcGxvdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsb3RNaW5NYXggPSB0aGlzLl9wcml2YXRlX19taW5NYXhPblJhbmdlQ2FjaGVkSW1wbChzdGFydCwgZW5kLCBwbG90KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlTWluTWF4KHJlc3VsdCwgcGxvdE1pbk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEocGxvdFJvd3MpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93U2VhcmNoQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluTWF4Q2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXRlbXMgPSBwbG90Um93cztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kaWNlcyA9IHBsb3RSb3dzLm1hcCgocGxvdFJvdykgPT4gcGxvdFJvdy5faW50ZXJuYWxfaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUaW1lUG9pbnRJbmRleCB2YWx1ZXMgZm9yIGZ1bGZpbGxlZCBkYXRhIHBvaW50c1xuICAgIF9pbnRlcm5hbF9pbmRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faW5kaWNlcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2luZGV4QXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtc1tvZmZzZXRdLl9pbnRlcm5hbF9pbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3ZhbHVlQXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtc1tvZmZzZXRdO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2VhcmNoKGluZGV4LCBzZWFyY2hNb2RlKSB7XG4gICAgICAgIGNvbnN0IGV4YWN0UG9zID0gdGhpcy5fcHJpdmF0ZV9fYnNlYXJjaChpbmRleCk7XG4gICAgICAgIGlmIChleGFjdFBvcyA9PT0gbnVsbCAmJiBzZWFyY2hNb2RlICE9PSAwIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5vbmUgKi8pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VhcmNoTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdExlZnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZWFyY2hOZWFyZXN0TGVmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RSaWdodChpbmRleCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBzZWFyY2ggbW9kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGFjdFBvcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RMZWZ0KGluZGV4KSB7XG4gICAgICAgIGxldCBuZWFyZXN0TGVmdFBvcyA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQoaW5kZXgpO1xuICAgICAgICBpZiAobmVhcmVzdExlZnRQb3MgPiAwKSB7XG4gICAgICAgICAgICBuZWFyZXN0TGVmdFBvcyA9IG5lYXJlc3RMZWZ0UG9zIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5lYXJlc3RMZWZ0UG9zICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgdGhpcy5fcHJpdmF0ZV9faW5kZXhBdChuZWFyZXN0TGVmdFBvcykgPCBpbmRleCkgPyBuZWFyZXN0TGVmdFBvcyA6IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZWFyY2hOZWFyZXN0UmlnaHQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbmVhcmVzdFJpZ2h0UG9zID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChpbmRleCk7XG4gICAgICAgIHJldHVybiAobmVhcmVzdFJpZ2h0UG9zICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgaW5kZXggPCB0aGlzLl9wcml2YXRlX19pbmRleEF0KG5lYXJlc3RSaWdodFBvcykpID8gbmVhcmVzdFJpZ2h0UG9zIDogbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2JzZWFyY2goaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9wcml2YXRlX19sb3dlcmJvdW5kKGluZGV4KTtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSB0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggJiYgIShpbmRleCA8IHRoaXMuX3ByaXZhdGVfX2l0ZW1zW3N0YXJ0XS5faW50ZXJuYWxfaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19sb3dlcmJvdW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsb3dlckJvdW5kKHRoaXMuX3ByaXZhdGVfX2l0ZW1zLCBpbmRleCwgKGEsIGIpID0+IGEuX2ludGVybmFsX2luZGV4IDwgYik7XG4gICAgfVxuICAgIF9wcml2YXRlX191cHBlcmJvdW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB1cHBlckJvdW5kKHRoaXMuX3ByaXZhdGVfX2l0ZW1zLCBpbmRleCwgKGEsIGIpID0+IGEuX2ludGVybmFsX2luZGV4ID4gYik7XG4gICAgfVxuICAgIF9wcml2YXRlX19wbG90TWluTWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4RXhjbHVzaXZlLCBwbG90SW5kZXgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXhFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5fcHJpdmF0ZV9faXRlbXNbaV0uX2ludGVybmFsX3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1twbG90SW5kZXhdO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih2KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgX2ludGVybmFsX21pbjogdiwgX2ludGVybmFsX21heDogdiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPCByZXN1bHQuX2ludGVybmFsX21pbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX2ludGVybmFsX21pbiA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2ID4gcmVzdWx0Ll9pbnRlcm5hbF9tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcm5hbF9tYXggPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWluTWF4T25SYW5nZUNhY2hlZEltcGwoc3RhcnQsIGVuZCwgcGxvdEluZGV4KSB7XG4gICAgICAgIC8vIHRoaXMgY29kZSB3b3JrcyBmb3Igc2luZ2xlIHNlcmllcyBvbmx5XG4gICAgICAgIC8vIGNvdWxkIGZhaWwgYWZ0ZXIgd2hpdGVzcGFjZXMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIC8vIGFzc3VtZSB0aGF0IGJhciBpbmRleGVzIG9ubHkgaW5jcmVhc2VcbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfZmlyc3RJbmRleCgpKTtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9sYXN0SW5kZXgoKSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLm1heChzdGFydCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGNvbnN0IGUgPSBNYXRoLm1pbihlbmQsIGxhc3RJbmRleCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZExvdyA9IE1hdGguY2VpbChzIC8gQ0hVTktfU0laRSkgKiBDSFVOS19TSVpFO1xuICAgICAgICBjb25zdCBjYWNoZWRIaWdoID0gTWF0aC5tYXgoY2FjaGVkTG93LCBNYXRoLmZsb29yKGUgLyBDSFVOS19TSVpFKSAqIENIVU5LX1NJWkUpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbG93ZXJib3VuZChzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChNYXRoLm1pbihlLCBjYWNoZWRMb3csIGVuZCkpOyAvLyBub24taW5jbHVzaXZlIGVuZFxuICAgICAgICAgICAgY29uc3QgcGxvdE1pbk1heCA9IHRoaXMuX3ByaXZhdGVfX3Bsb3RNaW5NYXgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHBsb3RJbmRleCk7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZU1pbk1heChyZXN1bHQsIHBsb3RNaW5NYXgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaW5NYXhDYWNoZSA9IHRoaXMuX3ByaXZhdGVfX21pbk1heENhY2hlLmdldChwbG90SW5kZXgpO1xuICAgICAgICBpZiAobWluTWF4Q2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWluTWF4Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19taW5NYXhDYWNoZS5zZXQocGxvdEluZGV4LCBtaW5NYXhDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGdvIGNhY2hlZFxuICAgICAgICBmb3IgKGxldCBjID0gTWF0aC5tYXgoY2FjaGVkTG93ICsgMSwgcyk7IGMgPCBjYWNoZWRIaWdoOyBjICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGMgLyBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGxldCBjaHVua01pbk1heCA9IG1pbk1heENhY2hlLmdldChjaHVua0luZGV4KTtcbiAgICAgICAgICAgIGlmIChjaHVua01pbk1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTdGFydCA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQoY2h1bmtJbmRleCAqIENIVU5LX1NJWkUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRW5kID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZCgoY2h1bmtJbmRleCArIDEpICogQ0hVTktfU0laRSAtIDEpO1xuICAgICAgICAgICAgICAgIGNodW5rTWluTWF4ID0gdGhpcy5fcHJpdmF0ZV9fcGxvdE1pbk1heChjaHVua1N0YXJ0LCBjaHVua0VuZCwgcGxvdEluZGV4KTtcbiAgICAgICAgICAgICAgICBtaW5NYXhDYWNoZS5zZXQoY2h1bmtJbmRleCwgY2h1bmtNaW5NYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2VNaW5NYXgocmVzdWx0LCBjaHVua01pbk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFpbFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbG93ZXJib3VuZChjYWNoZWRIaWdoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdXBwZXJib3VuZChlKTsgLy8gbm9uLWluY2x1c2l2ZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBsb3RNaW5NYXggPSB0aGlzLl9wcml2YXRlX19wbG90TWluTWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBwbG90SW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2VNaW5NYXgocmVzdWx0LCBwbG90TWluTWF4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlTWluTWF4KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWNvbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIE1pbk1heCB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGZpcnN0Ll9pbnRlcm5hbF9taW4sIHNlY29uZC5faW50ZXJuYWxfbWluKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGZpcnN0Ll9pbnRlcm5hbF9tYXgsIHNlY29uZC5faW50ZXJuYWxfbWF4KTtcbiAgICAgICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9taW46IG1pbiwgX2ludGVybmFsX21heDogbWF4IH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcmllc1Bsb3RMaXN0KCkge1xuICAgIHJldHVybiBuZXcgUGxvdExpc3QoKTtcbn1cblxuY2xhc3MgUHJpbWl0aXZlUmVuZGVyZXJXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyID0gYmFzZVJlbmRlcmVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyLmRyYXcodGFyZ2V0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kKHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlUmVuZGVyZXIuZHJhd0JhY2tncm91bmQ/Lih0YXJnZXQpO1xuICAgIH1cbn1cbmNsYXNzIFByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IocGFuZVZpZXcpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IHBhbmVWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VSZW5kZXJlciA9IHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChiYXNlUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jYWNoZT8uX2ludGVybmFsX2Jhc2UgPT09IGJhc2VSZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgUHJpbWl0aXZlUmVuZGVyZXJXcmFwcGVyKGJhc2VSZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2VSZW5kZXJlcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3pPcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnpPcmRlcj8uKCkgPz8gJ25vcm1hbCc7XG4gICAgfVxufVxuY2xhc3MgUHJpbWl0aXZlV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaW1pdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS51cGRhdGVBbGxWaWV3cz8uKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLnBhbmVWaWV3cz8uKCkgPz8gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lVmlld3NDYWNoZT8uX2ludGVybmFsX2Jhc2UgPT09IGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlld3NDYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gYmFzZS5tYXAoKHB3KSA9PiBuZXcgUHJpbWl0aXZlUGFuZVZpZXdXcmFwcGVyKHB3KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuaGl0VGVzdD8uKHgsIHkpID8/IG51bGw7XG4gICAgfVxufVxubGV0IFBhbmVQcmltaXRpdmVXcmFwcGVyJDEgPSBjbGFzcyBQYW5lUHJpbWl0aXZlV3JhcHBlciBleHRlbmRzIFByaW1pdGl2ZVdyYXBwZXIge1xuICAgIF9pbnRlcm5hbF9sYWJlbFBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbmNsYXNzIFNlcmllc1ByaW1pdGl2ZVJlbmRlcmVyV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoYmFzZVJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VSZW5kZXJlciA9IGJhc2VSZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VSZW5kZXJlci5kcmF3KHRhcmdldCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3QmFja2dyb3VuZCh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyLmRyYXdCYWNrZ3JvdW5kPy4odGFyZ2V0KTtcbiAgICB9XG59XG5jbGFzcyBTZXJpZXNQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhbmVWaWV3KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBwYW5lVmlldztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBjb25zdCBiYXNlUmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5yZW5kZXJlcigpO1xuICAgICAgICBpZiAoYmFzZVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gbmV3IFNlcmllc1ByaW1pdGl2ZVJlbmRlcmVyV3JhcHBlcihiYXNlUmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlUmVuZGVyZXIsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF96T3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy56T3JkZXI/LigpID8/ICdub3JtYWwnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEF4aXNWaWV3RGF0YShiYXNlVmlldykge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF90ZXh0OiBiYXNlVmlldy50ZXh0KCksXG4gICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiBiYXNlVmlldy5jb29yZGluYXRlKCksXG4gICAgICAgIF9pbnRlcm5hbF9maXhlZENvb3JkaW5hdGU6IGJhc2VWaWV3LmZpeGVkQ29vcmRpbmF0ZT8uKCksXG4gICAgICAgIF9pbnRlcm5hbF9jb2xvcjogYmFzZVZpZXcudGV4dENvbG9yKCksXG4gICAgICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kOiBiYXNlVmlldy5iYWNrQ29sb3IoKSxcbiAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGJhc2VWaWV3LnZpc2libGU/LigpID8/IHRydWUsXG4gICAgICAgIF9pbnRlcm5hbF90aWNrVmlzaWJsZTogYmFzZVZpZXcudGlja1Zpc2libGU/LigpID8/IHRydWUsXG4gICAgfTtcbn1cbmNsYXNzIFNlcmllc1ByaW1pdGl2ZVRpbWVBeGlzVmlld1dyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VWaWV3LCB0aW1lU2NhbGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgVGltZUF4aXNWaWV3UmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVZpZXcgPSBiYXNlVmlldztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlID0gdGltZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aDogdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF93aWR0aCgpLFxuICAgICAgICAgICAgLi4uZ2V0QXhpc1ZpZXdEYXRhKHRoaXMuX3ByaXZhdGVfX2Jhc2VWaWV3KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG59XG5jbGFzcyBTZXJpZXNQcmltaXRpdmVQcmljZUF4aXNWaWV3V3JhcHBlciBleHRlbmRzIFByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VWaWV3LCBwcmljZVNjYWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VWaWV3ID0gYmFzZVZpZXc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZVJlbmRlcmVyRGF0YShheGlzUmVuZGVyZXJEYXRhLCBwYW5lUmVuZGVyZXJEYXRhLCBjb21tb25SZW5kZXJlckRhdGEpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEF4aXNWaWV3RGF0YSh0aGlzLl9wcml2YXRlX19iYXNlVmlldyk7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZCA9IGRhdGEuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX2NvbG9yID0gZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxQYWRkaW5nID0gMiAvIDEyICogdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9udFNpemUoKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ1RvcCA9IGFkZGl0aW9uYWxQYWRkaW5nO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nQm90dG9tID0gYWRkaXRpb25hbFBhZGRpbmc7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSA9IGRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfZml4ZWRDb29yZGluYXRlID0gZGF0YS5faW50ZXJuYWxfZml4ZWRDb29yZGluYXRlO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gZGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGRhdGEuX2ludGVybmFsX3Zpc2libGU7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlID0gZGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGU7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlV3JhcHBlciBleHRlbmRzIFByaW1pdGl2ZVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZSwgc2VyaWVzKSB7XG4gICAgICAgIHN1cGVyKHByaW1pdGl2ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzVmlld3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNQYW5lVmlld3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzUGFuZVZpZXdzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS50aW1lQXhpc1ZpZXdzPy4oKSA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzVmlld3NDYWNoZT8uX2ludGVybmFsX2Jhc2UgPT09IGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChhdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVRpbWVBeGlzVmlld1dyYXBwZXIoYXcsIHRpbWVTY2FsZSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXdzQ2FjaGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZTogYmFzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5wcmljZUF4aXNWaWV3cz8uKCkgPz8gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c0NhY2hlPy5faW50ZXJuYWxfYmFzZSA9PT0gYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gYmFzZS5tYXAoKGF3KSA9PiBuZXcgU2VyaWVzUHJpbWl0aXZlUHJpY2VBeGlzVmlld1dyYXBwZXIoYXcsIHByaWNlU2NhbGUpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NDYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3dyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VBeGlzUGFuZVZpZXdzKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5wcmljZUF4aXNQYW5lVmlld3M/LigpID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChwdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlcihwdykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNQYW5lVmlld3NDYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3dyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZUF4aXNQYW5lVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLnRpbWVBeGlzUGFuZVZpZXdzPy4oKSA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzUGFuZVZpZXdzQ2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNQYW5lVmlld3NDYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gYmFzZS5tYXAoKHB3KSA9PiBuZXcgU2VyaWVzUHJpbWl0aXZlUGFuZVZpZXdXcmFwcGVyKHB3KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzUGFuZVZpZXdzQ2FjaGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZTogYmFzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2F1dG9zY2FsZUluZm8oc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuYXV0b3NjYWxlSW5mbz8uKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpID8/IG51bGwpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyhwcmltaXRpdmVzLCBleHRyYWN0b3IsIHpPcmRlciwgZGVzdGluYXRpb24pIHtcbiAgICBwcmltaXRpdmVzLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgZXh0cmFjdG9yKHdyYXBwZXIpLmZvckVhY2goKHBhbmVWaWV3KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFuZVZpZXcuX2ludGVybmFsX3pPcmRlcigpICE9PSB6T3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBhbmVWaWV3KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmltaXRpdmVQYW5lVmlld3NFeHRyYWN0b3Iod3JhcHBlcikge1xuICAgIHJldHVybiB3cmFwcGVyLl9pbnRlcm5hbF9wYW5lVmlld3MoKTtcbn1cbmZ1bmN0aW9uIHByaW1pdGl2ZVByaWNlUGFuZVZpZXdzRXh0cmFjdG9yKHdyYXBwZXIpIHtcbiAgICByZXR1cm4gd3JhcHBlci5faW50ZXJuYWxfcHJpY2VBeGlzUGFuZVZpZXdzKCk7XG59XG5mdW5jdGlvbiBwcmltaXRpdmVUaW1lUGFuZVZpZXdzRXh0cmFjdG9yKHdyYXBwZXIpIHtcbiAgICByZXR1cm4gd3JhcHBlci5faW50ZXJuYWxfdGltZUF4aXNQYW5lVmlld3MoKTtcbn1cbmNvbnN0IGxpbmVCYXNlZFNlcmllcyA9IFsnQXJlYScsICdMaW5lJywgJ0Jhc2VsaW5lJ107XG5jbGFzcyBTZXJpZXMgZXh0ZW5kcyBQcmljZURhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBzZXJpZXNUeXBlLCBvcHRpb25zLCBjcmVhdGVQYW5lVmlldywgY3VzdG9tUGFuZVZpZXcpIHtcbiAgICAgICAgc3VwZXIobW9kZWwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gY3JlYXRlU2VyaWVzUGxvdExpc3QoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldyA9IG5ldyBTZXJpZXNQcmljZUxpbmVQYW5lVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSG9yaXpvbnRhbExpbmVWaWV3ID0gbmV3IFNlcmllc0hvcml6b250YWxCYXNlTGluZVBhbmVWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPSBzZXJpZXNUeXBlO1xuICAgICAgICBjb25zdCBwcmljZUF4aXNWaWV3ID0gbmV3IFNlcmllc1ByaWNlQXhpc1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzID0gW3ByaWNlQXhpc1ZpZXddO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUHJpY2VBeGlzVmlldyA9IG5ldyBQYW5lUHJpY2VBeGlzVmlldyhwcmljZUF4aXNWaWV3LCB0aGlzLCBtb2RlbCk7XG4gICAgICAgIGlmIChsaW5lQmFzZWRTZXJpZXMuaW5jbHVkZXModGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3ID0gbmV3IFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gY3JlYXRlUGFuZVZpZXcodGhpcywgdGhpcy5faW50ZXJuYWxfbW9kZWwoKSwgY3VzdG9tUGFuZVZpZXcpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlTGluZUNvbG9yKGxhc3RCYXJDb2xvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUxpbmVDb2xvciB8fCBsYXN0QmFyQ29sb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sYXN0VmFsdWVEYXRhKGdsb2JhbExhc3QpIHtcbiAgICAgICAgY29uc3Qgbm9EYXRhUmVzID0geyBfaW50ZXJuYWxfbm9EYXRhOiB0cnVlIH07XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8IHByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub0RhdGFSZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCB8fCBmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgcmFuZ2Ugb2YgYmFycyBpbnNpZGUgcmFuZ2VcbiAgICAgICAgLy8gVE9ETzogbWFrZSBpdCBtb3JlIG9wdGltYWxcbiAgICAgICAgbGV0IGJhcjtcbiAgICAgICAgbGV0IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKGdsb2JhbExhc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9sYXN0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub0RhdGFSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXIgPSBsYXN0QmFyO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gbGFzdEJhci5faW50ZXJuYWxfaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbmRCYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZWFyY2godmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCksIC0xIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RMZWZ0ICovKTtcbiAgICAgICAgICAgIGlmIChlbmRCYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmFsdWVBdChlbmRCYXIuX2ludGVybmFsX2luZGV4KTtcbiAgICAgICAgICAgIGlmIChiYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluZGV4ID0gZW5kQmFyLl9pbnRlcm5hbF9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZSA9IGJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL107XG4gICAgICAgIGNvbnN0IGJhckNvbG9yZXIgPSB0aGlzLl9pbnRlcm5hbF9iYXJDb2xvcmVyKCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gYmFyQ29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUobGFzdEluZGV4LCB7IF9pbnRlcm5hbF92YWx1ZTogYmFyIH0pO1xuICAgICAgICBjb25zdCBjb29yZGluYXRlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ub0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlOiBwcmljZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiBwcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpLFxuICAgICAgICAgICAgX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGU6IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlQWJzb2x1dGUocHJpY2UpLFxuICAgICAgICAgICAgX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlUGVyY2VudGFnZTogcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2VQZXJjZW50YWdlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSksXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6IHN0eWxlLl9pbnRlcm5hbF9iYXJDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX2luZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJDb2xvcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSA9IG5ldyBTZXJpZXNCYXJDb2xvcmVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyQ29sb3JlckNhY2hlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0YXJnZXRQcmljZVNjYWxlSWQgPSBvcHRpb25zLnByaWNlU2NhbGVJZDtcbiAgICAgICAgaWYgKHRhcmdldFByaWNlU2NhbGVJZCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFByaWNlU2NhbGVJZCAhPT0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZVNjYWxlSWQpIHtcbiAgICAgICAgICAgIC8vIHNlcmllcyBjYW5ub3QgZG8gaXQgaXRzZWxmLCBhc2sgbW9kZWxcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX21vdmVTZXJpZXNUb1NjYWxlKHRoaXMsIHRhcmdldFByaWNlU2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnByaWNlRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAvLyB1cGRhdGVkIGZvcm1hdHRlciBtaWdodCBhZmZlY3QgcmVuZGVyaW5nICBhbmQgYXMgYSBjb25zZXF1ZW5jZSBvZiB0aGlzIHRoZSB3aWR0aCBvZiBwcmljZSBheGlzIG1pZ2h0IGJlIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIHRodXMgd2UgbmVlZCB0byBmb3JjZSB0aGUgY2hhcnQgdG8gZG8gYSBmdWxsIHVwZGF0ZSB0byBhcHBseSBjaGFuZ2VzIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gZnVsbCB1cGRhdGUgaXMgcXVpdGUgaGVhdnkgb3BlcmF0aW9uIGluIHRlcm1zIG9mIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBidXQgdXBkYXRpbmcgZm9ybWF0dGVyIGxvb2tzIGxpa2UgcXVpdGUgcmFyZSBzbyBmb3JjaW5nIGEgZnVsbCB1cGRhdGUgaGVyZSBzaG91bGRuJ3QgYWZmZWN0IHRoZSBwZXJmb3JtYW5jZSBhIGxvdFxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgLy8gYSBzZXJpZXMgbWlnaHQgYWZmZWN0IGNyb3NzaGFpciBieSBzb21lIG9wdGlvbnMgKGxpa2UgY3Jvc3NoYWlyIG1hcmtlcnMpXG4gICAgICAgIC8vIHRoYXQncyB3aHkgd2UgbmVlZCB0byB1cGRhdGUgY3Jvc3NoYWlyIGFzIHdlbGxcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoJ29wdGlvbnMnKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSwgdXBkYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCdkYXRhJyk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZUluZm8gJiYgdXBkYXRlSW5mby5faW50ZXJuYWxfbGFzdEJhclVwZGF0ZWRPck5ld0JhcnNBZGRlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldy5faW50ZXJuYWxfb25OZXdSZWFsdGltZURhdGFSZWNlaXZlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldy5faW50ZXJuYWxfb25EYXRhQ2xlYXJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZVBhbmUgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVBhbmUoc291cmNlUGFuZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jcmVhdGVQcmljZUxpbmUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQ3VzdG9tUHJpY2VMaW5lKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlU291cmNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlUHJpY2VMaW5lKGxpbmUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLmluZGV4T2YobGluZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UodGhpcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcztcbiAgICB9XG4gICAgX2ludGVybmFsX3Nlcmllc1R5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyc3RWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgYmFyID0gdGhpcy5faW50ZXJuYWxfZmlyc3RCYXIoKTtcbiAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92YWx1ZTogYmFyLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lUG9pbnQ6IGJhci5faW50ZXJuYWxfdGltZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpcnN0QmFyKCkge1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWVQb2ludCA9IHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9zZWFyY2goc3RhcnRUaW1lUG9pbnQsIDEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdFJpZ2h0ICovKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2JhcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGF0YUF0KHRpbWUpIHtcbiAgICAgICAgY29uc3QgcHJpY2VzID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmFsdWVBdCh0aW1lKTtcbiAgICAgICAgaWYgKHByaWNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdCYXInIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdDYW5kbGVzdGljaycgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0N1c3RvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX29wZW46IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaGlnaDogcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVsxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sb3c6IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi9dLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jbG9zZTogcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpY2VzLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdG9wUGFuZVZpZXdzKHBhbmUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGV4dHJhY3RQcmltaXRpdmVQYW5lVmlld3ModGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcywgcHJpbWl0aXZlUGFuZVZpZXdzRXh0cmFjdG9yLCAndG9wJywgcmVzKTtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uUGFuZVZpZXcgPSB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldztcbiAgICAgICAgaWYgKGFuaW1hdGlvblBhbmVWaWV3ID09PSBudWxsIHx8ICFhbmltYXRpb25QYW5lVmlldy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPT09IG51bGwgJiYgYW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX2FuaW1hdGlvbkFjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2N1cnNvclVwZGF0ZSgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX2ludmFsaWRhdGVTdGFnZSgpO1xuICAgICAgICByZXMudW5zaGlmdChhbmltYXRpb25QYW5lVmlldyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2lzT3ZlcmxheSgpKSB7XG4gICAgICAgICAgICByZXMucHVzaCh0aGlzLl9wcml2YXRlX19iYXNlSG9yaXpvbnRhbExpbmVWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaCh0aGlzLl9wcml2YXRlX19wYW5lVmlldywgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldyk7XG4gICAgICAgIGNvbnN0IHByaWNlTGluZVZpZXdzID0gdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcy5tYXAoKGxpbmUpID0+IGxpbmUuX2ludGVybmFsX3BhbmVWaWV3KCkpO1xuICAgICAgICByZXMucHVzaCguLi5wcmljZUxpbmVWaWV3cyk7XG4gICAgICAgIGV4dHJhY3RQcmltaXRpdmVQYW5lVmlld3ModGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcywgcHJpbWl0aXZlUGFuZVZpZXdzRXh0cmFjdG9yLCAnbm9ybWFsJywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2ludGVybmFsX2JvdHRvbVBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2V4dHJhY3RQYW5lVmlld3MocHJpbWl0aXZlUGFuZVZpZXdzRXh0cmFjdG9yLCAnYm90dG9tJyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVBhbmVWaWV3cyh6T3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2V4dHJhY3RQYW5lVmlld3MocHJpbWl0aXZlUHJpY2VQYW5lVmlld3NFeHRyYWN0b3IsIHpPcmRlcik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lUGFuZVZpZXdzKHpPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyhwcmltaXRpdmVUaW1lUGFuZVZpZXdzRXh0cmFjdG9yLCB6T3JkZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpbWl0aXZlSGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzXG4gICAgICAgICAgICAubWFwKChwcmltaXRpdmUpID0+IHByaW1pdGl2ZS5faW50ZXJuYWxfaGl0VGVzdCh4LCB5KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0ICE9PSBudWxsKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2xhYmVsUGFuZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVByaWNlQXhpc1ZpZXcsXG4gICAgICAgICAgICAuLi50aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLm1hcCgobGluZSkgPT4gbGluZS5faW50ZXJuYWxfbGFiZWxQYW5lVmlldygpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgIT09IHRoaXMuX2ludGVybmFsX19wcmljZVNjYWxlICYmICF0aGlzLl9wcml2YXRlX19pc092ZXJsYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi50aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c107XG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tUHJpY2VMaW5lIG9mIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1c3RvbVByaWNlTGluZS5faW50ZXJuYWxfcHJpY2VBeGlzVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLndyYXBwZXIuX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgICAgIHJlcy5wdXNoKC4uLndyYXBwZXIuX2ludGVybmFsX3RpbWVBeGlzVmlld3MoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXV0b3NjYWxlSW5mbyhzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9zY2FsZUluZm9Qcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRvc2NhbGVJbmZvID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvc2NhbGVJbmZvUHJvdmlkZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX3ByaXZhdGVfX2F1dG9zY2FsZUluZm9JbXBsKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVzID09PSBudWxsKSA/IG51bGwgOiByZXMuX2ludGVybmFsX3RvUmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBdXRvc2NhbGVJbmZvSW1wbC5faW50ZXJuYWxfZnJvbVJhdyhhdXRvc2NhbGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXV0b3NjYWxlSW5mb0ltcGwoc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9taW5Nb3ZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5taW5Nb3ZlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmljZUF4aXNWaWV3IG9mIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzKSB7XG4gICAgICAgICAgICBwcmljZUF4aXNWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbVByaWNlTGluZSBvZiB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzKSB7XG4gICAgICAgICAgICBjdXN0b21QcmljZUxpbmUuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSG9yaXpvbnRhbExpbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXc/Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB3cmFwcGVyLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHN1cGVyLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFya2VyRGF0YUF0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0xpbmUnIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdBcmVhJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQmFzZWxpbmUnKSAmJlxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJWaXNpYmxlO1xuICAgICAgICBpZiAoIWdldFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXIgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92YWx1ZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2UgPSBiYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dO1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJSYWRpdXMoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJCb3JkZXJDb2xvcigpO1xuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX21hcmtlckJvcmRlcldpZHRoKCk7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHRoaXMuX3ByaXZhdGVfX21hcmtlckJhY2tncm91bmRDb2xvcihpbmRleCk7XG4gICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9wcmljZTogcHJpY2UsIF9pbnRlcm5hbF9yYWRpdXM6IHJhZGl1cywgX2ludGVybmFsX2JvcmRlckNvbG9yOiBib3JkZXJDb2xvciwgX2ludGVybmFsX2JvcmRlcldpZHRoOiBib3JkZXJXaWR0aCwgX2ludGVybmFsX2JhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGl0bGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy52aXNpYmxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLnB1c2gobmV3IFNlcmllc1ByaW1pdGl2ZVdyYXBwZXIocHJpbWl0aXZlLCB0aGlzKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXRhY2hQcmltaXRpdmUoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMgPSB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZpbHRlcigod3JhcHBlcikgPT4gd3JhcHBlci5faW50ZXJuYWxfcHJpbWl0aXZlKCkgIT09IHNvdXJjZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgIT09ICdDdXN0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF9wcmljZVZhbHVlQnVpbGRlcihkYXRhKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX2N1c3RvbVNlcmllc1doaXRlc3BhY2VDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgIT09ICdDdXN0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF9pc1doaXRlc3BhY2UoZGF0YSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mdWxmaWxsZWRJbmRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaW5kaWNlcygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faXNPdmVybGF5KCkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICByZXR1cm4gIWlzRGVmYXVsdFByaWNlU2NhbGUocHJpY2VTY2FsZS5faW50ZXJuYWxfaWQoKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hdXRvc2NhbGVJbmZvSW1wbChzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KSB7XG4gICAgICAgIGlmICghaXNJbnRlZ2VyKHN0YXJ0VGltZVBvaW50KSB8fCAhaXNJbnRlZ2VyKGVuZFRpbWVQb2ludCkgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzXG4gICAgICAgIC8vIHNlcmllcyBkYXRhIGlzIHN0cm9uZ2x5IGhhcmRjb2RlZCB0byBrZWVwIGJhcnNcbiAgICAgICAgY29uc3QgcGxvdHMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnTGluZScgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0FyZWEnIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdCYXNlbGluZScgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0hpc3RvZ3JhbSdcbiAgICAgICAgICAgID8gWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dXG4gICAgICAgICAgICA6IFsyIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkxvdyAqLywgMSAvKiBQbG90Um93VmFsdWVJbmRleC5IaWdoICovXTtcbiAgICAgICAgY29uc3QgYmFyc01pbk1heCA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX21pbk1heE9uUmFuZ2VDYWNoZWQoc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCwgcGxvdHMpO1xuICAgICAgICBsZXQgcmFuZ2UgPSBiYXJzTWluTWF4ICE9PSBudWxsID8gbmV3IFByaWNlUmFuZ2VJbXBsKGJhcnNNaW5NYXguX2ludGVybmFsX21pbiwgYmFyc01pbk1heC5faW50ZXJuYWxfbWF4KSA6IG51bGw7XG4gICAgICAgIGxldCBtYXJnaW5zID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKSA9PT0gJ0hpc3RvZ3JhbScpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmJhc2U7XG4gICAgICAgICAgICBjb25zdCByYW5nZVdpdGhCYXNlID0gbmV3IFByaWNlUmFuZ2VJbXBsKGJhc2UsIGJhc2UpO1xuICAgICAgICAgICAgcmFuZ2UgPSByYW5nZSAhPT0gbnVsbCA/IHJhbmdlLl9pbnRlcm5hbF9tZXJnZShyYW5nZVdpdGhCYXNlKSA6IHJhbmdlV2l0aEJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKChwcmltaXRpdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZUF1dG9zY2FsZSA9IHByaW1pdGl2ZS5faW50ZXJuYWxfYXV0b3NjYWxlSW5mbyhzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmVBdXRvc2NhbGU/LnByaWNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltaXRpdmVSYW5nZSA9IG5ldyBQcmljZVJhbmdlSW1wbChwcmltaXRpdmVBdXRvc2NhbGUucHJpY2VSYW5nZS5taW5WYWx1ZSwgcHJpbWl0aXZlQXV0b3NjYWxlLnByaWNlUmFuZ2UubWF4VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UgIT09IG51bGwgPyByYW5nZS5faW50ZXJuYWxfbWVyZ2UocHJpbWl0aXZlUmFuZ2UpIDogcHJpbWl0aXZlUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlQXV0b3NjYWxlPy5tYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2lucyA9IHByaW1pdGl2ZUF1dG9zY2FsZS5tYXJnaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRvc2NhbGVJbmZvSW1wbChyYW5nZSwgbWFyZ2lucyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJSYWRpdXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgICAgICBjYXNlICdBcmVhJzpcbiAgICAgICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJCb3JkZXJDb2xvcigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ0FyZWEnOlxuICAgICAgICAgICAgY2FzZSAnQmFzZWxpbmUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3IgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21hcmtlckJvcmRlcldpZHRoKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xpbmUnOlxuICAgICAgICAgICAgY2FzZSAnQXJlYSc6XG4gICAgICAgICAgICBjYXNlICdCYXNlbGluZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY3Jvc3NoYWlyTWFya2VyQm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJCYWNrZ3JvdW5kQ29sb3IoaW5kZXgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ0FyZWEnOlxuICAgICAgICAgICAgY2FzZSAnQmFzZWxpbmUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2JhckNvbG9yZXIoKS5faW50ZXJuYWxfYmFyU3R5bGUoaW5kZXgpLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY3JlYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VzdG9tJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IHsgZm9ybWF0OiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LmZvcm1hdHRlciB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndm9sdW1lJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IG5ldyBWb2x1bWVGb3JtYXR0ZXIodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncGVyY2VudCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBuZXcgUGVyY2VudGFnZUZvcm1hdHRlcih0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IE1hdGgucG93KDEwLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gbmV3IFByaWNlRm9ybWF0dGVyKHByaWNlU2NhbGUsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQubWluTW92ZSAqIHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19leHRyYWN0UGFuZVZpZXdzKGV4dHJhY3Rvciwgek9yZGVyKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBleHRyYWN0UHJpbWl0aXZlUGFuZVZpZXdzKHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMsIGV4dHJhY3Rvciwgek9yZGVyLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cblxuY29uc3QgbWFnbmV0UGxvdFJvd0tleXMgPSBbXG4gICAgMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqLyxcbl07XG5jb25zdCBtYWduZXRPSExDUGxvdFJvd0tleXMgPSBbXG4gICAgMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovLFxuICAgIDEgLyogUGxvdFJvd1ZhbHVlSW5kZXguSGlnaCAqLyxcbiAgICAyIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkxvdyAqLyxcbiAgICAzIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovLFxuXTtcbmNsYXNzIE1hZ25ldCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX2FsaWduKHByaWNlLCBpbmRleCwgcGFuZSkge1xuICAgICAgICBsZXQgcmVzID0gcHJpY2U7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDAgLyogQ3Jvc3NoYWlyTW9kZS5Ob3JtYWwgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdFByaWNlU2NhbGUgPSBwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gZGVmYXVsdFByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeSA9IGRlZmF1bHRQcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIC8vIGdldCBhbGwgc2VyaWVzZXMgZnJvbSB0aGUgcGFuZVxuICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHBhbmUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkuZmlsdGVyKCgoZHMpID0+IChkcyBpbnN0YW5jZW9mIFNlcmllcykpKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHNlcmllc2VzLnJlZHVjZSgoYWNjLCBzZXJpZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChwYW5lLl9pbnRlcm5hbF9pc092ZXJsYXkoc2VyaWVzKSB8fCAhc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHMgPSBzZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJhcnMgPSBzZXJpZXMuX2ludGVybmFsX2JhcnMoKTtcbiAgICAgICAgICAgIGlmIChwcy5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICFiYXJzLl9pbnRlcm5hbF9jb250YWlucyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFycy5faW50ZXJuYWxfdmFsdWVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoYmFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFyIHRvIHBpeGVsc1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQcmljZSA9IGVuc3VyZShzZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSk7XG4gICAgICAgICAgICBjb25zdCBwbG90Um93S2V5cyA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSA9PT0gMyAvKiBDcm9zc2hhaXJNb2RlLk1hZ25ldE9ITEMgKi9cbiAgICAgICAgICAgICAgICA/IG1hZ25ldE9ITENQbG90Um93S2V5c1xuICAgICAgICAgICAgICAgIDogbWFnbmV0UGxvdFJvd0tleXM7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChwbG90Um93S2V5cy5tYXAoKGtleSkgPT4gcHMuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKGJhci5faW50ZXJuYWxfdmFsdWVba2V5XSwgZmlyc3RQcmljZS5faW50ZXJuYWxfdmFsdWUpKSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZXMuc29ydCgoeTEsIHkyKSA9PiBNYXRoLmFicyh5MSAtIHkpIC0gTWF0aC5hYnMoeTIgLSB5KSk7XG4gICAgICAgIGNvbnN0IG5lYXJlc3QgPSBjYW5kaWRhdGVzWzBdO1xuICAgICAgICByZXMgPSBkZWZhdWx0UHJpY2VTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UobmVhcmVzdCwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluVmFsLCBtYXhWYWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pblZhbCksIG1heFZhbCk7XG59XG5mdW5jdGlvbiBpc0Jhc2VEZWNpbWFsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGN1cnJlbnQgPSB2YWx1ZTsgY3VycmVudCA+IDE7IGN1cnJlbnQgLz0gMTApIHtcbiAgICAgICAgaWYgKChjdXJyZW50ICUgMTApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBncmVhdGVyT3JFcXVhbCh4MSwgeDIsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gKHgyIC0geDEpIDw9IGVwc2lsb247XG59XG5mdW5jdGlvbiBlcXVhbCh4MSwgeDIsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPCBlcHNpbG9uO1xufVxuLy8gV2UgY2FuJ3QgdXNlIE1hdGgubWluKC4uLmFycikgYmVjYXVzZSB0aGF0IHdvdWxkIG9ubHkgc3VwcG9ydCBhcnJheXMgc2hvcnRlciB0aGFuIDY1NTM2IGl0ZW1zLlxuZnVuY3Rpb24gbWluKGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignYXJyYXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgbGV0IG1pblZhbCA9IGFyclswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDwgbWluVmFsKSB7XG4gICAgICAgICAgICBtaW5WYWwgPSBhcnJbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pblZhbDtcbn1cbmZ1bmN0aW9uIGNlaWxlZEV2ZW4oeCkge1xuICAgIGNvbnN0IGNlaWxlZCA9IE1hdGguY2VpbCh4KTtcbiAgICByZXR1cm4gKGNlaWxlZCAlIDIgIT09IDApID8gY2VpbGVkIC0gMSA6IGNlaWxlZDtcbn1cbmZ1bmN0aW9uIGNlaWxlZE9kZCh4KSB7XG4gICAgY29uc3QgY2VpbGVkID0gTWF0aC5jZWlsKHgpO1xuICAgIHJldHVybiAoY2VpbGVkICUgMiA9PT0gMCkgPyBjZWlsZWQgLSAxIDogY2VpbGVkO1xufVxuXG5jbGFzcyBHcmlkUmVuZGVyZXIgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHN0cm9rZUluUGl4ZWwoY3R4LCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGF0YS5faW50ZXJuYWxfdmVydExpbmVzQ29sb3I7XG4gICAgICAgICAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgZGF0YS5faW50ZXJuYWxfdmVydExpbmVTdHlsZSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGltZU1hcmsgb2YgZGF0YS5faW50ZXJuYWxfdGltZU1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHRpbWVNYXJrLl9pbnRlcm5hbF9jb29yZCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCAtbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBiaXRtYXBTaXplLmhlaWdodCArIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLl9pbnRlcm5hbF9ob3J6TGluZXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGF0YS5faW50ZXJuYWxfaG9yekxpbmVzQ29sb3I7XG4gICAgICAgICAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgZGF0YS5faW50ZXJuYWxfaG9yekxpbmVTdHlsZSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJpY2VNYXJrIG9mIGRhdGEuX2ludGVybmFsX3ByaWNlTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQocHJpY2VNYXJrLl9pbnRlcm5hbF9jb29yZCAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oLWxpbmVXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYml0bWFwU2l6ZS53aWR0aCArIGxpbmVXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBHcmlkUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHBhbmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgR3JpZFJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IHBhbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfb3B0aW9ucygpLmdyaWQ7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6TGluZXNWaXNpYmxlOiBncmlkT3B0aW9ucy5ob3J6TGluZXMudmlzaWJsZSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdmVydExpbmVzVmlzaWJsZTogZ3JpZE9wdGlvbnMudmVydExpbmVzLnZpc2libGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hvcnpMaW5lc0NvbG9yOiBncmlkT3B0aW9ucy5ob3J6TGluZXMuY29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRMaW5lc0NvbG9yOiBncmlkT3B0aW9ucy52ZXJ0TGluZXMuY29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hvcnpMaW5lU3R5bGU6IGdyaWRPcHRpb25zLmhvcnpMaW5lcy5zdHlsZSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdmVydExpbmVTdHlsZTogZ3JpZE9wdGlvbnMudmVydExpbmVzLnN0eWxlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wcmljZU1hcmtzOiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9tYXJrcygpLFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBjb252ZXJzaW9tIGJlY2F1c2UgVGltZU1hcmsgaXMgYSBwYXJ0IG9mIGV4dGVybmFsIGludGVyZmFjZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBmaWVsZHMgaW5zaWRlIFRpbWVNYXJrIGFyZSBub3QgbWluaWZpZWRcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZU1hcmtzOiAodGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX21hcmtzKCkgfHwgW10pLm1hcCgodG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgX2ludGVybmFsX2Nvb3JkOiB0bS5jb29yZCB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxufVxuXG5jbGFzcyBHcmlkIHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbmV3IEdyaWRQYW5lVmlldyhwYW5lKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXc7XG4gICAgfVxufVxuXG5jb25zdCBkZWZMb2dGb3JtdWxhID0ge1xuICAgIF9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0OiA0LFxuICAgIF9pbnRlcm5hbF9jb29yZE9mZnNldDogMC4wMDAxLFxufTtcbmZ1bmN0aW9uIGZyb21QZXJjZW50KHZhbHVlLCBiYXNlVmFsdWUpIHtcbiAgICBpZiAoYmFzZVZhbHVlIDwgMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAvIDEwMCkgKiBiYXNlVmFsdWUgKyBiYXNlVmFsdWU7XG59XG5mdW5jdGlvbiB0b1BlcmNlbnQodmFsdWUsIGJhc2VWYWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IDEwMCAqICh2YWx1ZSAtIGJhc2VWYWx1ZSkgLyBiYXNlVmFsdWU7XG4gICAgcmV0dXJuIChiYXNlVmFsdWUgPCAwID8gLXJlc3VsdCA6IHJlc3VsdCk7XG59XG5mdW5jdGlvbiB0b1BlcmNlbnRSYW5nZShwcmljZVJhbmdlLCBiYXNlVmFsdWUpIHtcbiAgICBjb25zdCBtaW5QZXJjZW50ID0gdG9QZXJjZW50KHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIGJhc2VWYWx1ZSk7XG4gICAgY29uc3QgbWF4UGVyY2VudCA9IHRvUGVyY2VudChwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBiYXNlVmFsdWUpO1xuICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwobWluUGVyY2VudCwgbWF4UGVyY2VudCk7XG59XG5mdW5jdGlvbiBmcm9tSW5kZXhlZFRvMTAwKHZhbHVlLCBiYXNlVmFsdWUpIHtcbiAgICB2YWx1ZSAtPSAxMDA7XG4gICAgaWYgKGJhc2VWYWx1ZSA8IDApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLyAxMDApICogYmFzZVZhbHVlICsgYmFzZVZhbHVlO1xufVxuZnVuY3Rpb24gdG9JbmRleGVkVG8xMDAodmFsdWUsIGJhc2VWYWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IDEwMCAqICh2YWx1ZSAtIGJhc2VWYWx1ZSkgLyBiYXNlVmFsdWUgKyAxMDA7XG4gICAgcmV0dXJuIChiYXNlVmFsdWUgPCAwID8gLXJlc3VsdCA6IHJlc3VsdCk7XG59XG5mdW5jdGlvbiB0b0luZGV4ZWRUbzEwMFJhbmdlKHByaWNlUmFuZ2UsIGJhc2VWYWx1ZSkge1xuICAgIGNvbnN0IG1pblBlcmNlbnQgPSB0b0luZGV4ZWRUbzEwMChwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBiYXNlVmFsdWUpO1xuICAgIGNvbnN0IG1heFBlcmNlbnQgPSB0b0luZGV4ZWRUbzEwMChwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBiYXNlVmFsdWUpO1xuICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwobWluUGVyY2VudCwgbWF4UGVyY2VudCk7XG59XG5mdW5jdGlvbiB0b0xvZyhwcmljZSwgbG9nRm9ybXVsYSkge1xuICAgIGNvbnN0IG0gPSBNYXRoLmFicyhwcmljZSk7XG4gICAgaWYgKG0gPCAxZS0xNSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gTWF0aC5sb2cxMChtICsgbG9nRm9ybXVsYS5faW50ZXJuYWxfY29vcmRPZmZzZXQpICsgbG9nRm9ybXVsYS5faW50ZXJuYWxfbG9naWNhbE9mZnNldDtcbiAgICByZXR1cm4gKChwcmljZSA8IDApID8gLXJlcyA6IHJlcyk7XG59XG5mdW5jdGlvbiBmcm9tTG9nKGxvZ2ljYWwsIGxvZ0Zvcm11bGEpIHtcbiAgICBjb25zdCBtID0gTWF0aC5hYnMobG9naWNhbCk7XG4gICAgaWYgKG0gPCAxZS0xNSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gTWF0aC5wb3coMTAsIG0gLSBsb2dGb3JtdWxhLl9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0KSAtIGxvZ0Zvcm11bGEuX2ludGVybmFsX2Nvb3JkT2Zmc2V0O1xuICAgIHJldHVybiAobG9naWNhbCA8IDApID8gLXJlcyA6IHJlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQcmljZVJhbmdlVG9Mb2cocHJpY2VSYW5nZSwgbG9nRm9ybXVsYSkge1xuICAgIGlmIChwcmljZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSB0b0xvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICBjb25zdCBtYXggPSB0b0xvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICByZXR1cm4gbmV3IFByaWNlUmFuZ2VJbXBsKG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnZlcnRQcmljZVJhbmdlRnJvbUxvZyhwcmljZVJhbmdlLCBsb2dGb3JtdWxhKSB7XG4gICAgaWYgKHByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSBmcm9tTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIGNvbnN0IG1heCA9IGZyb21Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgcmV0dXJuIGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUobWF4KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQcmljZVJhbmdlRnJvbUxvZyhwcmljZVJhbmdlLCBsb2dGb3JtdWxhKSB7XG4gICAgaWYgKHByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IGZyb21Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgY29uc3QgbWF4ID0gZnJvbUxvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICByZXR1cm4gbmV3IFByaWNlUmFuZ2VJbXBsKG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIGxvZ0Zvcm11bGFGb3JQcmljZVJhbmdlKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZMb2dGb3JtdWxhO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMocmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCkgLSByYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSk7XG4gICAgaWYgKGRpZmYgPj0gMSB8fCBkaWZmIDwgMWUtMTUpIHtcbiAgICAgICAgcmV0dXJuIGRlZkxvZ0Zvcm11bGE7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2l0cyA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLmxvZzEwKGRpZmYpKSk7XG4gICAgY29uc3QgbG9naWNhbE9mZnNldCA9IGRlZkxvZ0Zvcm11bGEuX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQgKyBkaWdpdHM7XG4gICAgY29uc3QgY29vcmRPZmZzZXQgPSAxIC8gTWF0aC5wb3coMTAsIGxvZ2ljYWxPZmZzZXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0OiBsb2dpY2FsT2Zmc2V0LFxuICAgICAgICBfaW50ZXJuYWxfY29vcmRPZmZzZXQ6IGNvb3JkT2Zmc2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBsb2dGb3JtdWxhc0FyZVNhbWUoZjEsIGYyKSB7XG4gICAgcmV0dXJuIGYxLl9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0ID09PSBmMi5faW50ZXJuYWxfbG9naWNhbE9mZnNldCAmJiBmMS5faW50ZXJuYWxfY29vcmRPZmZzZXQgPT09IGYyLl9pbnRlcm5hbF9jb29yZE9mZnNldDtcbn1cblxuY2xhc3MgUHJpY2VUaWNrU3BhbkNhbGN1bGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGludGVncmFsRGl2aWRlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludGVncmFsRGl2aWRlcnMgPSBpbnRlZ3JhbERpdmlkZXJzO1xuICAgICAgICBpZiAoaXNCYXNlRGVjaW1hbCh0aGlzLl9wcml2YXRlX19iYXNlKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzID0gWzIsIDIuNSwgMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJhc2VSZXN0ID0gdGhpcy5fcHJpdmF0ZV9fYmFzZTsgYmFzZVJlc3QgIT09IDE7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChiYXNlUmVzdCAlIDIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycy5wdXNoKDIpO1xuICAgICAgICAgICAgICAgICAgICBiYXNlUmVzdCAvPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYmFzZVJlc3QgJSA1KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMucHVzaCgyLCAyLjUpO1xuICAgICAgICAgICAgICAgICAgICBiYXNlUmVzdCAvPSA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGJhc2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycy5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb21ldGhpbmcgd3Jvbmcgd2l0aCBiYXNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aWNrU3BhbihoaWdoLCBsb3csIG1heFRpY2tTcGFuKSB7XG4gICAgICAgIGNvbnN0IG1pbk1vdmVtZW50ID0gKHRoaXMuX3ByaXZhdGVfX2Jhc2UgPT09IDApID8gKDApIDogKDEgLyB0aGlzLl9wcml2YXRlX19iYXNlKTtcbiAgICAgICAgbGV0IHJlc3VsdFRpY2tTcGFuID0gTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZzEwKGhpZ2ggLSBsb3cpKSkpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgYyA9IHRoaXMuX3ByaXZhdGVfX2ludGVncmFsRGl2aWRlcnNbMF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzZWNvbmQgcGFydCBpcyBhY3R1YWwgZm9yIHNtYWxsIHdpdGggdmVyeSBzbWFsbCB2YWx1ZXMgbGlrZSAxZS0xMFxuICAgICAgICAgICAgLy8gZ3JlYXRlck9yRXF1YWwgZmFpbHMgZm9yIHN1Y2ggdmFsdWVzXG4gICAgICAgICAgICBjb25zdCByZXN1bHRUaWNrU3Bhbkxhcmdlck1pbk1vdmVtZW50ID0gZ3JlYXRlck9yRXF1YWwocmVzdWx0VGlja1NwYW4sIG1pbk1vdmVtZW50LCAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKSAmJiByZXN1bHRUaWNrU3BhbiA+IChtaW5Nb3ZlbWVudCArIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0VGlja1NwYW5MYXJnZXJNYXhUaWNrU3BhbiA9IGdyZWF0ZXJPckVxdWFsKHJlc3VsdFRpY2tTcGFuLCBtYXhUaWNrU3BhbiAqIGMsIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0VGlja1NwYW5MYXJnZXIxID0gZ3JlYXRlck9yRXF1YWwocmVzdWx0VGlja1NwYW4sIDEsIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pO1xuICAgICAgICAgICAgY29uc3QgaGF2ZVRvQ29udGludWUgPSByZXN1bHRUaWNrU3Bhbkxhcmdlck1pbk1vdmVtZW50ICYmIHJlc3VsdFRpY2tTcGFuTGFyZ2VyTWF4VGlja1NwYW4gJiYgcmVzdWx0VGlja1NwYW5MYXJnZXIxO1xuICAgICAgICAgICAgaWYgKCFoYXZlVG9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0VGlja1NwYW4gLz0gYztcbiAgICAgICAgICAgIGMgPSB0aGlzLl9wcml2YXRlX19pbnRlZ3JhbERpdmlkZXJzWysraW5kZXggJSB0aGlzLl9wcml2YXRlX19pbnRlZ3JhbERpdmlkZXJzLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFRpY2tTcGFuIDw9IChtaW5Nb3ZlbWVudCArIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pKSB7XG4gICAgICAgICAgICByZXN1bHRUaWNrU3BhbiA9IG1pbk1vdmVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFRpY2tTcGFuID0gTWF0aC5tYXgoMSwgcmVzdWx0VGlja1NwYW4pO1xuICAgICAgICBpZiAoKHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycy5sZW5ndGggPiAwKSAmJiBlcXVhbChyZXN1bHRUaWNrU3BhbiwgMSwgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLykpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGMgPSB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnNbMF07XG4gICAgICAgICAgICB3aGlsZSAoZ3JlYXRlck9yRXF1YWwocmVzdWx0VGlja1NwYW4sIG1heFRpY2tTcGFuICogYywgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLykgJiYgcmVzdWx0VGlja1NwYW4gPiAobWluTW92ZW1lbnQgKyAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFRpY2tTcGFuIC89IGM7XG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVyc1srK2luZGV4ICUgdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzLmxlbmd0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFRpY2tTcGFuO1xuICAgIH1cbn1cblxuY29uc3QgVElDS19ERU5TSVRZID0gMi41O1xuY2xhc3MgUHJpY2VUaWNrTWFya0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlU2NhbGUsIGJhc2UsIGNvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jLCBsb2dpY2FsVG9Db29yZGluYXRlRnVuYykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jID0gY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jID0gbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aWNrU3BhbihoaWdoLCBsb3cpIHtcbiAgICAgICAgaWYgKGhpZ2ggPCBsb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGlnaCA8IGxvdycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYWxlSGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IG1hcmtIZWlnaHQgPSB0aGlzLl9wcml2YXRlX190aWNrTWFya0hlaWdodCgpO1xuICAgICAgICBjb25zdCBtYXhUaWNrU3BhbiA9IChoaWdoIC0gbG93KSAqIG1hcmtIZWlnaHQgLyBzY2FsZUhlaWdodDtcbiAgICAgICAgY29uc3Qgc3BhbkNhbGN1bGF0b3IxID0gbmV3IFByaWNlVGlja1NwYW5DYWxjdWxhdG9yKHRoaXMuX3ByaXZhdGVfX2Jhc2UsIFsyLCAyLjUsIDJdKTtcbiAgICAgICAgY29uc3Qgc3BhbkNhbGN1bGF0b3IyID0gbmV3IFByaWNlVGlja1NwYW5DYWxjdWxhdG9yKHRoaXMuX3ByaXZhdGVfX2Jhc2UsIFsyLCAyLCAyLjVdKTtcbiAgICAgICAgY29uc3Qgc3BhbkNhbGN1bGF0b3IzID0gbmV3IFByaWNlVGlja1NwYW5DYWxjdWxhdG9yKHRoaXMuX3ByaXZhdGVfX2Jhc2UsIFsyLjUsIDIsIDJdKTtcbiAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgc3BhbnMucHVzaChzcGFuQ2FsY3VsYXRvcjEuX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdywgbWF4VGlja1NwYW4pLCBzcGFuQ2FsY3VsYXRvcjIuX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdywgbWF4VGlja1NwYW4pLCBzcGFuQ2FsY3VsYXRvcjMuX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdywgbWF4VGlja1NwYW4pKTtcbiAgICAgICAgcmV0dXJuIG1pbihzcGFucyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWJ1aWxkVGlja01hcmtzKCkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NhbGVIZWlnaHQgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9oZWlnaHQoKTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMoc2NhbGVIZWlnaHQgLSAxLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMoMCwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4dHJhVG9wQm90dG9tTWFyZ2luID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLmVudGlyZVRleHRPbmx5ID8gdGhpcy5fcHJpdmF0ZV9fZm9udEhlaWdodCgpIC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IG1pbkNvb3JkID0gZXh0cmFUb3BCb3R0b21NYXJnaW47XG4gICAgICAgIGNvbnN0IG1heENvb3JkID0gc2NhbGVIZWlnaHQgLSAxIC0gZXh0cmFUb3BCb3R0b21NYXJnaW47XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBNYXRoLm1heChib3R0b20sIHRvcCk7XG4gICAgICAgIGNvbnN0IGxvdyA9IE1hdGgubWluKGJvdHRvbSwgdG9wKTtcbiAgICAgICAgaWYgKGhpZ2ggPT09IGxvdykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3MgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5faW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlTWFya3MoZmlyc3RWYWx1ZSwgc3BhbiwgaGlnaCwgbG93LCBtaW5Db29yZCwgbWF4Q29vcmQpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaGFzVmlzaWJsZUVkZ2VNYXJrcygpICYmIHRoaXMuX3ByaXZhdGVfX3Nob3VsZEFwcGx5RWRnZU1hcmtzKHNwYW4sIGxvdywgaGlnaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9nZXRFZGdlTWFya3NQYWRkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseUVkZ2VNYXJrcyhmaXJzdFZhbHVlLCBzcGFuLCBtaW5Db29yZCwgbWF4Q29vcmQsIHBhZGRpbmcsIHBhZGRpbmcgKiAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXJrcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb250U2l6ZSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdGlja01hcmtIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fZm9udEhlaWdodCgpICogVElDS19ERU5TSVRZKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZU1hcmtzKGZpcnN0VmFsdWUsIHNwYW4sIGhpZ2gsIGxvdywgbWluQ29vcmQsIG1heENvb3JkKSB7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gdGhpcy5fcHJpdmF0ZV9fbWFya3M7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICBsZXQgbW9kID0gaGlnaCAlIHNwYW47XG4gICAgICAgIG1vZCArPSBtb2QgPCAwID8gc3BhbiA6IDA7XG4gICAgICAgIGNvbnN0IHNpZ24gPSAoaGlnaCA+PSBsb3cpID8gMSA6IC0xO1xuICAgICAgICBsZXQgcHJldkNvb3JkID0gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbG9naWNhbCA9IGhpZ2ggLSBtb2Q7IGxvZ2ljYWwgPiBsb3c7IGxvZ2ljYWwgLT0gc3Bhbikge1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlRnVuYyhsb2dpY2FsLCBmaXJzdFZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIHBsYWNlIGZvciBpdFxuICAgICAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBmb3IgbG9nIHNjYWxlXG4gICAgICAgICAgICBpZiAocHJldkNvb3JkICE9PSBudWxsICYmIE1hdGguYWJzKGNvb3JkIC0gcHJldkNvb3JkKSA8IHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrSGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGEgdGljayBtYXJrIGlzIHBhcnRpYWxseSB2aXNpYmxlIGFuZCBza2lwIGl0IGlmIGVudGlyZVRleHRPbmx5IGlzIHRydWVcbiAgICAgICAgICAgIGlmIChjb29yZCA8IG1pbkNvb3JkIHx8IGNvb3JkID4gbWF4Q29vcmQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1hcmtzW3RhcmdldEluZGV4XS5faW50ZXJuYWxfY29vcmQgPSBjb29yZDtcbiAgICAgICAgICAgICAgICBtYXJrc1t0YXJnZXRJbmRleF0uX2ludGVybmFsX2xhYmVsID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0TG9naWNhbChsb2dpY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29vcmQ6IGNvb3JkLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGFiZWw6IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdExvZ2ljYWwobG9naWNhbCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRJbmRleCsrO1xuICAgICAgICAgICAgcHJldkNvb3JkID0gY29vcmQ7XG4gICAgICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlY2FsYyBzcGFuXG4gICAgICAgICAgICAgICAgc3BhbiA9IHRoaXMuX2ludGVybmFsX3RpY2tTcGFuKGxvZ2ljYWwgKiBzaWduLCBsb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcmtzLmxlbmd0aCA9IHRhcmdldEluZGV4O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXBwbHlFZGdlTWFya3MoZmlyc3RWYWx1ZSwgc3BhbiwgbWluQ29vcmQsIG1heENvb3JkLCBtaW5QYWRkaW5nLCBtYXhQYWRkaW5nKSB7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gdGhpcy5fcHJpdmF0ZV9fbWFya3M7XG4gICAgICAgIC8vIHRvcCBib3VuZGFyeVxuICAgICAgICBjb25zdCB0b3BNYXJrID0gdGhpcy5fcHJpdmF0ZV9fY29tcHV0ZUJvdW5kYXJ5UHJpY2VNYXJrKGZpcnN0VmFsdWUsIG1pbkNvb3JkLCBtaW5QYWRkaW5nLCBtYXhQYWRkaW5nKTtcbiAgICAgICAgLy8gYm90dG9tIGJvdW5kYXJ5XG4gICAgICAgIGNvbnN0IGJvdHRvbU1hcmsgPSB0aGlzLl9wcml2YXRlX19jb21wdXRlQm91bmRhcnlQcmljZU1hcmsoZmlyc3RWYWx1ZSwgbWF4Q29vcmQsIC1tYXhQYWRkaW5nLCAtbWluUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHNwYW5QeCA9IHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jKDAsIGZpcnN0VmFsdWUsIHRydWUpXG4gICAgICAgICAgICAtIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jKHNwYW4sIGZpcnN0VmFsdWUsIHRydWUpO1xuICAgICAgICBpZiAobWFya3MubGVuZ3RoID4gMCAmJiBtYXJrc1swXS5faW50ZXJuYWxfY29vcmQgLSB0b3BNYXJrLl9pbnRlcm5hbF9jb29yZCA8IHNwYW5QeCAvIDIpIHtcbiAgICAgICAgICAgIG1hcmtzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCA+IDAgJiYgYm90dG9tTWFyay5faW50ZXJuYWxfY29vcmQgLSBtYXJrc1ttYXJrcy5sZW5ndGggLSAxXS5faW50ZXJuYWxfY29vcmQgPCBzcGFuUHggLyAyKSB7XG4gICAgICAgICAgICBtYXJrcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy51bnNoaWZ0KHRvcE1hcmspO1xuICAgICAgICBtYXJrcy5wdXNoKGJvdHRvbU1hcmspO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29tcHV0ZUJvdW5kYXJ5UHJpY2VNYXJrKGZpcnN0VmFsdWUsIGNvb3JkLCBtaW5QYWRkaW5nLCBtYXhQYWRkaW5nKSB7XG4gICAgICAgIGNvbnN0IGF2Z1BhZGRpbmcgPSAobWluUGFkZGluZyArIG1heFBhZGRpbmcpIC8gMjtcbiAgICAgICAgY29uc3QgdmFsdWUxID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMoY29vcmQgKyBtaW5QYWRkaW5nLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMoY29vcmQgKyBtYXhQYWRkaW5nLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgY29uc3QgbWluVmFsdWUgPSBNYXRoLm1pbih2YWx1ZTEsIHZhbHVlMik7XG4gICAgICAgIGNvbnN0IG1heFZhbHVlID0gTWF0aC5tYXgodmFsdWUxLCB2YWx1ZTIpO1xuICAgICAgICBjb25zdCB2YWx1ZVNwYW4gPSBNYXRoLm1heCgwLjEsIHRoaXMuX2ludGVybmFsX3RpY2tTcGFuKG1heFZhbHVlLCBtaW5WYWx1ZSkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jKGNvb3JkICsgYXZnUGFkZGluZywgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRWYWx1ZSA9IHZhbHVlIC0gKHZhbHVlICUgdmFsdWVTcGFuKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZENvb3JkID0gdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmMocm91bmRlZFZhbHVlLCBmaXJzdFZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHsgX2ludGVybmFsX2xhYmVsOiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRMb2dpY2FsKHJvdW5kZWRWYWx1ZSksIF9pbnRlcm5hbF9jb29yZDogcm91bmRlZENvb3JkIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19zaG91bGRBcHBseUVkZ2VNYXJrcyhzcGFuLCBsb3csIGhpZ2gpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZW5zdXJlKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9pc0xvZygpKSB7XG4gICAgICAgICAgICByYW5nZSA9IGNvbnZlcnRQcmljZVJhbmdlRnJvbUxvZyhyYW5nZSwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZ2V0TG9nRm9ybXVsYSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpIC0gbG93IDwgc3BhbikgJiYgKGhpZ2ggLSByYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSA8IHNwYW4pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc29ydFNvdXJjZXMoc291cmNlcykge1xuICAgIHJldHVybiBzb3VyY2VzLnNsaWNlKCkuc29ydCgoczEsIHMyKSA9PiB7XG4gICAgICAgIHJldHVybiAoZW5zdXJlTm90TnVsbChzMS5faW50ZXJuYWxfem9yZGVyKCkpIC0gZW5zdXJlTm90TnVsbChzMi5faW50ZXJuYWxfem9yZGVyKCkpKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwcmljZSBzY2FsZSBtb2RlLlxuICovXG52YXIgUHJpY2VTY2FsZU1vZGU7XG4oZnVuY3Rpb24gKFByaWNlU2NhbGVNb2RlKSB7XG4gICAgLyoqXG4gICAgICogUHJpY2Ugc2NhbGUgc2hvd3MgcHJpY2VzLiBQcmljZSByYW5nZSBjaGFuZ2VzIGxpbmVhcmx5LlxuICAgICAqL1xuICAgIFByaWNlU2NhbGVNb2RlW1ByaWNlU2NhbGVNb2RlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xuICAgIC8qKlxuICAgICAqIFByaWNlIHNjYWxlIHNob3dzIHByaWNlcy4gUHJpY2UgcmFuZ2UgY2hhbmdlcyBsb2dhcml0aG1pY2FsbHkuXG4gICAgICovXG4gICAgUHJpY2VTY2FsZU1vZGVbUHJpY2VTY2FsZU1vZGVbXCJMb2dhcml0aG1pY1wiXSA9IDFdID0gXCJMb2dhcml0aG1pY1wiO1xuICAgIC8qKlxuICAgICAqIFByaWNlIHNjYWxlIHNob3dzIHBlcmNlbnRhZ2UgdmFsdWVzIGFjY29yZGluZyB0aGUgZmlyc3QgdmlzaWJsZSB2YWx1ZSBvZiB0aGUgcHJpY2Ugc2NhbGUuXG4gICAgICogVGhlIGZpcnN0IHZpc2libGUgdmFsdWUgaXMgMCUgaW4gdGhpcyBtb2RlLlxuICAgICAqL1xuICAgIFByaWNlU2NhbGVNb2RlW1ByaWNlU2NhbGVNb2RlW1wiUGVyY2VudGFnZVwiXSA9IDJdID0gXCJQZXJjZW50YWdlXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgcGVyY2VudGFnZSBtb2RlLCBidXQgdGhlIGZpcnN0IHZhbHVlIGlzIG1vdmVkIHRvIDEwMC5cbiAgICAgKi9cbiAgICBQcmljZVNjYWxlTW9kZVtQcmljZVNjYWxlTW9kZVtcIkluZGV4ZWRUbzEwMFwiXSA9IDNdID0gXCJJbmRleGVkVG8xMDBcIjtcbn0pKFByaWNlU2NhbGVNb2RlIHx8IChQcmljZVNjYWxlTW9kZSA9IHt9KSk7XG5jb25zdCBwZXJjZW50YWdlRm9ybWF0dGVyID0gbmV3IFBlcmNlbnRhZ2VGb3JtYXR0ZXIoKTtcbmNvbnN0IGRlZmF1bHRQcmljZUZvcm1hdHRlciA9IG5ldyBQcmljZUZvcm1hdHRlcigxMDAsIDEpO1xuY2xhc3MgUHJpY2VTY2FsZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIG9wdGlvbnMsIGxheW91dE9wdGlvbnMsIGxvY2FsaXphdGlvbk9wdGlvbnMsIGNvbG9yUGFyc2VyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludGVybmFsSGVpZ2h0Q2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZSA9IHsgX2ludGVybmFsX2lzVmFsaWQ6IGZhbHNlLCBfaW50ZXJuYWxfdmlzaWJsZUJhcnM6IG51bGwgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNDdXN0b21QcmljZVJhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3cgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gZGVmYXVsdFByaWNlRm9ybWF0dGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhID0gbG9nRm9ybXVsYUZvclByaWNlUmFuZ2UobnVsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zID0gbGF5b3V0T3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyA9IGxvY2FsaXphdGlvbk9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbG9yUGFyc2VyID0gY29sb3JQYXJzZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyID0gbmV3IFByaWNlVGlja01hcmtCdWlsZGVyKHRoaXMsIDEwMCwgdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbC5iaW5kKHRoaXMpLCB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pZDtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldE1vZGUoeyBfaW50ZXJuYWxfbW9kZTogb3B0aW9ucy5tb2RlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjYWxlTWFyZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBlbnN1cmVEZWZpbmVkKG9wdGlvbnMuc2NhbGVNYXJnaW5zLnRvcCk7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBlbnN1cmVEZWZpbmVkKG9wdGlvbnMuc2NhbGVNYXJnaW5zLmJvdHRvbSk7XG4gICAgICAgICAgICBpZiAodG9wIDwgMCB8fCB0b3AgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvcCBtYXJnaW4gLSBleHBlY3QgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBnaXZlbj0ke3RvcH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3R0b20gPCAwIHx8IGJvdHRvbSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm90dG9tIG1hcmdpbiAtIGV4cGVjdCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGdpdmVuPSR7Ym90dG9tfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCArIGJvdHRvbSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWFyZ2lucyAtIHN1bSBvZiBtYXJnaW5zIG11c3QgYmUgbGVzcyB0aGFuIDEsIGdpdmVuPSR7dG9wICsgYm90dG9tfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUludGVybmFsSGVpZ2h0Q2FjaGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNDdXN0b21QcmljZVJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faXNDdXN0b21QcmljZVJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNMb2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi87XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX2dldExvZ0Zvcm11bGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX2lzSW52ZXJ0ZWQ6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaW52ZXJ0U2NhbGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW9kZTogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9pbnRlcm5hbF9zZXRNb2RlKG5ld01vZGUpIHtcbiAgICAgICAgY29uc3Qgb2xkTW9kZSA9IHRoaXMuX2ludGVybmFsX21vZGUoKTtcbiAgICAgICAgbGV0IHByaWNlUmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfYXV0b1NjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlID0gbmV3TW9kZS5faW50ZXJuYWxfYXV0b1NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdNb2RlLl9pbnRlcm5hbF9tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSA9IG5ld01vZGUuX2ludGVybmFsX21vZGU7XG4gICAgICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfbW9kZSA9PT0gMiAvKiBQcmljZVNjYWxlTW9kZS5QZXJjZW50YWdlICovIHx8IG5ld01vZGUuX2ludGVybmFsX21vZGUgPT09IDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvU2NhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGFmdGVyIG1ha2luZyByZWJ1aWxkVGlja01hcmtzIGxhenlcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UuX2ludGVybmFsX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgd2hpY2ggc2NhbGUgY29udmVydGVkIGZyb21cbiAgICAgICAgaWYgKG9sZE1vZGUuX2ludGVybmFsX21vZGUgPT09IDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi8gJiYgbmV3TW9kZS5faW50ZXJuYWxfbW9kZSAhPT0gb2xkTW9kZS5faW50ZXJuYWxfbW9kZSkge1xuICAgICAgICAgICAgaWYgKGNhbkNvbnZlcnRQcmljZVJhbmdlRnJvbUxvZyh0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSkge1xuICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgaWYgKHByaWNlUmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShwcmljZVJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHdoaWNoIHNjYWxlIGNvbnZlcnRlZCB0b1xuICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfbW9kZSA9PT0gMSAvKiBQcmljZVNjYWxlTW9kZS5Mb2dhcml0aG1pYyAqLyAmJiBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlICE9PSBvbGRNb2RlLl9pbnRlcm5hbF9tb2RlKSB7XG4gICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyh0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKTtcbiAgICAgICAgICAgIGlmIChwcmljZVJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShwcmljZVJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlQ2hhbmdlZCA9IG9sZE1vZGUuX2ludGVybmFsX21vZGUgIT09IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZTtcbiAgICAgICAgaWYgKG1vZGVDaGFuZ2VkICYmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi8gfHwgdGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZUNoYW5nZWQgJiYgKG9sZE1vZGUuX2ludGVybmFsX21vZGUgPT09IDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovIHx8IHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfaXNJbnZlcnRlZCAhPT0gdW5kZWZpbmVkICYmIG9sZE1vZGUuX2ludGVybmFsX2lzSW52ZXJ0ZWQgIT09IG5ld01vZGUuX2ludGVybmFsX2lzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaW52ZXJ0U2NhbGUgPSBuZXdNb2RlLl9pbnRlcm5hbF9pc0ludmVydGVkO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Jc0ludmVydGVkQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKG9sZE1vZGUsIHRoaXMuX2ludGVybmFsX21vZGUoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21vZGVDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zLmZvbnRTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0SGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oZWlnaHQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVJbnRlcm5hbEhlaWdodENhY2hlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSAtIHRoaXMuX3ByaXZhdGVfX3RvcE1hcmdpblB4KCkgLSB0aGlzLl9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlID0gcmVzO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UsIGlzRm9yY2VTZXRWYWx1ZSkge1xuICAgICAgICBjb25zdCBvbGRQcmljZVJhbmdlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZTtcbiAgICAgICAgaWYgKCFpc0ZvcmNlU2V0VmFsdWUgJiZcbiAgICAgICAgICAgICEob2xkUHJpY2VSYW5nZSA9PT0gbnVsbCAmJiBuZXdQcmljZVJhbmdlICE9PSBudWxsKSAmJlxuICAgICAgICAgICAgKG9sZFByaWNlUmFuZ2UgPT09IG51bGwgfHwgb2xkUHJpY2VSYW5nZS5faW50ZXJuYWxfZXF1YWxzKG5ld1ByaWNlUmFuZ2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlID0gbmV3UHJpY2VSYW5nZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEN1c3RvbVByaWNlUmFuZ2UobmV3UHJpY2VSYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b2dnbGVDdXN0b21QcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UgIT09IG51bGwpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNFbXB0eSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9PT0gMCB8fCAhdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSB8fCB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlLl9pbnRlcm5hbF9pc0VtcHR5KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbnZlcnRlZENvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpID8gY29vcmRpbmF0ZSA6IHRoaXMuX2ludGVybmFsX2hlaWdodCgpIC0gMSAtIGNvb3JkaW5hdGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgYmFzZVZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSkge1xuICAgICAgICAgICAgcHJpY2UgPSB0b1BlcmNlbnQocHJpY2UsIGJhc2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcHJpY2UgPSB0b0luZGV4ZWRUbzEwMChwcmljZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZShwcmljZSwgYmFzZVZhbHVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BvaW50c0FycmF5VG9Db29yZGluYXRlcyhwb2ludHMsIGJhc2VWYWx1ZSwgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIGNvbnN0IGJoID0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpO1xuICAgICAgICBjb25zdCBtYXggPSByYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKTtcbiAgICAgICAgY29uc3QgaWggPSAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpO1xuICAgICAgICBjb25zdCBpc0ludmVydGVkID0gdGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpO1xuICAgICAgICBjb25zdCBobW0gPSBpaCAvIChtYXggLSBtaW4pO1xuICAgICAgICBjb25zdCBmcm9tSW5kZXggPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gMCA6IHZpc2libGVSYW5nZS5mcm9tO1xuICAgICAgICBjb25zdCB0b0luZGV4ID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50cy5sZW5ndGggOiB2aXNpYmxlUmFuZ2UudG87XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gdGhpcy5fcHJpdmF0ZV9fZ2V0Q29vcmRpbmF0ZVRyYW5zZm9ybWVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBwb2ludC5faW50ZXJuYWxfcHJpY2U7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpY2UpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbG9naWNhbCA9IHByaWNlO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUZuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9naWNhbCA9IHRyYW5zZm9ybUZuKHBvaW50Ll9pbnRlcm5hbF9wcmljZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGludkNvb3JkaW5hdGUgPSBiaCArIGhtbSAqIChsb2dpY2FsIC0gbWluKTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBpc0ludmVydGVkID8gaW52Q29vcmRpbmF0ZSA6IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEgLSBpbnZDb29yZGluYXRlO1xuICAgICAgICAgICAgcG9pbnQuX2ludGVybmFsX3kgPSBjb29yZGluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJQcmljZXNUb0Nvb3JkaW5hdGVzKHByaWNlc0xpc3QsIGJhc2VWYWx1ZSwgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIGNvbnN0IGJoID0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpO1xuICAgICAgICBjb25zdCBtYXggPSByYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKTtcbiAgICAgICAgY29uc3QgaWggPSAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpO1xuICAgICAgICBjb25zdCBpc0ludmVydGVkID0gdGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpO1xuICAgICAgICBjb25zdCBobW0gPSBpaCAvIChtYXggLSBtaW4pO1xuICAgICAgICBjb25zdCBmcm9tSW5kZXggPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gMCA6IHZpc2libGVSYW5nZS5mcm9tO1xuICAgICAgICBjb25zdCB0b0luZGV4ID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IHByaWNlc0xpc3QubGVuZ3RoIDogdmlzaWJsZVJhbmdlLnRvO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IHRoaXMuX3ByaXZhdGVfX2dldENvb3JkaW5hdGVUcmFuc2Zvcm1lcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUluZGV4OyBpIDwgdG9JbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiYXIgPSBwcmljZXNMaXN0W2ldO1xuICAgICAgICAgICAgbGV0IG9wZW5Mb2dpY2FsID0gYmFyLl9pbnRlcm5hbF9vcGVuO1xuICAgICAgICAgICAgbGV0IGhpZ2hMb2dpY2FsID0gYmFyLl9pbnRlcm5hbF9oaWdoO1xuICAgICAgICAgICAgbGV0IGxvd0xvZ2ljYWwgPSBiYXIuX2ludGVybmFsX2xvdztcbiAgICAgICAgICAgIGxldCBjbG9zZUxvZ2ljYWwgPSBiYXIuX2ludGVybmFsX2Nsb3NlO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUZuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3BlbkxvZ2ljYWwgPSB0cmFuc2Zvcm1GbihiYXIuX2ludGVybmFsX29wZW4sIGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaGlnaExvZ2ljYWwgPSB0cmFuc2Zvcm1GbihiYXIuX2ludGVybmFsX2hpZ2gsIGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbG93TG9naWNhbCA9IHRyYW5zZm9ybUZuKGJhci5faW50ZXJuYWxfbG93LCBiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNsb3NlTG9naWNhbCA9IHRyYW5zZm9ybUZuKGJhci5faW50ZXJuYWxfY2xvc2UsIGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW52Q29vcmRpbmF0ZSA9IGJoICsgaG1tICogKG9wZW5Mb2dpY2FsIC0gbWluKTtcbiAgICAgICAgICAgIGxldCBjb29yZGluYXRlID0gaXNJbnZlcnRlZCA/IGludkNvb3JkaW5hdGUgOiB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxIC0gaW52Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGJhci5faW50ZXJuYWxfb3BlblkgPSBjb29yZGluYXRlO1xuICAgICAgICAgICAgaW52Q29vcmRpbmF0ZSA9IGJoICsgaG1tICogKGhpZ2hMb2dpY2FsIC0gbWluKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBpc0ludmVydGVkID8gaW52Q29vcmRpbmF0ZSA6IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEgLSBpbnZDb29yZGluYXRlO1xuICAgICAgICAgICAgYmFyLl9pbnRlcm5hbF9oaWdoWSA9IGNvb3JkaW5hdGU7XG4gICAgICAgICAgICBpbnZDb29yZGluYXRlID0gYmggKyBobW0gKiAobG93TG9naWNhbCAtIG1pbik7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gaXNJbnZlcnRlZCA/IGludkNvb3JkaW5hdGUgOiB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxIC0gaW52Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGJhci5faW50ZXJuYWxfbG93WSA9IGNvb3JkaW5hdGU7XG4gICAgICAgICAgICBpbnZDb29yZGluYXRlID0gYmggKyBobW0gKiAoY2xvc2VMb2dpY2FsIC0gbWluKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBpc0ludmVydGVkID8gaW52Q29vcmRpbmF0ZSA6IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEgLSBpbnZDb29yZGluYXRlO1xuICAgICAgICAgICAgYmFyLl9pbnRlcm5hbF9jbG9zZVkgPSBjb29yZGluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbG9naWNhbCA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwoY29vcmRpbmF0ZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2xvZ2ljYWxUb1ByaWNlKGxvZ2ljYWwsIGJhc2VWYWx1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sb2dpY2FsVG9QcmljZShsb2dpY2FsLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbG9naWNhbDtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21QZXJjZW50KHZhbHVlLCBiYXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbUluZGV4ZWRUbzEwMCh2YWx1ZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYXRhU291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gc29ydFNvdXJjZXModGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNvdXJjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfaW52YWxpZGF0ZVNvdXJjZXNDYWNoZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGlzIG5vdCBhdHRhY2hlZCB0byBzY2FsZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldE1vZGUoe1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIG5vIHNvdXJjZXMgb24gcHJpY2Ugc2NhbGUgbGV0J3MgY2xlYXIgcHJpY2UgcmFuZ2UgY2FjaGUgYXMgd2VsbCBhcyBlbmFibGluZyBhdXRvIHNjYWxlXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXJzdFZhbHVlKCkge1xuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGUgcmVzdWx0XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHNvdXJjZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdGltZVBvaW50IDwgcmVzdWx0Ll9pbnRlcm5hbF90aW1lUG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBudWxsIDogcmVzdWx0Ll9pbnRlcm5hbF92YWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzSW52ZXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFya3MoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWVJc051bGwgPSB0aGlzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkgPT09IG51bGw7XG4gICAgICAgIC8vIGRvIG5vdCByZWNhbGN1bGF0ZSBtYXJrcyBpZiBmaXJzdFZhbHVlSXNOdWxsIGlzIHRydWUgYmVjYXVzZSBpbiB0aGlzIGNhc2Ugd2UnbGwgYWx3YXlzIGdldCBlbXB0eSByZXN1bHRcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSB3aGVuIGEgc2VyaWVzIGhhZCBzb21lIGRhdGEgYW5kIHRoZW4geW91IHNldCBlbXB0eSBkYXRhIHRvIGl0IChpbiBhIHNpbXBsaWZpZWQgY2FzZSlcbiAgICAgICAgLy8gd2UgY291bGQgZGlzcGxheSBhbiBlbXB0eSBwcmljZSBzY2FsZSwgYnV0IHRoaXMgaXMgbm90IGdvb2QgZnJvbSBVWFxuICAgICAgICAvLyBzbyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBrZWVwIGFuIHByZXZpb3VzIG1hcmtzIHRvIGRpc3BsYXkgdGhlbSBvbiB0aGUgc2NhbGVcbiAgICAgICAgLy8gYXMgb25lIG9mIHBvc3NpYmxlIGV4YW1wbGVzIGZvciB0aGlzIHNpdHVhdGlvbiBjb3VsZCBiZSB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyBsZXQncyBzYXkgeW91IGhhdmUgYSBzdHVkeS9pbmRpY2F0b3IgYXR0YWNoZWQgdG8gYSBwcmljZSBzY2FsZSBhbmQgdGhlbiB5b3UgZGVjaWRlIHRvIHN0b3AgaXQsIGkuZS4gcmVtb3ZlIGl0cyBkYXRhIGJlY2F1c2Ugb2YgaXRzIHZpc2liaWxpdHlcbiAgICAgICAgLy8gYSB1c2VyIHdpbGwgc2VlIHRoZSBwcmV2aW91cyBtYXJrcyBvbiB0aGUgc2NhbGUgdW50aWwgeW91IHR1cm4gb24geW91ciBzdHVkeSBiYWNrIG9yIHJlbW92ZSBpdCBmcm9tIHRoZSBjaGFydCBjb21wbGV0ZWx5XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlICE9PSBudWxsICYmIChmaXJzdFZhbHVlSXNOdWxsIHx8IHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUuX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGwgPT09IGZpcnN0VmFsdWVJc051bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZS5faW50ZXJuYWxfbWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIuX2ludGVybmFsX3JlYnVpbGRUaWNrTWFya3MoKTtcbiAgICAgICAgY29uc3QgbWFya3MgPSB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlci5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IHsgX2ludGVybmFsX21hcmtzOiBtYXJrcywgX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGw6IGZpcnN0VmFsdWVJc051bGwgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25NYXJrc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vbk1hcmtzQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGUoeCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgIT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludmVydCB4XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlVG8oeCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRNb2RlKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaW52ZXJ0IHhcbiAgICAgICAgeCA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIHg7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjYWxlQ29lZmYgPSAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ICsgKHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEpICogMC4yKSAvICh4ICsgKHRoaXMuX3ByaXZhdGVfX2hlaWdodCAtIDEpICogMC4yKTtcbiAgICAgICAgY29uc3QgbmV3UHJpY2VSYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90KS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICAgICAgc2NhbGVDb2VmZiA9IE1hdGgubWF4KHNjYWxlQ29lZmYsIDAuMSk7XG4gICAgICAgIG5ld1ByaWNlUmFuZ2UuX2ludGVybmFsX3NjYWxlQXJvdW5kQ2VudGVyKHNjYWxlQ29lZmYpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2NhbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSB8fCB0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCAhPT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlVW5pdHNQZXJQaXhlbCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKS5faW50ZXJuYWxfbGVuZ3RoKCkgLyAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpO1xuICAgICAgICBsZXQgcGl4ZWxEZWx0YSA9IHggLSB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50O1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpKSB7XG4gICAgICAgICAgICBwaXhlbERlbHRhICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlRGVsdGEgPSBwaXhlbERlbHRhICogcHJpY2VVbml0c1BlclBpeGVsO1xuICAgICAgICBjb25zdCBuZXdQcmljZVJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QpLl9pbnRlcm5hbF9jbG9uZSgpO1xuICAgICAgICBuZXdQcmljZVJhbmdlLl9pbnRlcm5hbF9zaGlmdChwcmljZURlbHRhKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdHRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXRQcmljZShwcmljZSwgZmlyc3RWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFBlcmNlbnRhZ2UodG9QZXJjZW50KHByaWNlLCBmaXJzdFZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKS5mb3JtYXQodG9JbmRleGVkVG8xMDAocHJpY2UsIGZpcnN0VmFsdWUpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFByaWNlKHByaWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0TG9naWNhbChsb2dpY2FsKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0UGVyY2VudGFnZShsb2dpY2FsKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQcmljZVNjYWxlTW9kZS5JbmRleGVkVG8xMDAgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2Zvcm1hdHRlcigpLmZvcm1hdChsb2dpY2FsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFByaWNlKGxvZ2ljYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXRQcmljZUFic29sdXRlKHByaWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQcmljZShwcmljZSwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UpLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXRQcmljZVBlcmNlbnRhZ2UocHJpY2UsIGJhc2VWYWx1ZSkge1xuICAgICAgICBwcmljZSA9IHRvUGVyY2VudChwcmljZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFBlcmNlbnRhZ2UocHJpY2UsIHBlcmNlbnRhZ2VGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc291cmNlc0ZvckF1dG9TY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVJhbmdlKHZpc2libGVCYXJzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZUJhcnM6IHZpc2libGVCYXJzLFxuICAgICAgICAgICAgX2ludGVybmFsX2lzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKHMpID0+IHMuX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGFzVmlzaWJsZUVkZ2VNYXJrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZW5zdXJlRWRnZVRpY2tNYXJrc1Zpc2libGUgJiYgdGhpcy5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVkZ2VNYXJrc1BhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9mb250U2l6ZSgpIC8gMjtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IG51bGw7XG4gICAgICAgIGxldCB6T3JkZXIgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlID0gbnVsbDtcbiAgICAgICAgLy8gY2hvb3NlIHNvdXJjZSB3aXRoIHRoZSBsb3dlc3Qgem9yZGVyXG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9pbnRlcm5hbF96b3JkZXIoKSA8IHpPcmRlcikge1xuICAgICAgICAgICAgICAgIHpPcmRlciA9IHNvdXJjZS5faW50ZXJuYWxfem9yZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBiYXNlID0gMTAwO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBiYXNlID0gTWF0aC5yb3VuZCgxIC8gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlLl9pbnRlcm5hbF9taW5Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IGRlZmF1bHRQcmljZUZvcm1hdHRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBwZXJjZW50YWdlRm9ybWF0dGVyO1xuICAgICAgICAgICAgYmFzZSA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBuZXcgUHJpY2VGb3JtYXR0ZXIoMTAwLCAxKTtcbiAgICAgICAgICAgIGJhc2UgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZS5faW50ZXJuYWxfZm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIgPSBuZXcgUHJpY2VUaWNrTWFya0J1aWxkZXIodGhpcywgYmFzZSwgdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbC5iaW5kKHRoaXMpLCB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlci5faW50ZXJuYWxfcmVidWlsZFRpY2tNYXJrcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZVNvdXJjZXNDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29sb3JQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jb2xvclBhcnNlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RvZ2dsZUN1c3RvbVByaWNlUmFuZ2Uodikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc0N1c3RvbVByaWNlUmFuZ2UgPSB2O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdG9wTWFyZ2luUHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9pc0ludmVydGVkKClcbiAgICAgICAgICAgID8gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5zY2FsZU1hcmdpbnMuYm90dG9tICogdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgKyB0aGlzLl9wcml2YXRlX19tYXJnaW5CZWxvd1xuICAgICAgICAgICAgOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnNjYWxlTWFyZ2lucy50b3AgKiB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSArIHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9pc0ludmVydGVkKClcbiAgICAgICAgICAgID8gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5zY2FsZU1hcmdpbnMudG9wICogdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgKyB0aGlzLl9wcml2YXRlX19tYXJnaW5BYm92ZVxuICAgICAgICAgICAgOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnNjYWxlTWFyZ2lucy5ib3R0b20gKiB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSArIHRoaXMuX3ByaXZhdGVfX21hcmdpbkJlbG93O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZS5faW50ZXJuYWxfaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZS5faW50ZXJuYWxfaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlUmFuZ2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2ludmFsaWRhdGVJbnRlcm5hbEhlaWdodENhY2hlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGUobG9naWNhbCwgYmFzZVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2ljYWwgPSB0aGlzLl9pbnRlcm5hbF9pc0xvZygpICYmIGxvZ2ljYWwgPyB0b0xvZyhsb2dpY2FsLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSA6IGxvZ2ljYWw7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wcmljZVJhbmdlKCkpO1xuICAgICAgICBjb25zdCBpbnZDb29yZGluYXRlID0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKSArXG4gICAgICAgICAgICAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpICogKGxvZ2ljYWwgLSByYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSkgLyByYW5nZS5faW50ZXJuYWxfbGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9pbnZlcnRlZENvb3JkaW5hdGUoaW52Q29vcmRpbmF0ZSk7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29vcmRpbmF0ZVRvTG9naWNhbChjb29yZGluYXRlLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW52Q29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX2ludmVydGVkQ29vcmRpbmF0ZShjb29yZGluYXRlKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSByYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSArIHJhbmdlLl9pbnRlcm5hbF9sZW5ndGgoKSAqXG4gICAgICAgICAgICAoKGludkNvb3JkaW5hdGUgLSB0aGlzLl9wcml2YXRlX19ib3R0b21NYXJnaW5QeCgpKSAvICh0aGlzLl9pbnRlcm5hbF9pbnRlcm5hbEhlaWdodCgpIC0gMSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfaXNMb2coKSA/IGZyb21Mb2cobG9naWNhbCwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkgOiBsb2dpY2FsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25Jc0ludmVydGVkQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyLl9pbnRlcm5hbF9yZWJ1aWxkVGlja01hcmtzKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VSYW5nZUltcGwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0N1c3RvbVByaWNlUmFuZ2UoKSAmJiAhdGhpcy5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRGb3JSYW5nZS5faW50ZXJuYWxfdmlzaWJsZUJhcnM7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZVJhbmdlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IHRoaXMuX2ludGVybmFsX3NvdXJjZXNGb3JBdXRvU2NhbGUoKTtcbiAgICAgICAgbGV0IG1hcmdpbkFib3ZlID0gMDtcbiAgICAgICAgbGV0IG1hcmdpbkJlbG93ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHNvdXJjZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dG9TY2FsZUluZm8gPSBzb3VyY2UuX2ludGVybmFsX2F1dG9zY2FsZUluZm8odmlzaWJsZUJhcnMuX2ludGVybmFsX2xlZnQoKSwgdmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCkpO1xuICAgICAgICAgICAgbGV0IHNvdXJjZVJhbmdlID0gYXV0b1NjYWxlSW5mbyAmJiBhdXRvU2NhbGVJbmZvLl9pbnRlcm5hbF9wcmljZVJhbmdlKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlUmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VSYW5nZSA9IGNvbnZlcnRQcmljZVJhbmdlVG9Mb2coc291cmNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBQcmljZVNjYWxlTW9kZS5QZXJjZW50YWdlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlUmFuZ2UgPSB0b1BlcmNlbnRSYW5nZShzb3VyY2VSYW5nZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBQcmljZVNjYWxlTW9kZS5JbmRleGVkVG8xMDAgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VSYW5nZSA9IHRvSW5kZXhlZFRvMTAwUmFuZ2Uoc291cmNlUmFuZ2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gc291cmNlUmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gcHJpY2VSYW5nZS5faW50ZXJuYWxfbWVyZ2UoZW5zdXJlTm90TnVsbChzb3VyY2VSYW5nZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXV0b1NjYWxlSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW5zID0gYXV0b1NjYWxlSW5mby5faW50ZXJuYWxfbWFyZ2lucygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luQWJvdmUgPSBNYXRoLm1heChtYXJnaW5BYm92ZSwgbWFyZ2lucy5hYm92ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5CZWxvdyA9IE1hdGgubWF4KG1hcmdpbkJlbG93LCBtYXJnaW5zLmJlbG93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaGFzVmlzaWJsZUVkZ2VNYXJrcygpKSB7XG4gICAgICAgICAgICBtYXJnaW5BYm92ZSA9IE1hdGgubWF4KG1hcmdpbkFib3ZlLCB0aGlzLl9pbnRlcm5hbF9nZXRFZGdlTWFya3NQYWRkaW5nKCkpO1xuICAgICAgICAgICAgbWFyZ2luQmVsb3cgPSBNYXRoLm1heChtYXJnaW5CZWxvdywgdGhpcy5faW50ZXJuYWxfZ2V0RWRnZU1hcmtzUGFkZGluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFyZ2luQWJvdmUgIT09IHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlIHx8IG1hcmdpbkJlbG93ICE9PSB0aGlzLl9wcml2YXRlX19tYXJnaW5CZWxvdykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQWJvdmUgPSBtYXJnaW5BYm92ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmdpbkJlbG93ID0gbWFyZ2luQmVsb3c7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVJbnRlcm5hbEhlaWdodENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaWNlUmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgY3VycmVudCByYW5nZSBpcyBuZXcgaXMgZW1wdHlcbiAgICAgICAgICAgIGlmIChwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpID09PSBwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyU291cmNlID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbk1vdmUgPSBmb3JtYXR0ZXJTb3VyY2UgPT09IG51bGwgfHwgdGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSA/IDEgOiBmb3JtYXR0ZXJTb3VyY2UuX2ludGVybmFsX21pbk1vdmUoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBwcmljZSByYW5nZSBpcyBkZWdlbmVyYXRlZCB0byAxIHBvaW50IGxldCdzIGV4dGVuZCBpdCBieSAxMCBtaW4gbW92ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmNvcnJlY3QgcmFuZ2UgYW5kIGVtcHR5IChibGFuaykgc2NhbGUgKGluIGNhc2Ugb2YgbWluIHRpY2sgbXVjaCBncmVhdGVyIHRoYW4gMSlcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbmRWYWx1ZSA9IDUgKiBtaW5Nb3ZlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0xvZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2cocHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBuZXcgUHJpY2VSYW5nZUltcGwocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSAtIGV4dGVuZFZhbHVlLCBwcmljZVJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpICsgZXh0ZW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0xvZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZVRvTG9nKHByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0xvZygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3UmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2cocHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TG9nRm9ybXVsYSA9IGxvZ0Zvcm11bGFGb3JQcmljZVJhbmdlKHJhd1JhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxvZ0Zvcm11bGFzQXJlU2FtZShuZXdMb2dGb3JtdWxhLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdTbmFwc2hvdCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCAhPT0gbnVsbCA/IGNvbnZlcnRQcmljZVJhbmdlRnJvbUxvZyh0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSA9IG5ld0xvZ0Zvcm11bGE7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlUmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZVRvTG9nKHJhd1JhbmdlLCBuZXdMb2dGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1NuYXBzaG90ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgPSBjb252ZXJ0UHJpY2VSYW5nZVRvTG9nKHJhd1NuYXBzaG90LCBuZXdMb2dGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UocHJpY2VSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXNldCBlbXB0eSB0byBkZWZhdWx0XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UobmV3IFByaWNlUmFuZ2VJbXBsKC0wLjUsIDAuNSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEgPSBsb2dGb3JtdWxhRm9yUHJpY2VSYW5nZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0Q29vcmRpbmF0ZVRyYW5zZm9ybWVyKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1BlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvSW5kZXhlZFRvMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybmFsX2lzTG9nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJpY2UpID0+IHRvTG9nKHByaWNlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdFZhbHVlKHZhbHVlLCBmb3JtYXR0ZXIsIGZhbGxiYWNrRm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChmb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGZhbGxiYWNrRm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Zvcm1hdHRlciA9IHRoaXMuX2ludGVybmFsX2Zvcm1hdHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRQcmljZShwcmljZSwgZmFsbGJhY2tGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFZhbHVlKHByaWNlLCB0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zLnByaWNlRm9ybWF0dGVyLCBmYWxsYmFja0Zvcm1hdHRlcik7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRQZXJjZW50YWdlKHBlcmNlbnRhZ2UsIGZhbGxiYWNrRm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRWYWx1ZShwZXJjZW50YWdlLCB0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zLnBlcmNlbnRhZ2VGb3JtYXR0ZXIsIGZhbGxiYWNrRm9ybWF0dGVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU2VyaWVzKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBTZXJpZXM7XG59XG5jb25zdCBERUZBVUxUX1NUUkVUQ0hfRkFDVE9SID0gMTAwMDtcbmNvbnN0IE1JTl9QQU5FX0hFSUdIVCA9IDMwO1xuY2xhc3MgUGFuZSB7XG4gICAgY29uc3RydWN0b3IodGltZVNjYWxlLCBtb2RlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHJldGNoRmFjdG9yID0gREVGQVVMVF9TVFJFVENIX0ZBQ1RPUjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kZXN0cm95ZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyaWQgPSBuZXcgR3JpZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY3JlYXRlUHJpY2VTY2FsZShcImxlZnRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLkxlZnQgKi8sIG9wdGlvbnMubGVmdFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jcmVhdGVQcmljZVNjYWxlKFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovLCBvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QcmljZVNjYWxlTW9kZUNoYW5nZWQuYmluZCh0aGlzLCB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX21vZGVDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblByaWNlU2NhbGVNb2RlQ2hhbmdlZC5iaW5kKHRoaXMsIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSksIHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdFByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucy5sZWZ0UHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlQcmljZVNjYWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQXJyYXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC52YWx1ZXMoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyciBvZiBzb3VyY2VBcnJheXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gZW5zdXJlTm90TnVsbChhcnJbMF0uX2ludGVybmFsX3ByaWNlU2NhbGUoKSk7XG4gICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMub3ZlcmxheVByaWNlU2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQuZ2V0KGlkKSlbMF0uX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9pbnRlcm5hbF9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc291cmNlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5maWx0ZXIoKHByaW1pdGl2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IHByaW1pdGl2ZS5faW50ZXJuYWxfcHJpbWl0aXZlKCk7XG4gICAgICAgICAgICBpZiAocC5kZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHAuZGV0YWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3llZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3N0cmV0Y2hGYWN0b3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yKGZhY3Rvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHJldGNoRmFjdG9yID0gZmFjdG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3dpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19oZWlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAvLyBwcm9jZXNzIG92ZXJsYXlzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNPdmVybGF5KGRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBkcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NlcmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZpbHRlcihpc1Nlcmllcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYXRhU291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNPdmVybGF5KHNvdXJjZSkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUgIT09IHByaWNlU2NhbGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlICE9PSBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYWRkRGF0YVNvdXJjZShzb3VyY2UsIHRhcmdldFNjYWxlSWQsIGtlZXBTb3VyY2VzT3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5zZXJ0RGF0YVNvdXJjZShzb3VyY2UsIHRhcmdldFNjYWxlSWQsIGtlZXBTb3VyY2VzT3JkZXIgPyBzb3VyY2UuX2ludGVybmFsX3pvcmRlcigpIDogdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2Uoc291cmNlLCBrZWVwU291cmNlT3JkZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIGFzc2VydChpbmRleCAhPT0gLTEsICdyZW1vdmVEYXRhU291cmNlOiBpbnZhbGlkIGRhdGEgc291cmNlJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmICgha2VlcFNvdXJjZU9yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChkcywgaSkgPT4gZHMuX2ludGVybmFsX3NldFpvcmRlcihpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZUlkID0gZW5zdXJlTm90TnVsbChzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKSkuX2ludGVybmFsX2lkKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5oYXMocHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVNvdXJjZXMgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLmdldChwcmljZVNjYWxlSWQpKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlJbmRleCA9IG92ZXJsYXlTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChvdmVybGF5SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVNvdXJjZXMuc3BsaWNlKG92ZXJsYXlJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5kZWxldGUocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAvLyBpZiBzb3VyY2UgaGFzIG93bmVyLCBpdCByZXR1cm5zIG93bmVyJ3MgcHJpY2Ugc2NhbGVcbiAgICAgICAgLy8gYW5kIGl0IGRvZXMgbm90IGhhdmUgc291cmNlIGluIHRoZWlyIGxpc3RcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgJiYgcHJpY2VTY2FsZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGVQb3NpdGlvbihwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ292ZXJsYXknO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGVmdFByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGVQcmljZShwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3N0YXJ0U2NhbGUoeCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZVByaWNlVG8ocHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zY2FsZVRvKHgpO1xuICAgICAgICAvLyBUT0RPOiBiZSBtb3JlIHNtYXJ0IGFuZCB1cGRhdGUgb25seSBhZmZlY3RlZCB2aWV3c1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY2FsZVByaWNlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfZW5kU2NhbGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsUHJpY2UocHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zdGFydFNjcm9sbCh4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFByaWNlVG8ocHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zY3JvbGxUbyh4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2Nyb2xsUHJpY2UocHJpY2VTY2FsZSkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9lbmRTY3JvbGwoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgc291cmNlLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCkge1xuICAgICAgICBsZXQgcHJpY2VTY2FsZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLnJpZ2h0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5sZWZ0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9kYXRhU291cmNlcygpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzWzBdLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGUoKSB7XG4gICAgICAgIGxldCBwcmljZVNjYWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkucmlnaHRQcmljZVNjYWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5sZWZ0UHJpY2VTY2FsZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUocHJpY2VTY2FsZSkge1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCB8fCAhcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VTY2FsZUltcGwocHJpY2VTY2FsZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldFByaWNlU2NhbGUocHJpY2VTY2FsZSkge1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NldE1vZGUoeyBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0cnVlIH0pO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VSYW5nZSh2aXNpYmxlQmFycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9tZW50YXJ5QXV0b1NjYWxlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlU2NhbGVJbXBsKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbCh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZSh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZSh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChkcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzT3ZlcmxheShkcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUoZHMuX2ludGVybmFsX3ByaWNlU2NhbGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBzb3J0U291cmNlcyh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2VyaWVzT3JkZXIoc2VyaWVzLCBvcmRlcikge1xuICAgICAgICBvcmRlciA9IGNsYW1wKG9yZGVyLCAwLCB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5pbmRleE9mKHNlcmllcyk7XG4gICAgICAgIGFzc2VydChpbmRleCAhPT0gLTEsICdzZXRTZXJpZXNPcmRlcjogaW52YWxpZCBkYXRhIHNvdXJjZScpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5zcGxpY2Uob3JkZXIsIDAsIHNlcmllcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKHBzLCBpKSA9PiBwcy5faW50ZXJuYWxfc2V0Wm9yZGVyKGkpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBzIG9mIFt0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSwgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlXSkge1xuICAgICAgICAgICAgcHMuX2ludGVybmFsX2ludmFsaWRhdGVTb3VyY2VzQ2FjaGUoKTtcbiAgICAgICAgICAgIHBzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29yZGVyZWRTZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpLmZpbHRlcihpc1Nlcmllcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dyaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19ncmlkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLnB1c2gobmV3IFBhbmVQcmltaXRpdmVXcmFwcGVyJDEocHJpbWl0aXZlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXRhY2hQcmltaXRpdmUoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMgPSB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLmZpbHRlcigod3JhcHBlcikgPT4gd3JhcHBlci5faW50ZXJuYWxfcHJpbWl0aXZlKCkgIT09IHNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5kZXRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpbWl0aXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmltaXRpdmVIaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXNcbiAgICAgICAgICAgIC5tYXAoKHByaW1pdGl2ZSkgPT4gcHJpbWl0aXZlLl9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpKVxuICAgICAgICAgICAgLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQgIT09IG51bGwpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbChwcmljZVNjYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgdGhpcyBjaGVja3NcbiAgICAgICAgY29uc3Qgc291cmNlRm9yQXV0b1NjYWxlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfc291cmNlc0ZvckF1dG9TY2FsZSgpO1xuICAgICAgICBpZiAoc291cmNlRm9yQXV0b1NjYWxlICYmIHNvdXJjZUZvckF1dG9TY2FsZS5sZW5ndGggPiAwICYmICF0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKHZpc2libGVCYXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVJhbmdlKHZpc2libGVCYXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faW5zZXJ0RGF0YVNvdXJjZShzb3VyY2UsIHByaWNlU2NhbGVJZCwgb3JkZXIpIHtcbiAgICAgICAgbGV0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChwcmljZVNjYWxlSWQpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUocHJpY2VTY2FsZUlkLCB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLm92ZXJsYXlQcmljZVNjYWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuc3BsaWNlKG9yZGVyLCAwLCBzb3VyY2UpO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByaWNlU2NhbGUocHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVNvdXJjZXMgPSB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5nZXQocHJpY2VTY2FsZUlkKSB8fCBbXTtcbiAgICAgICAgICAgIG92ZXJsYXlTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLnNldChwcmljZVNjYWxlSWQsIG92ZXJsYXlTb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UuX2ludGVybmFsX3NldFpvcmRlcihvcmRlcik7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgc291cmNlLl9pbnRlcm5hbF9zZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUocHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uUHJpY2VTY2FsZU1vZGVDaGFuZ2VkKHByaWNlU2NhbGUsIG9sZE1vZGUsIG5ld01vZGUpIHtcbiAgICAgICAgaWYgKG9sZE1vZGUuX2ludGVybmFsX21vZGUgPT09IG5ld01vZGUuX2ludGVybmFsX21vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb21lbnRhcnkgYXV0byBzY2FsZSBpZiB3ZSB0b2dnbGUgcGVyY2VudGFnZS9pbmRleGVkVG8xMDAgbW9kZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlU2NhbGVJbXBsKHByaWNlU2NhbGUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY3JlYXRlUHJpY2VTY2FsZShpZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0geyB2aXNpYmxlOiB0cnVlLCBhdXRvU2NhbGU6IHRydWUsIC4uLmNsb25lKG9wdGlvbnMpIH07XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBuZXcgUHJpY2VTY2FsZShpZCwgYWN0dWFsT3B0aW9ucywgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10sIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkubG9jYWxpemF0aW9uLCB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfY29sb3JQYXJzZXIoKSk7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3NldEhlaWdodCh0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSk7XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlO1xuICAgIH1cbn1cblxuLy8gcmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgYWJvdmUgcmVmZXJlbmNlXG5mdW5jdGlvbiBjb21wYXJlUHJpbWl0aXZlWk9yZGVyKGl0ZW0sIHJlZmVyZW5jZSkge1xuICAgIHJldHVybiAoIXJlZmVyZW5jZSB8fFxuICAgICAgICAoaXRlbSA9PT0gJ3RvcCcgJiYgcmVmZXJlbmNlICE9PSAndG9wJykgfHxcbiAgICAgICAgKGl0ZW0gPT09ICdub3JtYWwnICYmIHJlZmVyZW5jZSA9PT0gJ2JvdHRvbScpKTtcbn1cbmZ1bmN0aW9uIGZpbmRCZXN0UHJpbWl0aXZlSGl0VGVzdChzb3VyY2VzLCB4LCB5KSB7XG4gICAgbGV0IGJlc3RQcmltaXRpdmVIaXQ7XG4gICAgbGV0IGJlc3RIaXRTb3VyY2U7XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBjb25zdCBwcmltaXRpdmVIaXRSZXN1bHRzID0gc291cmNlLl9pbnRlcm5hbF9wcmltaXRpdmVIaXRUZXN0Py4oeCwgeSkgPz8gW107XG4gICAgICAgIGZvciAoY29uc3QgaGl0UmVzdWx0IG9mIHByaW1pdGl2ZUhpdFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUHJpbWl0aXZlWk9yZGVyKGhpdFJlc3VsdC56T3JkZXIsIGJlc3RQcmltaXRpdmVIaXQ/LnpPcmRlcikpIHtcbiAgICAgICAgICAgICAgICBiZXN0UHJpbWl0aXZlSGl0ID0gaGl0UmVzdWx0O1xuICAgICAgICAgICAgICAgIGJlc3RIaXRTb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFiZXN0UHJpbWl0aXZlSGl0IHx8ICFiZXN0SGl0U291cmNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfaGl0OiBiZXN0UHJpbWl0aXZlSGl0LFxuICAgICAgICBfaW50ZXJuYWxfc291cmNlOiBiZXN0SGl0U291cmNlLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJpbWl0aXZlSGl0UmVzdWx0KHByaW1pdGl2ZUhpdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9zb3VyY2U6IHByaW1pdGl2ZUhpdC5faW50ZXJuYWxfc291cmNlLFxuICAgICAgICBfaW50ZXJuYWxfb2JqZWN0OiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfZXh0ZXJuYWxJZDogcHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9oaXQuZXh0ZXJuYWxJZCxcbiAgICAgICAgfSxcbiAgICAgICAgX2ludGVybmFsX2N1cnNvclN0eWxlOiBwcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC5jdXJzb3JTdHlsZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGhpdCB0ZXN0IG9uIGEgY29sbGVjdGlvbiBvZiBwYW5lIHZpZXdzIHRvIGRldGVybWluZSB3aGljaCB2aWV3IGFuZCBvYmplY3RcbiAqIGlzIGxvY2F0ZWQgYXQgYSBnaXZlbiBjb29yZGluYXRlICh4LCB5KSBhbmQgcmV0dXJucyB0aGUgbWF0Y2hpbmcgcGFuZSB2aWV3IGFuZFxuICogaGl0LXRlc3RlZCByZXN1bHQgb2JqZWN0LCBvciBudWxsIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlxuICovXG5mdW5jdGlvbiBoaXRUZXN0UGFuZVZpZXcocGFuZVZpZXdzLCB4LCB5LCBwYW5lKSB7XG4gICAgZm9yIChjb25zdCBwYW5lVmlldyBvZiBwYW5lVmlld3MpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBwYW5lVmlldy5faW50ZXJuYWxfcmVuZGVyZXIocGFuZSk7XG4gICAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5faW50ZXJuYWxfaGl0VGVzdCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVuZGVyZXIuX2ludGVybmFsX2hpdFRlc3QoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3ZpZXc6IHBhbmVWaWV3LFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfb2JqZWN0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRGF0YVNvdXJjZShzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLl9pbnRlcm5hbF9wYW5lVmlld3MgIT09IHVuZGVmaW5lZDtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBoaXRUZXN0UGFuZShwYW5lLCB4LCB5KSB7XG4gICAgY29uc3Qgc291cmNlcyA9IFtwYW5lLCAuLi5wYW5lLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpXTtcbiAgICBjb25zdCBiZXN0UHJpbWl0aXZlSGl0ID0gZmluZEJlc3RQcmltaXRpdmVIaXRUZXN0KHNvdXJjZXMsIHgsIHkpO1xuICAgIGlmIChiZXN0UHJpbWl0aXZlSGl0Py5faW50ZXJuYWxfaGl0LnpPcmRlciA9PT0gJ3RvcCcpIHtcbiAgICAgICAgLy8gYSBwcmltaXRpdmUgaGl0IG9uIHRoZSAndG9wJyBsYXllciB3aWxsIGFsd2F5cyBiZWF0IHRoZSBidWlsdC1pbiBoaXQgdGVzdHNcbiAgICAgICAgLy8gKG9uIG5vcm1hbCBsYXllcikgc28gd2UgY2FuIHJldHVybiBlYXJseSBoZXJlLlxuICAgICAgICByZXR1cm4gY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdChiZXN0UHJpbWl0aXZlSGl0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBpZiAoYmVzdFByaW1pdGl2ZUhpdCAmJiBiZXN0UHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9zb3VyY2UgPT09IHNvdXJjZSAmJiBiZXN0UHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9oaXQuek9yZGVyICE9PSAnYm90dG9tJyAmJiAhYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LmlzQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgLy8gYSBwcmltaXRpdmUgd2lsbCBiZSBkcmF3biBhYm92ZSBhIGJ1aWx0LWluIGl0ZW0gbGlrZSBhIHNlcmllcyBtYXJrZXJcbiAgICAgICAgICAgIC8vIHRoZXJlZm9yZSBpdCB0YWtlcyBwcmVjZWRlbmNlIGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdChiZXN0UHJpbWl0aXZlSGl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRhU291cmNlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJlc3VsdCA9IGhpdFRlc3RQYW5lVmlldyhzb3VyY2UuX2ludGVybmFsX3BhbmVWaWV3cyhwYW5lKSwgeCwgeSwgcGFuZSk7XG4gICAgICAgICAgICBpZiAoc291cmNlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3NvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdmlldzogc291cmNlUmVzdWx0Ll9pbnRlcm5hbF92aWV3LFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfb2JqZWN0OiBzb3VyY2VSZXN1bHQuX2ludGVybmFsX29iamVjdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0UHJpbWl0aXZlSGl0ICYmIGJlc3RQcmltaXRpdmVIaXQuX2ludGVybmFsX3NvdXJjZSA9PT0gc291cmNlICYmIGJlc3RQcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC56T3JkZXIgIT09ICdib3R0b20nICYmIGJlc3RQcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC5pc0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UHJpbWl0aXZlSGl0UmVzdWx0KGJlc3RQcmltaXRpdmVIaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0UHJpbWl0aXZlSGl0Py5faW50ZXJuYWxfaGl0KSB7XG4gICAgICAgIC8vIHJldHVybiBwcmltaXRpdmUgaGl0cyBmb3IgdGhlICdib3R0b20nIGxheWVyXG4gICAgICAgIHJldHVybiBjb252ZXJ0UHJpbWl0aXZlSGl0UmVzdWx0KGJlc3RQcmltaXRpdmVIaXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRm9ybWF0dGVkTGFiZWxzQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCwgaG9yelNjYWxlQmVoYXZpb3IsIHNpemUgPSA1MCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2xkZXN0VGljayA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdCh0aWNrTWFyaykge1xuICAgICAgICBjb25zdCB0aW1lID0gdGlja01hcmsudGltZTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jYWNoZUtleSh0aW1lKTtcbiAgICAgICAgY29uc3QgdGljayA9IHRoaXMuX3ByaXZhdGVfX2NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmICh0aWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrLl9pbnRlcm5hbF9zdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPT09IHRoaXMuX3ByaXZhdGVfX21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZGVzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMuZ2V0KHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2spO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMuZGVsZXRlKHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2spO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuZGVsZXRlKGVuc3VyZURlZmluZWQob2xkZXN0VmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2srKztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLl9wcml2YXRlX19mb3JtYXQodGlja01hcmspO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5zZXQoY2FjaGVLZXksIHsgX2ludGVybmFsX3N0cmluZzogc3RyLCBfaW50ZXJuYWxfdGljazogdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrMkxhYmVscy5zZXQodGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrLCBjYWNoZUtleSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUrKztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXNhZ2VUaWNrKys7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufVxuXG5jbGFzcyBSYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGFzc2VydChsZWZ0IDw9IHJpZ2h0LCAncmlnaHQgc2hvdWxkIGJlID49IGxlZnQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0IC0gdGhpcy5fcHJpdmF0ZV9fbGVmdCArIDE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb250YWlucyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdCA8PSBpbmRleCAmJiBpbmRleCA8PSB0aGlzLl9wcml2YXRlX19yaWdodDtcbiAgICB9XG4gICAgX2ludGVybmFsX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdCA9PT0gb3RoZXIuX2ludGVybmFsX2xlZnQoKSAmJiB0aGlzLl9wcml2YXRlX19yaWdodCA9PT0gb3RoZXIuX2ludGVybmFsX3JpZ2h0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJlUmFuZ2VzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChmaXJzdCA9PT0gbnVsbCB8fCBzZWNvbmQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdC5faW50ZXJuYWxfZXF1YWxzKHNlY29uZCk7XG59XG5cbmNsYXNzIFRpY2tNYXJrcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pZm9ybURpc3RyaWJ1dGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VW5pZm9ybURpc3RyaWJ1dGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pZm9ybURpc3RyaWJ1dGlvbiA9IHZhbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlUG9pbnRzKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW1vdmVNYXJrc1NpbmNlSW5kZXgoZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBmaXJzdENoYW5nZWRQb2ludEluZGV4OyBpbmRleCA8IG5ld1BvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3UG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBtYXJrc0ZvcldlaWdodCA9IHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZ2V0KHBvaW50LnRpbWVXZWlnaHQpO1xuICAgICAgICAgICAgaWYgKG1hcmtzRm9yV2VpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrc0ZvcldlaWdodCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuc2V0KHBvaW50LnRpbWVXZWlnaHQsIG1hcmtzRm9yV2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmtzRm9yV2VpZ2h0LnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiBwb2ludC50aW1lLFxuICAgICAgICAgICAgICAgIHdlaWdodDogcG9pbnQudGltZVdlaWdodCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRpbWU6IHBvaW50Lm9yaWdpbmFsVGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9idWlsZChzcGFjaW5nLCBtYXhXaWR0aCwgY2hlY2tJbmRpY2VzRm9yRGF0YSwgaW5kaWNlc1dpdGhEYXRhTWFwLCBpbmRpY2VzV2l0aERhdGFJZCkge1xuICAgICAgICBjb25zdCBtYXhJbmRleGVzUGVyTWFyayA9IE1hdGguY2VpbChtYXhXaWR0aCAvIHNwYWNpbmcpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGUgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF9tYXhJbmRleGVzUGVyTWFyayAhPT0gbWF4SW5kZXhlc1Blck1hcmsgfHxcbiAgICAgICAgICAgIGluZGljZXNXaXRoRGF0YUlkICE9PSB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfaW5kaWNlc1dpdGhEYXRhSWQgfHxcbiAgICAgICAgICAgIGNoZWNrSW5kaWNlc0ZvckRhdGEgIT09IHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF9jaGVja0luZGljZXNGb3JEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW5kaWNlc1dpdGhEYXRhSWQ6IGluZGljZXNXaXRoRGF0YUlkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jaGVja0luZGljZXNGb3JEYXRhOiBjaGVja0luZGljZXNGb3JEYXRhLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9tYXJrczogdGhpcy5fcHJpdmF0ZV9fYnVpbGRNYXJrc0ltcGwobWF4SW5kZXhlc1Blck1hcmssIGNoZWNrSW5kaWNlc0ZvckRhdGEsIGluZGljZXNXaXRoRGF0YU1hcCksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX21heEluZGV4ZXNQZXJNYXJrOiBtYXhJbmRleGVzUGVyTWFyayxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlLl9pbnRlcm5hbF9tYXJrcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlbW92ZU1hcmtzU2luY2VJbmRleChzaW5jZUluZGV4KSB7XG4gICAgICAgIGlmIChzaW5jZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2VpZ2h0c1RvQ2xlYXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5mb3JFYWNoKChtYXJrcywgdGltZVdlaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpbmNlSW5kZXggPD0gbWFya3NbMF0uaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzVG9DbGVhci5wdXNoKHRpbWVXZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya3Muc3BsaWNlKGxvd2VyQm91bmQobWFya3MsIHNpbmNlSW5kZXgsICh0bSkgPT4gdG0uaW5kZXggPCBzaW5jZUluZGV4KSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCB3ZWlnaHQgb2Ygd2VpZ2h0c1RvQ2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZGVsZXRlKHdlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2J1aWxkTWFya3NJbXBsKG1heEluZGV4ZXNQZXJNYXJrLCBjaGVja0luZGljZXNGb3JEYXRhLCBpbmRpY2VzV2l0aERhdGFNYXApIHtcbiAgICAgICAgbGV0IG1hcmtzID0gW107XG4gICAgICAgIGNvbnN0IGNhbkJlSW5jbHVkZWQgPSAobWFyaykgPT4gIWNoZWNrSW5kaWNlc0ZvckRhdGEgfHwgaW5kaWNlc1dpdGhEYXRhTWFwLmhhcyhtYXJrLmluZGV4KTtcbiAgICAgICAgZm9yIChjb25zdCB3ZWlnaHQgb2YgQXJyYXkuZnJvbSh0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmtleXMoKSkuc29ydCgoYSwgYikgPT4gYiAtIGEpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZ2V0KHdlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1aWx0IHRpY2tNYXJrcyBhcmUgbm93IHByZXZNYXJrcywgYW5kIG1hcmtzIGl0IGFzIG5ldyBhcnJheVxuICAgICAgICAgICAgY29uc3QgcHJldk1hcmtzID0gbWFya3M7XG4gICAgICAgICAgICBtYXJrcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJldk1hcmtzTGVuZ3RoID0gcHJldk1hcmtzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwcmV2TWFya3NQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZ2V0KHdlaWdodCkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFdlaWdodExlbmd0aCA9IGN1cnJlbnRXZWlnaHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHJpZ2h0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBsZWZ0SW5kZXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRXZWlnaHRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBjdXJyZW50V2VpZ2h0W2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IG1hcmsuaW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGluZGV4ZXMgd2l0aCB3aGljaCBjdXJyZW50IGluZGV4IHdpbGwgYmUgY29tcGFyZWRcbiAgICAgICAgICAgICAgICAvLyBBbGwgbWFya3MgdG8gdGhlIHJpZ2h0IGlzIG1vdmVkIHRvIG5ldyBhcnJheVxuICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2TWFya3NQb2ludGVyIDwgcHJldk1hcmtzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNYXJrID0gcHJldk1hcmtzW3ByZXZNYXJrc1BvaW50ZXJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBsYXN0TWFyay5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA8IGN1cnJlbnRJbmRleCAmJiBjYW5CZUluY2x1ZGVkKGxhc3RNYXJrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk1hcmtzUG9pbnRlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MucHVzaChsYXN0TWFyayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0SW5kZXggLSBjdXJyZW50SW5kZXggPj0gbWF4SW5kZXhlc1Blck1hcmsgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4IC0gbGVmdEluZGV4ID49IG1heEluZGV4ZXNQZXJNYXJrICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbkJlSW5jbHVkZWQobWFyaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGlja01hcmsgZml0cy4gUGxhY2UgaXQgaW50byBuZXcgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MucHVzaChtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3VuaWZvcm1EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2TWFya3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQbGFjZSBhbGwgdW51c2VkIHRpY2tNYXJrcyBpbnRvIG5ldyBhcnJheTtcbiAgICAgICAgICAgIGZvciAoOyBwcmV2TWFya3NQb2ludGVyIDwgcHJldk1hcmtzTGVuZ3RoOyBwcmV2TWFya3NQb2ludGVyKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVJbmNsdWRlZChwcmV2TWFya3NbcHJldk1hcmtzUG9pbnRlcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gocHJldk1hcmtzW3ByZXZNYXJrc1BvaW50ZXJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZVNjYWxlVmlzaWJsZVJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2dpY2FsUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlID0gbG9naWNhbFJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RyaWN0UmFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VJbXBsKE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9sZWZ0KCkpLCBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9yaWdodCgpKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2U7XG4gICAgfVxuICAgIHN0YXRpYyBfaW50ZXJuYWxfaW52YWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UobnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0VGlja01hcmtNYXhDaGFyYWN0ZXJMZW5ndGggPSA4O1xuZnVuY3Rpb24gbWFya1dpdGhHcmVhdGVyV2VpZ2h0JDIoYSwgYikge1xuICAgIHJldHVybiBhLndlaWdodCA+IGIud2VpZ2h0ID8gYSA6IGI7XG59XG5jbGFzcyBUaW1lU2NhbGUge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBvcHRpb25zLCBsb2NhbGl6YXRpb25PcHRpb25zLCBob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGlja01hcmtzID0gbmV3IFRpY2tNYXJrcygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZWRCeVdlaWdodCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlID0gVGltZVNjYWxlVmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9pbnZhbGlkKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc0FwcGxpZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lTWFya3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kaWNlc1dpdGhEYXRhVXBkYXRlSWQgPSAtMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFiZWxzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zID0gbG9jYWxpemF0aW9uT3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBvcHRpb25zLnJpZ2h0T2Zmc2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nID0gb3B0aW9ucy5iYXJTcGFjaW5nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVEYXRlVGltZUZvcm1hdHRlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aWNrTWFya3MuX2ludGVybmFsX3NldFVuaWZvcm1EaXN0cmlidXRpb24ob3B0aW9ucy51bmlmb3JtRGlzdHJpYnV0aW9uKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVJbmRpY2VzV2l0aERhdGEoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlMb2NhbGl6YXRpb25PcHRpb25zKGxvY2FsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucywgbG9jYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVUaWNrTWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zLCBsb2NhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZG9GaXhMZWZ0RWRnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeFJpZ2h0RWRnZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZG9GaXhSaWdodEVkZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlIHRoYXQgYmFyIHNwYWNpbmcgc2hvdWxkIGJlIGFwcGxpZWQgYmVmb3JlIHJpZ2h0IG9mZnNldFxuICAgICAgICAvLyBiZWNhdXNlIHJpZ2h0IG9mZnNldCBkZXBlbmRzIG9uIGJhciBzcGFjaW5nXG4gICAgICAgIGlmIChvcHRpb25zLmJhclNwYWNpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldEJhclNwYWNpbmcob3B0aW9ucy5iYXJTcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQob3B0aW9ucy5yaWdodE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWluQmFyU3BhY2luZyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4QmFyU3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB5ZXMsIGlmIHdlIGFwcGx5IGJhciBzcGFjaW5nIGNvbnN0cmFpbnMgdGhlbiB3ZSBuZWVkIHRvIGNvcnJlY3QgYmFyIHNwYWNpbmdcbiAgICAgICAgICAgIC8vIHRoZSBlYXNpZXN0IHdheSBpcyB0byBhcHBseSBpdCBvbmNlIGFnYWluXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhvcHRpb25zLmJhclNwYWNpbmcgPz8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZUluZGljZXMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzICE9PSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUluZGljZXNXaXRoRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVUaWNrTWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc0FwcGxpZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2luZGV4VG9UaW1lKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wb2ludHNbaW5kZXhdPy50aW1lID8/IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbmRleFRvVGltZVNjYWxlUG9pbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BvaW50c1tpbmRleF0gPz8gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVUb0luZGV4KHRpbWUsIGZpbmROZWFyZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgLy8gbm8gdGltZSBwb2ludHMgYXZhaWxhYmxlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpID4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRoaXMuX3ByaXZhdGVfX3BvaW50c1t0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoIC0gMV0udGltZSkpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGZpbmROZWFyZXN0ID8gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCAtIDEgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93ZXJCb3VuZCh0aGlzLl9wcml2YXRlX19wb2ludHMsIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSwgKGEsIGIpID0+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShhLnRpbWUpIDwgYik7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSkgPCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGhpcy5fcHJpdmF0ZV9fcG9pbnRzW2luZGV4XS50aW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmROZWFyZXN0ID8gaW5kZXggOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX193aWR0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCA9PT0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2hhc1BvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvLyBzdHJpY3QgcmFuZ2U6IGludGVnZXIgaW5kaWNlcyBvZiB0aGUgYmFycyBpbiB0aGUgdmlzaWJsZSByYW5nZSByb3VuZGVkIGluIG1vcmUgd2lkZSBkaXJlY3Rpb25cbiAgICBfaW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGVMb2dpY2FsUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVZpc2libGVSYW5nZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGVUaW1lUmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiB2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpLFxuICAgICAgICAgICAgdG86IHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfdGltZVJhbmdlRm9yTG9naWNhbFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVSYW5nZUZvckxvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5yb3VuZChyYW5nZS5mcm9tKTtcbiAgICAgICAgY29uc3QgdG8gPSBNYXRoLnJvdW5kKHJhbmdlLnRvKTtcbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZmlyc3RJbmRleCgpKTtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19sYXN0SW5kZXgoKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludChNYXRoLm1heChmaXJzdEluZGV4LCBmcm9tKSkpLFxuICAgICAgICAgICAgdG86IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KE1hdGgubWluKGxhc3RJbmRleCwgdG8pKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VGb3JUaW1lUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfdGltZVRvSW5kZXgocmFuZ2UuZnJvbSwgdHJ1ZSkpLFxuICAgICAgICAgICAgdG86IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfdGltZVRvSW5kZXgocmFuZ2UudG8sIHRydWUpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX3dpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRXaWR0aChuZXdXaWR0aCkge1xuICAgICAgICBpZiAoIWlzRmluaXRlKG5ld1dpZHRoKSB8fCBuZXdXaWR0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3dpZHRoID09PSBuZXdXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gd2UgY2hhbmdlIHRoZSB3aWR0aCBhbmQgd2UgbmVlZCB0byBjb3JyZWN0IHZpc2libGUgcmFuZ2UgYmVjYXVzZSBvZiBmaXhpbmcgbGVmdCBlZGdlXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgdGhlIHByZXZpb3VzIHZpc2libGUgcmFuZ2UgcmF0aGVyIHRoYW4gdGhlIG5ldyBvbmVcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBtaWdodCBiZSB1cGRhdGVkIGJ5IGNoYW5naW5nIHdpZHRoLCBiYXIgc3BhY2luZywgZXRjXG4gICAgICAgIC8vIGJ1dCB3ZSBuZWVkIHRvIHRyeSB0byBrZWVwIHRoZSBzYW1lIHJhbmdlXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmlzaWJsZVJhbmdlID0gdGhpcy5faW50ZXJuYWxfdmlzaWJsZUxvZ2ljYWxSYW5nZSgpO1xuICAgICAgICBjb25zdCBvbGRXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemUgJiYgb2xkV2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGJhciBzcGFjaW5nXG4gICAgICAgICAgICBjb25zdCBuZXdCYXJTcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyAqIG5ld1dpZHRoIC8gb2xkV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nID0gbmV3QmFyU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aW1lIHNjYWxlIGlzIHNjcm9sbGVkIHRvIHRoZSBlbmQgb2YgZGF0YSBhbmQgd2UgaGF2ZSBmaXhlZCByaWdodCBlZGdlXG4gICAgICAgIC8vIGtlZXAgbGVmdCBlZGdlIGluc3RlYWQgb2YgcmlnaHRcbiAgICAgICAgLy8gd2UgbmVlZCBpdCB0byBhdm9pZCBcInNoYWtpbmdcIiBpZiB0aGUgbGFzdCBiYXIgdmlzaWJpbGl0eSBhZmZlY3RzIHRpbWUgc2NhbGUgd2lkdGhcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBsb2dpY2FsIGxlZnQgcmFuZ2UgbWVhbnMgbm90IHRoZSBtaWRkbGUgb2YgYSBiYXIgKGl0J3MgdGhlIGxlZnQgYm9yZGVyKVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmlzaWJsZVJhbmdlICE9PSBudWxsICYmIHByZXZpb3VzVmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sZWZ0KCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gb2xkV2lkdGggLSBuZXdXaWR0aDtcbiAgICAgICAgICAgICAgICAvLyByZWR1Y2UgIF9yaWdodE9mZnNldCBtZWFucyBtb3ZlIHJpZ2h0XG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgbW92ZSBtb3JlIHRoYW4gcmVxdWlyZWQgLSB0aGlzIHdpbGwgYmUgZml4ZWQgYnkgX2NvcnJlY3RPZmZzZXQoKVxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC09IE1hdGgucm91bmQoZGVsdGEgLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0aW5nIGJhciBzcGFjaW5nIHNob3VsZCBiZSBmaXJzdCBiZWNhdXNlIHJpZ2h0IG9mZnNldCBkZXBlbmRzIG9uIGl0XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgIWlzSW50ZWdlcihpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCBkZWx0YUZyb21SaWdodCA9IGJhc2VJbmRleCArIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLl9wcml2YXRlX193aWR0aCAtIChkZWx0YUZyb21SaWdodCArIDAuNSkgKiB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nIC0gMTtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbmRleGVzVG9Db29yZGluYXRlcyhwb2ludHMsIHZpc2libGVSYW5nZSkge1xuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9pbnRlcm5hbF9iYXNlSW5kZXgoKTtcbiAgICAgICAgY29uc3QgaW5kZXhGcm9tID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB2aXNpYmxlUmFuZ2UuZnJvbTtcbiAgICAgICAgY29uc3QgaW5kZXhUbyA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyBwb2ludHMubGVuZ3RoIDogdmlzaWJsZVJhbmdlLnRvO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXhGcm9tOyBpIDwgaW5kZXhUbzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBvaW50c1tpXS5faW50ZXJuYWxfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhRnJvbVJpZ2h0ID0gYmFzZUluZGV4ICsgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgLSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLl9wcml2YXRlX193aWR0aCAtIChkZWx0YUZyb21SaWdodCArIDAuNSkgKiB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nIC0gMTtcbiAgICAgICAgICAgIHBvaW50c1tpXS5faW50ZXJuYWxfeCA9IGNvb3JkaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgsIGNvbnNpZGVySWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IE1hdGguY2VpbCh0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHgpKTtcbiAgICAgICAgaWYgKCFjb25zaWRlcklnbm9yZVdoaXRlc3BhY2UgfHxcbiAgICAgICAgICAgICF0aGlzLl9wcml2YXRlX19vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzIHx8XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zaG91bGRDb25zaWRlckluZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19maW5kTmVhcmVzdEluZGV4V2l0aERhdGEoaW5kZXgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcobmV3QmFyU3BhY2luZykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRCYXJTcGFjaW5nKG5ld0JhclNwYWNpbmcpO1xuICAgICAgICAvLyBkbyBub3QgYWxsb3cgc2Nyb2xsIG91dCBvZiB2aXNpYmxlIGJhcnNcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX2ludGVybmFsX21hcmtzKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lTWFya3NDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5mb250U2l6ZTtcbiAgICAgICAgY29uc3QgcGl4ZWxzUGVyOENoYXJhY3RlcnMgPSAoZm9udFNpemUgKyA0KSAqIDU7XG4gICAgICAgIGNvbnN0IHBpeGVsc1BlckNoYXJhY3RlciA9IHBpeGVsc1BlcjhDaGFyYWN0ZXJzIC8gZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gcGl4ZWxzUGVyQ2hhcmFjdGVyICogKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGlja01hcmtNYXhDaGFyYWN0ZXJMZW5ndGggfHwgZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaW5kZXhQZXJMYWJlbCA9IE1hdGgucm91bmQobWF4TGFiZWxXaWR0aCAvIHNwYWNpbmcpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCkpO1xuICAgICAgICBjb25zdCBmaXJzdEJhciA9IE1hdGgubWF4KHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCksIHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCkgLSBpbmRleFBlckxhYmVsKTtcbiAgICAgICAgY29uc3QgbGFzdEJhciA9IE1hdGgubWF4KHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpLCB2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSAtIGluZGV4UGVyTGFiZWwpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcy5faW50ZXJuYWxfYnVpbGQoc3BhY2luZywgbWF4TGFiZWxXaWR0aCwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlSW5kaWNlcywgdGhpcy5fcHJpdmF0ZV9faW5kaWNlc1dpdGhEYXRhLCB0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGFVcGRhdGVJZCk7XG4gICAgICAgIC8vIGFjY29yZGluZyB0byBpbmRleFBlckxhYmVsIHZhbHVlIHRoaXMgdmFsdWUgbWVhbnMgXCJlYXJsaWVzdCBpbmRleCB3aGljaCBfbWlnaHQgYmVfIHVzZWQgYXMgdGhlIHNlY29uZCBsYWJlbCBvbiB0aW1lIHNjYWxlXCJcbiAgICAgICAgY29uc3QgZWFybGllc3RJbmRleE9mU2Vjb25kTGFiZWwgPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCkgKyBpbmRleFBlckxhYmVsO1xuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gaW5kZXhQZXJMYWJlbCB2YWx1ZSB0aGlzIHZhbHVlIG1lYW5zIFwiZWFybGllc3QgaW5kZXggd2hpY2ggX21pZ2h0IGJlXyB1c2VkIGFzIHRoZSBzZWNvbmQgbGFzdCBsYWJlbCBvbiB0aW1lIHNjYWxlXCJcbiAgICAgICAgY29uc3QgaW5kZXhPZlNlY29uZExhc3RMYWJlbCA9IHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpIC0gaW5kZXhQZXJMYWJlbDtcbiAgICAgICAgY29uc3QgaXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQgPSB0aGlzLl9wcml2YXRlX19pc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZCgpO1xuICAgICAgICBjb25zdCBpc0xlZnRFZGdlRml4ZWQgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlIHx8IGlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkO1xuICAgICAgICBjb25zdCBpc1JpZ2h0RWRnZUZpeGVkID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2UgfHwgaXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQ7XG4gICAgICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdG0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghKGZpcnN0QmFyIDw9IHRtLmluZGV4ICYmIHRtLmluZGV4IDw9IGxhc3RCYXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCB0aGlzLl9wcml2YXRlX19sYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSB0aGlzLl9wcml2YXRlX19sYWJlbHNbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGxhYmVsLmNvb3JkID0gdGhpcy5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUodG0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhYmVsLmxhYmVsID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TGFiZWwodG0pO1xuICAgICAgICAgICAgICAgIGxhYmVsLndlaWdodCA9IHRtLndlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVsID0ge1xuICAgICAgICAgICAgICAgICAgICBuZWVkQWxpZ25Db29yZGluYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmQ6IHRoaXMuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKHRtLmluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdExhYmVsKHRtKSxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiB0bS53ZWlnaHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA+IChtYXhMYWJlbFdpZHRoIC8gMikgJiYgIWlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIHRoZW4gbGV0J3Mgc2hvdyBhbGwgdGljayBtYXJrcyBhcyB1c3VhbFxuICAgICAgICAgICAgICAgIGxhYmVsLm5lZWRBbGlnbkNvb3JkaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgdXNlciBpcyBhYmxlIHRvIHNjcm9sbCBhZnRlciBhIHRpY2sgbWFyayB0aGVuIHNob3cgaXQgYXMgdXN1YWwsIG90aGVyd2lzZSB0aGUgY29vcmRpbmF0ZSBtaWdodCBiZSBhbGlnbmVkXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGluZGV4IGlzIGZvciB0aGUgc2Vjb25kIChsYXN0KSBsYWJlbCBvciBsYXRlciAoZWFybGllcikgdGhlbiBtb3N0IGxpa2VseSB0aGlzIGxhYmVsIG1pZ2h0IGJlIGRpc3BsYXllZCB3aXRob3V0IGNvcnJlY3RpbmcgdGhlIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICBsYWJlbC5uZWVkQWxpZ25Db29yZGluYXRlID0gKGlzTGVmdEVkZ2VGaXhlZCAmJiB0bS5pbmRleCA8PSBlYXJsaWVzdEluZGV4T2ZTZWNvbmRMYWJlbCkgfHwgKGlzUmlnaHRFZGdlRml4ZWQgJiYgdG0uaW5kZXggPj0gaW5kZXhPZlNlY29uZExhc3RMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhYmVscy5sZW5ndGggPSB0YXJnZXRJbmRleDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgPSB0aGlzLl9wcml2YXRlX19sYWJlbHM7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sYWJlbHM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXN0b3JlRGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYmFyU3BhY2luZyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRPZmZzZXQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0QmFzZUluZGV4KGJhc2VJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCA9IGJhc2VJbmRleDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kb0ZpeExlZnRFZGdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFpvb20gaW4vb3V0IHRoZSBzY2FsZSBhcm91bmQgYSBgem9vbVBvaW50YCBvbiBgc2NhbGVgIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHpvb21Qb2ludCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gYXBwbHkgdGhlIHpvb20uXG4gICAgICogSWYgYHJpZ2h0QmFyU3RheXNPblNjcm9sbGAgb3B0aW9uIGlzIGRpc2FibGVkLCB0aGVuIHdpbGwgYmUgdXNlZCB0byByZXN0b3JlIHJpZ2h0IG9mZnNldC5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBab29tIHZhbHVlIChpbiAxLzEwIHBhcnRzIG9mIGN1cnJlbnQgYmFyIHNwYWNpbmcpLlxuICAgICAqIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIHpvb20gb3V0LCBwb3NpdGl2ZSAtIHpvb20gaW4uXG4gICAgICovXG4gICAgX2ludGVybmFsX3pvb20oem9vbVBvaW50LCBzY2FsZSkge1xuICAgICAgICBjb25zdCBmbG9hdEluZGV4QXRab29tUG9pbnQgPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHpvb21Qb2ludCk7XG4gICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSB0aGlzLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgIGNvbnN0IG5ld0JhclNwYWNpbmcgPSBiYXJTcGFjaW5nICsgc2NhbGUgKiAoYmFyU3BhY2luZyAvIDEwKTtcbiAgICAgICAgLy8gem9vbSBpbi9vdXQgYmFyIHNwYWNpbmdcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhuZXdCYXJTcGFjaW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLnJpZ2h0QmFyU3RheXNPblNjcm9sbCkge1xuICAgICAgICAgICAgLy8gYW5kIHRoZW4gY29ycmVjdCByaWdodCBvZmZzZXQgdG8gbW92ZSBpbmRleCB1bmRlciB6b29tUG9pbnQgYmFjayB0byBpdHMgY29vcmRpbmF0ZVxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQodGhpcy5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSArIChmbG9hdEluZGV4QXRab29tUG9pbnQgLSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9GbG9hdEluZGV4KHpvb21Qb2ludCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY2FsZSh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9lbmRTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ICE9PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NhdmVDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlVG8oeCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydExlbmd0aEZyb21SaWdodCA9IGNsYW1wKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0geCwgMCwgdGhpcy5fcHJpdmF0ZV9fd2lkdGgpO1xuICAgICAgICBjb25zdCBjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0ID0gY2xhbXAodGhpcy5fcHJpdmF0ZV9fd2lkdGggLSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCksIDAsIHRoaXMuX3ByaXZhdGVfX3dpZHRoKTtcbiAgICAgICAgaWYgKHN0YXJ0TGVuZ3RoRnJvbVJpZ2h0ID09PSAwIHx8IGN1cnJlbnRMZW5ndGhGcm9tUmlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogc3RhcnRMZW5ndGhGcm9tUmlnaHQgLyBjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgIT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NhdmVDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGlmdEluTG9naWNhbCA9ICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50IC0geCkgLyB0aGlzLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSkuX2ludGVybmFsX3JpZ2h0T2Zmc2V0ICsgc2hpZnRJbkxvZ2ljYWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZG8gbm90IGFsbG93IHNjcm9sbCBvdXQgb2YgdmlzaWJsZSBiYXJzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRvUmVhbFRpbWUoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3Njcm9sbFRvT2Zmc2V0QW5pbWF0ZWQodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodE9mZnNldCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkKG9mZnNldCwgYW5pbWF0aW9uRHVyYXRpb24gPSA0MDAgLyogQ29uc3RhbnRzLkRlZmF1bHRBbmltYXRpb25EdXJhdGlvbiAqLykge1xuICAgICAgICBpZiAoIWlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgZmluaXRlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5pdGUoYW5pbWF0aW9uRHVyYXRpb24pIHx8IGFuaW1hdGlvbkR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhbmltYXRpb25EdXJhdGlvbiAob3B0aW9uYWwpIG11c3QgYmUgZmluaXRlIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0O1xuICAgICAgICBjb25zdCBhbmltYXRpb25TdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9maW5pc2hlZDogKHRpbWUpID0+ICh0aW1lIC0gYW5pbWF0aW9uU3RhcnQpIC8gYW5pbWF0aW9uRHVyYXRpb24gPj0gMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9nZXRQb3NpdGlvbjogKHRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25Qcm9ncmVzcyA9ICh0aW1lIC0gYW5pbWF0aW9uU3RhcnQpIC8gYW5pbWF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgZmluaXNoQW5pbWF0aW9uID0gYW5pbWF0aW9uUHJvZ3Jlc3MgPj0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoQW5pbWF0aW9uID8gb2Zmc2V0IDogc291cmNlICsgKG9mZnNldCAtIHNvdXJjZSkgKiBhbmltYXRpb25Qcm9ncmVzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGlja01hcmtzLl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVQb2ludHMobmV3UG9pbnRzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZUJhcnNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9naWNhbFJhbmdlQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNBcHBsaWVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFzZUluZGV4KCkge1xuICAgICAgICAvLyBudWxsIGlzIHVzZWQgdG8ga25vd24gdGhhdCBiYXNlSW5kZXggaXMgbm90IHNldCB5ZXRcbiAgICAgICAgLy8gc28gaW4gbWV0aG9kcyB3aGljaCBzaG91bGQga25vd24gd2hldGhlciBpdCBpcyBzZXQgb3Igbm90XG4gICAgICAgIC8vIHdlIHNob3VsZCBjaGVjayBmaWVsZCBgX2Jhc2VJbmRleE9yTnVsbGAgaW5zdGVhZCBvZiBnZXR0ZXIgYGJhc2VJbmRleCgpYFxuICAgICAgICAvLyBzZWUgbWluUmlnaHRPZmZzZXQgZm9yIGV4YW1wbGVcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbCB8fCAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VmlzaWJsZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJhbmdlLl9pbnRlcm5hbF9jb3VudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRCYXJTcGFjaW5nKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSByYW5nZS5faW50ZXJuYWxfcmlnaHQoKSAtIHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXRDb250ZW50KCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKTtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpO1xuICAgICAgICBpZiAoZmlyc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFZpc2libGVSYW5nZShuZXcgUmFuZ2VJbXBsKGZpcnN0LCBsYXN0ICsgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodE9mZnNldCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0TG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGJhclJhbmdlID0gbmV3IFJhbmdlSW1wbChyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFZpc2libGVSYW5nZShiYXJSYW5nZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXREYXRlVGltZSh0aW1lU2NhbGVQb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucy50aW1lRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zLnRpbWVGb3JtYXR0ZXIodGltZVNjYWxlUG9pbnQub3JpZ2luYWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuZm9ybWF0SG9yekl0ZW0odGltZVNjYWxlUG9pbnQudGltZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZUluZGljZXNXaXRoRGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kaWNlc1dpdGhEYXRhLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXJpZXNlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHMuX2ludGVybmFsX2Z1bGZpbGxlZEluZGljZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YS5zZXQoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YVVwZGF0ZUlkKys7XG4gICAgfVxuICAgIF9wcml2YXRlX19pc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZCgpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2Nyb2xsJ107XG4gICAgICAgIGNvbnN0IGhhbmRsZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXTtcbiAgICAgICAgcmV0dXJuICFoYW5kbGVTY3JvbGwuaG9yelRvdWNoRHJhZ1xuICAgICAgICAgICAgJiYgIWhhbmRsZVNjcm9sbC5tb3VzZVdoZWVsXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2Nyb2xsLnByZXNzZWRNb3VzZU1vdmVcbiAgICAgICAgICAgICYmICFoYW5kbGVTY3JvbGwudmVydFRvdWNoRHJhZ1xuICAgICAgICAgICAgJiYgIWhhbmRsZVNjYWxlLmF4aXNEb3VibGVDbGlja1Jlc2V0LnRpbWVcbiAgICAgICAgICAgICYmICFoYW5kbGVTY2FsZS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2NhbGUubW91c2VXaGVlbFxuICAgICAgICAgICAgJiYgIWhhbmRsZVNjYWxlLnBpbmNoO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyc3RJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogMDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2xhc3RJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogKHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0Rm9yQ29vcmRpbmF0ZSh4KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcHJpdmF0ZV9fd2lkdGggLSAxIC0geCkgLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh4KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhRnJvbVJpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXRGb3JDb29yZGluYXRlKHgpO1xuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9pbnRlcm5hbF9iYXNlSW5kZXgoKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiYXNlSW5kZXggKyB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCAtIGRlbHRhRnJvbVJpZ2h0O1xuICAgICAgICAvLyBKYXZhU2NyaXB0IHVzZXMgdmVyeSBzdHJhbmdlIHJvdW5kaW5nXG4gICAgICAgIC8vIHdlIG5lZWQgcm91bmRpbmcgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCBjYWxjdWxhdGlvbiBlcnJvcnNcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoaW5kZXggKiAxMDAwMDAwKSAvIDEwMDAwMDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRCYXJTcGFjaW5nKG5ld0JhclNwYWNpbmcpIHtcbiAgICAgICAgY29uc3Qgb2xkQmFyU3BhY2luZyA9IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPSBuZXdCYXJTcGFjaW5nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpO1xuICAgICAgICAvLyB0aGlzLl9iYXJTcGFjaW5nIG1pZ2h0IGJlIGNoYW5nZWQgaW4gX2NvcnJlY3RCYXJTcGFjaW5nXG4gICAgICAgIGlmIChvbGRCYXJTcGFjaW5nICE9PSB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZVZpc2libGVSYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldFZpc2libGVSYW5nZShUaW1lU2NhbGVWaXNpYmxlUmFuZ2UuX2ludGVybmFsX2ludmFsaWQoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5faW50ZXJuYWxfYmFzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IG5ld0JhcnNMZW5ndGggPSB0aGlzLl9wcml2YXRlX193aWR0aCAvIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmc7XG4gICAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyID0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgKyBiYXNlSW5kZXg7XG4gICAgICAgIGNvbnN0IGxlZnRCb3JkZXIgPSByaWdodEJvcmRlciAtIG5ld0JhcnNMZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBsb2dpY2FsUmFuZ2UgPSBuZXcgUmFuZ2VJbXBsKGxlZnRCb3JkZXIsIHJpZ2h0Qm9yZGVyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0VmlzaWJsZVJhbmdlKG5ldyBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UobG9naWNhbFJhbmdlKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpIHtcbiAgICAgICAgY29uc3QgYmFyU3BhY2luZyA9IGNsYW1wKHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcsIHRoaXMuX3ByaXZhdGVfX21pbkJhclNwYWNpbmcoKSwgdGhpcy5fcHJpdmF0ZV9fbWF4QmFyU3BhY2luZygpKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgIT09IGJhclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPSBiYXJTcGFjaW5nO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXhCYXJTcGFjaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tYXhCYXJTcGFjaW5nID4gMCkge1xuICAgICAgICAgICAgLy8gb3B0aW9uIHRha2VzIHByZWNlZGFuY2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1heEJhclNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoYWxmIG9mIHRoZSB3aWR0aCBpcyBkZWZhdWx0IHZhbHVlIGZvciBtYXhpbXVtIGJhciBzcGFjaW5nXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGggKiAwLjU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21pbkJhclNwYWNpbmcoKSB7XG4gICAgICAgIC8vIGlmIGJvdGggb3B0aW9ucyBhcmUgZW5hYmxlZCB0aGVuIGxpbWl0IGJhciBzcGFjaW5nIHNvIHRoYXQgem9vbWluZy1vdXQgaXMgbm90IHBvc3NpYmxlXG4gICAgICAgIC8vIGlmIGl0IHdvdWxkIGNhdXNlIGVpdGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBwb2ludHMgdG8gbW92ZSB0b28gZmFyIGZyb20gYW4gZWRnZVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeFJpZ2h0RWRnZSAmJiB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1pbkJhclNwYWNpbmc7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCkge1xuICAgICAgICAvLyBibG9jayBzY3JvbGxpbmcgb2YgdG8gcGFzdFxuICAgICAgICBjb25zdCBtaW5SaWdodE9mZnNldCA9IHRoaXMuX3ByaXZhdGVfX21pblJpZ2h0T2Zmc2V0KCk7XG4gICAgICAgIGlmIChtaW5SaWdodE9mZnNldCAhPT0gbnVsbCAmJiB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCA8IG1pblJpZ2h0T2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCA9IG1pblJpZ2h0T2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJsb2NrIHNjcm9sbGluZyBvZiB0byBmdXR1cmVcbiAgICAgICAgY29uc3QgbWF4UmlnaHRPZmZzZXQgPSB0aGlzLl9wcml2YXRlX19tYXhSaWdodE9mZnNldCgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPiBtYXhSaWdodE9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBtYXhSaWdodE9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWluUmlnaHRPZmZzZXQoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VJbmRleE9yTnVsbDtcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPT09IG51bGwgfHwgYmFzZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXJzRXN0aW1hdGlvbiA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2VcbiAgICAgICAgICAgID8gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nXG4gICAgICAgICAgICA6IE1hdGgubWluKDIgLyogQ29uc3RhbnRzLk1pblZpc2libGVCYXJzQ291bnQgKi8sIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmlyc3RJbmRleCAtIGJhc2VJbmRleCAtIDEgKyBiYXJzRXN0aW1hdGlvbjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21heFJpZ2h0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2VcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiAodGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nKSAtIE1hdGgubWluKDIgLyogQ29uc3RhbnRzLk1pblZpc2libGVCYXJzQ291bnQgKi8sIHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2F2ZUNvbW1vblRyYW5zaXRpb25zU3RhcnRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX3JpZ2h0T2Zmc2V0OiB0aGlzLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYXJDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdExhYmVsKHRpY2tNYXJrKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZWRCeVdlaWdodC5nZXQodGlja01hcmsud2VpZ2h0KTtcbiAgICAgICAgaWYgKGZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVkTGFiZWxzQ2FjaGUoKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TGFiZWxJbXBsKG1hcmspO1xuICAgICAgICAgICAgfSwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQuc2V0KHRpY2tNYXJrLndlaWdodCwgZm9ybWF0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLl9pbnRlcm5hbF9mb3JtYXQodGlja01hcmspO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0TGFiZWxJbXBsKHRpY2tNYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5mb3JtYXRUaWNrbWFyayh0aWNrTWFyaywgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRWaXNpYmxlUmFuZ2UobmV3VmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGNvbnN0IG9sZFZpc2libGVSYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlID0gbmV3VmlzaWJsZVJhbmdlO1xuICAgICAgICBpZiAoIWFyZVJhbmdlc0VxdWFsKG9sZFZpc2libGVSYW5nZS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKSwgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9zdHJpY3RSYW5nZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVSYW5nZXNFcXVhbChvbGRWaXNpYmxlUmFuZ2UuX2ludGVybmFsX2xvZ2ljYWxSYW5nZSgpLCB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2UuX2ludGVybmFsX2xvZ2ljYWxSYW5nZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlc2V0IG9ubHkgY29vcmRzIGluIGNhc2Ugd2hlbiB0aGlzLl92aXNpYmxlQmFycyBoYXMgbm90IGJlZW4gY2hhbmdlZFxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lTWFya3NDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRlVGlja01hcmtzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRpbWVNYXJrc0NhY2hlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlZEJ5V2VpZ2h0LmNsZWFyKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVEYXRlVGltZUZvcm1hdHRlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IudXBkYXRlRm9ybWF0dGVyKHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZG9GaXhMZWZ0RWRnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKTtcbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB0aGlzLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sZWZ0KCkgLSBmaXJzdEluZGV4O1xuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0RWRnZU9mZnNldCA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC0gZGVsdGEgLSAxO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQobGVmdEVkZ2VPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RCYXJTcGFjaW5nKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kb0ZpeFJpZ2h0RWRnZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2hvdWxkQ29uc2lkZXJJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaWdub3JlV2hpdGVzcGFjZUluZGljZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGEuZ2V0KGluZGV4KSB8fCBmYWxzZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZpbmROZWFyZXN0SW5kZXhXaXRoRGF0YSh4KSB7XG4gICAgICAgIGNvbnN0IGdlbiA9IHRlc3ROZWFyZXN0SW50ZWdlcnMoeCk7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbGFzdEluZGV4KCk7XG4gICAgICAgIHdoaWxlIChtYXhJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZW4ubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YS5nZXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7IC8vIGZhbGxiYWNrIHRvIG9yaWdpbmFsIGluZGV4XG4gICAgfVxufVxuZnVuY3Rpb24qIHRlc3ROZWFyZXN0SW50ZWdlcnMobnVtKSB7XG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcbiAgICBjb25zdCBpc1JvdW5kZWREb3duID0gcm91bmRlZCA8IG51bTtcbiAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaXNSb3VuZGVkRG93bikge1xuICAgICAgICAgICAgeWllbGQgcm91bmRlZCArIG9mZnNldDtcbiAgICAgICAgICAgIHlpZWxkIHJvdW5kZWQgLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCByb3VuZGVkIC0gb2Zmc2V0O1xuICAgICAgICAgICAgeWllbGQgcm91bmRlZCArIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQrKztcbiAgICB9XG59XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiX2J1aWxkLXRpbWUtY29uc3RhbnRzXCIgLz5cbi8qKlxuICogRGV0ZXJtaW5lIGhvdyB0byBleGl0IHRoZSB0cmFja2luZyBtb2RlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIG1vYmlsZSB1c2VycyB3aWxsIGxvbmcgcHJlc3MgdG8gZGVhY3RpdmF0ZSB0aGUgc2Nyb2xsIGFuZCBoYXZlIHRoZSBhYmlsaXR5IHRvIGNoZWNrIHZhbHVlcyBhbmQgZGF0ZXMuXG4gKiBBbm90aGVyIHByZXNzIGlzIHJlcXVpcmVkIHRvIGFjdGl2YXRlIHRoZSBzY3JvbGwsIGJlIGFibGUgdG8gbW92ZSBsZWZ0L3JpZ2h0LCB6b29tLCBldGMuXG4gKi9cbnZhciBUcmFja2luZ01vZGVFeGl0TW9kZTtcbihmdW5jdGlvbiAoVHJhY2tpbmdNb2RlRXhpdE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUcmFja2luZyBNb2RlIHdpbGwgYmUgZGVhY3RpdmF0ZWQgb24gdG91Y2ggZW5kIGV2ZW50LlxuICAgICAqL1xuICAgIFRyYWNraW5nTW9kZUV4aXRNb2RlW1RyYWNraW5nTW9kZUV4aXRNb2RlW1wiT25Ub3VjaEVuZFwiXSA9IDBdID0gXCJPblRvdWNoRW5kXCI7XG4gICAgLyoqXG4gICAgICogVHJhY2tpbmcgTW9kZSB3aWxsIGJlIGRlYWN0aXZhdGVkIG9uIHRoZSBuZXh0IHRhcCBldmVudC5cbiAgICAgKi9cbiAgICBUcmFja2luZ01vZGVFeGl0TW9kZVtUcmFja2luZ01vZGVFeGl0TW9kZVtcIk9uTmV4dFRhcFwiXSA9IDFdID0gXCJPbk5leHRUYXBcIjtcbn0pKFRyYWNraW5nTW9kZUV4aXRNb2RlIHx8IChUcmFja2luZ01vZGVFeGl0TW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBpc1BhbmVQcmltaXRpdmUoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZSBpbnN0YW5jZW9mIFBhbmU7XG59XG5jbGFzcyBDaGFydE1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihpbnZhbGlkYXRlSGFuZGxlciwgb3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3ZlcmVkU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIgPSBpbnZhbGlkYXRlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbG9yUGFyc2VyID0gbmV3IENvbG9yUGFyc2VyKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubGF5b3V0LmNvbG9yUGFyc2Vycyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gbmV3IFByaWNlQXhpc1JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSBuZXcgVGltZVNjYWxlKHRoaXMsIG9wdGlvbnMudGltZVNjYWxlLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvbiwgaG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIgPSBuZXcgQ3Jvc3NoYWlyKHRoaXMsIG9wdGlvbnMuY3Jvc3NoYWlyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFnbmV0ID0gbmV3IE1hZ25ldChvcHRpb25zLmNyb3NzaGFpcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dldE9yQ3JlYXRlUGFuZSgwKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXNbMF0uX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IoREVGQVVMVF9TVFJFVENIX0ZBQ1RPUiAqIDIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IoMCAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLlRvcCAqLyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvciA9IHRoaXMuX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcigxIC8qIEJhY2tncm91bmRDb2xvclNpZGUuQm90dG9tICovKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Z1bGxVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUoSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2Z1bGwoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9saWdodFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jdXJzb3JVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobmV3IEludmFsaWRhdGVNYXNrKDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGludiA9IHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGlvbk1hc2tGb3JTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShpbnYpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaG92ZXJlZFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRIb3ZlcmVkU291cmNlKHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faG92ZXJlZFNvdXJjZT8uX2ludGVybmFsX3NvdXJjZSA9PT0gc291cmNlPy5faW50ZXJuYWxfc291cmNlICYmIHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2U/Ll9pbnRlcm5hbF9vYmplY3Q/Ll9pbnRlcm5hbF9leHRlcm5hbElkID09PSBzb3VyY2U/Ll9pbnRlcm5hbF9vYmplY3Q/Ll9pbnRlcm5hbF9leHRlcm5hbElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGlmIChwcmV2U291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UocHJldlNvdXJjZS5faW50ZXJuYWxfc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGRpdGlvbmFsIGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgdXBkYXRlcyBvZiBzYW1lIHNvdXJjZVxuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsICYmIHNvdXJjZS5faW50ZXJuYWxfc291cmNlICE9PSBwcmV2U291cmNlPy5faW50ZXJuYWxfc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVTb3VyY2Uoc291cmNlLl9pbnRlcm5hbF9zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5mb3JFYWNoKChwKSA9PiBwLl9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zLnRpbWVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxpemF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYXBwbHlMb2NhbGl6YXRpb25PcHRpb25zKG9wdGlvbnMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0UHJpY2VTY2FsZSB8fCBvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRUb3BDb2xvciA9IHRoaXMuX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcigwIC8qIEJhY2tncm91bmRDb2xvclNpZGUuVG9wICovKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZEJvdHRvbUNvbG9yID0gdGhpcy5fcHJpdmF0ZV9fZ2V0QmFja2dyb3VuZENvbG9yKDEgLyogQmFja2dyb3VuZENvbG9yU2lkZS5Cb3R0b20gKi8pO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseVByaWNlU2NhbGVPcHRpb25zKHByaWNlU2NhbGVJZCwgb3B0aW9ucywgcGFuZUluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbcGFuZUluZGV4XTtcbiAgICAgICAgaWYgKHBhbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIGFwcGx5IHByaWNlIHNjYWxlIG9wdGlvbnMgd2l0aCBpbmNvcnJlY3QgcGFuZSBpbmRleDogJHtwYW5lSW5kZXh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmIChwcmljZVNjYWxlSWQgPT09IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLykge1xuICAgICAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGxlZnRQcmljZVNjYWxlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYW5lLl9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgbGVmdFByaWNlU2NhbGU6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaWNlU2NhbGVJZCA9PT0gXCJyaWdodFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuUmlnaHQgKi8pIHtcbiAgICAgICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByaWdodFByaWNlU2NhbGU6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgICByaWdodFByaWNlU2NhbGU6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9pbnRlcm5hbF9maW5kUHJpY2VTY2FsZShwcmljZVNjYWxlSWQsIHBhbmVJbmRleCk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBhcHBseSBwcmljZSBzY2FsZSBvcHRpb25zIHdpdGggaW5jb3JyZWN0IElEOiAke3ByaWNlU2NhbGVJZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMuX2ludGVybmFsX3ByaWNlU2NhbGUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmluZFByaWNlU2NhbGUocHJpY2VTY2FsZUlkLCBwYW5lSW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVzW3BhbmVJbmRleF07XG4gICAgICAgIGlmIChwYW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBwYW5lLl9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChwcmljZVNjYWxlSWQpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcGFuZTogcGFuZSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcHJpY2VTY2FsZTogcHJpY2VTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFBhbmVIZWlnaHQocGFuZSwgaGVpZ2h0KSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3NldEhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldFdpZHRoKHRoaXMuX3ByaXZhdGVfX3dpZHRoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocGFuZSkgPT4gcGFuZS5faW50ZXJuYWxfc2V0V2lkdGgod2lkdGgpKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlUGFuZShpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGgsICdJbnZhbGlkIHBhbmUgaW5kZXgnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2hhbmdlUGFuZXNIZWlnaHQocGFuZUluZGV4LCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocGFuZUluZGV4ID49IDAgJiYgcGFuZUluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoLCAnSW52YWxpZCBwYW5lIGluZGV4Jyk7XG4gICAgICAgIGNvbnN0IHRhcmdldFBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lc1twYW5lSW5kZXhdO1xuICAgICAgICBjb25zdCB0b3RhbFN0cmV0Y2ggPSB0aGlzLl9wcml2YXRlX19wYW5lcy5yZWR1Y2UoKHByZXZWYWx1ZSwgcGFuZSkgPT4gcHJldlZhbHVlICsgcGFuZS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpLCAwKTtcbiAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSB0aGlzLl9wcml2YXRlX19wYW5lcy5yZWR1Y2UoKHByZXZWYWx1ZSwgcGFuZSkgPT4gcHJldlZhbHVlICsgcGFuZS5faW50ZXJuYWxfaGVpZ2h0KCksIDApO1xuICAgICAgICBjb25zdCBtYXhQYW5lSGVpZ2h0ID0gdG90YWxIZWlnaHQgLSBNSU5fUEFORV9IRUlHSFQgKiAodGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGhlaWdodCA9IE1hdGgubWluKG1heFBhbmVIZWlnaHQsIE1hdGgubWF4KE1JTl9QQU5FX0hFSUdIVCwgaGVpZ2h0KSk7XG4gICAgICAgIGNvbnN0IHBpeGVsU3RyZXRjaEZhY3RvciA9IHRvdGFsU3RyZXRjaCAvIHRvdGFsSGVpZ2h0O1xuICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSB0YXJnZXRQYW5lLl9pbnRlcm5hbF9oZWlnaHQoKTtcbiAgICAgICAgdGFyZ2V0UGFuZS5faW50ZXJuYWxfc2V0U3RyZXRjaEZhY3RvcihoZWlnaHQgKiBwaXhlbFN0cmV0Y2hGYWN0b3IpO1xuICAgICAgICBsZXQgb3RoZXJQYW5lc0NoYW5nZSA9IGhlaWdodCAtIG9sZEhlaWdodDtcbiAgICAgICAgbGV0IHBhbmVzQ291bnQgPSB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHBhbmUgb2YgdGhpcy5fcHJpdmF0ZV9fcGFuZXMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lICE9PSB0YXJnZXRQYW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGFuZUhlaWdodCA9IE1hdGgubWluKG1heFBhbmVIZWlnaHQsIE1hdGgubWF4KDMwLCBwYW5lLl9pbnRlcm5hbF9oZWlnaHQoKSAtIG90aGVyUGFuZXNDaGFuZ2UgLyBwYW5lc0NvdW50KSk7XG4gICAgICAgICAgICAgICAgb3RoZXJQYW5lc0NoYW5nZSAtPSAocGFuZS5faW50ZXJuYWxfaGVpZ2h0KCkgLSBuZXdQYW5lSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBwYW5lc0NvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RyZXRjaEZhY3RvciA9IG5ld1BhbmVIZWlnaHQgKiBwaXhlbFN0cmV0Y2hGYWN0b3I7XG4gICAgICAgICAgICAgICAgcGFuZS5faW50ZXJuYWxfc2V0U3RyZXRjaEZhY3RvcihuZXdTdHJldGNoRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zd2FwUGFuZXMoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBhc3NlcnQoZmlyc3QgPj0gMCAmJiBmaXJzdCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCAmJiBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPCB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGgsICdJbnZhbGlkIHBhbmUgaW5kZXgnKTtcbiAgICAgICAgY29uc3QgZmlyc3RQYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbZmlyc3RdO1xuICAgICAgICBjb25zdCBzZWNvbmRQYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXNbZmlyc3RdID0gc2Vjb25kUGFuZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXNbc2Vjb25kXSA9IGZpcnN0UGFuZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY2FsZVByaWNlKHBhbmUsIHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfc3RhcnRTY2FsZVByaWNlKHByaWNlU2NhbGUsIHgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2NhbGVQcmljZVRvKHBhbmUsIHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfc2NhbGVQcmljZVRvKHByaWNlU2NhbGUsIHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVDcm9zc2hhaXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZSh0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY2FsZVByaWNlKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfZW5kU2NhbGVQcmljZShwcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZSh0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjcm9sbFByaWNlKHBhbmUsIHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zdGFydFNjcm9sbFByaWNlKHByaWNlU2NhbGUsIHgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2Nyb2xsUHJpY2VUbyhwYW5lLCBwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFuZS5faW50ZXJuYWxfc2Nyb2xsUHJpY2VUbyhwcmljZVNjYWxlLCB4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUodGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2Nyb2xsUHJpY2UocGFuZSwgcHJpY2VTY2FsZSkge1xuICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhbmUuX2ludGVybmFsX2VuZFNjcm9sbFByaWNlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2V0UHJpY2VTY2FsZShwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3Jlc2V0UHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZSh0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjYWxlVGltZShwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3N0YXJ0U2NhbGUocG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBab29tIGluL291dCB0aGUgY2hhcnQgKGRlcGVuZHMgb24gc2NhbGUgdmFsdWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50WCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gYXBwbHkgdGhlIHpvb20gKHRoZSBwb2ludCB3aGljaCBzaG91bGQgc3RheSBvbiBpdHMgcGxhY2UpXG4gICAgICogQHBhcmFtIHNjYWxlIC0gWm9vbSB2YWx1ZS4gTmVnYXRpdmUgdmFsdWUgbWVhbnMgem9vbSBvdXQsIHBvc2l0aXZlIC0gem9vbSBpbi5cbiAgICAgKi9cbiAgICBfaW50ZXJuYWxfem9vbVRpbWUocG9pbnRYLCBzY2FsZSkge1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgaWYgKHRpbWVTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8IHNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVNjYWxlV2lkdGggPSB0aW1lU2NhbGUuX2ludGVybmFsX3dpZHRoKCk7XG4gICAgICAgIHBvaW50WCA9IE1hdGgubWF4KDEsIE1hdGgubWluKHBvaW50WCwgdGltZVNjYWxlV2lkdGgpKTtcbiAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF96b29tKHBvaW50WCwgc2NhbGUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxDaGFydCh4KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3N0YXJ0U2Nyb2xsVGltZSgwKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2Nyb2xsVGltZVRvKHgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9lbmRTY3JvbGxUaW1lKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZVRpbWVUbyh4KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc2NhbGVUbyh4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2NhbGVUaW1lKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2VuZFNjYWxlKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjcm9sbFRpbWUoeCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3N0YXJ0U2Nyb2xsKHgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2Nyb2xsVGltZVRvKHgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zY3JvbGxUbyh4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2Nyb2xsVGltZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9lbmRTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Nlcmllc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRBbmRTYXZlQ3VycmVudFBvc2l0aW9uKHgsIHksIGV2ZW50LCBwYW5lLCBza2lwRXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9zYXZlT3JpZ2luQ29vcmQoeCwgeSk7XG4gICAgICAgIGxldCBwcmljZSA9IE5hTjtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9JbmRleCh4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgodmlzaWJsZUJhcnMuX2ludGVybmFsX2xlZnQoKSwgaW5kZXgpLCB2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHBhbmUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmljZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKHksIGZpcnN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHByaWNlID0gdGhpcy5fcHJpdmF0ZV9fbWFnbmV0Ll9pbnRlcm5hbF9hbGlnbihwcmljZSwgaW5kZXgsIHBhbmUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX3NldFBvc2l0aW9uKGluZGV4LCBwcmljZSwgcGFuZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2N1cnNvclVwZGF0ZSgpO1xuICAgICAgICBpZiAoIXNraXBFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgaGl0VGVzdCA9IGhpdFRlc3RQYW5lKHBhbmUsIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0SG92ZXJlZFNvdXJjZShoaXRUZXN0ICYmIHsgX2ludGVybmFsX3NvdXJjZTogaGl0VGVzdC5faW50ZXJuYWxfc291cmNlLCBfaW50ZXJuYWxfb2JqZWN0OiBoaXRUZXN0Ll9pbnRlcm5hbF9vYmplY3QsIF9pbnRlcm5hbF9jdXJzb3JTdHlsZTogaGl0VGVzdC5faW50ZXJuYWxfY3Vyc29yU3R5bGUgfHwgbnVsbCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZEluZGV4KCksIHsgeCwgeSB9LCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQSBwb3NpdGlvbiBwcm92aWRlZCBleHRlcm5hbCAobm90IGZyb20gYW4gaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXIpXG4gICAgX2ludGVybmFsX3NldEFuZFNhdmVTeW50aGV0aWNQb3NpdGlvbihwcmljZSwgaG9yaXpvbnRhbFBvc2l0aW9uLCBwYW5lKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBjb25zdCB5ID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGVuc3VyZU5vdE51bGwoZmlyc3RWYWx1ZSkpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdGltZVRvSW5kZXgoaG9yaXpvbnRhbFBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUoZW5zdXJlTm90TnVsbChpbmRleCkpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRBbmRTYXZlQ3VycmVudFBvc2l0aW9uKHgsIHksIG51bGwsIHBhbmUsIHRydWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xlYXJDdXJyZW50UG9zaXRpb24oc2tpcEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNyb3NzaGFpciA9IHRoaXMuX2ludGVybmFsX2Nyb3NzaGFpclNvdXJjZSgpO1xuICAgICAgICBjcm9zc2hhaXIuX2ludGVybmFsX2NsZWFyUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfY3Vyc29yVXBkYXRlKCk7XG4gICAgICAgIGlmICghc2tpcEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZC5faW50ZXJuYWxfZmlyZShudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCkge1xuICAgICAgICAvLyBhcHBseSBtYWduZXRcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfcGFuZSgpO1xuICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3JpZ2luQ29vcmRYKCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9vcmlnaW5Db29yZFkoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldEFuZFNhdmVDdXJyZW50UG9zaXRpb24oeCwgeSwgbnVsbCwgcGFuZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlVGltZVNjYWxlKG5ld0Jhc2VJbmRleCwgbmV3UG9pbnRzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEZpcnN0VGltZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb1RpbWUoMCk7XG4gICAgICAgIGlmIChuZXdQb2ludHMgIT09IHVuZGVmaW5lZCAmJiBmaXJzdENoYW5nZWRQb2ludEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdXBkYXRlKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Rmlyc3RUaW1lID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9pbmRleFRvVGltZSgwKTtcbiAgICAgICAgY29uc3QgY3VycmVudEJhc2VJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYmFzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgLy8gaWYgdGltZSBzY2FsZSBjYW5ub3QgcmV0dXJuIGN1cnJlbnQgdmlzaWJsZSBiYXJzIHJhbmdlIChlLmcuIHRpbWUgc2NhbGUgaGFzIHplcm8td2lkdGgpXG4gICAgICAgIC8vIHRoZW4gd2UgZG8gbm90IG5lZWQgdG8gdXBkYXRlIHJpZ2h0IG9mZnNldCB0byBzaGlmdCB2aXNpYmxlIGJhcnMgcmFuZ2UgdG8gaGF2ZSB0aGUgc2FtZSByaWdodCBvZmZzZXQgYXMgd2UgaGF2ZSBiZWZvcmUgbmV3IGJhclxuICAgICAgICAvLyAoYW5kIGFjdHVhbGx5IHdlIGNhbm5vdClcbiAgICAgICAgaWYgKHZpc2libGVCYXJzICE9PSBudWxsICYmIG9sZEZpcnN0VGltZSAhPT0gbnVsbCAmJiBuZXdGaXJzdFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdFNlcmllc0JhclZpc2libGUgPSB2aXNpYmxlQmFycy5faW50ZXJuYWxfY29udGFpbnMoY3VycmVudEJhc2VJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBpc0xlZnRCYXJTaGlmdFRvTGVmdCA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShvbGRGaXJzdFRpbWUpID4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KG5ld0ZpcnN0VGltZSk7XG4gICAgICAgICAgICBjb25zdCBpc1Nlcmllc1BvaW50c0FkZGVkID0gbmV3QmFzZUluZGV4ICE9PSBudWxsICYmIG5ld0Jhc2VJbmRleCA+IGN1cnJlbnRCYXNlSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBpc1Nlcmllc1BvaW50c0FkZGVkVG9SaWdodCA9IGlzU2VyaWVzUG9pbnRzQWRkZWQgJiYgIWlzTGVmdEJhclNoaWZ0VG9MZWZ0O1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTaGlmdFdoZW5SZXBsYWNpbmdXaGl0ZXNwYWNlID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkuYWxsb3dTaGlmdFZpc2libGVSYW5nZU9uV2hpdGVzcGFjZVJlcGxhY2VtZW50O1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZWRFeGlzdGluZ1doaXRlc3BhY2UgPSBmaXJzdENoYW5nZWRQb2ludEluZGV4ID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBuZWVkU2hpZnRWaXNpYmxlUmFuZ2VPbk5ld0JhciA9IGlzTGFzdFNlcmllc0JhclZpc2libGUgJiYgKCFyZXBsYWNlZEV4aXN0aW5nV2hpdGVzcGFjZSB8fCBhbGxvd1NoaWZ0V2hlblJlcGxhY2luZ1doaXRlc3BhY2UpICYmIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLnNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXI7XG4gICAgICAgICAgICBpZiAoaXNTZXJpZXNQb2ludHNBZGRlZFRvUmlnaHQgJiYgIW5lZWRTaGlmdFZpc2libGVSYW5nZU9uTmV3QmFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGVuc2F0aW9uU2hpZnQgPSBuZXdCYXNlSW5kZXggLSBjdXJyZW50QmFzZUluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQodGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpIC0gY29tcGVuc2F0aW9uU2hpZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc2V0QmFzZUluZGV4KG5ld0Jhc2VJbmRleCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZVBhbmUocGFuZSkge1xuICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVjYWxjdWxhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZUZvclNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzUGFuZVByaW1pdGl2ZShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lcy5maW5kKChwKSA9PiBwLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpLmluY2x1ZGVzKHNvdXJjZSkpO1xuICAgICAgICByZXR1cm4gcGFuZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhbmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5mb3JFYWNoKChwKSA9PiBwLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZSgpKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5mb3JFYWNoKChwKSA9PiBwLl9pbnRlcm5hbF9kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyB0byBhdm9pZCBtZW1sZWFrc1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvbi5wcmljZUZvcm1hdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24ucGVyY2VudGFnZUZvcm1hdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24udGltZUZvcm1hdHRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNSZW5kZXJlck9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlci5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hZGRTZXJpZXNUb1BhbmUoc2VyaWVzLCBwYW5lSW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX2dldE9yQ3JlYXRlUGFuZShwYW5lSW5kZXgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hZGRTZXJpZXNUb1BhbmUoc2VyaWVzLCBwYW5lKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzZXMucHVzaChzZXJpZXMpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGZ1bGxVcGRhdGUgdG8gcmVjYWxjdWxhdGUgY2hhcnQncyBwYXJ0cyBnZW9tZXRyeVxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVtb3ZlU2VyaWVzKHNlcmllcykge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzZXJpZXMpO1xuICAgICAgICBjb25zdCBzZXJpZXNJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLmluZGV4T2Yoc2VyaWVzKTtcbiAgICAgICAgYXNzZXJ0KHNlcmllc0luZGV4ICE9PSAtMSwgJ1NlcmllcyBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFuZUltcGwgPSBlbnN1cmVOb3ROdWxsKHBhbmUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNlcy5zcGxpY2Uoc2VyaWVzSW5kZXgsIDEpO1xuICAgICAgICBwYW5lSW1wbC5faW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzZXJpZXMpO1xuICAgICAgICBpZiAoc2VyaWVzLl9pbnRlcm5hbF9kZXN0cm95KSB7XG4gICAgICAgICAgICBzZXJpZXMuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3JlY2FsY3VsYXRlSW5kaWNlc1dpdGhEYXRhKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFudXBJZlBhbmVJc0VtcHR5KHBhbmVJbXBsKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vdmVTZXJpZXNUb1NjYWxlKHNlcmllcywgdGFyZ2V0U2NhbGVJZCkge1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHNlcmllcykpO1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9yZW1vdmVEYXRhU291cmNlKHNlcmllcywgdHJ1ZSk7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc2VyaWVzLCB0YXJnZXRTY2FsZUlkLCB0cnVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpdENvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfc2V0Rml0Q29udGVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGFyZ2V0TG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfYXBwbHlSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9saWdodCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0QmFyU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhzcGFjaW5nKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRUaW1lU2NhbGVBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKGFuaW1hdGlvbik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3N0b3BUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodFByaWNlU2NhbGUudmlzaWJsZSA/IFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovIDogXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW92ZVNlcmllc1RvUGFuZShzZXJpZXMsIG5ld1BhbmVJbmRleCkge1xuICAgICAgICBhc3NlcnQobmV3UGFuZUluZGV4ID49IDAsICdJbmRleCBzaG91bGQgYmUgZ3JlYXRlciBvciBlcXVhbCB0byAwJyk7XG4gICAgICAgIGNvbnN0IGZyb21QYW5lSW5kZXggPSB0aGlzLl9wcml2YXRlX19zZXJpZXNQYW5lSW5kZXgoc2VyaWVzKTtcbiAgICAgICAgaWYgKG5ld1BhbmVJbmRleCA9PT0gZnJvbVBhbmVJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUGFuZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzZXJpZXMpKTtcbiAgICAgICAgcHJldmlvdXNQYW5lLl9pbnRlcm5hbF9yZW1vdmVEYXRhU291cmNlKHNlcmllcyk7XG4gICAgICAgIGNvbnN0IG5ld1BhbmUgPSB0aGlzLl9wcml2YXRlX19nZXRPckNyZWF0ZVBhbmUobmV3UGFuZUluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzVG9QYW5lKHNlcmllcywgbmV3UGFuZSk7XG4gICAgICAgIGlmIChwcmV2aW91c1BhbmUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhbnVwSWZQYW5lSXNFbXB0eShwcmV2aW91c1BhbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kQm90dG9tQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kQm90dG9tQ29sb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3JBdFlQZXJjZW50RnJvbVRvcChwZXJjZW50KSB7XG4gICAgICAgIGNvbnN0IGJvdHRvbUNvbG9yID0gdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZEJvdHRvbUNvbG9yO1xuICAgICAgICBjb25zdCB0b3BDb2xvciA9IHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRUb3BDb2xvcjtcbiAgICAgICAgaWYgKGJvdHRvbUNvbG9yID09PSB0b3BDb2xvcikge1xuICAgICAgICAgICAgLy8gc29saWQgYmFja2dyb3VuZFxuICAgICAgICAgICAgcmV0dXJuIGJvdHRvbUNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyYWRpZW50IGJhY2tncm91bmRcbiAgICAgICAgLy8gcGVyY2VudCBzaG91bGQgYmUgZnJvbSAwIHRvIDEwMCAod2UncmUgdXNpbmcgb25seSBpbnRlZ2VyIHZhbHVlcyB0byBtYWtlIGNhY2hlIG1vcmUgZWZmaWNpZW50KVxuICAgICAgICBwZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBNYXRoLnJvdW5kKHBlcmNlbnQgKiAxMDApKSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlLl9pbnRlcm5hbF90b3BDb2xvciAhPT0gdG9wQ29sb3IgfHwgdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZS5faW50ZXJuYWxfYm90dG9tQ29sb3IgIT09IGJvdHRvbUNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlID0ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjogdG9wQ29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yOiBib3R0b21Db2xvcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29sb3JzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkVmFsdWUgPSB0aGlzLl9wcml2YXRlX19ncmFkaWVudENvbG9yc0NhY2hlLl9pbnRlcm5hbF9jb2xvcnMuZ2V0KHBlcmNlbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcHJpdmF0ZV9fY29sb3JQYXJzZXIuX2ludGVybmFsX2dyYWRpZW50Q29sb3JBdFBlcmNlbnQodG9wQ29sb3IsIGJvdHRvbUNvbG9yLCBwZXJjZW50IC8gMTAwKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZS5faW50ZXJuYWxfY29sb3JzLnNldChwZXJjZW50LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0UGFuZUluZGV4KHBhbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmluZGV4T2YocGFuZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb2xvclBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NvbG9yUGFyc2VyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0T3JDcmVhdGVQYW5lKGluZGV4KSB7XG4gICAgICAgIGFzc2VydChpbmRleCA+PSAwLCAnSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMCcpO1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFuZSA9IG5ldyBQYW5lKHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLnB1c2gocGFuZSk7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBkbyBhdXRvc2NhbGluZyBvbiB0aGUgY3JlYXRpb25cbiAgICAgICAgLy8gaWYgYXV0b3NjYWxlIG9wdGlvbiBpcyB0cnVlLCBpdCBpcyBvaywganVzdCByZWNhbGN1bGF0ZSBieSBpbnZhbGlkYXRpb24gbWFza1xuICAgICAgICAvLyBpZiBhdXRvc2NhbGUgb3B0aW9uIGlzIGZhbHNlLCBhdXRvc2NhbGUgYW55d2F5IG9uIHRoZSBmaXJzdCBkcmF3XG4gICAgICAgIC8vIGFsc28gdGhlcmUgaXMgYSBzY2VuYXJpbyB3aGVuIGF1dG9zY2FsZSBpcyB0cnVlIGluIGNvbnN0cnVjdG9yIGFuZCBmYWxzZSBsYXRlciBvbiBhcHBseU9wdGlvbnNcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9mdWxsKCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX2ludmFsaWRhdGVQYW5lKGluZGV4LCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGV2ZWw6IDAgLyogSW52YWxpZGF0aW9uTGV2ZWwuTm9uZSAqLyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hdXRvU2NhbGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgICAgICByZXR1cm4gcGFuZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Nlcmllc1BhbmVJbmRleChzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZpbmRJbmRleCgocGFuZSkgPT4gcGFuZS5faW50ZXJuYWxfc2VyaWVzKCkuaW5jbHVkZXMoc2VyaWVzKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCBsZXZlbCkge1xuICAgICAgICBjb25zdCBpbnYgPSBuZXcgSW52YWxpZGF0ZU1hc2sobGV2ZWwpO1xuICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX19wYW5lcy5pbmRleE9mKHBhbmUpO1xuICAgICAgICAgICAgaW52Ll9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZShpbmRleCwge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faW52YWxpZGF0aW9uTWFza0ZvclNvdXJjZShzb3VyY2UsIGludmFsaWRhdGVUeXBlKSB7XG4gICAgICAgIGlmIChpbnZhbGlkYXRlVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnZhbGlkYXRlVHlwZSA9IDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHRoaXMuX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc291cmNlKSwgaW52YWxpZGF0ZVR5cGUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIobWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocGFuZSkgPT4gcGFuZS5faW50ZXJuYWxfZ3JpZCgpLl9pbnRlcm5hbF9wYW5lVmlldygpLl9pbnRlcm5hbF91cGRhdGUoKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hZGRTZXJpZXNUb1BhbmUoc2VyaWVzLCBwYW5lKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGVJZCA9IHNlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLnByaWNlU2NhbGVJZDtcbiAgICAgICAgY29uc3QgdGFyZ2V0U2NhbGVJZCA9IHByaWNlU2NhbGVJZCAhPT0gdW5kZWZpbmVkID8gcHJpY2VTY2FsZUlkIDogdGhpcy5faW50ZXJuYWxfZGVmYXVsdFZpc2libGVQcmljZVNjYWxlSWQoKTtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfYWRkRGF0YVNvdXJjZShzZXJpZXMsIHRhcmdldFNjYWxlSWQpO1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByaWNlU2NhbGUodGFyZ2V0U2NhbGVJZCkpIHtcbiAgICAgICAgICAgIC8vIGxldCdzIGFwcGx5IHRoYXQgb3B0aW9ucyBhZ2FpbiB0byBhcHBseSBtYXJnaW5zXG4gICAgICAgICAgICBzZXJpZXMuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhzZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcihzaWRlKSB7XG4gICAgICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zWydsYXlvdXQnXTtcbiAgICAgICAgaWYgKGxheW91dE9wdGlvbnMuYmFja2dyb3VuZC50eXBlID09PSBcImdyYWRpZW50XCIgLyogQ29sb3JUeXBlLlZlcnRpY2FsR3JhZGllbnQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBzaWRlID09PSAwIC8qIEJhY2tncm91bmRDb2xvclNpZGUuVG9wICovID9cbiAgICAgICAgICAgICAgICBsYXlvdXRPcHRpb25zLmJhY2tncm91bmQudG9wQ29sb3IgOlxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbnMuYmFja2dyb3VuZC5ib3R0b21Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0T3B0aW9ucy5iYWNrZ3JvdW5kLmNvbG9yO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYW51cElmUGFuZUlzRW1wdHkocGFuZSkge1xuICAgICAgICBpZiAocGFuZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5sZW5ndGggPT09IDAgJiYgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuc3BsaWNlKHRoaXMuX2ludGVybmFsX2dldFBhbmVJbmRleChwYW5lKSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxVcERvd25DYW5kbGVzdGlja3NDb2xvcnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmJvcmRlckNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJVcENvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJEb3duQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aWNrQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLndpY2tVcENvbG9yID0gb3B0aW9ucy53aWNrQ29sb3I7XG4gICAgICAgIG9wdGlvbnMud2lja0Rvd25Db2xvciA9IG9wdGlvbnMud2lja0NvbG9yO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdHlwZSBvZiB0aGUgbGFzdCBwcmljZSBhbmltYXRpb24gZm9yIHNlcmllcyBzdWNoIGFzIGFyZWEgb3IgbGluZS5cbiAqL1xudmFyIExhc3RQcmljZUFuaW1hdGlvbk1vZGU7XG4oZnVuY3Rpb24gKExhc3RQcmljZUFuaW1hdGlvbk1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gaXMgYWx3YXlzIGRpc2FibGVkXG4gICAgICovXG4gICAgTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtMYXN0UHJpY2VBbmltYXRpb25Nb2RlW1wiRGlzYWJsZWRcIl0gPSAwXSA9IFwiRGlzYWJsZWRcIjtcbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gaXMgYWx3YXlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtMYXN0UHJpY2VBbmltYXRpb25Nb2RlW1wiQ29udGludW91c1wiXSA9IDFdID0gXCJDb250aW51b3VzXCI7XG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGlzIGFjdGl2ZSBhZnRlciBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBMYXN0UHJpY2VBbmltYXRpb25Nb2RlW0xhc3RQcmljZUFuaW1hdGlvbk1vZGVbXCJPbkRhdGFVcGRhdGVcIl0gPSAyXSA9IFwiT25EYXRhVXBkYXRlXCI7XG59KShMYXN0UHJpY2VBbmltYXRpb25Nb2RlIHx8IChMYXN0UHJpY2VBbmltYXRpb25Nb2RlID0ge30pKTtcbmZ1bmN0aW9uIHByZWNpc2lvbkJ5TWluTW92ZShtaW5Nb3ZlKSB7XG4gICAgaWYgKG1pbk1vdmUgPj0gMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGludFBhcnQgPSBNYXRoLnJvdW5kKG1pbk1vdmUpO1xuICAgICAgICBjb25zdCBmcmFjdFBhcnQgPSBNYXRoLmFicyhpbnRQYXJ0IC0gbWluTW92ZSk7XG4gICAgICAgIGlmIChmcmFjdFBhcnQgPCAxZS04KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBtaW5Nb3ZlID0gbWluTW92ZSAqIDEwO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgc291cmNlIG9mIGRhdGEgdG8gYmUgdXNlZCBmb3IgdGhlIGhvcml6b250YWwgcHJpY2UgbGluZS5cbiAqL1xudmFyIFByaWNlTGluZVNvdXJjZTtcbihmdW5jdGlvbiAoUHJpY2VMaW5lU291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBsYXN0IGJhciBkYXRhLlxuICAgICAqL1xuICAgIFByaWNlTGluZVNvdXJjZVtQcmljZUxpbmVTb3VyY2VbXCJMYXN0QmFyXCJdID0gMF0gPSBcIkxhc3RCYXJcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGxhc3QgdmlzaWJsZSBkYXRhIG9mIHRoZSBjaGFydCB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBQcmljZUxpbmVTb3VyY2VbUHJpY2VMaW5lU291cmNlW1wiTGFzdFZpc2libGVcIl0gPSAxXSA9IFwiTGFzdFZpc2libGVcIjtcbn0pKFByaWNlTGluZVNvdXJjZSB8fCAoUHJpY2VMaW5lU291cmNlID0ge30pKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHlwZSBvZiBjb2xvci5cbiAqL1xudmFyIENvbG9yVHlwZTtcbihmdW5jdGlvbiAoQ29sb3JUeXBlKSB7XG4gICAgLyoqIFNvbGlkIGNvbG9yICovXG4gICAgQ29sb3JUeXBlW1wiU29saWRcIl0gPSBcInNvbGlkXCI7XG4gICAgLyoqIFZlcnRpY2FsIGdyYWRpZW50IGNvbG9yICovXG4gICAgQ29sb3JUeXBlW1wiVmVydGljYWxHcmFkaWVudFwiXSA9IFwiZ3JhZGllbnRcIjtcbn0pKENvbG9yVHlwZSB8fCAoQ29sb3JUeXBlID0ge30pKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHRpbWUgdmFsdWUgaXMgYSBidXNpbmVzcyBkYXkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0aW1lIC0gVGhlIHRpbWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRpbWVgIGlzIGEge0BsaW5rIEJ1c2luZXNzRGF5fSBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNCdXNpbmVzc0RheSh0aW1lKSB7XG4gICAgcmV0dXJuICFpc051bWJlcih0aW1lKSAmJiAhaXNTdHJpbmcodGltZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdGltZSB2YWx1ZSBpcyBhIFVUQyB0aW1lc3RhbXAgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB0aW1lIC0gVGhlIHRpbWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRpbWVgIGlzIGEge0BsaW5rIFVUQ1RpbWVzdGFtcH0gbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVVRDVGltZXN0YW1wKHRpbWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGltZSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHR5cGUgb2YgYSB0aWNrIG1hcmsgb24gdGhlIHRpbWUgYXhpcy5cbiAqL1xudmFyIFRpY2tNYXJrVHlwZTtcbihmdW5jdGlvbiAoVGlja01hcmtUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IG9mIHRoZSB5ZWFyIChlLmcuIGl0J3MgdGhlIGZpcnN0IHRpY2sgbWFyayBpbiBhIHllYXIpLlxuICAgICAqL1xuICAgIFRpY2tNYXJrVHlwZVtUaWNrTWFya1R5cGVbXCJZZWFyXCJdID0gMF0gPSBcIlllYXJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoIChlLmcuIGl0J3MgdGhlIGZpcnN0IHRpY2sgbWFyayBpbiBhIG1vbnRoKS5cbiAgICAgKi9cbiAgICBUaWNrTWFya1R5cGVbVGlja01hcmtUeXBlW1wiTW9udGhcIl0gPSAxXSA9IFwiTW9udGhcIjtcbiAgICAvKipcbiAgICAgKiBBIGRheSBvZiB0aGUgbW9udGguXG4gICAgICovXG4gICAgVGlja01hcmtUeXBlW1RpY2tNYXJrVHlwZVtcIkRheU9mTW9udGhcIl0gPSAyXSA9IFwiRGF5T2ZNb250aFwiO1xuICAgIC8qKlxuICAgICAqIEEgdGltZSB3aXRob3V0IHNlY29uZHMuXG4gICAgICovXG4gICAgVGlja01hcmtUeXBlW1RpY2tNYXJrVHlwZVtcIlRpbWVcIl0gPSAzXSA9IFwiVGltZVwiO1xuICAgIC8qKlxuICAgICAqIEEgdGltZSB3aXRoIHNlY29uZHMuXG4gICAgICovXG4gICAgVGlja01hcmtUeXBlW1RpY2tNYXJrVHlwZVtcIlRpbWVXaXRoU2Vjb25kc1wiXSA9IDRdID0gXCJUaW1lV2l0aFNlY29uZHNcIjtcbn0pKFRpY2tNYXJrVHlwZSB8fCAoVGlja01hcmtUeXBlID0ge30pKTtcblxuY29uc3QgZ2V0TW9udGggPSAoZGF0ZSkgPT4gZGF0ZS5nZXRVVENNb250aCgpICsgMTtcbmNvbnN0IGdldERheSA9IChkYXRlKSA9PiBkYXRlLmdldFVUQ0RhdGUoKTtcbmNvbnN0IGdldFllYXIgPSAoZGF0ZSkgPT4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuY29uc3QgZGQgPSAoZGF0ZSkgPT4gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZ2V0RGF5KGRhdGUpLCAyKTtcbmNvbnN0IE1NTU0gPSAoZGF0ZSwgbG9jYWxlKSA9PiBuZXcgRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgMSlcbiAgICAudG9Mb2NhbGVTdHJpbmcobG9jYWxlLCB7IG1vbnRoOiAnbG9uZycgfSk7XG5jb25zdCBNTU0gPSAoZGF0ZSwgbG9jYWxlKSA9PiBuZXcgRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgMSlcbiAgICAudG9Mb2NhbGVTdHJpbmcobG9jYWxlLCB7IG1vbnRoOiAnc2hvcnQnIH0pO1xuY29uc3QgTU0gPSAoZGF0ZSkgPT4gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZ2V0TW9udGgoZGF0ZSksIDIpO1xuY29uc3QgeXkgPSAoZGF0ZSkgPT4gbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZ2V0WWVhcihkYXRlKSAlIDEwMCwgMik7XG5jb25zdCB5eXl5ID0gKGRhdGUpID0+IG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGdldFllYXIoZGF0ZSksIDQpO1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXRcbiAgICAgICAgLnJlcGxhY2UoL3l5eXkvZywgeXl5eShkYXRlKSlcbiAgICAgICAgLnJlcGxhY2UoL3l5L2csIHl5KGRhdGUpKVxuICAgICAgICAucmVwbGFjZSgvTU1NTS9nLCBNTU1NKGRhdGUsIGxvY2FsZSkpXG4gICAgICAgIC5yZXBsYWNlKC9NTU0vZywgTU1NKGRhdGUsIGxvY2FsZSkpXG4gICAgICAgIC5yZXBsYWNlKC9NTS9nLCBNTShkYXRlKSlcbiAgICAgICAgLnJlcGxhY2UoL2RkL2csIGRkKGRhdGUpKTtcbn1cblxuY2xhc3MgRGF0ZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoZGF0ZUZvcm1hdCA9ICd5eXl5LU1NLWRkJywgbG9jYWxlID0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGVGb3JtYXQgPSBkYXRlRm9ybWF0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2NhbGUgPSBsb2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCB0aGlzLl9wcml2YXRlX19kYXRlRm9ybWF0LCB0aGlzLl9wcml2YXRlX19sb2NhbGUpO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFN0ciA9IGZvcm1hdCB8fCAnJWg6JW06JXMnO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFN0ci5yZXBsYWNlKCclaCcsIG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGRhdGUuZ2V0VVRDSG91cnMoKSwgMikpLlxuICAgICAgICAgICAgcmVwbGFjZSgnJW0nLCBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhkYXRlLmdldFVUQ01pbnV0ZXMoKSwgMikpLlxuICAgICAgICAgICAgcmVwbGFjZSgnJXMnLCBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhkYXRlLmdldFVUQ1NlY29uZHMoKSwgMikpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICBfaW50ZXJuYWxfZGF0ZUZvcm1hdDogJ3l5eXktTU0tZGQnLFxuICAgIF9pbnRlcm5hbF90aW1lRm9ybWF0OiAnJWg6JW06JXMnLFxuICAgIF9pbnRlcm5hbF9kYXRlVGltZVNlcGFyYXRvcjogJyAnLFxuICAgIF9pbnRlcm5hbF9sb2NhbGU6ICdkZWZhdWx0Jyxcbn07XG5jbGFzcyBEYXRlVGltZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyUGFyYW1zID0geyAuLi5kZWZhdWx0UGFyYW1zLCAuLi5wYXJhbXMgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0ZUZvcm1hdHRlciA9IG5ldyBEYXRlRm9ybWF0dGVyKGZvcm1hdHRlclBhcmFtcy5faW50ZXJuYWxfZGF0ZUZvcm1hdCwgZm9ybWF0dGVyUGFyYW1zLl9pbnRlcm5hbF9sb2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lRm9ybWF0dGVyID0gbmV3IFRpbWVGb3JtYXR0ZXIoZm9ybWF0dGVyUGFyYW1zLl9pbnRlcm5hbF90aW1lRm9ybWF0KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VwYXJhdG9yID0gZm9ybWF0dGVyUGFyYW1zLl9pbnRlcm5hbF9kYXRlVGltZVNlcGFyYXRvcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdChkYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5fcHJpdmF0ZV9fZGF0ZUZvcm1hdHRlci5faW50ZXJuYWxfZm9ybWF0KGRhdGVUaW1lKX0ke3RoaXMuX3ByaXZhdGVfX3NlcGFyYXRvcn0ke3RoaXMuX3ByaXZhdGVfX3RpbWVGb3JtYXR0ZXIuX2ludGVybmFsX2Zvcm1hdChkYXRlVGltZSl9YDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUaWNrTWFya0Zvcm1hdHRlcih0aW1lUG9pbnQsIHRpY2tNYXJrVHlwZSwgbG9jYWxlKSB7XG4gICAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IHt9O1xuICAgIHN3aXRjaCAodGlja01hcmtUeXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUaWNrTWFya1R5cGUuWWVhciAqLzpcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMueWVhciA9ICdudW1lcmljJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogVGlja01hcmtUeXBlLk1vbnRoICovOlxuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5tb250aCA9ICdzaG9ydCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIFRpY2tNYXJrVHlwZS5EYXlPZk1vbnRoICovOlxuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5kYXkgPSAnbnVtZXJpYyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIFRpY2tNYXJrVHlwZS5UaW1lICovOlxuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5ob3VyMTIgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBUaWNrTWFya1R5cGUuVGltZVdpdGhTZWNvbmRzICovOlxuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5ob3VyMTIgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgZm9ybWF0T3B0aW9ucy5zZWNvbmQgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgZGF0ZSA9IHRpbWVQb2ludC5faW50ZXJuYWxfYnVzaW5lc3NEYXkgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IG5ldyBEYXRlKHRpbWVQb2ludC5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMClcbiAgICAgICAgOiBuZXcgRGF0ZShEYXRlLlVUQyh0aW1lUG9pbnQuX2ludGVybmFsX2J1c2luZXNzRGF5LnllYXIsIHRpbWVQb2ludC5faW50ZXJuYWxfYnVzaW5lc3NEYXkubW9udGggLSAxLCB0aW1lUG9pbnQuX2ludGVybmFsX2J1c2luZXNzRGF5LmRheSkpO1xuICAgIC8vIGZyb20gZ2l2ZW4gZGF0ZSB3ZSBzaG91bGQgdXNlIG9ubHkgYXMgVVRDIGRhdGUgb3IgdGltZXN0YW1wXG4gICAgLy8gYnV0IHRvIGZvcm1hdCBhcyBsb2NhbGUgZGF0ZSB3ZSBjYW4gY29udmVydCBVVEMgZGF0ZSB0byBsb2NhbCBkYXRlXG4gICAgY29uc3QgbG9jYWxEYXRlRnJvbVV0YyA9IG5ldyBEYXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSwgZGF0ZS5nZXRVVENIb3VycygpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCksIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpO1xuICAgIHJldHVybiBsb2NhbERhdGVGcm9tVXRjLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwgZm9ybWF0T3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGhvdXJzKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50ICogNjAgKiA2MCAqIDEwMDA7XG59XG5mdW5jdGlvbiBtaW51dGVzKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50ICogNjAgKiAxMDAwO1xufVxuZnVuY3Rpb24gc2Vjb25kcyhjb3VudCkge1xuICAgIHJldHVybiBjb3VudCAqIDEwMDA7XG59XG5jb25zdCBpbnRyYWRheVdlaWdodERpdmlzb3JzID0gW1xuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IHNlY29uZHMoMSksIF9pbnRlcm5hbF93ZWlnaHQ6IDEwIC8qIFRpY2tNYXJrV2VpZ2h0LlNlY29uZCAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IG1pbnV0ZXMoMSksIF9pbnRlcm5hbF93ZWlnaHQ6IDIwIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTEgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBtaW51dGVzKDUpLCBfaW50ZXJuYWxfd2VpZ2h0OiAyMSAvKiBUaWNrTWFya1dlaWdodC5NaW51dGU1ICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogbWludXRlcygzMCksIF9pbnRlcm5hbF93ZWlnaHQ6IDIyIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTMwICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogaG91cnMoMSksIF9pbnRlcm5hbF93ZWlnaHQ6IDMwIC8qIFRpY2tNYXJrV2VpZ2h0LkhvdXIxICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogaG91cnMoMyksIF9pbnRlcm5hbF93ZWlnaHQ6IDMxIC8qIFRpY2tNYXJrV2VpZ2h0LkhvdXIzICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogaG91cnMoNiksIF9pbnRlcm5hbF93ZWlnaHQ6IDMyIC8qIFRpY2tNYXJrV2VpZ2h0LkhvdXI2ICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogaG91cnMoMTIpLCBfaW50ZXJuYWxfd2VpZ2h0OiAzMyAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMTIgKi8gfSxcbl07XG5mdW5jdGlvbiB3ZWlnaHRCeVRpbWUoY3VycmVudERhdGUsIHByZXZEYXRlKSB7XG4gICAgaWYgKGN1cnJlbnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgIT09IHByZXZEYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcbiAgICAgICAgcmV0dXJuIDcwIC8qIFRpY2tNYXJrV2VpZ2h0LlllYXIgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbnREYXRlLmdldFVUQ01vbnRoKCkgIT09IHByZXZEYXRlLmdldFVUQ01vbnRoKCkpIHtcbiAgICAgICAgcmV0dXJuIDYwIC8qIFRpY2tNYXJrV2VpZ2h0Lk1vbnRoICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50RGF0ZS5nZXRVVENEYXRlKCkgIT09IHByZXZEYXRlLmdldFVUQ0RhdGUoKSkge1xuICAgICAgICByZXR1cm4gNTAgLyogVGlja01hcmtXZWlnaHQuRGF5ICovO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gaW50cmFkYXlXZWlnaHREaXZpc29ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoTWF0aC5mbG9vcihwcmV2RGF0ZS5nZXRUaW1lKCkgLyBpbnRyYWRheVdlaWdodERpdmlzb3JzW2ldLl9pbnRlcm5hbF9kaXZpc29yKSAhPT0gTWF0aC5mbG9vcihjdXJyZW50RGF0ZS5nZXRUaW1lKCkgLyBpbnRyYWRheVdlaWdodERpdmlzb3JzW2ldLl9pbnRlcm5hbF9kaXZpc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludHJhZGF5V2VpZ2h0RGl2aXNvcnNbaV0uX2ludGVybmFsX3dlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBUaWNrTWFya1dlaWdodC5MZXNzVGhhblNlY29uZCAqLztcbn1cbmZ1bmN0aW9uIGNhc3QodCkge1xuICAgIHJldHVybiB0O1xufVxuZnVuY3Rpb24gZmlsbFdlaWdodHNGb3JQb2ludHMoc29ydGVkVGltZVBvaW50cywgc3RhcnRJbmRleCA9IDApIHtcbiAgICBpZiAoc29ydGVkVGltZVBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJldlRpbWUgPSBzdGFydEluZGV4ID09PSAwID8gbnVsbCA6IGNhc3Qoc29ydGVkVGltZVBvaW50c1tzdGFydEluZGV4IC0gMV0udGltZSkuX2ludGVybmFsX3RpbWVzdGFtcDtcbiAgICBsZXQgcHJldkRhdGUgPSBwcmV2VGltZSAhPT0gbnVsbCA/IG5ldyBEYXRlKHByZXZUaW1lICogMTAwMCkgOiBudWxsO1xuICAgIGxldCB0b3RhbFRpbWVEaWZmID0gMDtcbiAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgc29ydGVkVGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gc29ydGVkVGltZVBvaW50c1tpbmRleF07XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoY2FzdChjdXJyZW50UG9pbnQudGltZSkuX2ludGVybmFsX3RpbWVzdGFtcCAqIDEwMDApO1xuICAgICAgICBpZiAocHJldkRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC50aW1lV2VpZ2h0ID0gd2VpZ2h0QnlUaW1lKGN1cnJlbnREYXRlLCBwcmV2RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxUaW1lRGlmZiArPSBjYXN0KGN1cnJlbnRQb2ludC50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wIC0gKHByZXZUaW1lIHx8IGNhc3QoY3VycmVudFBvaW50LnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXApO1xuICAgICAgICBwcmV2VGltZSA9IGNhc3QoY3VycmVudFBvaW50LnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXA7XG4gICAgICAgIHByZXZEYXRlID0gY3VycmVudERhdGU7XG4gICAgfVxuICAgIGlmIChzdGFydEluZGV4ID09PSAwICYmIHNvcnRlZFRpbWVQb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBsZXQncyBndWVzcyBhIHdlaWdodCBmb3IgdGhlIGZpcnN0IHBvaW50XG4gICAgICAgIC8vIGxldCdzIHNheSB0aGUgcHJldmlvdXMgcG9pbnQgd2FzIGF2ZXJhZ2UgdGltZSBiYWNrIGluIHRoZSBoaXN0b3J5XG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VUaW1lRGlmZiA9IE1hdGguY2VpbCh0b3RhbFRpbWVEaWZmIC8gKHNvcnRlZFRpbWVQb2ludHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICBjb25zdCBhcHByb3hQcmV2RGF0ZSA9IG5ldyBEYXRlKChjYXN0KHNvcnRlZFRpbWVQb2ludHNbMF0udGltZSkuX2ludGVybmFsX3RpbWVzdGFtcCAtIGF2ZXJhZ2VUaW1lRGlmZikgKiAxMDAwKTtcbiAgICAgICAgc29ydGVkVGltZVBvaW50c1swXS50aW1lV2VpZ2h0ID0gd2VpZ2h0QnlUaW1lKG5ldyBEYXRlKGNhc3Qoc29ydGVkVGltZVBvaW50c1swXS50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMCksIGFwcHJveFByZXZEYXRlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1c2luZXNzRGF5Q29udmVydGVyKHRpbWUpIHtcbiAgICBsZXQgYnVzaW5lc3NEYXkgPSB0aW1lO1xuICAgIGlmIChpc1N0cmluZyh0aW1lKSkge1xuICAgICAgICBidXNpbmVzc0RheSA9IHN0cmluZ1RvQnVzaW5lc3NEYXkodGltZSk7XG4gICAgfVxuICAgIGlmICghaXNCdXNpbmVzc0RheShidXNpbmVzc0RheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aW1lIG11c3QgYmUgb2YgdHlwZSBCdXNpbmVzc0RheScpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoYnVzaW5lc3NEYXkueWVhciwgYnVzaW5lc3NEYXkubW9udGggLSAxLCBidXNpbmVzc0RheS5kYXksIDAsIDAsIDAsIDApKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfdGltZXN0YW1wOiBNYXRoLnJvdW5kKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCksXG4gICAgICAgIF9pbnRlcm5hbF9idXNpbmVzc0RheTogYnVzaW5lc3NEYXksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcENvbnZlcnRlcih0aW1lKSB7XG4gICAgaWYgKCFpc1VUQ1RpbWVzdGFtcCh0aW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RpbWUgbXVzdCBiZSBvZiB0eXBlIGlzVVRDVGltZXN0YW1wJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF90aW1lc3RhbXA6IHRpbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRpbWVDb252ZXJ0ZXIoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzQnVzaW5lc3NEYXkoZGF0YVswXS50aW1lKSB8fCBpc1N0cmluZyhkYXRhWzBdLnRpbWUpKSB7XG4gICAgICAgIHJldHVybiBidXNpbmVzc0RheUNvbnZlcnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcENvbnZlcnRlcjtcbn1cbmNvbnN0IHZhbGlkRGF0ZVJlZ2V4ID0gL15cXGRcXGRcXGRcXGQtXFxkXFxkLVxcZFxcZCQvO1xuZnVuY3Rpb24gY29udmVydFRpbWUodGltZSkge1xuICAgIGlmIChpc1VUQ1RpbWVzdGFtcCh0aW1lKSkge1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wQ29udmVydGVyKHRpbWUpO1xuICAgIH1cbiAgICBpZiAoIWlzQnVzaW5lc3NEYXkodGltZSkpIHtcbiAgICAgICAgcmV0dXJuIGJ1c2luZXNzRGF5Q29udmVydGVyKHN0cmluZ1RvQnVzaW5lc3NEYXkodGltZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVzaW5lc3NEYXlDb252ZXJ0ZXIodGltZSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J1c2luZXNzRGF5KHZhbHVlKSB7XG4gICAge1xuICAgICAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChJIGxvb2sgYXQgeW91ciBDaHJvbWUpIHRoZSBEYXRlIGNvbnN0cnVjdG9yIG1heSBhY2NlcHQgaW52YWxpZCBkYXRlIHN0cmluZ1xuICAgICAgICAvLyBidXQgcGFyc2VzIHRoZW0gaW4gJ2ltcGxlbWVudGF0aW9uIHNwZWNpZmljJyB3YXlcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUgMjAxOS0xLTEgaXNuJ3QgdGhlIHNhbWUgYXMgMjAxOS0wMS0wMSAoZm9yIENocm9tZSBib3RoIGFyZSAndmFsaWQnIGRhdGUgc3RyaW5ncylcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk2ODkzOVxuICAgICAgICAvLyBzbywgd2UgbmVlZCB0byBiZSBzdXJlIHRoYXQgZGF0ZSBoYXMgdmFsaWQgZm9ybWF0IHRvIGF2b2lkIHN0cmFuZ2UgYmVoYXZpb3IgYW5kIGhvdXJzIG9mIGRlYnVnZ2luZ1xuICAgICAgICAvLyBidXQgbGV0J3MgZG8gdGhpcyBpbiBkZXZlbG9wbWVudCBidWlsZCBvbmx5IGJlY2F1c2Ugb2YgcGVyZlxuICAgICAgICBpZiAoIXZhbGlkRGF0ZVJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmc9JHt2YWx1ZX0sIGV4cGVjdGVkIGZvcm1hdD15eXl5LW1tLWRkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZz0ke3ZhbHVlfSwgZXhwZWN0ZWQgZm9ybWF0PXl5eXktbW0tZGRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF5OiBkLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbW9udGg6IGQuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFN0cmluZ1RvQnVzaW5lc3NEYXkodmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUudGltZSkpIHtcbiAgICAgICAgdmFsdWUudGltZSA9IHN0cmluZ1RvQnVzaW5lc3NEYXkodmFsdWUudGltZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFN0cmluZ3NUb0J1c2luZXNzRGF5cyhkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuZm9yRWFjaChjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB3ZWlnaHRUb1RpY2tNYXJrVHlwZSh3ZWlnaHQsIHRpbWVWaXNpYmxlLCBzZWNvbmRzVmlzaWJsZSkge1xuICAgIHN3aXRjaCAod2VpZ2h0KSB7XG4gICAgICAgIGNhc2UgMCAvKiBUaWNrTWFya1dlaWdodC5MZXNzVGhhblNlY29uZCAqLzpcbiAgICAgICAgY2FzZSAxMCAvKiBUaWNrTWFya1dlaWdodC5TZWNvbmQgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZVZpc2libGVcbiAgICAgICAgICAgICAgICA/IChzZWNvbmRzVmlzaWJsZSA/IDQgLyogVGlja01hcmtUeXBlLlRpbWVXaXRoU2Vjb25kcyAqLyA6IDMgLyogVGlja01hcmtUeXBlLlRpbWUgKi8pXG4gICAgICAgICAgICAgICAgOiAyIC8qIFRpY2tNYXJrVHlwZS5EYXlPZk1vbnRoICovO1xuICAgICAgICBjYXNlIDIwIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTEgKi86XG4gICAgICAgIGNhc2UgMjEgLyogVGlja01hcmtXZWlnaHQuTWludXRlNSAqLzpcbiAgICAgICAgY2FzZSAyMiAvKiBUaWNrTWFya1dlaWdodC5NaW51dGUzMCAqLzpcbiAgICAgICAgY2FzZSAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLzpcbiAgICAgICAgY2FzZSAzMSAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMyAqLzpcbiAgICAgICAgY2FzZSAzMiAvKiBUaWNrTWFya1dlaWdodC5Ib3VyNiAqLzpcbiAgICAgICAgY2FzZSAzMyAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMTIgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZVZpc2libGUgPyAzIC8qIFRpY2tNYXJrVHlwZS5UaW1lICovIDogMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLztcbiAgICAgICAgY2FzZSA1MCAvKiBUaWNrTWFya1dlaWdodC5EYXkgKi86XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLztcbiAgICAgICAgY2FzZSA2MCAvKiBUaWNrTWFya1dlaWdodC5Nb250aCAqLzpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFRpY2tNYXJrVHlwZS5Nb250aCAqLztcbiAgICAgICAgY2FzZSA3MCAvKiBUaWNrTWFya1dlaWdodC5ZZWFyICovOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogVGlja01hcmtUeXBlLlllYXIgKi87XG4gICAgfVxufVxuY2xhc3MgSG9yelNjYWxlQmVoYXZpb3JUaW1lIHtcbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlcihvcHRpb25zLmxvY2FsaXphdGlvbik7XG4gICAgfVxuICAgIHByZXByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnZlcnRTdHJpbmdzVG9CdXNpbmVzc0RheXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwoc2VsZWN0VGltZUNvbnZlcnRlcihkYXRhKSk7XG4gICAgfVxuICAgIGtleShpdGVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIFwiX2ludGVybmFsX3RpbWVzdGFtcFwiIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLl9pbnRlcm5hbF90aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkodGhpcy5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZUtleShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBpdGVtO1xuICAgICAgICByZXR1cm4gdGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh0aW1lLl9pbnRlcm5hbF90aW1lc3RhbXAgKiAxMDAwKS5nZXRUaW1lKClcbiAgICAgICAgICAgIDogbmV3IERhdGUoRGF0ZS5VVEModGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkueWVhciwgdGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkubW9udGggLSAxLCB0aW1lLl9pbnRlcm5hbF9idXNpbmVzc0RheS5kYXkpKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwoaXRlbSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRpbWUoaXRlbSk7XG4gICAgfVxuICAgIHVwZGF0ZUZvcm1hdHRlcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBvcHRpb25zLmRhdGVGb3JtYXQ7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS50aW1lVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0ZVRpbWVGb3JtYXR0ZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIoe1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9kYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lRm9ybWF0OiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS5zZWNvbmRzVmlzaWJsZSA/ICclaDolbTolcycgOiAnJWg6JW0nLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9kYXRlVGltZVNlcGFyYXRvcjogJyAgICcsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xvY2FsZTogb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGVUaW1lRm9ybWF0dGVyID0gbmV3IERhdGVGb3JtYXR0ZXIoZGF0ZUZvcm1hdCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcm1hdEhvcnpJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdHAgPSBpdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0ZVRpbWVGb3JtYXR0ZXIuX2ludGVybmFsX2Zvcm1hdChuZXcgRGF0ZSh0cC5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMCkpO1xuICAgIH1cbiAgICBmb3JtYXRUaWNrbWFyayh0aWNrTWFyaywgbG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0aWNrTWFya1R5cGUgPSB3ZWlnaHRUb1RpY2tNYXJrVHlwZSh0aWNrTWFyay53ZWlnaHQsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnRpbWVWaXNpYmxlLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS5zZWNvbmRzVmlzaWJsZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGlja01hcmtGb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGlja01hcmtTdHJpbmcgPSBvcHRpb25zLnRpY2tNYXJrRm9ybWF0dGVyKHRpY2tNYXJrLm9yaWdpbmFsVGltZSwgdGlja01hcmtUeXBlLCBsb2NhbGl6YXRpb25PcHRpb25zLmxvY2FsZSk7XG4gICAgICAgICAgICBpZiAodGlja01hcmtTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlja01hcmtTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUaWNrTWFya0Zvcm1hdHRlcih0aWNrTWFyay50aW1lLCB0aWNrTWFya1R5cGUsIGxvY2FsaXphdGlvbk9wdGlvbnMubG9jYWxlKTtcbiAgICB9XG4gICAgbWF4VGlja01hcmtXZWlnaHQodGlja01hcmtzKSB7XG4gICAgICAgIGxldCBtYXhXZWlnaHQgPSB0aWNrTWFya3MucmVkdWNlKG1hcmtXaXRoR3JlYXRlcldlaWdodCQyLCB0aWNrTWFya3NbMF0pLndlaWdodDtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBpdCBsb29rcyBzdHJhbmdlIGlmIDE1OjAwIGlzIGJvbGQgYnV0IDE0OjAwIGlzIG5vdFxuICAgICAgICAvLyBzbyBpZiBtYXhXZWlnaHQgPiBUaWNrTWFya1dlaWdodC5Ib3VyMSBhbmQgPCBUaWNrTWFya1dlaWdodC5EYXkgcmVkdWNlIGl0IHRvIFRpY2tNYXJrV2VpZ2h0LkhvdXIxXG4gICAgICAgIGlmIChtYXhXZWlnaHQgPiAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLyAmJiBtYXhXZWlnaHQgPCA1MCAvKiBUaWNrTWFya1dlaWdodC5EYXkgKi8pIHtcbiAgICAgICAgICAgIG1heFdlaWdodCA9IDMwIC8qIFRpY2tNYXJrV2VpZ2h0LkhvdXIxICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhXZWlnaHQ7XG4gICAgfVxuICAgIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZmlsbFdlaWdodHNGb3JQb2ludHMoc29ydGVkVGltZVBvaW50cywgc3RhcnRJbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBfaW50ZXJuYWxfYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBtZXJnZSh7IGxvY2FsaXphdGlvbjogeyBkYXRlRm9ybWF0OiAnZGQgTU1NIFxcJ3l5JyB9IH0sIG9wdGlvbnMgPz8ge30pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBXaGVuIHlvdSdyZSB0cnlpbmcgdG8gdXNlIHRoZSBsaWJyYXJ5IGluIHNlcnZlci1zaWRlIGNvbnRleHQgKGZvciBpbnN0YW5jZSBpbiBTU1IpXG4gKiB5b3UgZG9uJ3QgaGF2ZSBzb21lIGJyb3dzZXItc3BlY2lmaWMgdmFyaWFibGVzIGxpa2UgbmF2aWdhdG9yIG9yIHdpbmRvd1xuICogYW5kIGlmIHRoZSBsaWJyYXJ5IHdpbGwgdXNlIHRoZW0gb24gdGhlIHRvcCBsZXZlbCBvZiB0aGUgbGlicmFyeVxuICogdGhlIGltcG9ydCB3aWxsIGZhaWwgZHVlIFJlZmVyZW5jZUVycm9yXG4gKiB0aHVzLCB0aGlzIGFsbG93cyB1c2UgdGhlIG5hdmlnYXRvciBvbiB0aGUgdG9wIGxldmVsIGFuZCBiZWluZyBpbXBvcnRlZCBpbiBzZXJ2ZXItc2lkZSBjb250ZXh0IGFzIHdlbGxcbiAqIFNlZSBpc3N1ZSAjNDQ2XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdHNsaW50L2NvbmZpZ1xuY29uc3QgaXNSdW5uaW5nT25DbGllbnRTaWRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGlzRkYoKSB7XG4gICAgaWYgKCFpc1J1bm5pbmdPbkNsaWVudFNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMTtcbn1cbmZ1bmN0aW9uIGlzSU9TKCkge1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pO1xufVxuZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gICAgaWYgKCFpc1J1bm5pbmdPbkNsaWVudFNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmNocm9tZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBvbiB3aW5kb3dzLlxuZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbW9yZSBhY2N1cmF0ZSBpZiBhdmFpbGFibGVcbiAgICBpZiAobmF2aWdhdG9yPy51c2VyQWdlbnREYXRhPy5wbGF0Zm9ybSkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEucGxhdGZvcm0gPT09ICdXaW5kb3dzJztcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aW4nKSA+PSAwO1xufVxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21pdW0gYmFzZWQuXG5mdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKSB7XG4gICAgaWYgKCFpc1J1bm5pbmdPbkNsaWVudFNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW5hdmlnYXRvci51c2VyQWdlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcy5zb21lKChicmFuZCkgPT4ge1xuICAgICAgICByZXR1cm4gYnJhbmQuYnJhbmQuaW5jbHVkZXMoJ0Nocm9taXVtJyk7XG4gICAgfSk7XG59XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiX2J1aWxkLXRpbWUtY29uc3RhbnRzXCIgLz5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9XG59XG5cbi8vIG9uIEhpLURQSSBDU1Mgc2l6ZSAqIERldmljZSBQaXhlbCBSYXRpbyBzaG91bGQgYmUgaW50ZWdlciB0byBhdm9pZCBzbW9vdGhpbmdcbi8vIEZvciBjaGFydCB3aWRnZXQgd2UgZGVjcmVhc2UgdGhlIHNpemUgYmVjYXVzZSB3ZSBtdXN0IGJlIGluc2lkZSBjb250YWluZXIuXG4vLyBGb3IgdGltZSBheGlzIHRoaXMgaXMgbm90IGltcG9ydGFudCwgc2luY2UgaXQganVzdCBhZmZlY3RzIHNwYWNlIGZvciBwYW5lIHdpZGdldHNcbmZ1bmN0aW9uIHN1Z2dlc3RDaGFydFNpemUob3JpZ2luYWxTaXplKSB7XG4gICAgY29uc3QgaW50ZWdlcldpZHRoID0gTWF0aC5mbG9vcihvcmlnaW5hbFNpemUud2lkdGgpO1xuICAgIGNvbnN0IGludGVnZXJIZWlnaHQgPSBNYXRoLmZsb29yKG9yaWdpbmFsU2l6ZS5oZWlnaHQpO1xuICAgIGNvbnN0IHdpZHRoID0gaW50ZWdlcldpZHRoIC0gKGludGVnZXJXaWR0aCAlIDIpO1xuICAgIGNvbnN0IGhlaWdodCA9IGludGVnZXJIZWlnaHQgLSAoaW50ZWdlckhlaWdodCAlIDIpO1xuICAgIHJldHVybiBzaXplJDEoeyB3aWR0aCwgaGVpZ2h0IH0pO1xufVxuZnVuY3Rpb24gc3VnZ2VzdFRpbWVTY2FsZUhlaWdodChvcmlnaW5hbEhlaWdodCkge1xuICAgIHJldHVybiBvcmlnaW5hbEhlaWdodCArIChvcmlnaW5hbEhlaWdodCAlIDIpO1xufVxuZnVuY3Rpb24gc3VnZ2VzdFByaWNlU2NhbGVXaWR0aChvcmlnaW5hbFdpZHRoKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsV2lkdGggKyAob3JpZ2luYWxXaWR0aCAlIDIpO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50U2Nyb2xsQnlXaGVlbENsaWNrKGVsKSB7XG4gICAgaWYgKCFpc0Nocm9tZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMSAvKiBNb3VzZUV2ZW50QnV0dG9uLk1pZGRsZSAqLykge1xuICAgICAgICAgICAgLy8gcHJldmVudCBpbmNvcnJlY3Qgc2Nyb2xsaW5nIGV2ZW50XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiBhIGxvdCBvZiBib29sZWFuIGZsYWdzLCBwcm9iYWJseSB3ZSBzaG91bGQgcmVwbGFjZSBpdCB3aXRoIHNvbWUgZW51bVxuY2xhc3MgTW91c2VFdmVudEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uID0geyBfaW50ZXJuYWxfeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBfaW50ZXJuYWxfeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwUG9zaXRpb24gPSB7IF9pbnRlcm5hbF94OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIF9pbnRlcm5hbF95OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlU3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19waW5jaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSAwO1xuICAgICAgICAvLyBmb3IgdG91Y2hzdGFydC90b3VjaG1vdmUvdG91Y2hlbmQgZXZlbnRzIHdlIGhhbmRsZSBvbmx5IGZpcnN0IHRvdWNoXG4gICAgICAgIC8vIGkuZS4gd2UgZG9uJ3Qgc3VwcG9ydCBzZXZlcmFsIGFjdGl2ZSB0b3VjaGVzIGF0IHRoZSBzYW1lIHRpbWUgKGV4Y2VwdCBwaW5jaCBldmVudClcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCA9IG51bGw7XG4gICAgICAgIC8vIGFjY2VwdCBhbGwgbW91c2UgbGVhdmUgZXZlbnRzIGlmIGl0J3Mgbm90IGFuIGlPUyBkZXZpY2VcbiAgICAgICAgLy8gc2VlIF9tb3VzZUVudGVySGFuZGxlciwgX21vdXNlTW92ZUhhbmRsZXIsIF9tb3VzZUxlYXZlSGFuZGxlclxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBGaXJlZm94IG1vdXNlIGV2ZW50cyBkb250J3QgZmlyZSBpZiB0aGUgbW91c2UgcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICogVG8gcHJldmVudCB0aGUgbW91c2UgZnJvbSBoYW5naW5nIHdoaWxlIHByZXNzZWQgd2UncmUgc3Vic2NyaWJpbmcgb24gdGhlIG1vdXNlbGVhdmUgZXZlbnQgb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQuXG4gICAgICAgICAqIFdlJ3JlIHN1YnNjcmliaW5nIG9uIG1vdXNlbGVhdmUsIGJ1dCB0aGlzIGV2ZW50IGlzIGFjdHVhbGx5IGZpcmVkIG9uIG1vdXNldXAgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uRmlyZWZveE91dHNpZGVNb3VzZVVwID0gKG1vdXNlVXBFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEhhbmRsZXIobW91c2VVcEV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhZmFyaSBkb2Vzbid0IGZpcmUgdG91Y2hzdGFydC9tb3VzZWRvd24gZXZlbnRzIG9uIGRvdWJsZSB0YXAgc2luY2UgaU9TIDEzLlxuICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICogMSkgQ2FsbCBwcmV2ZW50RGVmYXVsdCBpbiB0b3VjaEVuZCBoYW5kbGVyLiBCdXQgaXQgYWxzbyBwcmV2ZW50cyBjbGljayBldmVudCBmcm9tIGZpcmluZy5cbiAgICAgICAgICogMikgQWRkIGxpc3RlbmVyIG9uIGRibGNsaWNrIGV2ZW50IHRoYXQgZmlyZXMgd2l0aCB0aGUgcHJlY2VkaW5nIG1vdXNlZG93bi9tb3VzZXVwLlxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC8xMjUwNzNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2sgPSAoZGJsQ2xpY2tFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZGJsQ2xpY2tFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChkYmxDbGlja0V2ZW50KTtcbiAgICAgICAgICAgICAgICArK3RoaXMuX3ByaXZhdGVfX3RhcENvdW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24oZGJsQ2xpY2tFdmVudCksIHRoaXMuX3ByaXZhdGVfX3RhcFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA8IDMwIC8qIENvbnN0YW50cy5Eb3VibGVUYXBNYW5oYXR0YW5EaXN0YW5jZSAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfZG91YmxlVGFwRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGRibENsaWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgICsrdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgJiYgdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhnZXRQb3NpdGlvbihkYmxDbGlja0V2ZW50KSwgdGhpcy5fcHJpdmF0ZV9fY2xpY2tQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCA1IC8qIENvbnN0YW50cy5Eb3VibGVDbGlja01hbmhhdHRhbkRpc3RhbmNlICovICYmICF0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRDbGlja1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZUVudGVySGFuZGxlcihlbnRlckV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3VuZE1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX19tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhlbnRlckV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGVudGVyRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VFbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSA9IHRydWU7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24gPSB7IF9pbnRlcm5hbF94OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIF9pbnRlcm5hbF95OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RhcFRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX3RhcFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXBQb3NpdGlvbiA9IHsgX2ludGVybmFsX3g6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgX2ludGVybmFsX3k6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VNb3ZlSGFuZGxlcihtb3ZlRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vdXNlUHJlc3NlZCB8fCB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMobW92ZUV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdmVFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZU1vdmVFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjY2VwdE1vdXNlTGVhdmUgPSB0cnVlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdG91Y2hNb3ZlSGFuZGxlcihtb3ZlRXZlbnQpIHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaFdpdGhJZChtb3ZlRXZlbnQuY2hhbmdlZFRvdWNoZXMsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCkpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCA9IGV2ZW50VGltZVN0YW1wKG1vdmVFdmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IHBpbmNoIGlmIG1vdmUgZXZlbnQgY29tZXMgZmFzdGVyIHRoYW4gdGhlIHNlY29uZCB0b3VjaFxuICAgICAgICB0aGlzLl9wcml2YXRlX19waW5jaFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1vdmVJbmZvID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24odG91Y2gpLCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24pKTtcbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfeE9mZnNldDogeE9mZnNldCwgX2ludGVybmFsX3lPZmZzZXQ6IHlPZmZzZXQsIF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfSA9IG1vdmVJbmZvO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlICYmIG1hbmhhdHRhbkRpc3RhbmNlIDwgNSAvKiBDb25zdGFudHMuQ2FuY2VsVGFwTWFuaGF0dGFuRGlzdGFuY2UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgd2hlbiBjdXJyZW50IHBvc2l0aW9uIGV4Y2VlZGVkIG1hbmhhdHRhbiBkaXN0YW5jZVxuICAgICAgICAgICAgLy8gdmVydGljYWwgZHJhZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIGhvcml6b250YWwgZHJhZ1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBzY3JvbGwgdGhlIHBhZ2UgdmVydGljYWxseSBvZnRlbiB0aGFuIGhvcml6b250YWxseVxuICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkWE9mZnNldCA9IHhPZmZzZXQgKiAwLjU7XG4gICAgICAgICAgICAvLyBhIGRyYWcgY2FuIGJlIG9ubHkgaWYgdG91Y2ggcGFnZSBzY3JvbGwgaXNuJ3QgYWxsb3dlZFxuICAgICAgICAgICAgY29uc3QgaXNWZXJ0RHJhZyA9IHlPZmZzZXQgPj0gY29ycmVjdGVkWE9mZnNldCAmJiAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5faW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICBjb25zdCBpc0hvcnpEcmFnID0gY29ycmVjdGVkWE9mZnNldCA+IHlPZmZzZXQgJiYgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMuX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgLy8gaWYgZHJhZyBldmVudCBoYXBwZW5lZCB0aGVuIHdlIHNob3VsZCByZXZlcnQgcHJldmVudERlZmF1bHQgc3RhdGUgdG8gb3JpZ2luYWwgb25lXG4gICAgICAgICAgICAvLyBhbmQgdHJ5IHRvIHByb2Nlc3MgdGhlIGRyYWcgZXZlbnRcbiAgICAgICAgICAgIC8vIGVsc2Ugd2Ugc2hvdWxkbid0IHByZXZlbnQgZGVmYXVsdCBvZiB0aGUgZXZlbnQgYW5kIGlnbm9yZSBwcm9jZXNzaW5nIHRoZSBkcmFnIGV2ZW50XG4gICAgICAgICAgICBpZiAoIWlzVmVydERyYWcgJiYgIWlzSG9yekRyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGlmIG1hbmhhdHRhbiBkaXN0YW5jZSBpcyBtb3JlIHRoYXQgNSAtIHdlIHNob3VsZCBjYW5jZWwgdGFwIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxUYXAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQobW92ZUV2ZW50LCB0b3VjaCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQpO1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHByZXZlbnQgZGVmYXVsdCBpbiBjYXNlIG9mIHRvdWNoIG9ubHlcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChtb3ZlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICBpZiAobW92ZUV2ZW50LmJ1dHRvbiAhPT0gMCAvKiBNb3VzZUV2ZW50QnV0dG9uLkxlZnQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3ZlSW5mbyA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKG1vdmVFdmVudCksIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlU3RhcnRQb3NpdGlvbikpO1xuICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfSA9IG1vdmVJbmZvO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlID49IDUgLyogQ29uc3RhbnRzLkNhbmNlbENsaWNrTWFuaGF0dGFuRGlzdGFuY2UgKi8pIHtcbiAgICAgICAgICAgIC8vIGlmIG1hbmhhdHRhbiBkaXN0YW5jZSBpcyBtb3JlIHRoYXQgNSAtIHdlIHNob3VsZCBjYW5jZWwgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9jYW5jZWxDbGljayBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoYXQgbWluaW11bSBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgYWxyZWFkeSBleGNlZWRlZFxuICAgICAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQobW92ZUV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhjdXJyZW50UG9zaXRpb24sIHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IE1hdGguYWJzKHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3ggLSBjdXJyZW50UG9zaXRpb24uX2ludGVybmFsX3gpO1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gTWF0aC5hYnMoc3RhcnRQb3NpdGlvbi5faW50ZXJuYWxfeSAtIGN1cnJlbnRQb3NpdGlvbi5faW50ZXJuYWxfeSk7XG4gICAgICAgIGNvbnN0IG1hbmhhdHRhbkRpc3RhbmNlID0geE9mZnNldCArIHlPZmZzZXQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfeE9mZnNldDogeE9mZnNldCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF95T2Zmc2V0OiB5T2Zmc2V0LFxuICAgICAgICAgICAgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fdG91Y2hFbmRIYW5kbGVyKHRvdWNoRW5kRXZlbnQpIHtcbiAgICAgICAgbGV0IHRvdWNoID0gdG91Y2hXaXRoSWQodG91Y2hFbmRFdmVudC5jaGFuZ2VkVG91Y2hlcywgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkKSk7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCAmJiB0b3VjaEVuZEV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZywgc29tZWhvdyB3ZSBtaXNzZWQgdGhlIHJlcXVpcmVkIHRvdWNoZW5kIGV2ZW50XG4gICAgICAgICAgICAvLyBwcm9iYWJseSB0aGUgYnJvd3NlciBoYXMgbm90IHNlbnQgdGhpcyBldmVudFxuICAgICAgICAgICAgdG91Y2ggPSB0b3VjaEVuZEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCA9IGV2ZW50VGltZVN0YW1wKHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQodG91Y2hFbmRFdmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdG91Y2hFbmRFdmVudCk7XG4gICAgICAgICsrdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQ7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGJvdGggY2xpY2tzIGFyZSBuZWFyIGVub3VnaFxuICAgICAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhnZXRQb3NpdGlvbih0b3VjaCksIHRoaXMuX3ByaXZhdGVfX3RhcFBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgMzAgLyogQ29uc3RhbnRzLkRvdWJsZVRhcE1hbmhhdHRhbkRpc3RhbmNlICovICYmICF0aGlzLl9wcml2YXRlX19jYW5jZWxUYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfZG91YmxlVGFwRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF90YXBFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGZpcmUgbW91c2UgZXZlbnRzIGlmIHRhcCBoYW5kbGVyIHdhcyBleGVjdXRlZFxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgY2xpY2sgZXZlbnQgb24gbmV3IGRvbSBlbGVtZW50ICh3aG8gYXBwZWFyZWQgYWZ0ZXIgdGFwKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF90YXBFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCwgZm9yIGV4YW1wbGUsIHNhZmFyaSdzIGRibGNsaWNrLXRvLXpvb20gb3IgZmFzdC1jbGljayBhZnRlciBsb25nLXRhcFxuICAgICAgICAvLyB3ZSBoYW5kbGUgbW91c2VEb3VibGVDbGlja0V2ZW50IGhlcmUgb3Vyc2VsdmVzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQodG91Y2hFbmRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoRW5kRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sb25nVGFwQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbmF0aXZlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQodG91Y2hFbmRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlVXBIYW5kbGVyKG1vdXNlVXBFdmVudCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKG1vdXNlVXBFdmVudC5idXR0b24gIT09IDAgLyogTW91c2VFdmVudEJ1dHRvbi5MZWZ0ICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQobW91c2VVcEV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlU3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRkYoKSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9wcml2YXRlX190YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcHJpdmF0ZV9fb25GaXJlZm94T3V0c2lkZU1vdXNlVXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKG1vdXNlVXBFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VVcEV2ZW50KTtcbiAgICAgICAgKyt0aGlzLl9wcml2YXRlX19jbGlja0NvdW50O1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgJiYgdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgYm90aCBjbGlja3MgYXJlIG5lYXIgZW5vdWdoXG4gICAgICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfSA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKG1vdXNlVXBFdmVudCksIHRoaXMuX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCA1IC8qIENvbnN0YW50cy5Eb3VibGVDbGlja01hbmhhdHRhbkRpc3RhbmNlICovICYmICF0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRDbGlja1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VDbGlja0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBUaW1lb3V0SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdG91Y2hTdGFydEhhbmRsZXIoZG93bkV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG91Y2ggPSBkb3duRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCA9IGV2ZW50VGltZVN0YW1wKGRvd25FdmVudCk7XG4gICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uID0gZ2V0UG9zaXRpb24odG91Y2gpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYm91bmRUb3VjaE1vdmVXaXRoRG93bkhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBib3VuZFRvdWNoRW5kSGFuZGxlciA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoRW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgYm91bmRUb3VjaE1vdmVXaXRoRG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgYm91bmRUb3VjaEVuZEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBib3VuZFRvdWNoRW5kSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBIYW5kbGVyLmJpbmQodGhpcywgZG93bkV2ZW50KSwgMjQwIC8qIERlbGF5LkxvbmdUYXAgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdG91Y2hTdGFydEV2ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fcHJpdmF0ZV9fcmVzZXRUYXBUaW1lb3V0LmJpbmQodGhpcyksIDUwMCAvKiBEZWxheS5SZXNldENsaWNrICovKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcFBvc2l0aW9uID0gZ2V0UG9zaXRpb24odG91Y2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZURvd25IYW5kbGVyKGRvd25FdmVudCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKGRvd25FdmVudC5idXR0b24gIT09IDAgLyogTW91c2VFdmVudEJ1dHRvbi5MZWZ0ICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9wcml2YXRlX190YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChpc0ZGKCkpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9wcml2YXRlX19vbkZpcmVmb3hPdXRzaWRlTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FuY2VsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlU3RhcnRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGRvd25FdmVudCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlciA9IHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVdpdGhEb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRNb3VzZVVwSGFuZGxlciA9IHRoaXMuX3ByaXZhdGVfX21vdXNlVXBIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGJvdW5kTW91c2VVcEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW91c2VNb3ZlV2l0aERvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZE1vdXNlVXBIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhkb3duRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZG93bkV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRG93bkV2ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fcHJpdmF0ZV9fcmVzZXRDbGlja1RpbWVvdXQuYmluZCh0aGlzKSwgNTAwIC8qIERlbGF5LlJlc2V0Q2xpY2sgKi8pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGRvd25FdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2luaXQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fcHJpdmF0ZV9fbW91c2VFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIERvIG5vdCBzaG93IGNvbnRleHQgbWVudSB3aGVuIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX3ByaXZhdGVfX3RhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgY29uc3Qgb3V0c2lkZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRG93bk91dHNpZGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb21wb3NlZCAmJiB0aGlzLl9wcml2YXRlX190YXJnZXQuY29udGFpbnMoZXZlbnQuY29tcG9zZWRQYXRoKClbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiB0aGlzLl9wcml2YXRlX190YXJnZXQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRG93bk91dHNpZGVFdmVudCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb3V0c2lkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG91dHNpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb3V0c2lkZUhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJT1MoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fcHJpdmF0ZV9fb25Nb2JpbGVTYWZhcmlEb3VibGVDbGljayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fcHJpdmF0ZV9fb25Nb2JpbGVTYWZhcmlEb3VibGVDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9wcml2YXRlX19tb3VzZUxlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9wcml2YXRlX190b3VjaFN0YXJ0SGFuZGxlci5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHByZXZlbnRTY3JvbGxCeVdoZWVsQ2xpY2sodGhpcy5fcHJpdmF0ZV9fdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bkhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luaXRQaW5jaCgpO1xuICAgICAgICAvLyBIZXkgbW9iaWxlIFNhZmFyaSwgd2hhdCdzIHVwP1xuICAgICAgICAvLyBJZiBtb2JpbGUgU2FmYXJpIGRvZXNuJ3QgaGF2ZSBhbnkgdG91Y2htb3ZlIGhhbmRsZXIgd2l0aCBwYXNzaXZlPWZhbHNlXG4gICAgICAgIC8vIGl0IHRyZWF0cyBhIHRvdWNoc3RhcnQgYW5kIHRoZSBmb2xsb3dpbmcgdG91Y2htb3ZlIGV2ZW50cyBhcyBjYW5jZWxhYmxlPWZhbHNlLFxuICAgICAgICAvLyBzbyB3ZSBjYW4ndCBwcmV2ZW50IHRoZW0gKGFzIHNvb24gd2Ugc3Vic2NyaWJlIG9uIHRvdWNobW92ZSBpbnNpZGUgdG91Y2hzdGFydCdzIGhhbmRsZXIpLlxuICAgICAgICAvLyBBbmQgd2UnbGwgZ2V0IHNjcm9sbCBvZiB0aGUgcGFnZSBhbG9uZyB3aXRoIGNoYXJ0J3Mgb25lIGluc3RlYWQgb2Ygb25seSBjaGFydCdzIHNjcm9sbC5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsICgpID0+IHsgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2luaXRQaW5jaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEV2ZW50ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoRW5kRXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGV2ZW50KSA9PiB0aGlzLl9wcml2YXRlX19jaGVja1BpbmNoU3RhdGUoZXZlbnQudG91Y2hlcyksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGlzdGFuY2UgPSBnZXREaXN0YW5jZShldmVudC50b3VjaGVzWzBdLCBldmVudC50b3VjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnREaXN0YW5jZSAvIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEV2ZW50KHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jaGVja1BpbmNoU3RhdGUoZXZlbnQudG91Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlKHRvdWNoZXMpIHtcbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19waW5jaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9wcml2YXRlX19waW5jaFByZXZlbnRlZCB8fCB0aGlzLl9wcml2YXRlX19sb25nVGFwQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdG9wUGluY2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2godG91Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3N0YXJ0UGluY2godG91Y2hlcykge1xuICAgICAgICBjb25zdCBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5fcHJpdmF0ZV9fdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3g6ICgodG91Y2hlc1swXS5jbGllbnRYIC0gYm94LmxlZnQpICsgKHRvdWNoZXNbMV0uY2xpZW50WCAtIGJveC5sZWZ0KSkgLyAyLFxuICAgICAgICAgICAgX2ludGVybmFsX3k6ICgodG91Y2hlc1swXS5jbGllbnRZIC0gYm94LnRvcCkgKyAodG91Y2hlc1sxXS5jbGllbnRZIC0gYm94LnRvcCkpIC8gMixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaERpc3RhbmNlID0gZ2V0RGlzdGFuY2UodG91Y2hlc1swXSwgdG91Y2hlc1sxXSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaFN0YXJ0RXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hTdGFydEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc3RvcFBpbmNoKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoRW5kRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFbmRFdmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZUxlYXZlSGFuZGxlcihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICAvLyBtb2JpbGUgU2FmYXJpIHNvbWV0aW1lcyBlbWl0cyBtb3VzZSBsZWF2ZSBldmVudCBmb3Igbm8gcmVhc29uLCB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIGl0IGluIG90aGVyIHdheVxuICAgICAgICAgICAgLy8ganVzdCBpZ25vcmUgdGhpcyBldmVudCBpZiB0aGVyZSB3YXMgbm8gbW91c2UgbW92ZSBvciBtb3VzZSBlbnRlciBldmVudHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQpO1xuICAgICAgICAvLyBhY2NlcHQgYWxsIG1vdXNlIGxlYXZlIGV2ZW50cyBpZiBpdCdzIG5vdCBhbiBpT1MgZGV2aWNlXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjY2VwdE1vdXNlTGVhdmUgPSAhaXNJT1MoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2xvbmdUYXBIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gdG91Y2hXaXRoSWQoZXZlbnQudG91Y2hlcywgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkKSk7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGV2ZW50LCB0b3VjaCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NUb3VjaEV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9sb25nVGFwRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxUYXAgPSB0cnVlO1xuICAgICAgICAvLyBsb25nIHRhcCBpcyBhY3RpdmUgdW50aWwgdG91Y2hlbmQgZXZlbnQgd2l0aCAwIHRvdWNoZXMgb2NjdXJyZWRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIF9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKGUpIHtcbiAgICAgICAgaWYgKGUuc291cmNlQ2FwYWJpbGl0aWVzICYmIGUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50VGltZVN0YW1wKGUpIDwgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgKyA1MDAgLyogRGVsYXkuUHJldmVudEZpcmVzVG91Y2hFdmVudHMgKi87XG4gICAgfVxuICAgIF9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIsIGV2ZW50KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChldmVudCwgdG91Y2gpIHtcbiAgICAgICAgLy8gVG91Y2hFdmVudCBoYXMgbm8gY2xpZW50WC9ZIGNvb3JkaW5hdGVzOlxuICAgICAgICAvLyBXZSBoYXZlIHRvIHVzZSB0aGUgbGFzdCBUb3VjaCBpbnN0ZWFkXG4gICAgICAgIGNvbnN0IGV2ZW50TGlrZSA9IHRvdWNoIHx8IGV2ZW50O1xuICAgICAgICBjb25zdCBib3ggPSB0aGlzLl9wcml2YXRlX190YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgeyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50TGlrZS5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogZXZlbnRMaWtlLmNsaWVudFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnRMaWtlLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50TGlrZS5wYWdlWSxcbiAgICAgICAgICAgIHNjcmVlblg6IGV2ZW50TGlrZS5zY3JlZW5YLFxuICAgICAgICAgICAgc2NyZWVuWTogZXZlbnRMaWtlLnNjcmVlblksXG4gICAgICAgICAgICBsb2NhbFg6IChldmVudExpa2UuY2xpZW50WCAtIGJveC5sZWZ0KSxcbiAgICAgICAgICAgIGxvY2FsWTogKGV2ZW50TGlrZS5jbGllbnRZIC0gYm94LnRvcCksXG4gICAgICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgICAgICAgICBzaGlmdEtleTogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgX2ludGVybmFsX2lzVG91Y2g6ICFldmVudC50eXBlLnN0YXJ0c1dpdGgoJ21vdXNlJykgJiYgZXZlbnQudHlwZSAhPT0gJ2NvbnRleHRtZW51JyAmJiBldmVudC50eXBlICE9PSAnY2xpY2snLFxuICAgICAgICAgICAgX2ludGVybmFsX3NyY1R5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGFyZ2V0OiBldmVudExpa2UudGFyZ2V0LFxuICAgICAgICAgICAgX2ludGVybmFsX3ZpZXc6IGV2ZW50LnZpZXcsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdWNoc3RhcnQgaXMgcGFzc2l2ZSBhbmQgY2Fubm90IGJlIHByZXZlbnRlZFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IHsgbGVmdDogMCwgdG9wOiAwIH07XG59XG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgICBjb25zdCB4RGlmZiA9IHAxLmNsaWVudFggLSBwMi5jbGllbnRYO1xuICAgIGNvbnN0IHlEaWZmID0gcDEuY2xpZW50WSAtIHAyLmNsaWVudFk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZik7XG59XG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oZXZlbnRMaWtlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3g6IGV2ZW50TGlrZS5wYWdlWCxcbiAgICAgICAgX2ludGVybmFsX3k6IGV2ZW50TGlrZS5wYWdlWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXZlbnRUaW1lU3RhbXAoZSkge1xuICAgIC8vIGZvciBzb21lIHJlYXNvbiBlLnRpbWVzdGFtcCBpcyBhbHdheXMgMCBvbiBpUGFkIHdpdGggbWFnaWMgbW91c2UsIHNvIHdlIHVzZSBwZXJmb3JtYW5jZS5ub3coKSBhcyBhIGZhbGxiYWNrXG4gICAgcmV0dXJuIGUudGltZVN0YW1wIHx8IHBlcmZvcm1hbmNlLm5vdygpO1xufVxuZnVuY3Rpb24gdG91Y2hXaXRoSWQodG91Y2hlcywgaWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRvdWNoZXNbaV0uaWRlbnRpZmllciA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3VjaGVzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBQYW5lU2VwYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydFdpZGdldCwgdG9wUGFuZUluZGV4LCBib3R0b21QYW5lSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNpemVFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzaXplSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0ID0gY2hhcnRXaWRnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUgPSBjaGFydFdpZGdldC5faW50ZXJuYWxfcGFuZVdpZGdldHMoKVt0b3BQYW5lSW5kZXhdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ib3R0b21QYW5lID0gY2hhcnRXaWRnZXQuX2ludGVybmFsX3BhbmVXaWRnZXRzKClbYm90dG9tUGFuZUluZGV4XTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gMSAvKiBTZXBhcmF0b3JDb25zdGFudHMuU2VwYXJhdG9ySGVpZ2h0ICovICsgJ3B4JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnNldEF0dHJpYnV0ZSgnY29sc3BhbicsICczJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUJvcmRlckNvbG9yKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fY2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUVuYWJsZWQgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5wYW5lcy5lbmFibGVSZXNpemU7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fcmVzaXplRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FkZFJlc2l6YWJsZUhhbmRsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNpemUkMSh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5fcHJpdmF0ZV9fdG9wUGFuZS5faW50ZXJuYWxfZ2V0U2l6ZSgpLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAxIC8qIFNlcGFyYXRvckNvbnN0YW50cy5TZXBhcmF0b3JIZWlnaHQgKi8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNpemUkMSh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5fcHJpdmF0ZV9fdG9wUGFuZS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAxIC8qIFNlcGFyYXRvckNvbnN0YW50cy5TZXBhcmF0b3JIZWlnaHQgKi8gKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgeCwgeSkge1xuICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gdGhpcy5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuc2VwYXJhdG9yQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUJvcmRlckNvbG9yKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5wYW5lcy5lbmFibGVSZXNpemUgIT09IHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUVuYWJsZWQgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5wYW5lcy5lbmFibGVSZXNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVzaXplRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FkZFJlc2l6YWJsZUhhbmRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2hhbmRsZS5faW50ZXJuYWxfYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2hhbmRsZS5faW50ZXJuYWxfZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19hZGRSZXNpemFibGVIYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGJnU3R5bGUgPSBiYWNrZ3JvdW5kRWxlbWVudC5zdHlsZTtcbiAgICAgICAgYmdTdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIGJnU3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYmdTdHlsZS56SW5kZXggPSAnNDknO1xuICAgICAgICBiZ1N0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgYmdTdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBiZ1N0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBiZ1N0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgYmdTdHlsZS5jdXJzb3IgPSAncm93LXJlc2l6ZSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS56SW5kZXggPSAnNTAnO1xuICAgICAgICBzdHlsZS50b3AgPSAnLTRweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9ICc5cHgnO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICAgIHN0eWxlLmN1cnNvciA9ICdyb3ctcmVzaXplJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VFbnRlckV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZU92ZXJFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlTGVhdmVFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VMZWF2ZUV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VEb3duRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bkV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hTdGFydEV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvd25FdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudDogdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlTW92ZUV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlVXBFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbmV3IE1vdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXJzLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdEhvcnpUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGUgPSB7IF9pbnRlcm5hbF9lbGVtZW50OiBlbGVtZW50LCBfaW50ZXJuYWxfYmFja2dyb3VuZEVsZW1lbnQ6IGJhY2tncm91bmRFbGVtZW50IH07XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVCb3JkZXJDb2xvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5iYWNrZ3JvdW5kID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuc2VwYXJhdG9yQ29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZU92ZXJFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGUuX2ludGVybmFsX2VsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuc2VwYXJhdG9ySG92ZXJDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VMZWF2ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGUgIT09IG51bGwgJiYgdGhpcy5fcHJpdmF0ZV9fcmVzaXplSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlLl9pbnRlcm5hbF9lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZURvd25FdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxTdHJldGNoID0gdGhpcy5fcHJpdmF0ZV9fdG9wUGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpICsgdGhpcy5fcHJpdmF0ZV9fYm90dG9tUGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpO1xuICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX2dldFNpemUoKS5oZWlnaHQgKyB0aGlzLl9wcml2YXRlX19ib3R0b21QYW5lLl9pbnRlcm5hbF9nZXRTaXplKCkuaGVpZ2h0O1xuICAgICAgICBjb25zdCBwaXhlbFN0cmV0Y2hGYWN0b3IgPSB0b3RhbFN0cmV0Y2ggLyB0b3RhbEhlaWdodDtcbiAgICAgICAgY29uc3QgbWluUGFuZVN0cmV0Y2ggPSAzMCAvKiBTZXBhcmF0b3JDb25zdGFudHMuTWluUGFuZUhlaWdodCAqLyAqIHBpeGVsU3RyZXRjaEZhY3RvcjtcbiAgICAgICAgaWYgKHRvdGFsU3RyZXRjaCA8PSBtaW5QYW5lU3RyZXRjaCAqIDIpIHtcbiAgICAgICAgICAgIC8vIGNhbm5vdCByZXNpemUgcGFuZXMgdGhhdCBhbHJlYWR5IGhhdmUgbGVzcyB0aGFuIG1pbmltYWwgaGVpZ2h0XG4gICAgICAgICAgICAvLyB0aGF0J3MgcG9zc2libGUgaWYgdGhlcmUgYXJlIG1hbnkgcGFuZXMgb24gdGhlIGNoYXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzaXplSW5mbyA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zdGFydFk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgICAgX2ludGVybmFsX3ByZXZTdHJldGNoVG9wUGFuZTogdGhpcy5fcHJpdmF0ZV9fdG9wUGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpLFxuICAgICAgICAgICAgX2ludGVybmFsX21heFBhbmVTdHJldGNoOiB0b3RhbFN0cmV0Y2ggLSBtaW5QYW5lU3RyZXRjaCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3RhbFN0cmV0Y2g6IHRvdGFsU3RyZXRjaCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9waXhlbFN0cmV0Y2hGYWN0b3I6IHBpeGVsU3RyZXRjaEZhY3RvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9taW5QYW5lU3RyZXRjaDogbWluUGFuZVN0cmV0Y2gsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZS5faW50ZXJuYWxfYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIF9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVzaXplSW5mbyA9IHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUluZm87XG4gICAgICAgIGlmIChyZXNpemVJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGFZID0gZXZlbnQucGFnZVkgLSByZXNpemVJbmZvLl9pbnRlcm5hbF9zdGFydFk7XG4gICAgICAgIGNvbnN0IGRlbHRhU3RyZXRjaEZhY3RvciA9IGRlbHRhWSAqIHJlc2l6ZUluZm8uX2ludGVybmFsX3BpeGVsU3RyZXRjaEZhY3RvcjtcbiAgICAgICAgY29uc3QgdXBwZXJQYW5lTmV3U3RyZXRjaCA9IGNsYW1wKHJlc2l6ZUluZm8uX2ludGVybmFsX3ByZXZTdHJldGNoVG9wUGFuZSArIGRlbHRhU3RyZXRjaEZhY3RvciwgcmVzaXplSW5mby5faW50ZXJuYWxfbWluUGFuZVN0cmV0Y2gsIHJlc2l6ZUluZm8uX2ludGVybmFsX21heFBhbmVTdHJldGNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wUGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfc2V0U3RyZXRjaEZhY3Rvcih1cHBlclBhbmVOZXdTdHJldGNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYm90dG9tUGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfc2V0U3RyZXRjaEZhY3RvcihyZXNpemVJbmZvLl9pbnRlcm5hbF90b3RhbFN0cmV0Y2ggLSB1cHBlclBhbmVOZXdTdHJldGNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlVXBFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVzaXplSW5mbyA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19oYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNpemVJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlLl9pbnRlcm5hbF9iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHBvczEsIHBvczIpIHtcbiAgICByZXR1cm4gcG9zMS5faW50ZXJuYWxfcG9zaXRpb24gLSBwb3MyLl9pbnRlcm5hbF9wb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIHNwZWVkUHhQZXJNU2VjKHBvczEsIHBvczIsIG1heFNwZWVkKSB7XG4gICAgY29uc3Qgc3BlZWQgPSAocG9zMS5faW50ZXJuYWxfcG9zaXRpb24gLSBwb3MyLl9pbnRlcm5hbF9wb3NpdGlvbikgLyAocG9zMS5faW50ZXJuYWxfdGltZSAtIHBvczIuX2ludGVybmFsX3RpbWUpO1xuICAgIHJldHVybiBNYXRoLnNpZ24oc3BlZWQpICogTWF0aC5taW4oTWF0aC5hYnMoc3BlZWQpLCBtYXhTcGVlZCk7XG59XG5mdW5jdGlvbiBkdXJhdGlvbk1TZWMoc3BlZWQsIGR1bXBpbmdDb2VmZikge1xuICAgIGNvbnN0IGxuRHVtcGluZ0NvZWZmID0gTWF0aC5sb2coZHVtcGluZ0NvZWZmKTtcbiAgICByZXR1cm4gTWF0aC5sb2coKDEgLyogQ29uc3RhbnRzLkVwc2lsb25EaXN0YW5jZSAqLyAqIGxuRHVtcGluZ0NvZWZmKSAvIC1zcGVlZCkgLyAobG5EdW1waW5nQ29lZmYpO1xufVxuY2xhc3MgS2luZXRpY0FuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWluU3BlZWQsIG1heFNwZWVkLCBkdW1waW5nQ29lZmYsIG1pbk1vdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R1cmF0aW9uTXNlY3MgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zcGVlZFB4UGVyTXNlYyA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21pblNwZWVkID0gbWluU3BlZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21heFNwZWVkID0gbWF4U3BlZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZiA9IGR1bXBpbmdDb2VmZjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluTW92ZSA9IG1pbk1vdmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hZGRQb3NpdGlvbihwb3NpdGlvbiwgdGltZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xLl9pbnRlcm5hbF90aW1lID09PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xLl9pbnRlcm5hbF9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEuX2ludGVybmFsX3Bvc2l0aW9uIC0gcG9zaXRpb24pIDwgdGhpcy5fcHJpdmF0ZV9fbWluTW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjQgPSB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMyA9IHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yID0gdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEgPSB7IF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfcG9zaXRpb246IHBvc2l0aW9uIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydChwb3NpdGlvbiwgdGltZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICBpZiAodGltZSAtIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMS5faW50ZXJuYWxfdGltZSA+IDUwIC8qIENvbnN0YW50cy5NYXhTdGFydERlbGF5ICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIGFsbCB0aGUgcmVzdCBwYXJhbWV0ZXJzIHdlIHNob3VsZCBjYWxjdWxhdGUgdGhlIHNwZWVkIGFmIGZpcnN0XG4gICAgICAgIGxldCB0b3RhbERpc3RhbmNlID0gMDtcbiAgICAgICAgY29uc3Qgc3BlZWQxID0gc3BlZWRQeFBlck1TZWModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xLCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjIsIHRoaXMuX3ByaXZhdGVfX21heFNwZWVkKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yKTtcbiAgICAgICAgLy8gV2UncmUgY2FsY3VsYXRpbmcgd2VpZ2h0ZWQgYXZlcmFnZSBzcGVlZFxuICAgICAgICAvLyBUaGFuIG1vcmUgZGlzdGFuY2UgZm9yIGEgc2VnbWVudCwgdGhhbiBtb3JlIGl0cyB3ZWlnaHRcbiAgICAgICAgY29uc3Qgc3BlZWRJdGVtcyA9IFtzcGVlZDFdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZUl0ZW1zID0gW2Rpc3RhbmNlMV07XG4gICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZGlzdGFuY2UxO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVlZDIgPSBzcGVlZFB4UGVyTVNlYyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjIsIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMywgdGhpcy5fcHJpdmF0ZV9fbWF4U3BlZWQpO1xuICAgICAgICAgICAgLy8gc3RvcCBhdCB0aGlzIG1vbWVudCBpZiBkaXJlY3Rpb24gb2YgdGhlIHNlZ21lbnQgaXMgb3Bwb3NpdGVcbiAgICAgICAgICAgIGlmIChNYXRoLnNpZ24oc3BlZWQyKSA9PT0gTWF0aC5zaWduKHNwZWVkMSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yLCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMpO1xuICAgICAgICAgICAgICAgIHNwZWVkSXRlbXMucHVzaChzcGVlZDIpO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlSXRlbXMucHVzaChkaXN0YW5jZTIpO1xuICAgICAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZGlzdGFuY2UyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BlZWQzID0gc3BlZWRQeFBlck1TZWModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zLCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjQsIHRoaXMuX3ByaXZhdGVfX21heFNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguc2lnbihzcGVlZDMpID09PSBNYXRoLnNpZ24oc3BlZWQxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UzID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMywgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkSXRlbXMucHVzaChzcGVlZDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VJdGVtcy5wdXNoKGRpc3RhbmNlMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0U3BlZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWVkSXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFNwZWVkICs9IGRpc3RhbmNlSXRlbXNbaV0gLyB0b3RhbERpc3RhbmNlICogc3BlZWRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMocmVzdWx0U3BlZWQpIDwgdGhpcy5fcHJpdmF0ZV9fbWluU3BlZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25TdGFydFBvc2l0aW9uID0geyBfaW50ZXJuYWxfcG9zaXRpb246IHBvc2l0aW9uLCBfaW50ZXJuYWxfdGltZTogdGltZSB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zcGVlZFB4UGVyTXNlYyA9IHJlc3VsdFNwZWVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdXJhdGlvbk1zZWNzID0gZHVyYXRpb25NU2VjKE1hdGguYWJzKHJlc3VsdFNwZWVkKSwgdGhpcy5fcHJpdmF0ZV9fZHVtcGluZ0NvZWZmKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFBvc2l0aW9uKHRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uTXNlY3MgPSB0aW1lIC0gc3RhcnRQb3NpdGlvbi5faW50ZXJuYWxfdGltZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3Bvc2l0aW9uICsgdGhpcy5fcHJpdmF0ZV9fc3BlZWRQeFBlck1zZWMgKiAoTWF0aC5wb3codGhpcy5fcHJpdmF0ZV9fZHVtcGluZ0NvZWZmLCBkdXJhdGlvbk1zZWNzKSAtIDEpIC8gKE1hdGgubG9nKHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZikpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmluaXNoZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbiA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcm9ncmVzc0R1cmF0aW9uKHRpbWUpID09PSB0aGlzLl9wcml2YXRlX19kdXJhdGlvbk1zZWNzO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJvZ3Jlc3NEdXJhdGlvbih0aW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRpbWUgLSBzdGFydFBvc2l0aW9uLl9pbnRlcm5hbF90aW1lO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJvZ3Jlc3MsIHRoaXMuX3ByaXZhdGVfX2R1cmF0aW9uTXNlY3MpO1xuICAgIH1cbn1cblxuY29uc3Qgc3ZnID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzVcIiBoZWlnaHQ9XCIxOVwiIGZpbGw9XCJub25lXCI+PGcgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcGF0aD1cInVybCgjYSlcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCI+PHBhdGggZmlsbD1cInZhcigtLXN0cm9rZSlcIiBkPVwiTTIgMEgwdjEwaDZ2OWgyMS40bC41LTEuMyA2LTE1IDEtMi43SDIzLjdsLS41IDEuMy0uMi42YTUgNSAwIDAgMC03LS45VjBIMlptMjAgMTdoNGw1LjItMTMgLjgtMmgtN2wtMSAyLjUtLjIuNS0xLjUgMy44LS4zLjdWMTdabS0uOC0xMGEzIDMgMCAwIDAgLjctMi43QTMgMyAwIDEgMCAxNi44IDdoNC40Wk0xNCA3VjJIMnY2aDZ2OWg0VjdoMlpcIi8+PHBhdGggZmlsbD1cInZhcigtLWZpbGwpXCIgZD1cIk0xNCAySDJ2Nmg2djloNlYyWm0xMiAxNWgtN2w2LTE1aDdsLTYgMTVabS03LTlhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2WlwiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPVwiYVwiPjxwYXRoIGZpbGw9XCJ2YXIoLS1zdHJva2UpXCIgZD1cIk0wIDBoMzV2MTlIMHpcIi8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+YDtcbmNvbnN0IGNzcyA9IGBhI3R2LWF0dHItbG9nb3stLWZpbGw6IzEzMTcyMjstLXN0cm9rZTojZmZmO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MTBweDtib3R0b206MTBweDtoZWlnaHQ6MTlweDt3aWR0aDozNXB4O21hcmdpbjowO3BhZGRpbmc6MDtib3JkZXI6MDt6LWluZGV4OjM7fWEjdHYtYXR0ci1sb2dvW2RhdGEtZGFya117LS1maWxsOiNEMUQ0REM7LS1zdHJva2U6IzEzMTcyMjt9YDtcbi8vIFRoaXMgd2lkZ2V0IGRvZXNuJ3Qgc3VwcG9ydCBkeW5hbWljYWxseSByZXNwb25kaW5nIHRvIG9wdGlvbnMgY2hhbmdlc1xuLy8gYmVjYXVzZSBpdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBgYXR0cmlidXRpb25Mb2dvYCBvcHRpb24gd29uJ3QgYmUgY2hhbmdlZFxuLy8gYW5kIHRoaXMgc2F2ZXMgc29tZSBidW5kbGUgc2l6ZS5cbmNsYXNzIEF0dHJpYnV0aW9uTG9nb1dpZGdldCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBjaGFydCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aGVtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXIoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZUVsZW1lbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2Nzc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2hvdWxkVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSAhPT0gdGhpcy5fcHJpdmF0ZV9fc2hvdWxkQmVWaXNpYmxlKCkgfHwgdGhpcy5fcHJpdmF0ZV9fdGhlbWUgIT09IHRoaXMuX3ByaXZhdGVfX3RoZW1lVG9Vc2UoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RoZW1lVG9Vc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY29sb3JQYXJzZXIoKS5faW50ZXJuYWxfY29sb3JTdHJpbmdUb0dyYXlzY2FsZSh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS50ZXh0Q29sb3IpID4gMTYwXG4gICAgICAgICAgICA/ICdkYXJrJ1xuICAgICAgICAgICAgOiAnbGlnaHQnO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2hvdWxkQmVWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10uYXR0cmlidXRpb25Mb2dvO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0VVRNU291cmNlKCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBpZiAoIXVybC5ob3N0bmFtZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGxvY2FsIHRlc3RpbmdcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyZ1dG1fc291cmNlPScgKyB1cmwuaG9zdG5hbWUgKyB1cmwucGF0aG5hbWU7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2hvdWxkVXBkYXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZW1vdmVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19zaG91bGRCZVZpc2libGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RoZW1lID0gdGhpcy5fcHJpdmF0ZV9fdGhlbWVUb1VzZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50LmlubmVyVGV4dCA9IGNzcztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmhyZWYgPSBgaHR0cHM6Ly93d3cudHJhZGluZ3ZpZXcuY29tLz91dG1fbWVkaXVtPWx3Yy1saW5rJnV0bV9jYW1wYWlnbj1sd2MtY2hhcnQke3RoaXMuX3ByaXZhdGVfX2dldFVUTVNvdXJjZSgpfWA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnRpdGxlID0gJ0NoYXJ0aW5nIGJ5IFRyYWRpbmdWaWV3JztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuaWQgPSAndHYtYXR0ci1sb2dvJztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmlubmVySFRNTCA9IHN2ZztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQudG9nZ2xlQXR0cmlidXRlKCdkYXRhLWRhcmsnLCB0aGlzLl9wcml2YXRlX190aGVtZSA9PT0gJ2RhcmsnKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQm91bmRDYW52YXMocGFyZW50RWxlbWVudCwgc2l6ZSkge1xuICAgIGNvbnN0IGRvYyA9IGVuc3VyZU5vdE51bGwocGFyZW50RWxlbWVudC5vd25lckRvY3VtZW50KTtcbiAgICBjb25zdCBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kQ2FudmFzRWxlbWVudEJpdG1hcFNpemVUbyhjYW52YXMsIHtcbiAgICAgICAgdHlwZTogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGFsbG93UmVzaXplT2JzZXJ2ZXI6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybTogKGJpdG1hcFNpemUsIGNhbnZhc0VsZW1lbnRDbGllbnRTaXplKSA9PiAoe1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KGJpdG1hcFNpemUud2lkdGgsIGNhbnZhc0VsZW1lbnRDbGllbnRTaXplLndpZHRoKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoYml0bWFwU2l6ZS5oZWlnaHQsIGNhbnZhc0VsZW1lbnRDbGllbnRTaXplLmhlaWdodCksXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGJpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChzaXplKTtcbiAgICByZXR1cm4gYmluZGluZztcbn1cbmZ1bmN0aW9uIHJlbGVhc2VDYW52YXMoY2FudmFzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBmaXhlcyB0aGUgaU9TIFNhZmFyaSBlcnJvciBcIlRvdGFsIGNhbnZhcyBtZW1vcnkgdXNlIGV4Y2VlZHMgdGhlIG1heGltdW0gbGltaXRcIi5cbiAgICAvLyBTZWVtcyB0aGF0IGlPUyBTYWZhcmkgc3RvcmVzIGNhbnZhcyBlbGVtZW50cyBmb3Igc29tZSBhZGRpdGlvbmFsIHRpbWUgaW50ZXJuYWxseS5cbiAgICAvLyBTbyBpZiB3ZSBjcmVhdGUvZGVzdHJveSBhIGxvdCBvZiBjYW52YXMgZWxlbWVudHMgaW4gYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSB3ZSBjYW4gZ2V0IHRoaXMgZXJyb3IuXG4gICAgLy8gV2UgcmVzaXplIHRoZSBjYW52YXMgdG8gMXgxIHBpeGVscyB0byBmb3JjZSBpdCB0byByZWxlYXNlIG1lbW1vcnkgcmVzb3VyY2VzLlxuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY2FudmFzLmdldENvbnRleHQoJzJkJyk/LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tncm91bmQocmVuZGVyZXIsIHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgIGlmIChyZW5kZXJlci5faW50ZXJuYWxfZHJhd0JhY2tncm91bmQpIHtcbiAgICAgICAgcmVuZGVyZXIuX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kKHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd0ZvcmVncm91bmQocmVuZGVyZXIsIHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgIHJlbmRlcmVyLl9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSk7XG59XG5mdW5jdGlvbiBkcmF3U291cmNlVmlld3MocGFuZVZpZXdzR2V0dGVyLCBkcmF3UmVuZGVyZXJGbiwgc291cmNlLCBwYW5lKSB7XG4gICAgY29uc3Qgdmlld3MgPSBwYW5lVmlld3NHZXR0ZXIoc291cmNlLCBwYW5lKTtcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygdmlld3MpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB2aWV3Ll9pbnRlcm5hbF9yZW5kZXJlcihwYW5lKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkcmF3UmVuZGVyZXJGbihyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1ByaWNlU2NhbGUoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlcih6T3JkZXIsIHByaWNlU2NhbGVJZCkge1xuICAgIHJldHVybiAoc291cmNlKSA9PiB7XG4gICAgICAgIGlmICghaGFzUHJpY2VTY2FsZShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHNJZCA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpPy5faW50ZXJuYWxfaWQoKSA/PyAnJztcbiAgICAgICAgaWYgKHBzSWQgIT09IHByaWNlU2NhbGVJZCkge1xuICAgICAgICAgICAgLy8gZXhjbHVkZSBpZiBzb3VyY2UgaXMgdXNpbmcgYSBkaWZmZXJlbnQgcHJpY2Ugc2NhbGUuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfcHJpY2VQYW5lVmlld3M/Lih6T3JkZXIpID8/IFtdO1xuICAgIH07XG59XG5mdW5jdGlvbiByZWNhbGN1bGF0ZU92ZXJsYXBwaW5nKHZpZXdzLCBkaXJlY3Rpb24sIHNjYWxlSGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpIHtcbiAgICBpZiAoIXZpZXdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50R3JvdXBTdGFydCA9IDA7XG4gICAgY29uc3QgaW5pdExhYmVsSGVpZ2h0ID0gdmlld3NbMF0uX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIHRydWUpO1xuICAgIGxldCBzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCA9IGRpcmVjdGlvbiA9PT0gMVxuICAgICAgICA/IHNjYWxlSGVpZ2h0IC8gMiAtICh2aWV3c1swXS5faW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlKCkgLSBpbml0TGFiZWxIZWlnaHQgLyAyKVxuICAgICAgICA6IHZpZXdzWzBdLl9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUoKSAtIGluaXRMYWJlbEhlaWdodCAvIDIgLSBzY2FsZUhlaWdodCAvIDI7XG4gICAgc3BhY2VCZWZvcmVDdXJyZW50R3JvdXAgPSBNYXRoLm1heCgwLCBzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgIGNvbnN0IHByZXYgPSB2aWV3c1tpIC0gMV07XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHByZXYuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHZpZXcuX2ludGVybmFsX2dldEZpeGVkQ29vcmRpbmF0ZSgpO1xuICAgICAgICBjb25zdCBwcmV2Rml4ZWRDb29yZGluYXRlID0gcHJldi5faW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlKCk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXAgPSBkaXJlY3Rpb24gPT09IDFcbiAgICAgICAgICAgID8gY29vcmRpbmF0ZSA+IHByZXZGaXhlZENvb3JkaW5hdGUgLSBoZWlnaHRcbiAgICAgICAgICAgIDogY29vcmRpbmF0ZSA8IHByZXZGaXhlZENvb3JkaW5hdGUgKyBoZWlnaHQ7XG4gICAgICAgIGlmIChvdmVybGFwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXhlZENvb3JkaW5hdGUgPSBwcmV2Rml4ZWRDb29yZGluYXRlIC0gaGVpZ2h0ICogZGlyZWN0aW9uO1xuICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKGZpeGVkQ29vcmRpbmF0ZSk7XG4gICAgICAgICAgICBjb25zdCBlZGdlUG9pbnQgPSBmaXhlZENvb3JkaW5hdGUgLSBkaXJlY3Rpb24gKiBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3Qgb3V0T2ZWaWV3cG9ydCA9IGRpcmVjdGlvbiA9PT0gMSA/IGVkZ2VQb2ludCA8IDAgOiBlZGdlUG9pbnQgPiBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgIGlmIChvdXRPZlZpZXdwb3J0ICYmIHNwYWNlQmVmb3JlQ3VycmVudEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSB3aG9sZSBncm91cCB1cCBvciBkb3duXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZEdyb3VwU2hpZnQgPSBkaXJlY3Rpb24gPT09IDEgPyAtMSAtIGVkZ2VQb2ludCA6IGVkZ2VQb2ludCAtIHNjYWxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlU2hpZnQgPSBNYXRoLm1pbihkZXNpcmVkR3JvdXBTaGlmdCwgc3BhY2VCZWZvcmVDdXJyZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBjdXJyZW50R3JvdXBTdGFydDsgayA8IHZpZXdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzW2tdLl9pbnRlcm5hbF9zZXRGaXhlZENvb3JkaW5hdGUodmlld3Nba10uX2ludGVybmFsX2dldEZpeGVkQ29vcmRpbmF0ZSgpICsgZGlyZWN0aW9uICogcG9zc2libGVTaGlmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlQ3VycmVudEdyb3VwIC09IHBvc3NpYmxlU2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXBTdGFydCA9IGk7XG4gICAgICAgICAgICBzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCA9IGRpcmVjdGlvbiA9PT0gMVxuICAgICAgICAgICAgICAgID8gcHJldkZpeGVkQ29vcmRpbmF0ZSAtIGhlaWdodCAtIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICA6IGNvb3JkaW5hdGUgLSAocHJldkZpeGVkQ29vcmRpbmF0ZSArIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcmljZVNjYWxlQ3Jvc3NoYWlyTGFiZWxWaXNpYmxlKGNyb3NzaGFpcikge1xuICAgIHJldHVybiBjcm9zc2hhaXIubW9kZSAhPT0gMiAvKiBDcm9zc2hhaXJNb2RlLkhpZGRlbiAqLyAmJiBjcm9zc2hhaXIuaG9yekxpbmUudmlzaWJsZSAmJiBjcm9zc2hhaXIuaG9yekxpbmUubGFiZWxWaXNpYmxlO1xufVxuY2xhc3MgUHJpY2VBeGlzV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lLCBvcHRpb25zLCByZW5kZXJlck9wdGlvbnNQcm92aWRlciwgc2lkZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKDIwMCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2T3B0aW1hbFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zID0gb3B0aW9uc1snbGF5b3V0J107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gcmVuZGVyZXJPcHRpb25zUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA9IHNpZGUgPT09ICdsZWZ0JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlUGFuZVZpZXdzID0gYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlcignbm9ybWFsJywgc2lkZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVRvcFBhbmVWaWV3cyA9IGJ1aWxkUHJpY2VBeGlzVmlld3NHZXR0ZXIoJ3RvcCcsIHNpZGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2VCb3R0b21QYW5lVmlld3MgPSBidWlsZFByaWNlQXhpc1ZpZXdzR2V0dGVyKCdib3R0b20nLCBzaWRlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLndpZHRoID0gJzI1cHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fY2VsbCwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fY2VsbCwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCB0b3BDYW52YXMgPSB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS56SW5kZXggPSAnMic7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRG93bkV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvd25FdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50OiB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bk91dHNpZGVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlVXBFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VVcEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvdWJsZUNsaWNrRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9kb3VibGVUYXBFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3VibGVDbGlja0V2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VFbnRlckV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZUVudGVyRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50SGFuZGxlcih0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIGhhbmRsZXIsIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdFZlcnRUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+ICF0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY3JvbGwnXS52ZXJ0VG91Y2hEcmFnLFxuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vbk1hcmtzQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jZWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zLmZvbnRTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgaXNGb250Q2hhbmdlZCA9IHRoaXMuX3ByaXZhdGVfX2ZvbnQgIT09IG9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgIGlmIChpc0ZvbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9IG9wdGlvbnMuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpbWFsV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGlja01hcmtNYXhXaWR0aCA9IDA7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBjdHggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQuY29sb3JTcGFjZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjb25zdCB0aWNrTWFya3MgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9tYXJrcygpO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VGb250KCk7XG4gICAgICAgIGlmICh0aWNrTWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGlja01hcmtNYXhXaWR0aCA9IE1hdGgubWF4KHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGlja01hcmtzWzBdLl9pbnRlcm5hbF9sYWJlbCksIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGlja01hcmtzW3RpY2tNYXJrcy5sZW5ndGggLSAxXS5faW50ZXJuYWxfbGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cyA9IHRoaXMuX3ByaXZhdGVfX2JhY2tMYWJlbHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IHZpZXdzLmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHZpZXdzW2pdLl9pbnRlcm5hbF90ZXh0KCkpO1xuICAgICAgICAgICAgaWYgKHdpZHRoID4gdGlja01hcmtNYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRpY2tNYXJrTWF4V2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgcHJpY2VTY2FsZUNyb3NzaGFpckxhYmVsVmlzaWJsZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLmNyb3NzaGFpcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UoMSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBib3R0b21WYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC0gMiwgZmlyc3RWYWx1ZSk7XG4gICAgICAgICAgICB0aWNrTWFya01heFdpZHRoID0gTWF0aC5tYXgodGlja01hcmtNYXhXaWR0aCwgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZShNYXRoLmZsb29yKE1hdGgubWluKHRvcFZhbHVlLCBib3R0b21WYWx1ZSkpICsgMC4xMTExMTExMTExMTExMSwgZmlyc3RWYWx1ZSkpLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlKE1hdGguY2VpbChNYXRoLm1heCh0b3BWYWx1ZSwgYm90dG9tVmFsdWUpKSAtIDAuMTExMTExMTExMTExMTEsIGZpcnN0VmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0VGlja01hcmtzTWF4V2lkdGggPSB0aWNrTWFya01heFdpZHRoIHx8IDM0IC8qIENvbnN0YW50cy5EZWZhdWx0T3B0aW1hbFdpZHRoICovO1xuICAgICAgICBjb25zdCByZXMgPSBNYXRoLmNlaWwocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9ib3JkZXJTaXplICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdJbm5lciArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdPdXRlciArXG4gICAgICAgICAgICA1IC8qIENvbnN0YW50cy5MYWJlbE9mZnNldCAqLyArXG4gICAgICAgICAgICByZXN1bHRUaWNrTWFya3NNYXhXaWR0aCk7XG4gICAgICAgIC8vIG1ha2UgaXQgZXZlbiwgcmVtb3ZlIHRoaXMgYWZ0ZXIgbWlncmF0aW9uIHRvIHBlcmZlY3QgZmFuY3kgY2FudmFzXG4gICAgICAgIHJldHVybiBzdWdnZXN0UHJpY2VTY2FsZVdpZHRoKHJlcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTaXplKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwgfHwgIWVxdWFsU2l6ZXModGhpcy5fcHJpdmF0ZV9fc2l6ZSwgbmV3U2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBuZXdTaXplO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQobmV3U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQobmV3U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLndpZHRoID0gYCR7bmV3U2l6ZS53aWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemUuaGVpZ2h0fXB4YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3NpemUpLndpZHRoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UHJpY2VTY2FsZShwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBwcmljZVNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29uTWFya3NDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9vbk1hcmtzQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQuYmluZCh0aGlzKSwgdGhpcyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2V0KCkge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfcmVzZXRQcmljZVNjYWxlKHBhbmUsIGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYWludCh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQuY29sb3JTcGFjZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgIT09IDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hbGlnbkxhYmVscygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcsIGNhbnZhc09wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihzY29wZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgdGhpcy5fcHJpdmF0ZV9fc291cmNlQm90dG9tUGFuZVZpZXdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3VGlja01hcmtzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgdGhpcy5fcHJpdmF0ZV9fc291cmNlUGFuZVZpZXdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QmFja0xhYmVscyh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgIGNvbnN0IHRvcFRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcsIGNhbnZhc09wdGlvbnMpO1xuICAgICAgICBpZiAodG9wVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BUYXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdDcm9zc2hhaXJMYWJlbCh0b3BUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRvcFRhcmdldCwgdGhpcy5fcHJpdmF0ZV9fc291cmNlVG9wUGFuZVZpZXdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSB0aGlzLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID4gMCAmJiBiaXRtYXBTaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICAvLyB0aGlzIGNhbGwgaGFzIHNpZGUtZWZmZWN0IC0gaXQgcmVnZW5lcmF0ZXMgbWFya3Mgb24gdGhlIHByaWNlIHNjYWxlXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU/Ll9pbnRlcm5hbF9tYXJrcygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQoZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnNbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUucHJpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfc3RhcnRTY2FsZVByaWNlKHBhbmUsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUsIGUubG9jYWxZKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zY2FsZVByaWNlVG8ocGFuZSwgcHJpY2VTY2FsZSwgZS5sb2NhbFkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VEb3duT3V0c2lkZUV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS5wcmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY2FsZVByaWNlKHBhbmUsIHByaWNlU2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZVVwRXZlbnQoZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS5wcmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfZW5kU2NhbGVQcmljZShwYW5lLCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlRG91YmxlQ2xpY2tFdmVudChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY2FsZSddLmF4aXNEb3VibGVDbGlja1Jlc2V0LnByaWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZUVudGVyRXZlbnQoZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgaWYgKG1vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUucHJpY2UgJiYgIXRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpICYmICF0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMSAvKiBDdXJzb3JUeXBlLk5zUmVzaXplICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VMZWF2ZUV2ZW50KGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0Q3Vyc29yKDAgLyogQ3Vyc29yVHlwZS5EZWZhdWx0ICovKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2JhY2tMYWJlbHMoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpID8gdW5kZWZpbmVkIDogdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgY29uc3QgYWRkVmlld3NGb3JTb3VyY2VzID0gKHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBzb3VyY2UuX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCksIHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlld3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godmlld3Nbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIG1heCBhbmQgbWluIGNvb3JkaW5hdGVzIGZvciB2aWV3cyBvbiBzZWxlY3Rpb25cbiAgICAgICAgLy8gY3Jvc3NoYWlyIGluZGl2aWR1YWxseVxuICAgICAgICBhZGRWaWV3c0ZvclNvdXJjZXModGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYml0bWFwU2l6ZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCB0b3BDb2xvciA9IG1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IoKTtcbiAgICAgICAgY29uc3QgYm90dG9tQ29sb3IgPSBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCk7XG4gICAgICAgIGlmICh0b3BDb2xvciA9PT0gYm90dG9tQ29sb3IpIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRvcENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdFdpdGhHcmFkaWVudChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRvcENvbG9yLCBib3R0b21Db2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCb3JkZXIoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCB8fCAhdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLmJvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLmJvcmRlckNvbG9yO1xuICAgICAgICBjb25zdCBib3JkZXJTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aGlzLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMoKS5faW50ZXJuYWxfYm9yZGVyU2l6ZSAqIGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGxldCBsZWZ0O1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNMZWZ0KSB7XG4gICAgICAgICAgICBsZWZ0ID0gYml0bWFwU2l6ZS53aWR0aCAtIGJvcmRlclNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgMCwgYm9yZGVyU2l6ZSwgYml0bWFwU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd1RpY2tNYXJrcyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpY2tNYXJrcyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX21hcmtzKCk7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGVPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgdGlja01hcmtMZWZ0WCA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/XG4gICAgICAgICAgICAodGhpcy5fcHJpdmF0ZV9fc2l6ZS53aWR0aCAtIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCkgOlxuICAgICAgICAgICAgMDtcbiAgICAgICAgaWYgKHByaWNlU2NhbGVPcHRpb25zLmJvcmRlclZpc2libGUgJiYgcHJpY2VTY2FsZU9wdGlvbnMudGlja3NWaXNpYmxlKSB7XG4gICAgICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHByaWNlU2NhbGVPcHRpb25zLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tIZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tPZmZzZXQgPSBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbyAqIDAuNSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0xlbmd0aCA9IE1hdGgucm91bmQocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRpY2tNYXJrIG9mIHRpY2tNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChNYXRoLmZsb29yKHRpY2tNYXJrTGVmdFggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyksIE1hdGgucm91bmQodGlja01hcmsuX2ludGVybmFsX2Nvb3JkICogdmVydGljYWxQaXhlbFJhdGlvKSAtIHRpY2tPZmZzZXQsIHRpY2tMZW5ndGgsIHRpY2tIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCB9KSA9PiB7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VGb250KCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcHJpY2VTY2FsZU9wdGlvbnMudGV4dENvbG9yID8/IHRoaXMuX3ByaXZhdGVfX2xheW91dE9wdGlvbnMudGV4dENvbG9yO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVmdFggPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgP1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGlja01hcmtMZWZ0WCAtIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0lubmVyKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aWNrTWFya0xlZnRYICsgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICsgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSW5uZXIpO1xuICAgICAgICAgICAgY29uc3QgeU1pZENvcnJlY3Rpb25zID0gdGlja01hcmtzLm1hcCgobWFyaykgPT4gdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCBtYXJrLl9pbnRlcm5hbF9sYWJlbCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRpY2tNYXJrcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTWFyayA9IHRpY2tNYXJrc1tpXTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGlja01hcmsuX2ludGVybmFsX2xhYmVsLCB0ZXh0TGVmdFgsIHRpY2tNYXJrLl9pbnRlcm5hbF9jb29yZCArIHlNaWRDb3JyZWN0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWxpZ25MYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCB2aWV3cyA9IFtdO1xuICAgICAgICBjb25zdCBvcmRlcmVkU291cmNlcyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkuc2xpY2UoKTsgLy8gQ29weSBvZiBhcnJheVxuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZTtcbiAgICAgICAgY29uc3QgcGFuZVN0YXRlID0gcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBkZWZhdWx0IHByaWNlIHNjYWxlLCBhcHBlbmQgbGFiZWxzIGZyb20gbm8tc2NhbGVcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0ID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gcGFuZVN0YXRlLl9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGUoKTtcbiAgICAgICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKS5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFuZVN0YXRlLl9pbnRlcm5hbF9pc092ZXJsYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgY2FuIHVzZSBhbnksIGJ1dCBsZXQncyB1c2UgdGhlIGZpcnN0IHNvdXJjZSBhcyBcImNlbnRlclwiIG9uZVxuICAgICAgICBjb25zdCBjZW50ZXJTb3VyY2UgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9kYXRhU291cmNlcygpWzBdO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdXBkYXRlRm9yU291cmNlcyA9IChzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXdzID0gc291cmNlLl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyhwYW5lU3RhdGUsIHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgICAgIC8vIG5ldmVyIGFsaWduIHNlbGVjdGVkIHNvdXJjZXNcbiAgICAgICAgICAgICAgICBzb3VyY2VWaWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcuX2ludGVybmFsX2lzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclNvdXJjZSA9PT0gc291cmNlICYmIHNvdXJjZVZpZXdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gc291cmNlVmlld3NbMF0uX2ludGVybmFsX2Nvb3JkaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3Jvc3NoYWlyIGluZGl2aWR1YWxseVxuICAgICAgICB1cGRhdGVGb3JTb3VyY2VzKG9yZGVyZWRTb3VyY2VzKTtcbiAgICAgICAgdmlld3MuZm9yRWFjaCgodmlldykgPT4gdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSkpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWxpZ25MYWJlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19maXhMYWJlbE92ZXJsYXAodmlld3MsIHJlbmRlcmVyT3B0aW9ucywgY2VudGVyKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZpeExhYmVsT3ZlcmxhcCh2aWV3cywgcmVuZGVyZXJPcHRpb25zLCBjZW50ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGxpdCBpbnRvIHR3byBwYXJ0c1xuICAgICAgICBjb25zdCB0b3AgPSB2aWV3cy5maWx0ZXIoKHZpZXcpID0+IHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSA8PSBjZW50ZXIpO1xuICAgICAgICBjb25zdCBib3R0b20gPSB2aWV3cy5maWx0ZXIoKHZpZXcpID0+IHZpZXcuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSA+IGNlbnRlcik7XG4gICAgICAgIC8vIHNvcnQgdG9wIGZyb20gY2VudGVyIHRvIHRvcFxuICAgICAgICB0b3Auc29ydCgobCwgcikgPT4gci5faW50ZXJuYWxfY29vcmRpbmF0ZSgpIC0gbC5faW50ZXJuYWxfY29vcmRpbmF0ZSgpKTtcbiAgICAgICAgLy8gc2hhcmUgY2VudGVyIGxhYmVsXG4gICAgICAgIGlmICh0b3AubGVuZ3RoICYmIGJvdHRvbS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJvdHRvbS5wdXNoKHRvcFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgYm90dG9tLnNvcnQoKGwsIHIpID0+IGwuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSAtIHIuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSk7XG4gICAgICAgIGZvciAoY29uc3QgdmlldyBvZiB2aWV3cykge1xuICAgICAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGguZmxvb3Iodmlldy5faW50ZXJuYWxfaGVpZ2h0KHJlbmRlcmVyT3B0aW9ucykgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZSA+IC1oYWxmSGVpZ2h0ICYmIGNvb3JkaW5hdGUgPCBoYWxmSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUgPiAodGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLSBoYWxmSGVpZ2h0KSAmJiBjb29yZGluYXRlIDwgdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgKyBoYWxmSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVjYWxjdWxhdGVPdmVybGFwcGluZyh0b3AsIDEsIHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpO1xuICAgICAgICByZWNhbGN1bGF0ZU92ZXJsYXBwaW5nKGJvdHRvbSwgLTEsIHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tMYWJlbHModGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLl9wcml2YXRlX19iYWNrTGFiZWxzKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3Ll9pbnRlcm5hbF9pc0F4aXNMYWJlbFZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdmlldy5faW50ZXJuYWxfcmVuZGVyZXIoZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCByZW5kZXJlck9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUsIGFsaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyTGFiZWwodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gW107IC8vIGFycmF5IG9mIGFycmF5c1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZGVsLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKS5faW50ZXJuYWxfcHJpY2VBeGlzVmlld3MocGFuZSwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSk7XG4gICAgICAgIGlmICh2Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmlld3MucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBybyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKGFycikgPT4ge1xuICAgICAgICAgICAgYXJyLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3Ll9pbnRlcm5hbF9yZW5kZXJlcihlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUpKS5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIHJvLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLCBhbGlnbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRDdXJzb3IodHlwZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmN1cnNvciA9IHR5cGUgPT09IDEgLyogQ3Vyc29yVHlwZS5Oc1Jlc2l6ZSAqLyA/ICducy1yZXNpemUnIDogJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQoKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5faW50ZXJuYWxfb3B0aW1hbFdpZHRoKCk7XG4gICAgICAgIC8vIGF2b2lkIHByaWNlIHNjYWxlIGlzIHNocnVua1xuICAgICAgICAvLyB1c2luZyA8IGluc3RlYWQgIT09IHRvIGF2b2lkIGluZmluaXRlIGNoYW5nZXNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByZXZPcHRpbWFsV2lkdGggPCB3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZXZPcHRpbWFsV2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Jhc2VGb250KCkge1xuICAgICAgICByZXR1cm4gbWFrZUZvbnQodGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250U2l6ZSwgdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250RmFtaWx5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNvdXJjZUJvdHRvbVBhbmVWaWV3cyQxKHNvdXJjZSwgcGFuZSkge1xuICAgIHJldHVybiBzb3VyY2UuX2ludGVybmFsX2JvdHRvbVBhbmVWaWV3cz8uKHBhbmUpID8/IFtdO1xufVxuZnVuY3Rpb24gc291cmNlUGFuZVZpZXdzJDEoc291cmNlLCBwYW5lKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfcGFuZVZpZXdzPy4ocGFuZSkgPz8gW107XG59XG5mdW5jdGlvbiBzb3VyY2VMYWJlbFBhbmVWaWV3cyhzb3VyY2UsIHBhbmUpIHtcbiAgICByZXR1cm4gc291cmNlLl9pbnRlcm5hbF9sYWJlbFBhbmVWaWV3cz8uKHBhbmUpID8/IFtdO1xufVxuZnVuY3Rpb24gc291cmNlVG9wUGFuZVZpZXdzJDEoc291cmNlLCBwYW5lKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfdG9wUGFuZVZpZXdzPy4ocGFuZSkgPz8gW107XG59XG5jbGFzcyBQYW5lV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydCwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHNpemUkMSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZXZQaW5jaFNjYWxlID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19leGl0VHJhY2tpbmdNb2RlT25OZXh0VHJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luaXRDcm9zc2hhaXJQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgfHwgdGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IGNoYXJ0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uU3RhdGVEZXN0cm95ZWQuYmluZCh0aGlzKSwgdGhpcywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBjb25zdCBwYW5lV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYW5lV3JhcHBlci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgcGFuZVdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBwYW5lV3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIHBhbmVXcmFwcGVyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodEF4aXNDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbC5hcHBlbmRDaGlsZChwYW5lV3JhcHBlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcgPSBjcmVhdGVCb3VuZENhbnZhcyhwYW5lV3JhcHBlciwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXMocGFuZVdyYXBwZXIsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgdG9wQ2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUuekluZGV4ID0gJzInO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fbGVmdEF4aXNDZWxsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19wYW5lQ2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgPSBuZXcgTW91c2VFdmVudEhhbmRsZXIodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB0aGlzLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPT09IG51bGwgJiYgIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjcm9sbCddLnZlcnRUb3VjaERyYWcsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRIb3J6VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPT09IG51bGwgJiYgIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjcm9sbCddLmhvcnpUb3VjaERyYWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0cmlidXRpb25Mb2dvV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXRlKCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTdGF0ZShwYW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX29uRGVzdHJveWVkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlID0gcGFuZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKFBhbmVXaWRnZXQucHJvdG90eXBlLl9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkLmJpbmQodGhpcyksIHRoaXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9wYW5lV2lkZ2V0cygpLmluZGV4T2YodGhpcykgPT09IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9wYW5lV2lkZ2V0cygpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCA9IHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCA/PyBuZXcgQXR0cmlidXRpb25Mb2dvV2lkZ2V0KHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLCB0aGlzLl9wcml2YXRlX19jaGFydCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hdHRyaWJ1dGlvbkxvZ29XaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0cmlidXRpb25Mb2dvV2lkZ2V0Py5faW50ZXJuYWxfcmVtb3ZlRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0cmlidXRpb25Mb2dvV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfY2hhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlUHJpY2VBeGlzV2lkZ2V0c1N0YXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjcmVhdGVQcmljZUF4aXNXaWRnZXRzKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9zZXJpZXNlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0UHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfc2V0UHJpY2VTY2FsZShlbnN1cmVOb3ROdWxsKGxlZnRQcmljZVNjYWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodFByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfcmlnaHRQcmljZVNjYWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfc2V0UHJpY2VTY2FsZShlbnN1cmVOb3ROdWxsKHJpZ2h0UHJpY2VTY2FsZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zdGF0ZSAhPT0gbnVsbCA/IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9zdHJldGNoRmFjdG9yKCkgOiAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U3RyZXRjaEZhY3RvcihzdHJldGNoRmFjdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3Ioc3RyZXRjaEZhY3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX21vdXNlRW50ZXJFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5sb2NhbFg7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5sb2NhbFk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKHgsIHksIGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vdXNlRG93bkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVRvdWNoRG93bkV2ZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKGV2ZW50LmxvY2FsWCwgZXZlbnQubG9jYWxZLCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZU1vdmVFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5sb2NhbFg7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5sb2NhbFk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKHgsIHksIGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vdXNlQ2xpY2tFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vdXNlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZmlyZUNsaWNrZWREZWxlZ2F0ZShldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZmlyZU1vdXNlQ2xpY2tEZWxlZ2F0ZSh0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkLCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kb3VibGVUYXBFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VUb3VjaE1vdmVFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKGV2ZW50LmxvY2FsWCwgZXZlbnQubG9jYWxZLCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZVVwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kU2Nyb2xsKGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RhcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVDbGlja2VkRGVsZWdhdGUoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9uZ1RhcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHsgeDogZXZlbnQubG9jYWxYLCB5OiBldmVudC5sb2NhbFkgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tpbmdNb2RlKHBvaW50LCBwb2ludCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXRIb3ZlcmVkU291cmNlKG51bGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhckNyb3NzaGFpclBvc2l0aW9uKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbGlja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2RibENsaWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGluY2hTdGFydEV2ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3N0b3BUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3BpbmNoRXZlbnQobWlkZGxlUG9pbnQsIHNjYWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5waW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHpvb21TY2FsZSA9IChzY2FsZSAtIHRoaXMuX3ByaXZhdGVfX3ByZXZQaW5jaFNjYWxlKSAqIDU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZXZQaW5jaFNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3pvb21UaW1lKG1pZGRsZVBvaW50Ll9pbnRlcm5hbF94LCB6b29tU2NhbGUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hTdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSA9IHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCAhPT0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VUb3VjaERvd25FdmVudCgpO1xuICAgICAgICBjb25zdCBjcm9zc2hhaXIgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCAhPT0gbnVsbCAmJiBjcm9zc2hhaXIuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5pdENyb3NzaGFpclBvc2l0aW9uID0geyB4OiBjcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRYKCksIHk6IGNyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZFkoKSB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0geyB4OiBldmVudC5sb2NhbFgsIHk6IGV2ZW50LmxvY2FsWSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b3VjaE1vdmVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gZXZlbnQubG9jYWxYO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQubG9jYWxZO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0cmFja2luZyBtb2RlOiBtb3ZlIGNyb3NzaGFpclxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1BvaW50ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19pbml0Q3Jvc3NoYWlyUG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbmV3WCA9IG9yaWdQb2ludC54ICsgKHggLSB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQueCk7XG4gICAgICAgICAgICBjb25zdCBuZXdZID0gb3JpZ1BvaW50LnkgKyAoeSAtIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludC55KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKG5ld1gsIG5ld1ksIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VUb3VjaE1vdmVFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b3VjaEVuZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9vcHRpb25zKCkudHJhY2tpbmdNb2RlLmV4aXRNb2RlID09PSAwIC8qIFRyYWNraW5nTW9kZUV4aXRNb2RlLk9uVG91Y2hFbmQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RyeUV4aXRUcmFja2luZ01vZGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kU2Nyb2xsKGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hpdFRlc3QoeCwgeSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXRUZXN0UGFuZShzdGF0ZSwgeCwgeSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQcmljZUF4aXNTaXplKHdpZHRoLCBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBwcmljZUF4aXNXaWRnZXQgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCA6IHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0O1xuICAgICAgICBlbnN1cmVOb3ROdWxsKHByaWNlQXhpc1dpZGdldCkuX2ludGVybmFsX3NldFNpemUoc2l6ZSQxKHsgd2lkdGgsIGhlaWdodDogdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgfSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTaXplKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKGVxdWFsU2l6ZXModGhpcy5fcHJpdmF0ZV9fc2l6ZSwgbmV3U2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KG5ld1NpemUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLndpZHRoID0gbmV3U2l6ZS53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZXMoKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKTtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHBhbmUuX2ludGVybmFsX2xlZnRQcmljZVNjYWxlKCkpO1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUocGFuZS5faW50ZXJuYWxfcmlnaHRQcmljZVNjYWxlKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBwYW5lLl9pbnRlcm5hbF9kYXRhU291cmNlcygpKSB7XG4gICAgICAgICAgICBpZiAocGFuZS5faW50ZXJuYWxfaXNPdmVybGF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHByaWNlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmb3Igb3ZlcmxheSBkcmF3aW5ncyBwcmljZSBzY2FsZSBpcyBvd25lcidzIHByaWNlIHNjYWxlXG4gICAgICAgICAgICAgICAgLy8gaG93ZXZlciBvd25lcidzIHByaWNlIHNjYWxlIGNvdWxkIG5vdCBjb250YWluIGRzXG4gICAgICAgICAgICAgICAgc291cmNlLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHBhbmUuX2ludGVybmFsX3ByaW1pdGl2ZXMoKSkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5iaXRtYXBTaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHRoaXMuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgaWYgKGJpdG1hcFNpemUud2lkdGggPiAwICYmIGJpdG1hcFNpemUuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYWludCh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIEludmFsaWRhdGlvbkxldmVsLk5vbmUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA+IDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3BhaW50KHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3BhaW50KHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLmxheW91dC5jb2xvclNwYWNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSAhPT0gMSAvKiBJbnZhbGlkYXRpb25MZXZlbC5DdXJzb3IgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLCBjYW52YXNPcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QmFja2dyb3VuZChzY29wZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRhcmdldCwgc291cmNlQm90dG9tUGFuZVZpZXdzJDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3R3JpZCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHNvdXJjZVBhbmVWaWV3cyQxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZXModGFyZ2V0LCBzb3VyY2VMYWJlbFBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgIGNvbnN0IHRvcFRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcsIGNhbnZhc09wdGlvbnMpO1xuICAgICAgICBpZiAodG9wVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BUYXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdDcm9zc2hhaXIodG9wVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRvcFRhcmdldCwgc291cmNlVG9wUGFuZVZpZXdzJDEpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZXModG9wVGFyZ2V0LCBzb3VyY2VMYWJlbFBhbmVWaWV3cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldDtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHBhbmVWaWV3c0dldHRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHBhbmVWaWV3c0dldHRlcik7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19maXJlQ2xpY2tlZERlbGVnYXRlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUodGhpcy5fcHJpdmF0ZV9fY2xpY2tlZCwgZXZlbnQpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyZU1vdXNlQ2xpY2tEZWxlZ2F0ZShkZWxlZ2F0ZSwgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeCA9IGV2ZW50LmxvY2FsWDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmxvY2FsWTtcbiAgICAgICAgaWYgKGRlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgZGVsZWdhdGUuX2ludGVybmFsX2ZpcmUodGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgpLCB7IHgsIHkgfSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYml0bWFwU2l6ZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpO1xuICAgICAgICBjb25zdCB0b3BDb2xvciA9IG1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IoKTtcbiAgICAgICAgY29uc3QgYm90dG9tQ29sb3IgPSBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCk7XG4gICAgICAgIGlmICh0b3BDb2xvciA9PT0gYm90dG9tQ29sb3IpIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGJvdHRvbUNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyUmVjdFdpdGhHcmFkaWVudChjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRvcENvbG9yLCBib3R0b21Db2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdHcmlkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpO1xuICAgICAgICBjb25zdCBwYW5lVmlldyA9IHN0YXRlLl9pbnRlcm5hbF9ncmlkKCkuX2ludGVybmFsX3BhbmVWaWV3KCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gcGFuZVZpZXcuX2ludGVybmFsX3JlbmRlcmVyKHN0YXRlKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJlci5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpcih0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBzb3VyY2VQYW5lVmlld3MkMSwgZHJhd0ZvcmVncm91bmQsIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX2Nyb3NzaGFpclNvdXJjZSgpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRhcmdldCwgcGFuZVZpZXdzR2V0dGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBzdGF0ZS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgcGFuZVByaW1pdGl2ZXMgPSBzdGF0ZS5faW50ZXJuYWxfcHJpbWl0aXZlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhbmVQcmltaXRpdmUgb2YgcGFuZVByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VJbXBsKHRhcmdldCwgcGFuZVZpZXdzR2V0dGVyLCBkcmF3QmFja2dyb3VuZCwgcGFuZVByaW1pdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIsIGRyYXdCYWNrZ3JvdW5kLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFuZVByaW1pdGl2ZSBvZiBwYW5lUHJpbWl0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIsIGRyYXdGb3JlZ3JvdW5kLCBwYW5lUHJpbWl0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHBhbmVWaWV3c0dldHRlciwgZHJhd0ZvcmVncm91bmQsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdTb3VyY2VJbXBsKHRhcmdldCwgcGFuZVZpZXdzR2V0dGVyLCBkcmF3Rm4sIHNvdXJjZSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpO1xuICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gc3RhdGUuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2hvdmVyZWRTb3VyY2UoKTtcbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaG92ZXJlZFNvdXJjZSAhPT0gbnVsbCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9zb3VyY2UgPT09IHNvdXJjZTtcbiAgICAgICAgY29uc3Qgb2JqZWNJZCA9IGhvdmVyZWRTb3VyY2UgIT09IG51bGwgJiYgaXNIb3ZlcmVkICYmIGhvdmVyZWRTb3VyY2UuX2ludGVybmFsX29iamVjdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGhvdmVyZWRTb3VyY2UuX2ludGVybmFsX29iamVjdC5faW50ZXJuYWxfaGl0VGVzdERhdGFcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkcmF3UmVuZGVyZXJGbiA9IChyZW5kZXJlcikgPT4gZHJhd0ZuKHJlbmRlcmVyLCB0YXJnZXQsIGlzSG92ZXJlZCwgb2JqZWNJZCk7XG4gICAgICAgIGRyYXdTb3VyY2VWaWV3cyhwYW5lVmlld3NHZXR0ZXIsIGRyYXdSZW5kZXJlckZuLCBzb3VyY2UsIHN0YXRlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY3JlYXRlUHJpY2VBeGlzV2lkZ2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLl9wcml2YXRlX19jaGFydDtcbiAgICAgICAgY29uc3QgbGVmdEF4aXNWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX2xlZnRQcmljZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnMoKS52aXNpYmxlO1xuICAgICAgICBjb25zdCByaWdodEF4aXNWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkudmlzaWJsZTtcbiAgICAgICAgaWYgKCFsZWZ0QXhpc1Zpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdEF4aXNDZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJpZ2h0QXhpc1Zpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyKCk7XG4gICAgICAgIGlmIChsZWZ0QXhpc1Zpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCA9IG5ldyBQcmljZUF4aXNXaWRnZXQodGhpcywgY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKSwgcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIsICdsZWZ0Jyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRBeGlzVmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgPSBuZXcgUHJpY2VBeGlzV2lkZ2V0KHRoaXMsIGNoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCksIHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLCAncmlnaHQnKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3ByZXZlbnRTY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50Ll9pbnRlcm5hbF9pc1RvdWNoICYmIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgfHwgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ICE9PSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29ycmVjdFhDb29yZCh4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih4LCB0aGlzLl9wcml2YXRlX19zaXplLndpZHRoIC0gMSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29ycmVjdFlDb29yZCh5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih5LCB0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCAtIDEpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKHgsIHksIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3NldEFuZFNhdmVDdXJyZW50UG9zaXRpb24odGhpcy5fcHJpdmF0ZV9fY29ycmVjdFhDb29yZCh4KSwgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdFlDb29yZCh5KSwgZXZlbnQsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NsZWFyQ3Jvc3NoYWlyUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX2NsZWFyQ3VycmVudFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX190cnlFeGl0VHJhY2tpbmdNb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyQ3Jvc3NoYWlyUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fc3RhcnRUcmFja2luZ01vZGUoc3RhcnRUcmFja1BvaW50LCBjcm9zc0hhaXJQb3NpdGlvbiwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0gc3RhcnRUcmFja1BvaW50O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19leGl0VHJhY2tpbmdNb2RlT25OZXh0VHJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldENyb3NzaGFpclBvc2l0aW9uKGNyb3NzSGFpclBvc2l0aW9uLngsIGNyb3NzSGFpclBvc2l0aW9uLnksIGV2ZW50KTtcbiAgICAgICAgY29uc3QgY3Jvc3NoYWlyID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luaXRDcm9zc2hhaXJQb3NpdGlvbiA9IHsgeDogY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkWCgpLCB5OiBjcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRZKCkgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19lbmRTY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfZW5kU2Nyb2xsUHJpY2Uoc3RhdGUsIHN0YXRlLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfZW5kU2Nyb2xsVGltZSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRBbmltYXRpb25UaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uLl9pbnRlcm5hbF9zdGFydCh0aW1lU2NhbGUuX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCksIHN0YXJ0QW5pbWF0aW9uVGltZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24uX2ludGVybmFsX2ZpbmlzaGVkKHN0YXJ0QW5pbWF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19vbk1vdXNlRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZVRvdWNoRG93bkV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBmb2N1c2FibGUgZWxlbWVudCBleGNlcHQgdGhlIHBhZ2UgaXRzZWxmIGlzIGZvY3VzZWQsIHJlbW92ZSB0aGUgZm9jdXNcbiAgICAgICAgICAgIGVuc3VyZU5vdE51bGwoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8IHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9wcml2YXRlX19wcmVzc2VkTW91c2VUb3VjaE1vdmVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgaWYgKHRpbWVTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcnRPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsT3B0aW9ucyA9IGNoYXJ0T3B0aW9uc1snaGFuZGxlU2Nyb2xsJ107XG4gICAgICAgIGNvbnN0IGtpbmV0aWNTY3JvbGxPcHRpb25zID0gY2hhcnRPcHRpb25zLmtpbmV0aWNTY3JvbGw7XG4gICAgICAgIGlmICgoIXNjcm9sbE9wdGlvbnMucHJlc3NlZE1vdXNlTW92ZSB8fCBldmVudC5faW50ZXJuYWxfaXNUb3VjaCkgJiZcbiAgICAgICAgICAgICghc2Nyb2xsT3B0aW9ucy5ob3J6VG91Y2hEcmFnICYmICFzY3JvbGxPcHRpb25zLnZlcnRUb3VjaERyYWcgfHwgIWV2ZW50Ll9pbnRlcm5hbF9pc1RvdWNoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyA9PT0gbnVsbCAmJiAhdGhpcy5fcHJpdmF0ZV9fcHJldmVudFNjcm9sbChldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zID0ge1xuICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZXN0YW1wOiBub3csXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xvY2FsWDogZXZlbnQubG9jYWxYLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sb2NhbFk6IGV2ZW50LmxvY2FsWSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zICE9PSBudWxsICYmXG4gICAgICAgICAgICAhdGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgICh0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1Bvcy54ICE9PSBldmVudC5jbGllbnRYIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zLnkgIT09IGV2ZW50LmNsaWVudFkpKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuX2ludGVybmFsX2lzVG91Y2ggJiYga2luZXRpY1Njcm9sbE9wdGlvbnMudG91Y2ggfHwgIWV2ZW50Ll9pbnRlcm5hbF9pc1RvdWNoICYmIGtpbmV0aWNTY3JvbGxPcHRpb25zLm1vdXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyU3BhY2luZyA9IHRpbWVTY2FsZS5faW50ZXJuYWxfYmFyU3BhY2luZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24gPSBuZXcgS2luZXRpY0FuaW1hdGlvbigwLjIgLyogS2luZXRpY1Njcm9sbENvbnN0YW50cy5NaW5TY3JvbGxTcGVlZCAqLyAvIGJhclNwYWNpbmcsIDcgLyogS2luZXRpY1Njcm9sbENvbnN0YW50cy5NYXhTY3JvbGxTcGVlZCAqLyAvIGJhclNwYWNpbmcsIDAuOTk3IC8qIEtpbmV0aWNTY3JvbGxDb25zdGFudHMuRHVtcGluZ0NvZWZmICovLCAxNSAvKiBLaW5ldGljU2Nyb2xsQ29uc3RhbnRzLlNjcm9sbE1pbk1vdmUgKi8gLyBiYXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uLl9pbnRlcm5hbF9hZGRQb3NpdGlvbih0aW1lU2NhbGUuX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCksIHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zLl9pbnRlcm5hbF90aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zdGFydFNjcm9sbFByaWNlKHRoaXMuX3ByaXZhdGVfX3N0YXRlLCBwcmljZVNjYWxlLCBldmVudC5sb2NhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX3N0YXJ0U2Nyb2xsVGltZShldmVudC5sb2NhbFgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgLy8gdGhpcyBhbGxvd3Mgc2Nyb2xsaW5nIG5vdCBkZWZhdWx0IHByaWNlIHNjYWxlc1xuICAgICAgICAgICAgaWYgKCFwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2Nyb2xsUHJpY2VUbyh0aGlzLl9wcml2YXRlX19zdGF0ZSwgcHJpY2VTY2FsZSwgZXZlbnQubG9jYWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zY3JvbGxUaW1lVG8oZXZlbnQubG9jYWxYKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbi5faW50ZXJuYWxfYWRkUG9zaXRpb24odGltZVNjYWxlLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpLCBub3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBQcmljZUF4aXNTdHViIHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlLCBvcHRpb25zLCBwYXJhbXMsIGJvcmRlclZpc2libGUsIGJvdHRvbUNvbG9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHNpemUkMSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHRoaXMuX2ludGVybmFsX3BhaW50KDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzTGVmdCA9IHNpZGUgPT09ICdsZWZ0JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIgPSBwYXJhbXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYm9yZGVyVmlzaWJsZSA9IGJvcmRlclZpc2libGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JvdHRvbUNvbG9yID0gYm90dG9tQ29sb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS53aWR0aCA9ICcyNXB4JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NlbGwsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NlbGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFNpemUobmV3U2l6ZSkge1xuICAgICAgICBpZiAoIWVxdWFsU2l6ZXModGhpcy5fcHJpdmF0ZV9fc2l6ZSwgbmV3U2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBuZXdTaXplO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KG5ld1NpemUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS53aWR0aCA9IGAke25ld1NpemUud2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSBgJHtuZXdTaXplLmhlaWdodH1weGA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3BhaW50KHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPCAzIC8qIEludmFsaWRhdGlvbkxldmVsLkZ1bGwgKi8gJiYgIXRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NpemUud2lkdGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLCB7XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxheW91dC5jb2xvclNwYWNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QmFja2dyb3VuZChzY29wZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihzY29wZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSB0aGlzLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID4gMCAmJiBiaXRtYXBTaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcih7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fYm9yZGVyVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLmJvcmRlckNvbG9yO1xuICAgICAgICBjb25zdCBob3J6Qm9yZGVyU2l6ZSA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIuX2ludGVybmFsX29wdGlvbnMoKS5faW50ZXJuYWxfYm9yZGVyU2l6ZSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgdmVydEJvcmRlclNpemUgPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLl9pbnRlcm5hbF9vcHRpb25zKCkuX2ludGVybmFsX2JvcmRlclNpemUgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCBsZWZ0ID0gKHRoaXMuX3ByaXZhdGVfX2lzTGVmdCkgPyBiaXRtYXBTaXplLndpZHRoIC0gaG9yekJvcmRlclNpemUgOiAwO1xuICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgMCwgaG9yekJvcmRlclNpemUsIHZlcnRCb3JkZXJTaXplKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplIH0pIHtcbiAgICAgICAgY2xlYXJSZWN0KGN0eCwgMCwgMCwgYml0bWFwU2l6ZS53aWR0aCwgYml0bWFwU2l6ZS5oZWlnaHQsIHRoaXMuX3ByaXZhdGVfX2JvdHRvbUNvbG9yKCkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRUaW1lQXhpc1ZpZXdzR2V0dGVyKHpPcmRlcikge1xuICAgIHJldHVybiAoc291cmNlKSA9PiBzb3VyY2UuX2ludGVybmFsX3RpbWVQYW5lVmlld3M/Lih6T3JkZXIpID8/IFtdO1xufVxuY29uc3Qgc291cmNlUGFuZVZpZXdzID0gYnVpbGRUaW1lQXhpc1ZpZXdzR2V0dGVyKCdub3JtYWwnKTtcbmNvbnN0IHNvdXJjZVRvcFBhbmVWaWV3cyA9IGJ1aWxkVGltZUF4aXNWaWV3c0dldHRlcigndG9wJyk7XG5jb25zdCBzb3VyY2VCb3R0b21QYW5lVmlld3MgPSBidWlsZFRpbWVBeGlzVmlld3NHZXR0ZXIoJ2JvdHRvbScpO1xuY2xhc3MgVGltZUF4aXNXaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0V2lkZ2V0LCBob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gc2l6ZSQxKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZSA9IG5ldyBUZXh0V2lkdGhDYWNoZSg1KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gY2hhcnRXaWRnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBjaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViQ2VsbC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWJDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSAnMjVweCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHYuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdi5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2R2KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2R2LCBzaXplJDEoeyB3aWR0aDogMTYsIGhlaWdodDogMTYgfSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxJztcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcgPSBjcmVhdGVCb3VuZENhbnZhcyh0aGlzLl9wcml2YXRlX19kdiwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCB0b3BDYW52YXMgPSB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS56SW5kZXggPSAnMic7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViQ2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fY2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlU3R1YnMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlU3R1YnMuYmluZCh0aGlzKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbmV3IE1vdXNlRXZlbnRIYW5kbGVyKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgdGhpcywge1xuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0VmVydFRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdHJ1ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdEhvcnpUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+ICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY3JvbGwnXS5ob3J6VG91Y2hEcmFnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX2xlZnRTdHViKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yaWdodFN0dWIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodFN0dWI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvd25FdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgaWYgKG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5faW50ZXJuYWxfc3RhcnRTY2FsZVRpbWUoZXZlbnQubG9jYWxYKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb3VzZURvd25FdmVudChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGlmICghbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkgJiYgdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWUpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfZW5kU2NhbGVUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAobW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zY2FsZVRpbWVUbyhldmVudC5sb2NhbFgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vdXNlVXBFdmVudCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGlmIChtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2lzRW1wdHkoKSAmJiAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjYWxlVGltZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VVcEV2ZW50KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNEb3VibGVDbGlja1Jlc2V0LnRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kb3VibGVUYXBFdmVudCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUVudGVyRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldEN1cnNvcigxIC8qIEN1cnNvclR5cGUuRXdSZXNpemUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldEN1cnNvcigwIC8qIEN1cnNvclR5cGUuRGVmYXVsdCAqLyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NpemVDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTaXplcyh0aW1lQXhpc1NpemUsIGxlZnRTdHViV2lkdGgsIHJpZ2h0U3R1YldpZHRoKSB7XG4gICAgICAgIGlmICghZXF1YWxTaXplcyh0aGlzLl9wcml2YXRlX19zaXplLCB0aW1lQXhpc1NpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gdGltZUF4aXNTaXplO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQodGltZUF4aXNTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudCh0aW1lQXhpc1NpemUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS53aWR0aCA9IGAke3RpbWVBeGlzU2l6ZS53aWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLmhlaWdodCA9IGAke3RpbWVBeGlzU2l6ZS5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQuX2ludGVybmFsX2ZpcmUodGltZUF4aXNTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9zZXRTaXplKHNpemUkMSh7IHdpZHRoOiBsZWZ0U3R1YldpZHRoLCBoZWlnaHQ6IHRpbWVBeGlzU2l6ZS5oZWlnaHQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1Yi5faW50ZXJuYWxfc2V0U2l6ZShzaXplJDEoeyB3aWR0aDogcmlnaHRTdHViV2lkdGgsIGhlaWdodDogdGltZUF4aXNTaXplLmhlaWdodCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX29wdGltYWxIZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKFxuICAgICAgICAvLyByZW5kZXJlck9wdGlvbnMub2Zmc2V0U2l6ZSArXG4gICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nQm90dG9tICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfbGFiZWxCb3R0b21PZmZzZXQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICAvLyB0aGlzIGNhbGwgaGFzIHNpZGUtZWZmZWN0IC0gaXQgcmVnZW5lcmF0ZXMgbWFya3Mgb24gdGhlIHRpbWUgc2NhbGVcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9tYXJrcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSB0aGlzLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID4gMCAmJiBiaXRtYXBTaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBJbnZhbGlkYXRpb25MZXZlbC5Ob25lICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY29sb3JTcGFjZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgIT09IDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZywgY2FudmFzT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Qm9yZGVyKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgc291cmNlQm90dG9tUGFuZVZpZXdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3VGlja01hcmtzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgc291cmNlUGFuZVZpZXdzKTtcbiAgICAgICAgICAgICAgICAvLyBhdG0gd2UgZG9uJ3QgaGF2ZSBzb3VyY2VzIHRvIGJlIGRyYXduIG9uIHRpbWUgYXhpcyBleGNlcHQgY3Jvc3NoYWlyIHdoaWNoIGlzIHJlbmRlcmVkIG9uIHRvcCBsZXZlbCBjYW52YXNcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBkb24ndCBjYWxsIHRoaXMgY29kZSBhdCBhbGwgZm9yIG5vd1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2RyYXdMYWJlbHModGhpcy5fY2hhcnQubW9kZWwoKS5kYXRhU291cmNlcygpLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIuX2ludGVybmFsX3BhaW50KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1Yi5faW50ZXJuYWxfcGFpbnQodHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgY29uc3QgdG9wVGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZywgY2FudmFzT3B0aW9ucyk7XG4gICAgICAgIGlmICh0b3BUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcFRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0xhYmVscyhbLi4udGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3Nlcmllc2VzKCksIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKV0sIHRvcFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QWRkaXRpb25hbFNvdXJjZXModG9wVGFyZ2V0LCBzb3VyY2VUb3BQYW5lVmlld3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QWRkaXRpb25hbFNvdXJjZXModGFyZ2V0LCBheGlzVmlld3NHZXR0ZXIpIHtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXJpZXNlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBkcmF3U291cmNlVmlld3MoYXhpc1ZpZXdzR2V0dGVyLCAocmVuZGVyZXIpID0+IGRyYXdCYWNrZ3JvdW5kKHJlbmRlcmVyLCB0YXJnZXQsIGZhbHNlLCB1bmRlZmluZWQpLCBzb3VyY2UsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgZHJhd1NvdXJjZVZpZXdzKGF4aXNWaWV3c0dldHRlciwgKHJlbmRlcmVyKSA9PiBkcmF3Rm9yZWdyb3VuZChyZW5kZXJlciwgdGFyZ2V0LCBmYWxzZSwgdW5kZWZpbmVkKSwgc291cmNlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0LCB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcih7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkudGltZVNjYWxlLmJvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19saW5lQ29sb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpLl9pbnRlcm5hbF9ib3JkZXJTaXplICogdmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgYml0bWFwU2l6ZS53aWR0aCwgYm9yZGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdUaWNrTWFya3ModGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3QgdGlja01hcmtzID0gdGltZVNjYWxlLl9pbnRlcm5hbF9tYXJrcygpO1xuICAgICAgICBpZiAoIXRpY2tNYXJrcyB8fCB0aWNrTWFya3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4V2VpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IubWF4VGlja01hcmtXZWlnaHQodGlja01hcmtzKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fZ2V0UmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyVmlzaWJsZSAmJiBvcHRpb25zLnRpY2tzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2xpbmVDb2xvcigpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19saW5lQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8gKiAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTGVuID0gTWF0aC5yb3VuZChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gdGlja01hcmtzLmxlbmd0aDsgaW5kZXgtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodGlja01hcmtzW2luZGV4XS5jb29yZCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCAtIHRpY2tPZmZzZXQsIDAsIHRpY2tXaWR0aCwgdGlja0xlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHlUZXh0ID0gKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgLyAyKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX190ZXh0Q29sb3IoKTtcbiAgICAgICAgICAgIC8vIGRyYXcgYmFzZSBtYXJrc1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0aWNrTWFyayBvZiB0aWNrTWFya3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlja01hcmsud2VpZ2h0IDwgbWF4V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aWNrTWFyay5uZWVkQWxpZ25Db29yZGluYXRlID8gdGhpcy5fcHJpdmF0ZV9fYWxpZ25UaWNrTWFya0xhYmVsQ29vcmRpbmF0ZShjdHgsIHRpY2tNYXJrLmNvb3JkLCB0aWNrTWFyay5sYWJlbCkgOiB0aWNrTWFyay5jb29yZDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2tNYXJrLmxhYmVsLCBjb29yZGluYXRlLCB5VGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkudGltZVNjYWxlLmFsbG93Qm9sZExhYmVscykge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5fcHJpdmF0ZV9fYmFzZUJvbGRGb250KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRpY2tNYXJrIG9mIHRpY2tNYXJrcykge1xuICAgICAgICAgICAgICAgIGlmICh0aWNrTWFyay53ZWlnaHQgPj0gbWF4V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aWNrTWFyay5uZWVkQWxpZ25Db29yZGluYXRlID8gdGhpcy5fcHJpdmF0ZV9fYWxpZ25UaWNrTWFya0xhYmVsQ29vcmRpbmF0ZShjdHgsIHRpY2tNYXJrLmNvb3JkLCB0aWNrTWFyay5sYWJlbCkgOiB0aWNrTWFyay5jb29yZDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2tNYXJrLmxhYmVsLCBjb29yZGluYXRlLCB5VGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FsaWduVGlja01hcmtMYWJlbENvb3JkaW5hdGUoY3R4LCBjb29yZGluYXRlLCBsYWJlbFRleHQpIHtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgbGFiZWxUZXh0KTtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aEhhbGYgPSBsYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgbGVmdFRleHRDb29yZGluYXRlID0gTWF0aC5mbG9vcihjb29yZGluYXRlIC0gbGFiZWxXaWR0aEhhbGYpICsgMC41O1xuICAgICAgICBpZiAobGVmdFRleHRDb29yZGluYXRlIDwgMCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgKyBNYXRoLmFicygwIC0gbGVmdFRleHRDb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0VGV4dENvb3JkaW5hdGUgKyBsYWJlbFdpZHRoID4gdGhpcy5fcHJpdmF0ZV9fc2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgLSBNYXRoLmFicyh0aGlzLl9wcml2YXRlX19zaXplLndpZHRoIC0gKGxlZnRUZXh0Q29vcmRpbmF0ZSArIGxhYmVsV2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdMYWJlbHMoc291cmNlcywgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc291cmNlLl9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkpIHtcbiAgICAgICAgICAgICAgICB2aWV3Ll9pbnRlcm5hbF9yZW5kZXJlcigpLl9pbnRlcm5hbF9kcmF3KHRhcmdldCwgcmVuZGVyZXJPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbGluZUNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS50aW1lU2NhbGUuYm9yZGVyQ29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX190ZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRleHRDb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5mb250U2l6ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Jhc2VGb250KCkge1xuICAgICAgICByZXR1cm4gbWFrZUZvbnQodGhpcy5fcHJpdmF0ZV9fZm9udFNpemUoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5mb250RmFtaWx5KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Jhc2VCb2xkRm9udCgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGb250KHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplKCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZm9udEZhbWlseSwgJ2JvbGQnKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJTaXplOiAxIC8qIENvbnN0YW50cy5Cb3JkZXJTaXplICovLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlbGluZU9mZnNldDogTmFOLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nVG9wOiBOYU4sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdCb3R0b206IE5hTixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ0hvcml6b250YWw6IE5hTixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGlja0xlbmd0aDogNSAvKiBDb25zdGFudHMuVGlja0xlbmd0aCAqLyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZm9udFNpemU6IE5hTixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZm9udDogJycsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3dpZHRoQ2FjaGU6IG5ldyBUZXh0V2lkdGhDYWNoZSgpLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sYWJlbEJvdHRvbU9mZnNldDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBuZXdGb250ID0gdGhpcy5fcHJpdmF0ZV9fYmFzZUZvbnQoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udCAhPT0gbmV3Rm9udCkge1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9wcml2YXRlX19mb250U2l6ZSgpO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250ID0gbmV3Rm9udDtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcCA9IDMgKiBmb250U2l6ZSAvIDEyO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nQm90dG9tID0gMyAqIGZvbnRTaXplIC8gMTI7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdIb3Jpem9udGFsID0gOSAqIGZvbnRTaXplIC8gMTI7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2Jhc2VsaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfbGFiZWxCb3R0b21PZmZzZXQgPSA0ICogZm9udFNpemUgLyAxMjtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfd2lkdGhDYWNoZS5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0Q3Vyc29yKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5jdXJzb3IgPSB0eXBlID09PSAxIC8qIEN1cnNvclR5cGUuRXdSZXNpemUgKi8gPyAnZXctcmVzaXplJyA6ICdkZWZhdWx0JztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY3JlYXRlU3R1YnMoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVmdFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWJDZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMucmlnaHRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWJDZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1Yi5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1Yi5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnNQcm92aWRlciA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnNQcm92aWRlcigpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zUHJvdmlkZXI6IHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib3JkZXJWaXNpYmxlR2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGVmdFByaWNlU2NhbGUuYm9yZGVyVmlzaWJsZSAmJiBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnMoKS5ib3JkZXJWaXNpYmxlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib3R0b21Db2xvckdldHRlciA9ICgpID0+IG1vZGVsLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQm90dG9tQ29sb3IoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgPSBuZXcgUHJpY2VBeGlzU3R1YignbGVmdCcsIG9wdGlvbnMsIHBhcmFtcywgYm9yZGVyVmlzaWJsZUdldHRlciwgYm90dG9tQ29sb3JHZXR0ZXIpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWJDZWxsLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViID0gbmV3IFByaWNlQXhpc1N0dWIoJ3JpZ2h0Jywgb3B0aW9ucywgcGFyYW1zLCBib3JkZXJWaXNpYmxlR2V0dGVyLCBib3R0b21Db2xvckdldHRlcik7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWJDZWxsLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1Yi5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3Qgd2luZG93c0Nocm9tZSA9IGlzQ2hyb21pdW1CYXNlZCgpICYmIGlzV2luZG93cygpO1xuY2xhc3MgQ2hhcnRXaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1JhZklkID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UGxhbm5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jdXJzb3JTdHlsZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3R2LWxpZ2h0d2VpZ2h0LWNoYXJ0cycpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuc3R5bGUuZGlyZWN0aW9uID0gJ2x0cic7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdjZWxsc3BhY2luZycsICcwJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25XaGVlbEJvdW5kID0gdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZXdoZWVsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRNb3VzZVdoZWVsRXZlbnRMaXN0ZW5lcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG5ldyBDaGFydE1vZGVsKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVIYW5kbGVyLmJpbmQodGhpcyksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIGhvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uUGFuZVdpZGdldENyb3NzaGFpck1vdmVkLmJpbmQodGhpcyksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldCA9IG5ldyBUaW1lQXhpc1dpZGdldCh0aGlzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgY29uc3QgdXNlZE9ic2VydmVyID0gb3B0aW9ucy5hdXRvU2l6ZSAmJiB0aGlzLl9wcml2YXRlX19pbnN0YWxsT2JzZXJ2ZXIoKTtcbiAgICAgICAgLy8gb2JzZXJ2ZXIgY291bGQgbm90IGZpcmUgZXZlbnQgaW1tZWRpYXRlbHkgZm9yIHNvbWUgY2FzZXNcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBzZXQgaW5pdGlhbCBzaXplIG1hbnVhbGx5XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMud2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmhlaWdodDtcbiAgICAgICAgLy8gaWdub3JlIHdpZHRoL2hlaWdodCBvcHRpb25zIGlmIG9ic2VydmVyIGhhcyBhY3R1YWxseSBiZWVuIHVzZWRcbiAgICAgICAgLy8gaG93ZXZlciByZXNwZWN0IG9wdGlvbnMgaWYgaW5zdGFsbGluZyByZXNpemUgb2JzZXJ2ZXIgZmFpbGVkXG4gICAgICAgIGlmICh1c2VkT2JzZXJ2ZXIgfHwgd2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEJFV0FSRTogcmVzaXplIG11c3QgYmUgY2FsbGVkIEJFRk9SRSBfc3luY0d1aVdpdGhNb2RlbCAoaW4gY29uc3RydWN0b3Igb25seSlcbiAgICAgICAgLy8gb3IgYWZ0ZXIgYnV0IHdpdGggYWRqdXN0U2l6ZSB0byBwcm9wZXJseSB1cGRhdGUgdGltZSBzY2FsZVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N5bmNHdWlXaXRoTW9kZWwoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2Z1bGxVcGRhdGUuYmluZCh0aGlzLl9wcml2YXRlX19tb2RlbCksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcHJpY2VTY2FsZXNPcHRpb25zQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2Z1bGxVcGRhdGUuYmluZCh0aGlzLl9wcml2YXRlX19tb2RlbCksIHRoaXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVdpZGdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cztcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzV2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRNb3VzZVdoZWVsRXZlbnRMaXN0ZW5lcihmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kcmF3UmFmSWQgIT09IDApIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9wcml2YXRlX19kcmF3UmFmSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFuZVdpZGdldCBvZiB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50LnJlbW92ZUNoaWxkKHBhbmVXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9jbGlja2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfZGJsQ2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhbmVTZXBhcmF0b3Igb2YgdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Rlc3Ryb3lTZXBhcmF0b3IocGFuZVNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMgPSBbXTtcbiAgICAgICAgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldCkuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlcigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzaXplKHdpZHRoLCBoZWlnaHQsIGZvcmNlUmVwYWludCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oZWlnaHQgPT09IGhlaWdodCAmJiB0aGlzLl9wcml2YXRlX193aWR0aCA9PT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplSGludCA9IHN1Z2dlc3RDaGFydFNpemUoc2l6ZSQxKHsgd2lkdGgsIGhlaWdodCB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IHNpemVIaW50LmhlaWdodDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSBzaXplSGludC53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0U3RyID0gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgY29uc3Qgd2lkdGhTdHIgPSB0aGlzLl9wcml2YXRlX193aWR0aCArICdweCc7XG4gICAgICAgIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCkuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0U3RyO1xuICAgICAgICBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpLnN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoU3RyO1xuICAgICAgICBpZiAoZm9yY2VSZXBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3SW1wbChJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpLCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzaykge1xuICAgICAgICBpZiAoaW52YWxpZGF0ZU1hc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZU1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW2ldLl9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUoaSkuX2ludGVybmFsX2xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3BhaW50KGludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9mdWxsSW52YWxpZGF0aW9uKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIgPSBzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpO1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIG1lcmdlIG9wdGlvbnMgaGVyZSBiZWNhdXNlIGl0J3MgZG9uZSBpbiBjaGFydCBtb2RlbFxuICAgICAgICAvLyBhbmQgc2luY2UgYm90aCBtb2RlbCBhbmQgd2lkZ2V0IHNoYXJlIHRoZSBzYW1lIG9iamVjdCBpdCB3aWxsIGJlIGRvbmUgYXV0b21hdGljYWxseSBmb3Igd2lkZ2V0IGFzIHdlbGxcbiAgICAgICAgLy8gbm90IGlkZWFsIHNvbHV0aW9uIGZvciBzdXJlLCBidXQgaXQgd29yaydzIGZvciBub3cgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkSGF2ZU1vdXNlV2hlZWxMaXN0ZW5lciA9IHNob3VsZFN1YnNjcmliZU1vdXNlV2hlZWwodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyk7XG4gICAgICAgIGlmIChzaG91bGRIYXZlTW91c2VXaGVlbExpc3RlbmVyICE9PSBjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldE1vdXNlV2hlZWxFdmVudExpc3RlbmVyKHNob3VsZEhhdmVNb3VzZVdoZWVsTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zWydsYXlvdXQnXT8ucGFuZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5UGFuZXNPcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlVGltZUF4aXNWaXNpYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5QXV0b1NpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYmxDbGlja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90YWtlU2NyZWVuc2hvdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3SW1wbCh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaywgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcmVlc2hvdEJpdG1hcFNpemUgPSB0aGlzLl9wcml2YXRlX190cmF2ZXJzZUxheW91dChudWxsKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuc2hvdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBzY3JlZW5zaG90Q2FudmFzLndpZHRoID0gc2NyZWVzaG90Qml0bWFwU2l6ZS53aWR0aDtcbiAgICAgICAgc2NyZWVuc2hvdENhbnZhcy5oZWlnaHQgPSBzY3JlZXNob3RCaXRtYXBTaXplLmhlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gZW5zdXJlTm90TnVsbChzY3JlZW5zaG90Q2FudmFzLmdldENvbnRleHQoJzJkJykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190cmF2ZXJzZUxheW91dChjdHgpO1xuICAgICAgICByZXR1cm4gc2NyZWVuc2hvdENhbnZhcztcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFByaWNlQXhpc1dpZHRoKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovICYmICF0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovICYmICF0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBleGFjdGx5IHBhbmUgd2lkZ2V0IGhlcmVcbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgcGFuZSB3aWRnZXRzIGhhdmUgdGhlIHNhbWUgd2lkdGggb2YgcHJpY2UgYXhpcyB3aWRnZXRcbiAgICAgICAgLy8gc2VlIF9hZGp1c3RTaXplSW1wbFxuICAgICAgICBjb25zdCBwcmljZUF4aXNXaWRnZXQgPSBwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovXG4gICAgICAgICAgICA/IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KClcbiAgICAgICAgICAgIDogdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbMF0uX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0KCk7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHByaWNlQXhpc1dpZGdldCkuX2ludGVybmFsX2dldFdpZHRoKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hdXRvU2l6ZUFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NpemUgJiYgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgIT09IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEN1cnNvclN0eWxlKHN0eWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUgPSBzdHlsZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2VsZW1lbnQoKS5zdHlsZS5zZXRQcm9wZXJ0eSgnY3Vyc29yJywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfZWxlbWVudCgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjdXJzb3InKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Q3Vyc29yT3ZlcnJpZGVTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2N1cnNvclN0eWxlT3ZlcnJpZGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lU2l6ZShwYW5lSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbcGFuZUluZGV4XSkuX2ludGVybmFsX2dldFNpemUoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5UGFuZXNPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lU2VwYXJhdG9ycy5mb3JFYWNoKChzZXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgIHNlcGFyYXRvci5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9wcml2YXRlX19hcHBseUF1dG9TaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TaXplID09PSB1bmRlZmluZWQgJiYgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgJiYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgd2FybihgWW91IHNob3VsZCB0dXJuIGF1dG9TaXplIG9mZiBleHBsaWNpdGx5IGJlZm9yZSBzcGVjaWZ5aW5nIHNpemVzOyB0cnkgYWRkaW5nIG9wdGlvbnMuYXV0b1NpemU6IGZhbHNlIHRvIG5ldyBvcHRpb25zYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b1NpemUgJiYgIXRoaXMuX3ByaXZhdGVfX29ic2VydmVyKSB7XG4gICAgICAgICAgICAvLyBpbnN0YWxsaW5nIG9ic2VydmVyIHdpbGwgb3ZlcnJpZGUgcmVzaXplIGlmIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2luc3RhbGxPYnNlcnZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TaXplID09PSBmYWxzZSAmJiB0aGlzLl9wcml2YXRlX19vYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pbnN0YWxsT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuYXV0b1NpemUgJiYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzaXplKG9wdGlvbnMud2lkdGggfHwgdGhpcy5fcHJpdmF0ZV9fd2lkdGgsIG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuX3ByaXZhdGVfX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB3aWRnZXQncyBsYXlvdXQgKHBhbmUgYW5kIGF4aXMgY2hpbGQgd2lkZ2V0cyksXG4gICAgICogZHJhd3MgdGhlIHNjcmVlbnNob3QgKGlmIHJlbmRlcmluZyBjb250ZXh0IGlzIHBhc3NlZCkgYW5kIHJldHVybnMgdGhlIHNjcmVlbnNob3QgYml0bWFwIHNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdHggLSBpZiBwYXNzZWQsIHVzZWQgdG8gZHJhdyB0aGUgc2NyZWVuc2hvdCBvZiB3aWRnZXRcbiAgICAgKiBAcmV0dXJucyBzY3JlZW5zaG90IGJpdG1hcCBzaXplXG4gICAgICovXG4gICAgX3ByaXZhdGVfX3RyYXZlcnNlTGF5b3V0KGN0eCkge1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICAgIGNvbnN0IGZpcnN0UGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdO1xuICAgICAgICBjb25zdCBkcmF3UHJpY2VBeGlzZXMgPSAocG9zaXRpb24sIHRhcmdldFgpID0+IHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRZID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHBhbmVJbmRleCA9IDA7IHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDsgcGFuZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lV2lkZ2V0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbcGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZUF4aXNXaWRnZXQgPSBlbnN1cmVOb3ROdWxsKHBvc2l0aW9uID09PSAnbGVmdCcgPyBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KCkgOiBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9yaWdodFByaWNlQXhpc1dpZGdldCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gcHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0WSArPSBiaXRtYXBTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocGFuZUluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSB0aGlzLl9wcml2YXRlX19wYW5lU2VwYXJhdG9yc1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JCaXRtYXBTaXplID0gc2VwYXJhdG9yLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5faW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHRhcmdldFgsIHRhcmdldFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFkgKz0gc2VwYXJhdG9yQml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkcmF3IGxlZnQgcHJpY2Ugc2NhbGUgaWYgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICBkcmF3UHJpY2VBeGlzZXMoJ2xlZnQnLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRBeGlzQml0bWFwV2lkdGggPSBlbnN1cmVOb3ROdWxsKGZpcnN0UGFuZS5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSBsZWZ0QXhpc0JpdG1hcFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBhbmVJbmRleCA9IDA7IHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDsgcGFuZUluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHBhbmVXaWRnZXQuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gYml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFuZUluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzW3BhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yQml0bWFwU2l6ZSA9IHNlcGFyYXRvci5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLl9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdG90YWxXaWR0aCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodCArPSBzZXBhcmF0b3JCaXRtYXBTaXplLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFBhbmVCaXRtYXBXaWR0aCA9IGZpcnN0UGFuZS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoO1xuICAgICAgICB0b3RhbFdpZHRoICs9IGZpcnN0UGFuZUJpdG1hcFdpZHRoO1xuICAgICAgICAvLyBkcmF3IHJpZ2h0IHByaWNlIHNjYWxlIGlmIGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIGRyYXdQcmljZUF4aXNlcygncmlnaHQnLCB0b3RhbFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0QXhpc0JpdG1hcFdpZHRoID0gZW5zdXJlTm90TnVsbChmaXJzdFBhbmUuX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0KCkpLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkud2lkdGg7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJpZ2h0QXhpc0JpdG1hcFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYXdTdHViID0gKHBvc2l0aW9uLCB0YXJnZXRYLCB0YXJnZXRZKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHViID0gZW5zdXJlTm90TnVsbChwb3NpdGlvbiA9PT0gJ2xlZnQnID8gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2xlZnRTdHViKCkgOiB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfcmlnaHRTdHViKCkpO1xuICAgICAgICAgICAgc3R1Yi5faW50ZXJuYWxfZHJhd0JpdG1hcChlbnN1cmVOb3ROdWxsKGN0eCksIHRhcmdldFgsIHRhcmdldFkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkcmF3IHRpbWUgc2NhbGUgYW5kIHN0dWJzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lQXhpc0JpdG1hcFNpemUgPSB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgaWYgKGN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRYID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNMZWZ0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3U3R1YignbGVmdCcsIHRhcmdldFgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WCA9IGVuc3VyZU5vdE51bGwoZmlyc3RQYW5lLl9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KCkpLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCkud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdGFyZ2V0WCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRhcmdldFggKz0gdGltZUF4aXNCaXRtYXBTaXplLndpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3U3R1YigncmlnaHQnLCB0YXJnZXRYLCB0b3RhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gdGltZUF4aXNCaXRtYXBTaXplLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZSQxKHtcbiAgICAgICAgICAgIHdpZHRoOiB0b3RhbFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0b3RhbEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX2FkanVzdFNpemVJbXBsKCkge1xuICAgICAgICBsZXQgdG90YWxTdHJldGNoID0gMDtcbiAgICAgICAgbGV0IGxlZnRQcmljZUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIGxldCByaWdodFByaWNlQXhpc1dpZHRoID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lV2lkZ2V0IG9mIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNMZWZ0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGxlZnRQcmljZUF4aXNXaWR0aCA9IE1hdGgubWF4KGxlZnRQcmljZUF4aXNXaWR0aCwgZW5zdXJlTm90TnVsbChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KCkpLl9pbnRlcm5hbF9vcHRpbWFsV2lkdGgoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sZWZ0UHJpY2VTY2FsZS5taW5pbXVtV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzUmlnaHRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRQcmljZUF4aXNXaWR0aCA9IE1hdGgubWF4KHJpZ2h0UHJpY2VBeGlzV2lkdGgsIGVuc3VyZU5vdE51bGwocGFuZVdpZGdldC5faW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSkuX2ludGVybmFsX29wdGltYWxXaWR0aCgpLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnJpZ2h0UHJpY2VTY2FsZS5taW5pbXVtV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxTdHJldGNoICs9IHBhbmVXaWRnZXQuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBsZWZ0UHJpY2VBeGlzV2lkdGggPSBzdWdnZXN0UHJpY2VTY2FsZVdpZHRoKGxlZnRQcmljZUF4aXNXaWR0aCk7XG4gICAgICAgIHJpZ2h0UHJpY2VBeGlzV2lkdGggPSBzdWdnZXN0UHJpY2VTY2FsZVdpZHRoKHJpZ2h0UHJpY2VBeGlzV2lkdGgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3ByaXZhdGVfX3dpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9wcml2YXRlX19oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBhbmVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gbGVmdFByaWNlQXhpc1dpZHRoIC0gcmlnaHRQcmljZUF4aXNXaWR0aCwgMCk7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckNvdW50ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JIZWlnaHQgPSAxIC8qIFNlcGFyYXRvckNvbnN0YW50cy5TZXBhcmF0b3JIZWlnaHQgKi87XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvcnNIZWlnaHQgPSBzZXBhcmF0b3JIZWlnaHQgKiBzZXBhcmF0b3JDb3VudDtcbiAgICAgICAgY29uc3QgdGltZUF4aXNWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudmlzaWJsZTtcbiAgICAgICAgbGV0IHRpbWVBeGlzSGVpZ2h0ID0gdGltZUF4aXNWaXNpYmxlID8gTWF0aC5tYXgodGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX29wdGltYWxIZWlnaHQoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUubWluaW11bUhlaWdodCkgOiAwO1xuICAgICAgICB0aW1lQXhpc0hlaWdodCA9IHN1Z2dlc3RUaW1lU2NhbGVIZWlnaHQodGltZUF4aXNIZWlnaHQpO1xuICAgICAgICBjb25zdCBvdGhlcldpZGdldEhlaWdodCA9IHNlcGFyYXRvcnNIZWlnaHQgKyB0aW1lQXhpc0hlaWdodDtcbiAgICAgICAgY29uc3QgdG90YWxQYW5lSGVpZ2h0ID0gaGVpZ2h0IDwgb3RoZXJXaWRnZXRIZWlnaHQgPyAwIDogaGVpZ2h0IC0gb3RoZXJXaWRnZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHN0cmV0Y2hQaXhlbHMgPSB0b3RhbFBhbmVIZWlnaHQgLyB0b3RhbFN0cmV0Y2g7XG4gICAgICAgIGxldCBhY2N1bXVsYXRlZEhlaWdodCA9IDA7XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBmb3IgKGxldCBwYW5lSW5kZXggPSAwOyBwYW5lSW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7ICsrcGFuZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBwYW5lV2lkZ2V0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbcGFuZUluZGV4XTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFN0YXRlKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9wYW5lcygpW3BhbmVJbmRleF0pO1xuICAgICAgICAgICAgbGV0IHBhbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZVBhbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKHBhbmVJbmRleCA9PT0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhbmVIZWlnaHQgPSBNYXRoLmNlaWwoKHRvdGFsUGFuZUhlaWdodCAtIGFjY3VtdWxhdGVkSGVpZ2h0KSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhbmVIZWlnaHQgPSBNYXRoLnJvdW5kKHBhbmVXaWRnZXQuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSAqIHN0cmV0Y2hQaXhlbHMgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYW5lSGVpZ2h0ID0gTWF0aC5tYXgoY2FsY3VsYXRlUGFuZUhlaWdodCwgMik7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZEhlaWdodCArPSBwYW5lSGVpZ2h0O1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfc2V0U2l6ZShzaXplJDEoeyB3aWR0aDogcGFuZVdpZHRoLCBoZWlnaHQ6IHBhbmVIZWlnaHQgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzTGVmdEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zZXRQcmljZUF4aXNTaXplKGxlZnRQcmljZUF4aXNXaWR0aCwgJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFByaWNlQXhpc1NpemUocmlnaHRQcmljZUF4aXNXaWR0aCwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZVdpZGdldC5faW50ZXJuYWxfc3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRQYW5lSGVpZ2h0KHBhbmVXaWRnZXQuX2ludGVybmFsX3N0YXRlKCksIHBhbmVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9zZXRTaXplcyhzaXplJDEoeyB3aWR0aDogdGltZUF4aXNWaXNpYmxlID8gcGFuZVdpZHRoIDogMCwgaGVpZ2h0OiB0aW1lQXhpc0hlaWdodCB9KSwgdGltZUF4aXNWaXNpYmxlID8gbGVmdFByaWNlQXhpc1dpZHRoIDogMCwgdGltZUF4aXNWaXNpYmxlID8gcmlnaHRQcmljZUF4aXNXaWR0aCA6IDApO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0V2lkdGgocGFuZVdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWR0aCAhPT0gbGVmdFByaWNlQXhpc1dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkdGggPSBsZWZ0UHJpY2VBeGlzV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkdGggIT09IHJpZ2h0UHJpY2VBeGlzV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkdGggPSByaWdodFByaWNlQXhpc1dpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRNb3VzZVdoZWVsRXZlbnRMaXN0ZW5lcihhZGQpIHtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3ByaXZhdGVfX29uV2hlZWxCb3VuZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fcHJpdmF0ZV9fb25XaGVlbEJvdW5kKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RldGVybWluZVdoZWVsU3BlZWRBZGp1c3RtZW50KGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9QQUdFOlxuICAgICAgICAgICAgICAgIC8vIG9uZSBzY3JlZW4gYXQgdGltZSBzY3JvbGwgbW9kZVxuICAgICAgICAgICAgICAgIHJldHVybiAxMjA7XG4gICAgICAgICAgICBjYXNlIGV2ZW50LkRPTV9ERUxUQV9MSU5FOlxuICAgICAgICAgICAgICAgIC8vIG9uZSBsaW5lIGF0IHRpbWUgc2Nyb2xsIG1vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aW5kb3dzQ2hyb21lKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaHJvbWl1bSBvbiBXaW5kb3dzIGhhcyBhIGJ1ZyB3aGVyZSB0aGUgc2Nyb2xsIHNwZWVkIGlzbid0IGNvcnJlY3RseVxuICAgICAgICAvLyBhZGp1c3RlZCBmb3IgaGlnaCBkZW5zaXR5IGRpc3BsYXlzLiBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoaXMgc28gdGhhdFxuICAgICAgICAvLyBzY3JvbGwgc3BlZWQgaXMgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLlxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDAxNzM1XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMDczMDhcbiAgICAgICAgcmV0dXJuICgxIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25Nb3VzZXdoZWVsKGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQuZGVsdGFYID09PSAwIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY3JvbGwnXS5tb3VzZVdoZWVsKSAmJlxuICAgICAgICAgICAgKGV2ZW50LmRlbHRhWSA9PT0gMCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5tb3VzZVdoZWVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbFNwZWVkQWRqdXN0bWVudCA9IHRoaXMuX3ByaXZhdGVfX2RldGVybWluZVdoZWVsU3BlZWRBZGp1c3RtZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gc2Nyb2xsU3BlZWRBZGp1c3RtZW50ICogZXZlbnQuZGVsdGFYIC8gMTAwO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSAtKHNjcm9sbFNwZWVkQWRqdXN0bWVudCAqIGV2ZW50LmRlbHRhWSAvIDEwMCk7XG4gICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YVkgIT09IDAgJiYgdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5tb3VzZVdoZWVsKSB7XG4gICAgICAgICAgICBjb25zdCB6b29tU2NhbGUgPSBNYXRoLnNpZ24oZGVsdGFZKSAqIE1hdGgubWluKDEsIE1hdGguYWJzKGRlbHRhWSkpO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBldmVudC5jbGllbnRYIC0gdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfem9vbVRpbWUoc2Nyb2xsUG9zaXRpb24sIHpvb21TY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhWCAhPT0gMCAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY3JvbGwnXS5tb3VzZVdoZWVsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zY3JvbGxDaGFydChkZWx0YVggKiAtODApOyAvLyA4MCBpcyBhIG1hZGUgdXAgY29lZmZpY2llbnQsIGFuZCBtaW51cyBpcyBmb3IgdGhlIFwibmF0dXJhbFwiIHNjcm9sbFxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3SW1wbChpbnZhbGlkYXRlTWFzaywgdGltZSkge1xuICAgICAgICBjb25zdCBpbnZhbGlkYXRpb25UeXBlID0gaW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2Z1bGxJbnZhbGlkYXRpb24oKTtcbiAgICAgICAgLy8gYWN0aW9ucyBmb3IgZnVsbCBpbnZhbGlkYXRpb24gT05MWSAobm90IHNoYXJlZCB3aXRoIGxpZ2h0KVxuICAgICAgICBpZiAoaW52YWxpZGF0aW9uVHlwZSA9PT0gMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVHdWkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaWdodCBvciBmdWxsIGludmFsaWRhdGUgYWN0aW9uc1xuICAgICAgICBpZiAoaW52YWxpZGF0aW9uVHlwZSA9PT0gMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovIHx8XG4gICAgICAgICAgICBpbnZhbGlkYXRpb25UeXBlID09PSAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseU1vbWVudGFyeUF1dG9TY2FsZShpbnZhbGlkYXRlTWFzayk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbnMoaW52YWxpZGF0ZU1hc2ssIHRpbWUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMuZm9yRWFjaCgocGFuZSkgPT4ge1xuICAgICAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2UgYSBmdWxsIGludmFsaWRhdGlvbiBoYXMgYmVlbiBwb3N0cG9uZWQgZHVyaW5nIHRoZSBkcmF3LCByZWFwcGx5XG4gICAgICAgICAgICAvLyB0aGUgdGltZXNjYWxlIGludmFsaWRhdGlvbnMuIEEgZnVsbCBpbnZhbGlkYXRpb24gd291bGQgbWVhbiB0aGVyZSBpcyBhIGNoYW5nZVxuICAgICAgICAgICAgLy8gaW4gdGhlIHRpbWVzY2FsZSB3aWR0aCAoY2F1c2VkIGJ5IHByaWNlIHNjYWxlIGNoYW5nZXMpIHRoYXQgbmVlZHMgdG8gYmUgZHJhd25cbiAgICAgICAgICAgIC8vIHJpZ2h0IGF3YXkgdG8gYXZvaWQgZmxpY2tlcmluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaz8uX2ludGVybmFsX2Z1bGxJbnZhbGlkYXRpb24oKSA9PT0gMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2suX2ludGVybmFsX21lcmdlKGludmFsaWRhdGVNYXNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVHdWkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseU1vbWVudGFyeUF1dG9TY2FsZSh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb25zKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrLCB0aW1lKTtcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlTWFzayA9IHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzayk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbnMoaW52YWxpZGF0ZU1hc2ssIHRpbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCB0c0ludmFsaWRhdGlvbiBvZiBpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfdGltZVNjYWxlSW52YWxpZGF0aW9ucygpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbih0c0ludmFsaWRhdGlvbiwgdGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5TW9tZW50YXJ5QXV0b1NjYWxlKGludmFsaWRhdGVNYXNrKSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3BhbmVzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUoaSkuX2ludGVybmFsX2F1dG9TY2FsZSkge1xuICAgICAgICAgICAgICAgIHBhbmVzW2ldLl9pbnRlcm5hbF9tb21lbnRhcnlBdXRvU2NhbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb24oaW52YWxpZGF0aW9uLCB0aW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgc3dpdGNoIChpbnZhbGlkYXRpb24uX2ludGVybmFsX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkZpdENvbnRlbnQgKi86XG4gICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9maXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJhbmdlICovOlxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfc2V0TG9naWNhbFJhbmdlKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlCYXJTcGFjaW5nICovOlxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyhpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5UmlnaHRPZmZzZXQgKi86XG4gICAgICAgICAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNCAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLlJlc2V0ICovOlxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfcmVzdG9yZURlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFuaW1hdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUuX2ludGVybmFsX2ZpbmlzaGVkKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZS5faW50ZXJuYWxfZ2V0UG9zaXRpb24odGltZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIoaW52YWxpZGF0ZU1hc2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbWVyZ2UoaW52YWxpZGF0ZU1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgPSBpbnZhbGlkYXRlTWFzaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2RyYXdQbGFubmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UGxhbm5lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1BsYW5uZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3UmFmSWQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2s7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0ltcGwobWFzaywgdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHNJbnZhbGlkYXRpb24gb2YgbWFzay5faW50ZXJuYWxfdGltZVNjYWxlSW52YWxpZGF0aW9ucygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHNJbnZhbGlkYXRpb24uX2ludGVybmFsX3R5cGUgPT09IDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi8gJiYgIXRzSW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZS5faW50ZXJuYWxfZmluaXNoZWQodGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVBbmltYXRpb24odHNJbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVHdWkoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N5bmNHdWlXaXRoTW9kZWwoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Rlc3Ryb3lTZXBhcmF0b3Ioc2VwYXJhdG9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5yZW1vdmVDaGlsZChzZXBhcmF0b3IuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIHNlcGFyYXRvci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc3luY0d1aVdpdGhNb2RlbCgpIHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcGFuZXMoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFuZVdpZGdldHNDb3VudCA9IHBhbmVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYWN0dWFsUGFuZVdpZGdldHNDb3VudCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDtcbiAgICAgICAgLy8gUmVtb3ZlIChpZiBuZWVkZWQpIHBhbmUgd2lkZ2V0cyBhbmQgc2VwYXJhdG9yc1xuICAgICAgICBmb3IgKGxldCBpID0gdGFyZ2V0UGFuZVdpZGdldHNDb3VudDsgaSA8IGFjdHVhbFBhbmVXaWRnZXRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFuZVdpZGdldCA9IGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMucG9wKCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50LnJlbW92ZUNoaWxkKHBhbmVXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9jbGlja2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfZGJsQ2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVTZXBhcmF0b3IgPSB0aGlzLl9wcml2YXRlX19wYW5lU2VwYXJhdG9ycy5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwYW5lU2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kZXN0cm95U2VwYXJhdG9yKHBhbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSAoaWYgbmVlZGVkKSBuZXcgcGFuZSB3aWRnZXRzIGFuZCBzZXBhcmF0b3JzXG4gICAgICAgIGZvciAobGV0IGkgPSBhY3R1YWxQYW5lV2lkZ2V0c0NvdW50OyBpIDwgdGFyZ2V0UGFuZVdpZGdldHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYW5lV2lkZ2V0ID0gbmV3IFBhbmVXaWRnZXQodGhpcywgcGFuZXNbaV0pO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QYW5lV2lkZ2V0Q2xpY2tlZC5iaW5kKHRoaXMsIHBhbmVXaWRnZXQpLCB0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uUGFuZVdpZGdldERibENsaWNrZWQuYmluZCh0aGlzLCBwYW5lV2lkZ2V0KSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5wdXNoKHBhbmVXaWRnZXQpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuZCBpbnNlcnQgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lU2VwYXJhdG9yID0gbmV3IFBhbmVTZXBhcmF0b3IodGhpcywgaSAtIDEsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzLnB1c2gocGFuZVNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50Lmluc2VydEJlZm9yZShwYW5lU2VwYXJhdG9yLl9pbnRlcm5hbF9nZXRFbGVtZW50KCksIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5zZXJ0IHBhbmVXaWRnZXRcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5pbnNlcnRCZWZvcmUocGFuZVdpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpLCB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldFBhbmVXaWRnZXRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBwYW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zdGF0ZSgpICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWRqdXN0U2l6ZUltcGwoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE1vdXNlRXZlbnRQYXJhbXNJbXBsKGluZGV4LCBwb2ludCwgZXZlbnQsIHBhbmUpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzRGF0YSA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXJpZXNlcygpO1xuICAgICAgICAgICAgc2VyaWVzZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBzZWFyY2ggbGVmdFxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3NlYXJjaChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzRGF0YS5zZXQocywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsaWVudFRpbWU7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGltZVBvaW50ID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pbmRleFRvVGltZVNjYWxlUG9pbnQoaW5kZXgpPy5vcmlnaW5hbFRpbWU7XG4gICAgICAgICAgICBpZiAodGltZVBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRUaW1lID0gdGltZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyZWRTb3VyY2UgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9ob3ZlcmVkU291cmNlKCk7XG4gICAgICAgIGNvbnN0IGhvdmVyZWRTZXJpZXMgPSBob3ZlcmVkU291cmNlICE9PSBudWxsICYmIGhvdmVyZWRTb3VyY2UuX2ludGVybmFsX3NvdXJjZSBpbnN0YW5jZW9mIFNlcmllc1xuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9zb3VyY2VcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBob3ZlcmVkT2JqZWN0ID0gaG92ZXJlZFNvdXJjZSAhPT0gbnVsbCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QuX2ludGVybmFsX2V4dGVybmFsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYW5lSW5kZXggPSB0aGlzLl9wcml2YXRlX19nZXRQYW5lSW5kZXgocGFuZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBjbGllbnRUaW1lLFxuICAgICAgICAgICAgX2ludGVybmFsX2luZGV4OiBpbmRleCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcG9pbnQ6IHBvaW50ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYW5lSW5kZXg6IHBhbmVJbmRleCAhPT0gLTEgPyBwYW5lSW5kZXggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaG92ZXJlZFNlcmllczogaG92ZXJlZFNlcmllcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zZXJpZXNEYXRhOiBzZXJpZXNEYXRhLFxuICAgICAgICAgICAgX2ludGVybmFsX2hvdmVyZWRPYmplY3Q6IGhvdmVyZWRPYmplY3QsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG91Y2hNb3VzZUV2ZW50RGF0YTogZXZlbnQgPz8gdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0UGFuZUluZGV4KHBhbmUpIHtcbiAgICAgICAgbGV0IHBhbmVJbmRleCA9IC0xO1xuICAgICAgICBpZiAocGFuZSkge1xuICAgICAgICAgICAgcGFuZUluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMuaW5kZXhPZihwYW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzaGFpclBhbmUgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKS5faW50ZXJuYWxfcGFuZSgpO1xuICAgICAgICAgICAgaWYgKGNyb3NzaGFpclBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYW5lSW5kZXggPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lcygpLmluZGV4T2YoY3Jvc3NoYWlyUGFuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhbmVJbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uUGFuZVdpZGdldENsaWNrZWQocGFuZSwgdGltZSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQuX2ludGVybmFsX2ZpcmUoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fZ2V0TW91c2VFdmVudFBhcmFtc0ltcGwodGltZSwgcG9pbnQsIGV2ZW50LCBwYW5lKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblBhbmVXaWRnZXREYmxDbGlja2VkKHBhbmUsIHRpbWUsIHBvaW50LCBldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkLl9pbnRlcm5hbF9maXJlKCgpID0+IHRoaXMuX3ByaXZhdGVfX2dldE1vdXNlRXZlbnRQYXJhbXNJbXBsKHRpbWUsIHBvaW50LCBldmVudCwgcGFuZSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25QYW5lV2lkZ2V0Q3Jvc3NoYWlyTW92ZWQodGltZSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldEN1cnNvclN0eWxlKHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2hvdmVyZWRTb3VyY2UoKT8uX2ludGVybmFsX2N1cnNvclN0eWxlID8/IG51bGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZC5faW50ZXJuYWxfZmlyZSgoKSA9PiB0aGlzLl9wcml2YXRlX19nZXRNb3VzZUV2ZW50UGFyYW1zSW1wbCh0aW1lLCBwb2ludCwgZXZlbnQpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZVRpbWVBeGlzVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2lzTGVmdEF4aXNWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbMF0uX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX2xlZnRQcmljZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnMoKS52aXNpYmxlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbMF0uX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkudmlzaWJsZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2luc3RhbGxPYnNlcnZlcigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICghKCdSZXNpemVPYnNlcnZlcicgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgd2FybignT3B0aW9ucyBjb250YWlucyBcImF1dG9TaXplXCIgZmxhZywgYnV0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgUmVzaXplT2JzZXJ2ZXIgZmVhdHVyZS4gUGxlYXNlIHByb3ZpZGUgcG9seWZpbGwuJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgaWYgZW50cnkudGFyZ2V0ID09PSB0aGlzLl9jb250YWluZXIgc2luY2UgdGhlcmUgaXMgb25seVxuICAgICAgICAgICAgICAgIC8vIGEgc2luZ2xlIGVsZW1lbnQgYmVpbmcgb2JzZXJ2ZWQuXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlIHdhbnQgdG8gdXNlIHRoZSBsYXN0IGVudHJ5IChpZiBtdWx0aXBsZSkgYmVjYXVzZSBpdCB3b3VsZCBiZSBtb3N0IHVwIHRvIGRhdGVcbiAgICAgICAgICAgICAgICAvLyAoc2luY2UgdGhlIGJyb3dzZXIgbWF5IGJhdGNoIG11bHRpcGxlIHVwZGF0ZXMpLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckVudHJ5ID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtYXkgYmUgdW5kZWZpbmVkIGlmIHRoZSBlbnRyaWVzIGFycmF5IHdhcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXNpemUoY29udGFpbmVyRW50cnkuY29udGVudFJlY3Qud2lkdGgsIGNvbnRhaW5lckVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyLm9ic2VydmUodGhpcy5fcHJpdmF0ZV9fY29udGFpbmVyLCB7IGJveDogJ2JvcmRlci1ib3gnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3VuaW5zdGFsbE9ic2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlciA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzYWJsZVNlbGVjdGlvbihlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICBlbGVtZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9ICdub25lJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICBlbGVtZW50LnN0eWxlLk1velVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUYXBIaWdobGlnaHRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG59XG5mdW5jdGlvbiBzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zWydoYW5kbGVTY3JvbGwnXS5tb3VzZVdoZWVsIHx8IG9wdGlvbnNbJ2hhbmRsZVNjYWxlJ10ubW91c2VXaGVlbCk7XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZURhdGEoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLm9wZW4gPT09IHVuZGVmaW5lZCAmJiBkYXRhLnZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZERhdGEoZGF0YSkge1xuICAgIHJldHVybiBpc0Z1bGZpbGxlZEJhckRhdGEoZGF0YSkgfHwgaXNGdWxmaWxsZWRMaW5lRGF0YShkYXRhKTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkQmFyRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEub3BlbiAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWRMaW5lRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEudmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JlZExpbmVCYXNlZFNlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHZhbCA9IGl0ZW0udmFsdWU7XG4gICAgY29uc3QgcmVzID0geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiBbdmFsLCB2YWwsIHZhbCwgdmFsXSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH07XG4gICAgaWYgKGl0ZW0uY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2NvbG9yID0gaXRlbS5jb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEFyZWFTZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUpIHtcbiAgICBjb25zdCB2YWwgPSBpdGVtLnZhbHVlO1xuICAgIGNvbnN0IHJlcyA9IHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogW3ZhbCwgdmFsLCB2YWwsIHZhbF0sIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9O1xuICAgIGlmIChpdGVtLmxpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfbGluZUNvbG9yID0gaXRlbS5saW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLnRvcENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF90b3BDb2xvciA9IGl0ZW0udG9wQ29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLmJvdHRvbUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9ib3R0b21Db2xvciA9IGl0ZW0uYm90dG9tQ29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRCYXNlbGluZVNlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHZhbCA9IGl0ZW0udmFsdWU7XG4gICAgY29uc3QgcmVzID0geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiBbdmFsLCB2YWwsIHZhbCwgdmFsXSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH07XG4gICAgaWYgKGl0ZW0udG9wTGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IgPSBpdGVtLnRvcExpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uYm90dG9tTGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IgPSBpdGVtLmJvdHRvbUxpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKGl0ZW0udG9wRmlsbENvbG9yMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSA9IGl0ZW0udG9wRmlsbENvbG9yMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0udG9wRmlsbENvbG9yMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMiA9IGl0ZW0udG9wRmlsbENvbG9yMjtcbiAgICB9XG4gICAgaWYgKGl0ZW0uYm90dG9tRmlsbENvbG9yMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMSA9IGl0ZW0uYm90dG9tRmlsbENvbG9yMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0uYm90dG9tRmlsbENvbG9yMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMiA9IGl0ZW0uYm90dG9tRmlsbENvbG9yMjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEJhclNlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHJlcyA9IHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogW2l0ZW0ub3BlbiwgaXRlbS5oaWdoLCBpdGVtLmxvdywgaXRlbS5jbG9zZV0sIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9O1xuICAgIGlmIChpdGVtLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9jb2xvciA9IGl0ZW0uY29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRDYW5kbGVzdGlja1Nlcmllc1Bsb3RSb3codGltZSwgaW5kZXgsIGl0ZW0sIG9yaWdpbmFsVGltZSkge1xuICAgIGNvbnN0IHJlcyA9IHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogW2l0ZW0ub3BlbiwgaXRlbS5oaWdoLCBpdGVtLmxvdywgaXRlbS5jbG9zZV0sIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9O1xuICAgIGlmIChpdGVtLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9jb2xvciA9IGl0ZW0uY29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLmJvcmRlckNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA9IGl0ZW0uYm9yZGVyQ29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLndpY2tDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfd2lja0NvbG9yID0gaXRlbS53aWNrQ29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRDdXN0b21TZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUsIGRhdGFUb1Bsb3RSb3cpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBlbnN1cmVEZWZpbmVkKGRhdGFUb1Bsb3RSb3cpKGl0ZW0pO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oLi4udmFsdWVzKTtcbiAgICBjb25zdCBsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCB2YWx1ZSA9IFtsYXN0LCBtYXgsIG1pbiwgbGFzdF07XG4gICAgY29uc3QgeyB0aW1lOiBleGNsdWRlZFRpbWUsIGNvbG9yLCAuLi5kYXRhIH0gPSBpdGVtO1xuICAgIHJldHVybiB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IHZhbHVlLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUsIF9pbnRlcm5hbF9kYXRhOiBkYXRhLCBfaW50ZXJuYWxfY29sb3I6IGNvbG9yIH07XG59XG5mdW5jdGlvbiBpc1Nlcmllc1Bsb3RSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5faW50ZXJuYWxfdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHdyYXBDdXN0b21WYWx1ZXMocGxvdFJvdywgYmFyKSB7XG4gICAgaWYgKGJhci5jdXN0b21WYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwbG90Um93Ll9pbnRlcm5hbF9jdXN0b21WYWx1ZXMgPSBiYXIuY3VzdG9tVmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gcGxvdFJvdztcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZURhdGFXaXRoQ3VzdG9tQ2hlY2soYmFyLCBjdXN0b21Jc1doaXRlc3BhY2UpIHtcbiAgICBpZiAoY3VzdG9tSXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBjdXN0b21Jc1doaXRlc3BhY2UoYmFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV2hpdGVzcGFjZURhdGEoYmFyKTtcbn1cbmZ1bmN0aW9uIHdyYXBXaGl0ZXNwYWNlRGF0YShjcmVhdGVQbG90Um93Rm4pIHtcbiAgICByZXR1cm4gKHRpbWUsIGluZGV4LCBiYXIsIG9yaWdpbmFsVGltZSwgZGF0YVRvUGxvdFJvdywgY3VzdG9tSXNXaGl0ZXNwYWNlKSA9PiB7XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2VEYXRhV2l0aEN1c3RvbUNoZWNrKGJhciwgY3VzdG9tSXNXaGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBDdXN0b21WYWx1ZXMoeyBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lIH0sIGJhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBDdXN0b21WYWx1ZXMoY3JlYXRlUGxvdFJvd0ZuKHRpbWUsIGluZGV4LCBiYXIsIG9yaWdpbmFsVGltZSwgZGF0YVRvUGxvdFJvdyksIGJhcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlcmllc1Bsb3RSb3dDcmVhdG9yKHNlcmllc1R5cGUpIHtcbiAgICBjb25zdCBzZXJpZXNQbG90Um93Rm5NYXAgPSB7XG4gICAgICAgIENhbmRsZXN0aWNrOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0Q2FuZGxlc3RpY2tTZXJpZXNQbG90Um93KSxcbiAgICAgICAgQmFyOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0QmFyU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIEFyZWE6IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRBcmVhU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIEJhc2VsaW5lOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0QmFzZWxpbmVTZXJpZXNQbG90Um93KSxcbiAgICAgICAgSGlzdG9ncmFtOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0Q29sb3JlZExpbmVCYXNlZFNlcmllc1Bsb3RSb3cpLFxuICAgICAgICBMaW5lOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0Q29sb3JlZExpbmVCYXNlZFNlcmllc1Bsb3RSb3cpLFxuICAgICAgICBDdXN0b206IHdyYXBXaGl0ZXNwYWNlRGF0YShnZXRDdXN0b21TZXJpZXNQbG90Um93KSxcbiAgICB9O1xuICAgIHJldHVybiBzZXJpZXNQbG90Um93Rm5NYXBbc2VyaWVzVHlwZV07XG59XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiX2J1aWxkLXRpbWUtY29uc3RhbnRzXCIgLz5cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5VGltZVBvaW50RGF0YSh0aW1lUG9pbnQpIHtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfaW5kZXg6IDAsIF9pbnRlcm5hbF9tYXBwaW5nOiBuZXcgTWFwKCksIF9pbnRlcm5hbF90aW1lUG9pbnQ6IHRpbWVQb2ludCB9O1xufVxuZnVuY3Rpb24gc2VyaWVzUm93c0ZpcnN0QW5kTGFzdFRpbWUoc2VyaWVzUm93cywgYmgpIHtcbiAgICBpZiAoc2VyaWVzUm93cyA9PT0gdW5kZWZpbmVkIHx8IHNlcmllc1Jvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9maXJzdFRpbWU6IGJoLmtleShzZXJpZXNSb3dzWzBdLl9pbnRlcm5hbF90aW1lKSxcbiAgICAgICAgX2ludGVybmFsX2xhc3RUaW1lOiBiaC5rZXkoc2VyaWVzUm93c1tzZXJpZXNSb3dzLmxlbmd0aCAtIDFdLl9pbnRlcm5hbF90aW1lKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VyaWVzVXBkYXRlSW5mbyhzZXJpZXNSb3dzLCBwcmV2U2VyaWVzUm93cywgYmgpIHtcbiAgICBjb25zdCBmaXJzdEFuZExhc3RUaW1lID0gc2VyaWVzUm93c0ZpcnN0QW5kTGFzdFRpbWUoc2VyaWVzUm93cywgYmgpO1xuICAgIGNvbnN0IHByZXZGaXJzdEFuZExhc3RUaW1lID0gc2VyaWVzUm93c0ZpcnN0QW5kTGFzdFRpbWUocHJldlNlcmllc1Jvd3MsIGJoKTtcbiAgICBpZiAoZmlyc3RBbmRMYXN0VGltZSAhPT0gdW5kZWZpbmVkICYmIHByZXZGaXJzdEFuZExhc3RUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9oaXN0b3JpY2FsVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9sYXN0QmFyVXBkYXRlZE9yTmV3QmFyc0FkZGVkVG9UaGVSaWdodDogZmlyc3RBbmRMYXN0VGltZS5faW50ZXJuYWxfbGFzdFRpbWUgPj0gcHJldkZpcnN0QW5kTGFzdFRpbWUuX2ludGVybmFsX2xhc3RUaW1lICYmXG4gICAgICAgICAgICAgICAgZmlyc3RBbmRMYXN0VGltZS5faW50ZXJuYWxfZmlyc3RUaW1lID49IHByZXZGaXJzdEFuZExhc3RUaW1lLl9pbnRlcm5hbF9maXJzdFRpbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0aW1lU2NhbGVQb2ludFRpbWUobWVyZ2VkUG9pbnREYXRhKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBtZXJnZWRQb2ludERhdGEuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHYuX2ludGVybmFsX29yaWdpbmFsVGltZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBzYXZlT3JpZ2luYWxUaW1lKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lID0gZGF0YS50aW1lO1xuICAgIH1cbn1cbmNsYXNzIERhdGFMYXllciB7XG4gICAgY29uc3RydWN0b3IoaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgLy8gbm90ZSB0aGF0IF9wb2ludERhdGFCeVRpbWVQb2ludCBhbmQgX3Nlcmllc1Jvd3NCeVNlcmllcyBzaGFyZXMgVEhFIFNBTUUgb2JqZWN0cyBpbiB0aGVpciB2YWx1ZXMgYmV0d2VlbiBlYWNoIG90aGVyXG4gICAgICAgIC8vIGl0J3MganVzdCBkaWZmZXJlbnQga2luZCBvZiBtYXBzIHRvIG1ha2UgdXNhZ2VzL3BlcmYgYmV0dGVyXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRoaXMgaXMga2luZCBvZiBcImRlc3RcIiB2YWx1ZXMgKGluIG9wcG9zaXRlIHRvIFwic291cmNlXCIgb25lcykgLSB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSBpdCBtYW51YWxseSwgdGhlIG9ubHkgYnkgY2FsbGluZyBfdXBkYXRlVGltZVNjYWxlUG9pbnRzIG9yIHVwZGF0ZVNlcmllc0RhdGEgbWV0aG9kc1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzID0gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTZXJpZXNEYXRhKHNlcmllcywgZGF0YSkge1xuICAgICAgICBsZXQgbmVlZENsZWFudXBQb2ludHMgPSB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5zaXplICE9PSAwO1xuICAgICAgICBsZXQgaXNUaW1lU2NhbGVBZmZlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvLyBzYXZlIHByZXZpb3VzIHNlcmllcyByb3dzIGRhdGEgYmVmb3JlIGl0J3MgcmVwbGFjZWQgaW5zaWRlIHRoaXMuX3NldFJvd3NUb1Nlcmllc1xuICAgICAgICBjb25zdCBwcmV2U2VyaWVzUm93cyA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKHByZXZTZXJpZXNSb3dzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG5lZWRDbGVhbnVwUG9pbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNUaW1lU2NhbGVBZmZlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gcGVyZiBvcHRpbWl6YXRpb24gLSBpZiB0aGVyZSBpcyBvbmx5IDEgc2VyaWVzLCB0aGVuIHdlIGNhbiBqdXN0IGNsZWFyIGFuZCBmaWxsIGV2ZXJ5dGhpbmcgZnJvbSBzY3JhdGNoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHBlcmYgb3B0aW1pemF0aW9uIC0gYWN0dWFsbHkgd2UgaGF2ZSB0byB1c2UgdGhpcy5fcG9pbnREYXRhQnlUaW1lUG9pbnQgZm9yIGdvaW5nIHRocm91Z2ggaGVyZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBhcyBzb29uIGFzIHRoaXMuX3NvcnRlZFRpbWVQb2ludHMgaXMganVzdCBhIGRpZmZlcmVudCBmb3JtIG9mIF9wb2ludERhdGFCeVRpbWVQb2ludCB3ZSBjYW4gdXNlIGl0IGFzIHdlbGxcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50LnBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5kZWxldGUoc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNUaW1lU2NhbGVBZmZlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcmllc1Jvd3MgPSBbXTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRpbWVzID0gZGF0YS5tYXAoKGQpID0+IGQudGltZSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lQ29udmVydGVyID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaihkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVBsb3RSb3cgPSBnZXRTZXJpZXNQbG90Um93Q3JlYXRvcihzZXJpZXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhVG9QbG90Um93ID0gc2VyaWVzLl9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlcigpO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIgPSBzZXJpZXMuX2ludGVybmFsX2N1c3RvbVNlcmllc1doaXRlc3BhY2VDaGVjaygpO1xuICAgICAgICAgICAgc2VyaWVzUm93cyA9IGRhdGEubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lQ29udmVydGVyKGl0ZW0udGltZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9yekl0ZW1LZXkgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVQb2ludERhdGEgPSB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5nZXQoaG9yekl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lUG9pbnREYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4ZXMgd2lsbCBiZSBzeW5jIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVQb2ludERhdGEgPSBjcmVhdGVFbXB0eVRpbWVQb2ludERhdGEodGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LnNldChob3J6SXRlbUtleSwgdGltZVBvaW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlzVGltZVNjYWxlQWZmZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVQbG90Um93KHRpbWUsIHRpbWVQb2ludERhdGEuX2ludGVybmFsX2luZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWVzW2luZGV4XSwgZGF0YVRvUGxvdFJvdywgY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVQb2ludERhdGEuX2ludGVybmFsX21hcHBpbmcuc2V0KHNlcmllcywgcm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRDbGVhbnVwUG9pbnRzKSB7XG4gICAgICAgICAgICAvLyB3ZSBkZWxldGVkIHRoZSBvbGQgZGF0YSBmcm9tIG1hcHBpbmcgYW5kIGFkZGVkIHRoZSBuZXcgb25lc1xuICAgICAgICAgICAgLy8gc28gdGhlcmUgbWlnaHQgYmUgZW1wdHkgcG9pbnRzIG5vdywgbGV0J3MgcmVtb3ZlIHRoZW0gZmlyc3RcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFudXBQb2ludHNEYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0Um93c1RvU2VyaWVzKHNlcmllcywgc2VyaWVzUm93cyk7XG4gICAgICAgIGxldCBmaXJzdENoYW5nZWRQb2ludEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChpc1RpbWVTY2FsZUFmZmVjdGVkKSB7XG4gICAgICAgICAgICAvLyB0aGVuIGdlbmVyYXRlIHRoZSB0aW1lIHNjYWxlIHBvaW50c1xuICAgICAgICAgICAgLy8gdGltZVdlaWdodCB3aWxsIGJlIHVwZGF0ZXMgaW4gX3VwZGF0ZVRpbWVTY2FsZVBvaW50cyBsYXRlclxuICAgICAgICAgICAgY29uc3QgbmV3VGltZVNjYWxlUG9pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5mb3JFYWNoKChwb2ludERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdUaW1lU2NhbGVQb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVXZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHBvaW50RGF0YS5faW50ZXJuYWxfdGltZVBvaW50LFxuICAgICAgICAgICAgICAgICAgICBwb2ludERhdGEsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGltZTogdGltZVNjYWxlUG9pbnRUaW1lKHBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld1RpbWVTY2FsZVBvaW50cy5zb3J0KCh0MSwgdDIpID0+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0MS50aW1lKSAtIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0Mi50aW1lKSk7XG4gICAgICAgICAgICBmaXJzdENoYW5nZWRQb2ludEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fcmVwbGFjZVRpbWVTY2FsZVBvaW50cyhuZXdUaW1lU2NhbGVQb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19nZXRVcGRhdGVSZXNwb25zZShzZXJpZXMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgsIHNlcmllc1VwZGF0ZUluZm8odGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmdldChzZXJpZXMpLCBwcmV2U2VyaWVzUm93cywgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZVNlcmllcyhzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NldFNlcmllc0RhdGEoc2VyaWVzLCBbXSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVTZXJpZXNEYXRhKHNlcmllcywgZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSkge1xuICAgICAgICBjb25zdCBleHRlbmRlZERhdGEgPSBkYXRhO1xuICAgICAgICBzYXZlT3JpZ2luYWxUaW1lKGV4dGVuZGVkRGF0YSk7XG4gICAgICAgIC8vIGNvbnZlcnRTdHJpbmdUb0J1c2luZXNzRGF5KGRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5wcmVwcm9jZXNzRGF0YShkYXRhKTtcbiAgICAgICAgY29uc3QgdGltZUNvbnZlcnRlciA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmNyZWF0ZUNvbnZlcnRlclRvSW50ZXJuYWxPYmooW2RhdGFdKTtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVDb252ZXJ0ZXIoZGF0YS50aW1lKTtcbiAgICAgICAgY29uc3QgbGFzdFNlcmllc1RpbWUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50LmdldChzZXJpZXMpO1xuICAgICAgICBpZiAoIWhpc3RvcmljYWxVcGRhdGUgJiYgbGFzdFNlcmllc1RpbWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSkgPCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobGFzdFNlcmllc1RpbWUpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1cGRhdGUgb2xkZXN0IGRhdGEsIGxhc3QgdGltZT0ke2xhc3RTZXJpZXNUaW1lfSwgbmV3IHRpbWU9JHt0aW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludERhdGFBdFRpbWUgPSB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5nZXQodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpKTtcbiAgICAgICAgaWYgKGhpc3RvcmljYWxVcGRhdGUgJiYgcG9pbnREYXRhQXRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBub24tZXhpc3RpbmcgZGF0YSBwb2ludCB3aGVuIGhpc3RvcmljYWxVcGRhdGUgaXMgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIHBvaW50IGRhdGEgZm91bmQgZm9yIHRoZSBuZXcgZGF0YSBpdGVtXG4gICAgICAgIC8vIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHVwZGF0ZSBzY2FsZVxuICAgICAgICBjb25zdCBhZmZlY3RzVGltZVNjYWxlID0gcG9pbnREYXRhQXRUaW1lID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwb2ludERhdGFBdFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhlIGluZGV4ZXMgd2lsbCBiZSBzeW5jIGxhdGVyXG4gICAgICAgICAgICBwb2ludERhdGFBdFRpbWUgPSBjcmVhdGVFbXB0eVRpbWVQb2ludERhdGEodGltZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5zZXQodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpLCBwb2ludERhdGFBdFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBsb3RSb3cgPSBnZXRTZXJpZXNQbG90Um93Q3JlYXRvcihzZXJpZXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKSk7XG4gICAgICAgIGNvbnN0IGRhdGFUb1Bsb3RSb3cgPSBzZXJpZXMuX2ludGVybmFsX2N1c3RvbVNlcmllc1Bsb3RWYWx1ZXNCdWlsZGVyKCk7XG4gICAgICAgIGNvbnN0IGN1c3RvbVdoaXRlc3BhY2VDaGVja2VyID0gc2VyaWVzLl9pbnRlcm5hbF9jdXN0b21TZXJpZXNXaGl0ZXNwYWNlQ2hlY2soKTtcbiAgICAgICAgY29uc3QgcGxvdFJvdyA9IGNyZWF0ZVBsb3RSb3codGltZSwgcG9pbnREYXRhQXRUaW1lLl9pbnRlcm5hbF9pbmRleCwgZGF0YSwgZXh0ZW5kZWREYXRhLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWUsIGRhdGFUb1Bsb3RSb3csIGN1c3RvbVdoaXRlc3BhY2VDaGVja2VyKTtcbiAgICAgICAgcG9pbnREYXRhQXRUaW1lLl9pbnRlcm5hbF9tYXBwaW5nLnNldChzZXJpZXMsIHBsb3RSb3cpO1xuICAgICAgICBpZiAoaGlzdG9yaWNhbFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlSGlzdG9yaWNhbFNlcmllc1JvdyhzZXJpZXMsIHBsb3RSb3csIHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlTGFzdFNlcmllc1JvdyhzZXJpZXMsIHBsb3RSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGFzdEJhclVwZGF0ZWRPck5ld0JhcnNBZGRlZFRvVGhlUmlnaHQ6IGlzU2VyaWVzUGxvdFJvdyhwbG90Um93KSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9oaXN0b3JpY2FsVXBkYXRlOiBoaXN0b3JpY2FsVXBkYXRlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBpZiBwb2ludCBhbHJlYWR5IGV4aXN0IG9uIHRoZSB0aW1lIHNjYWxlIC0gd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgZnVsbCB1cGRhdGUgYW5kIGp1c3QgbWFrZSBhbiBpbmNyZW1lbnRhbCBvbmVcbiAgICAgICAgaWYgKCFhZmZlY3RzVGltZVNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2Uoc2VyaWVzLCAtMSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UG9pbnQgPSB7XG4gICAgICAgICAgICB0aW1lV2VpZ2h0OiAwLFxuICAgICAgICAgICAgdGltZTogcG9pbnREYXRhQXRUaW1lLl9pbnRlcm5hbF90aW1lUG9pbnQsXG4gICAgICAgICAgICBwb2ludERhdGE6IHBvaW50RGF0YUF0VGltZSxcbiAgICAgICAgICAgIG9yaWdpbmFsVGltZTogdGltZVNjYWxlUG9pbnRUaW1lKHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfbWFwcGluZyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gbG93ZXJCb3VuZCh0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobmV3UG9pbnQudGltZSksIChhLCBiKSA9PiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkoYS50aW1lKSA8IGIpO1xuICAgICAgICAvLyB5ZXMsIEkga25vdyB0aGF0IHRoaXMgYXJyYXkgaXMgcmVhZG9ubHkgYW5kIHRoaXMgY2hhbmdlIGlzIGludGVuZGVkIHRvIG1ha2UgaXQgcGVyZm9ybWF0aXZlXG4gICAgICAgIC8vIHdlIG1hcmtlZCBfc29ydGVkVGltZVBvaW50cyBhcnJheSBhcyByZWFkb25seSB0byBhdm9pZCBtb2RpZnlpbmcgdGhpcyBhcnJheSBhbnl3aGVyZSBlbHNlXG4gICAgICAgIC8vIGJ1dCB0aGlzIHBsYWNlIGlzIGV4Y2VwdGlvbmFsIGNhc2UgZHVlIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHNvcnJ5XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMuc3BsaWNlKGluc2VydEluZGV4LCAwLCBuZXdQb2ludCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gaW5zZXJ0SW5kZXg7IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGFzc2lnbkluZGV4VG9Qb2ludERhdGEodGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50c1tpbmRleF0ucG9pbnREYXRhLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuZmlsbFdlaWdodHNGb3JQb2ludHModGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cywgaW5zZXJ0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2Uoc2VyaWVzLCBpbnNlcnRJbmRleCwgaW5mbyk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVMYXN0U2VyaWVzUm93KHNlcmllcywgcGxvdFJvdykge1xuICAgICAgICBsZXQgc2VyaWVzRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKHNlcmllc0RhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNldChzZXJpZXMsIHNlcmllc0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RTZXJpZXNSb3cgPSBzZXJpZXNEYXRhLmxlbmd0aCAhPT0gMCA/IHNlcmllc0RhdGFbc2VyaWVzRGF0YS5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGlmIChsYXN0U2VyaWVzUm93ID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShwbG90Um93Ll9pbnRlcm5hbF90aW1lKSA+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShsYXN0U2VyaWVzUm93Ll9pbnRlcm5hbF90aW1lKSkge1xuICAgICAgICAgICAgaWYgKGlzU2VyaWVzUGxvdFJvdyhwbG90Um93KSkge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEucHVzaChwbG90Um93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Nlcmllc1Bsb3RSb3cocGxvdFJvdykpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXRhW3Nlcmllc0RhdGEubGVuZ3RoIC0gMV0gPSBwbG90Um93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzRGF0YS5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQuc2V0KHNlcmllcywgcGxvdFJvdy5faW50ZXJuYWxfdGltZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVIaXN0b3JpY2FsU2VyaWVzUm93KHNlcmllcywgcGxvdFJvdywgcG9pbnREYXRhSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKHNlcmllc0RhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2ggZm9yIGFjdHVhbCBpbmRleCBpbiBhcnJheS5cbiAgICAgICAgY29uc3QgaW5kZXggPSBsb3dlckJvdW5kKHNlcmllc0RhdGEsIHBvaW50RGF0YUluZGV4LCAocm93LCBjdXJyZW50SW5kZXgpID0+IHJvdy5faW50ZXJuYWxfaW5kZXggPCBjdXJyZW50SW5kZXgpO1xuICAgICAgICBpZiAoaXNTZXJpZXNQbG90Um93KHBsb3RSb3cpKSB7XG4gICAgICAgICAgICBzZXJpZXNEYXRhW2luZGV4XSA9IHBsb3RSb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpZXNEYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3NldFJvd3NUb1NlcmllcyhzZXJpZXMsIHNlcmllc1Jvd3MpIHtcbiAgICAgICAgaWYgKHNlcmllc1Jvd3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuc2V0KHNlcmllcywgc2VyaWVzUm93cy5maWx0ZXIoaXNTZXJpZXNQbG90Um93KSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50LnNldChzZXJpZXMsIHNlcmllc1Jvd3Nbc2VyaWVzUm93cy5sZW5ndGggLSAxXS5faW50ZXJuYWxfdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZGVsZXRlKHNlcmllcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50LmRlbGV0ZShzZXJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19jbGVhbnVwUG9pbnRzRGF0YSgpIHtcbiAgICAgICAgLy8gbGV0J3MgdHJlYXQgYWxsIGN1cnJlbnQgcG9pbnRzIGFzIFwicG90ZW50aWFsbHkgcmVtb3ZlZFwiXG4gICAgICAgIC8vIHdlIGNvdWxkIGNyZWF0ZSBhbiBhcnJheSB3aXRoIGFjdHVhbGx5IHBvdGVudGlhbGx5IHJlbW92ZWQgcG9pbnRzXG4gICAgICAgIC8vIGJ1dCBtb3N0IGxpa2VseSB0aGlzIGFycmF5IHdpbGwgYmUgc2ltaWxhciB0byBfc29ydGVkVGltZVBvaW50cyBzbyBsZXQncyBhdm9pZCB1c2luZyBhZGRpdGlvbmFsIG1lbW9yeVxuICAgICAgICAvLyBub3RlIHRoYXQgd2UgY2FuIHVzZSBfc29ydGVkVGltZVBvaW50cyBoZXJlIHNpbmNlIGEgcG9pbnQgbWlnaHQgYmUgcmVtb3ZlZCBvbmx5IGl0IHdhcyBoZXJlIHByZXZpb3VzbHlcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAocG9pbnQucG9pbnREYXRhLl9pbnRlcm5hbF9tYXBwaW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5kZWxldGUodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHBvaW50LnRpbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG5ldyB0aW1lIHNjYWxlIGFuZCBtYWtlIGluZGV4ZXMgdmFsaWQgZm9yIGFsbCBzZXJpZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhbmdlZCBwb2ludCBvciBgLTFgIGlmIHRoZXJlIGlzIG5vIGNoYW5nZS5cbiAgICAgKi9cbiAgICBfcHJpdmF0ZV9fcmVwbGFjZVRpbWVTY2FsZVBvaW50cyhuZXdUaW1lUG9pbnRzKSB7XG4gICAgICAgIGxldCBmaXJzdENoYW5nZWRQb2ludEluZGV4ID0gLTE7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZmlyc3QgZGlmZmVyZW50IHBvaW50IGFuZCBcInN5bmNpbmdcIiB0aW1lIHdlaWdodCBieSB0aGUgd2F5XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCAmJiBpbmRleCA8IG5ld1RpbWVQb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBvbGRQb2ludCA9IHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbmV3UG9pbnQgPSBuZXdUaW1lUG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkob2xkUG9pbnQudGltZSkgIT09IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShuZXdQb2ludC50aW1lKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlLWFzc2lnbiBwb2ludCdzIHRpbWUgd2VpZ2h0IGZvciBwb2ludHMgaWYgdGltZSBpcyB0aGUgc2FtZSAoYW5kIGFsbCBwcmlvciB0aW1lcyB3YXMgdGhlIHNhbWUpXG4gICAgICAgICAgICBuZXdQb2ludC50aW1lV2VpZ2h0ID0gb2xkUG9pbnQudGltZVdlaWdodDtcbiAgICAgICAgICAgIGFzc2lnbkluZGV4VG9Qb2ludERhdGEobmV3UG9pbnQucG9pbnREYXRhLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPT09IC0xICYmIHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMubGVuZ3RoICE9PSBuZXdUaW1lUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXJ0IG9mIHRoZSBwcmV2IGFuZCB0aGUgbmV3IHBvaW50cyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHNvIHRoZSBmaXJzdCBjaGFuZ2VkIHBvaW50IGlzIHRoZSBuZXh0IGFmdGVyIHRoZSBjb21tb24gcGFydFxuICAgICAgICAgICAgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9IE1hdGgubWluKHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMubGVuZ3RoLCBuZXdUaW1lUG9pbnRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBpZiBubyB0aW1lIHNjYWxlIGNoYW5nZWQsIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRpbWUgc2NhbGUgcG9pbnRzIGFyZSBjaGFuZ2VkIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIG1ha2UgZnVsbCB1cGRhdGUgdG8gYWxsIHNlcmllcyAod2l0aCBjbGVhcmluZyBwb2ludHMpXG4gICAgICAgIC8vIGJ1dCBmaXJzdCB3ZSBuZWVkIHRvIHN5bmNocm9uaXplIGluZGV4ZXMgYW5kIHJlLWZpbGwgdGltZSB3ZWlnaHRzXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleDsgaW5kZXggPCBuZXdUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgYXNzaWduSW5kZXhUb1BvaW50RGF0YShuZXdUaW1lUG9pbnRzW2luZGV4XS5wb2ludERhdGEsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS1maWxsIHRpbWUgd2VpZ2h0cyBmb3IgcG9pbnQgYWZ0ZXIgdGhlIGZpcnN0IGNoYW5nZWQgb25lXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmZpbGxXZWlnaHRzRm9yUG9pbnRzKG5ld1RpbWVQb2ludHMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzID0gbmV3VGltZVBvaW50cztcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXg7XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRCYXNlSW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBkYXRhIHRoZW4gJ3Jlc2V0JyB0aGUgYmFzZSBpbmRleCB0byBudWxsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmFzZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGJhc2VJbmRleCA9IE1hdGgubWF4KGJhc2VJbmRleCwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLl9pbnRlcm5hbF9pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmFzZUluZGV4O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2UodXBkYXRlZFNlcmllcywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCwgaW5mbykge1xuICAgICAgICBjb25zdCBkYXRhVXBkYXRlUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGltZVNjYWxlOiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VJbmRleDogdGhpcy5fcHJpdmF0ZV9fZ2V0QmFzZUluZGV4KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGl0J3MgcG9zc2libGUgdG8gbWFrZSBwZXJmIGltcHJvdmVtZW50cyBieSBjaGVja2luZyB3aGF0IHNlcmllcyBoYXMgZGF0YSBhZnRlciBmaXJzdENoYW5nZWRQb2ludEluZGV4XG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mgc2tpcCBmb3Igbm93XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZm9yRWFjaCgoZGF0YSwgcykgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfc2VyaWVzLnNldChzLCB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9kYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW5mbzogcyA9PT0gdXBkYXRlZFNlcmllcyA/IGluZm8gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZXJpZXMgZGF0YSB3YXMgc2V0IHRvIFtdIGl0IHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBmcm9tIF9zZXJpZXNSb3dCeVNlcmllc1xuICAgICAgICAgICAgLy8gbWVhbmluZyB0aGUgZm9yRWFjaCBhYm92ZSB3b24ndCBhZGQgdGhlIHNlcmllcyB0byB0aGUgZGF0YSB1cGRhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhbmRsZSB0aGF0IGNhc2UgaGVyZVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuaGFzKHVwZGF0ZWRTZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVVwZGF0ZVJlc3BvbnNlLl9pbnRlcm5hbF9zZXJpZXMuc2V0KHVwZGF0ZWRTZXJpZXMsIHsgX2ludGVybmFsX2RhdGE6IFtdLCBfaW50ZXJuYWxfaW5mbzogaW5mbyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9wb2ludHMgPSB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzO1xuICAgICAgICAgICAgZGF0YVVwZGF0ZVJlc3BvbnNlLl9pbnRlcm5hbF90aW1lU2NhbGUuX2ludGVybmFsX2ZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSBmaXJzdENoYW5nZWRQb2ludEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQodXBkYXRlZFNlcmllcyk7XG4gICAgICAgICAgICAvLyBpZiBubyBzZXJpZXNEYXRhIGZvdW5kIHRoYXQgbWVhbnMgdGhhdCB3ZSBqdXN0IHJlbW92ZWQgdGhlIHNlcmllc1xuICAgICAgICAgICAgZGF0YVVwZGF0ZVJlc3BvbnNlLl9pbnRlcm5hbF9zZXJpZXMuc2V0KHVwZGF0ZWRTZXJpZXMsIHsgX2ludGVybmFsX2RhdGE6IHNlcmllc0RhdGEgfHwgW10sIF9pbnRlcm5hbF9pbmZvOiBpbmZvIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhVXBkYXRlUmVzcG9uc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduSW5kZXhUb1BvaW50RGF0YShwb2ludERhdGEsIGluZGV4KSB7XG4gICAgLy8gZmlyc3QsIG5ldmVydGhlbGVzcyB1cGRhdGUgaW5kZXggb2YgcG9pbnQgZGF0YSAoXCJtYWtlIGl0IHZhbGlkXCIpXG4gICAgcG9pbnREYXRhLl9pbnRlcm5hbF9pbmRleCA9IGluZGV4O1xuICAgIC8vIGFuZCB0aGVuIHdlIG5lZWQgdG8gc3luYyBpbmRleGVzIGZvciBhbGwgc2VyaWVzXG4gICAgcG9pbnREYXRhLl9pbnRlcm5hbF9tYXBwaW5nLmZvckVhY2goKHNlcmllc1JvdykgPT4ge1xuICAgICAgICBzZXJpZXNSb3cuX2ludGVybmFsX2luZGV4ID0gaW5kZXg7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvd2VyQm91bmRJdGVtc0NvbXBhcmUoaXRlbSwgdGltZSkge1xuICAgIHJldHVybiBpdGVtLl9pbnRlcm5hbF90aW1lIDwgdGltZTtcbn1cbmZ1bmN0aW9uIHVwcGVyQm91bmRJdGVtc0NvbXBhcmUoaXRlbSwgdGltZSkge1xuICAgIHJldHVybiB0aW1lIDwgaXRlbS5faW50ZXJuYWxfdGltZTtcbn1cbmZ1bmN0aW9uIHZpc2libGVUaW1lZFZhbHVlcyhpdGVtcywgcmFuZ2UsIGV4dGVuZGVkUmFuZ2UpIHtcbiAgICBjb25zdCBmaXJzdEJhciA9IHJhbmdlLl9pbnRlcm5hbF9sZWZ0KCk7XG4gICAgY29uc3QgbGFzdEJhciA9IHJhbmdlLl9pbnRlcm5hbF9yaWdodCgpO1xuICAgIGNvbnN0IGZyb20gPSBsb3dlckJvdW5kKGl0ZW1zLCBmaXJzdEJhciwgbG93ZXJCb3VuZEl0ZW1zQ29tcGFyZSk7XG4gICAgY29uc3QgdG8gPSB1cHBlckJvdW5kKGl0ZW1zLCBsYXN0QmFyLCB1cHBlckJvdW5kSXRlbXNDb21wYXJlKTtcbiAgICBpZiAoIWV4dGVuZGVkUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9XG4gICAgbGV0IGV4dGVuZGVkRnJvbSA9IGZyb207XG4gICAgbGV0IGV4dGVuZGVkVG8gPSB0bztcbiAgICBpZiAoZnJvbSA+IDAgJiYgZnJvbSA8IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tmcm9tXS5faW50ZXJuYWxfdGltZSA+PSBmaXJzdEJhcikge1xuICAgICAgICBleHRlbmRlZEZyb20gPSBmcm9tIC0gMTtcbiAgICB9XG4gICAgaWYgKHRvID4gMCAmJiB0byA8IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1t0byAtIDFdLl9pbnRlcm5hbF90aW1lIDw9IGxhc3RCYXIpIHtcbiAgICAgICAgZXh0ZW5kZWRUbyA9IHRvICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbTogZXh0ZW5kZWRGcm9tLCB0bzogZXh0ZW5kZWRUbyB9O1xufVxuXG5jbGFzcyBTZXJpZXNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwsIGV4dGVuZGVkVmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fb3B0aW9uc0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19leHRlbmRlZFZpc2libGVSYW5nZSA9IGV4dGVuZGVkVmlzaWJsZVJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKHVwZGF0ZVR5cGUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGFJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZVR5cGUgPT09ICdvcHRpb25zJykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX29wdGlvbnNJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVZhbGlkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtcyA9IHRoaXMuX2ludGVybmFsX19pdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgLi4udGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpLl9pbnRlcm5hbF9iYXJTdHlsZShpdGVtLl9pbnRlcm5hbF90aW1lKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NsZWFyVmlzaWJsZVJhbmdlKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFrZVZhbGlkKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2RhdGFJbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2ZpbGxSYXdQb2ludHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX29wdGlvbnNJbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3VwZGF0ZU9wdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlVmFsaWRJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFrZVZhbGlkSW1wbCgpIHtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2NsZWFyVmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCBwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3NpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID0gdmlzaWJsZVRpbWVkVmFsdWVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgdmlzaWJsZUJhcnMsIHRoaXMuX3ByaXZhdGVfX2V4dGVuZGVkVmlzaWJsZVJhbmdlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2NvbnZlcnRUb0Nvb3JkaW5hdGVzKHByaWNlU2NhbGUsIHRpbWVTY2FsZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tU2VyaWVzUGFuZVJlbmRlcmVyV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlUmVuZGVyZXIsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlUmVuZGVyZXIgPSBzb3VyY2VSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2VSZW5kZXJlci5kcmF3KHRhcmdldCwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSk7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzQ3VzdG9tUGFuZVZpZXcgZXh0ZW5kcyBTZXJpZXNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwsIHBhbmVWaWV3KSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgbW9kZWwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBwYW5lVmlldztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IEN1c3RvbVNlcmllc1BhbmVSZW5kZXJlcldyYXBwZXIodGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcucmVuZGVyZXIoKSwgKHByaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlVmFsdWVCdWlsZGVyKHBsb3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnByaWNlVmFsdWVCdWlsZGVyKHBsb3RSb3cpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNXaGl0ZXNwYWNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LmlzV2hpdGVzcGFjZShkYXRhKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19maWxsUmF3UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBjb2xvcmVyID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3Jvd3MoKVxuICAgICAgICAgICAgLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lOiByb3cuX2ludGVybmFsX2luZGV4LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94OiBOYU4sXG4gICAgICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUocm93Ll9pbnRlcm5hbF9pbmRleCksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX29yaWdpbmFsRGF0YTogcm93Ll9pbnRlcm5hbF9kYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY29udmVydFRvQ29vcmRpbmF0ZXMocHJpY2VTY2FsZSwgdGltZVNjYWxlKSB7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcudXBkYXRlKHtcbiAgICAgICAgICAgIGJhcnM6IHRoaXMuX2ludGVybmFsX19pdGVtcy5tYXAodW53cmFwSXRlbURhdGEpLFxuICAgICAgICAgICAgYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgIH0sIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW53cmFwSXRlbURhdGEoaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGl0ZW0uX2ludGVybmFsX3gsXG4gICAgICAgIHRpbWU6IGl0ZW0uX2ludGVybmFsX3RpbWUsXG4gICAgICAgIG9yaWdpbmFsRGF0YTogaXRlbS5faW50ZXJuYWxfb3JpZ2luYWxEYXRhLFxuICAgICAgICBiYXJDb2xvcjogaXRlbS5faW50ZXJuYWxfYmFyQ29sb3IsXG4gICAgfTtcbn1cblxuY29uc3QgY3VzdG9tU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyMTk2ZjMnLFxufTtcbmNvbnN0IGNyZWF0ZVBhbmVWaWV3JDYgPSAoc2VyaWVzLCBtb2RlbCwgY3VzdG9tUGFuZVZpZXcpID0+IHtcbiAgICBjb25zdCBwYW5lVmlldyA9IGVuc3VyZShjdXN0b21QYW5lVmlldyk7XG4gICAgcmV0dXJuIG5ldyBTZXJpZXNDdXN0b21QYW5lVmlldyhzZXJpZXMsIG1vZGVsLCBwYW5lVmlldyk7XG59O1xuY29uc3QgY3JlYXRlQ3VzdG9tU2VyaWVzRGVmaW5pdGlvbiA9IChwYW5lVmlldykgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdDdXN0b20nLFxuICAgICAgICBpc0J1aWx0SW46IGZhbHNlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogeyAuLi5jdXN0b21TdHlsZURlZmF1bHRzLCAuLi5wYW5lVmlldy5kZWZhdWx0T3B0aW9ucygpIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIF9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldzogY3JlYXRlUGFuZVZpZXckNixcbiAgICAgICAgX2ludGVybmFsX2N1c3RvbVBhbmVWaWV3OiBwYW5lVmlldyxcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcblxuY29uc3QgaXNTZXJpZXNEZWZpbml0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlLl9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldyAhPT0gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gc2luZ2xlVmFsdWVEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB2YWx1ZTogcGxvdFJvdy5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgIHRpbWU6IHBsb3RSb3cuX2ludGVybmFsX29yaWdpbmFsVGltZSxcbiAgICB9O1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9jdXN0b21WYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhLmN1c3RvbVZhbHVlcyA9IHBsb3RSb3cuX2ludGVybmFsX2N1c3RvbVZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBsaW5lRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2luZ2xlVmFsdWVEYXRhKHBsb3RSb3cpO1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5jb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX2NvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJlYURhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNpbmdsZVZhbHVlRGF0YShwbG90Um93KTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfbGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmxpbmVDb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX2xpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX3RvcENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnRvcENvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfdG9wQ29sb3I7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21Db2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5ib3R0b21Db2xvciA9IHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmFzZWxpbmVEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaW5nbGVWYWx1ZURhdGEocGxvdFJvdyk7XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX3RvcExpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC50b3BMaW5lQ29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF90b3BMaW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYm90dG9tTGluZUNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfYm90dG9tTGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC50b3BGaWxsQ29sb3IxID0gcGxvdFJvdy5faW50ZXJuYWxfdG9wRmlsbENvbG9yMTtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX3RvcEZpbGxDb2xvcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQudG9wRmlsbENvbG9yMiA9IHBsb3RSb3cuX2ludGVybmFsX3RvcEZpbGxDb2xvcjI7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmJvdHRvbUZpbGxDb2xvcjEgPSBwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5ib3R0b21GaWxsQ29sb3IyID0gcGxvdFJvdy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9obGNEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBvcGVuOiBwbG90Um93Ll9pbnRlcm5hbF92YWx1ZVswIC8qIFBsb3RSb3dWYWx1ZUluZGV4Lk9wZW4gKi9dLFxuICAgICAgICBoaWdoOiBwbG90Um93Ll9pbnRlcm5hbF92YWx1ZVsxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dLFxuICAgICAgICBsb3c6IHBsb3RSb3cuX2ludGVybmFsX3ZhbHVlWzIgLyogUGxvdFJvd1ZhbHVlSW5kZXguTG93ICovXSxcbiAgICAgICAgY2xvc2U6IHBsb3RSb3cuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dLFxuICAgICAgICB0aW1lOiBwbG90Um93Ll9pbnRlcm5hbF9vcmlnaW5hbFRpbWUsXG4gICAgfTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfY3VzdG9tVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5jdXN0b21WYWx1ZXMgPSBwbG90Um93Ll9pbnRlcm5hbF9jdXN0b21WYWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gYmFyRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb2hsY0RhdGEocGxvdFJvdyk7XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfY29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYW5kbGVzdGlja0RhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG9obGNEYXRhKHBsb3RSb3cpO1xuICAgIGNvbnN0IHsgX2ludGVybmFsX2NvbG9yOiBjb2xvciwgX2ludGVybmFsX2JvcmRlckNvbG9yOiBib3JkZXJDb2xvciwgX2ludGVybmFsX3dpY2tDb2xvcjogd2lja0NvbG9yIH0gPSBwbG90Um93O1xuICAgIGlmIChjb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5jb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYm9yZGVyQ29sb3IgPSBib3JkZXJDb2xvcjtcbiAgICB9XG4gICAgaWYgKHdpY2tDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC53aWNrQ29sb3IgPSB3aWNrQ29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTZXJpZXNEYXRhQ3JlYXRvcihzZXJpZXNUeXBlKSB7XG4gICAgY29uc3Qgc2VyaWVzUGxvdFJvd1RvRGF0YU1hcCA9IHtcbiAgICAgICAgQXJlYTogKGFyZWFEYXRhKSxcbiAgICAgICAgTGluZTogKGxpbmVEYXRhKSxcbiAgICAgICAgQmFzZWxpbmU6IChiYXNlbGluZURhdGEpLFxuICAgICAgICBIaXN0b2dyYW06IChsaW5lRGF0YSksXG4gICAgICAgIEJhcjogKGJhckRhdGEpLFxuICAgICAgICBDYW5kbGVzdGljazogKGNhbmRsZXN0aWNrRGF0YSksXG4gICAgICAgIEN1c3RvbTogKGN1c3RvbURhdGEpLFxuICAgIH07XG4gICAgcmV0dXJuIHNlcmllc1Bsb3RSb3dUb0RhdGFNYXBbc2VyaWVzVHlwZV07XG59XG5mdW5jdGlvbiBjdXN0b21EYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCB0aW1lID0gcGxvdFJvdy5faW50ZXJuYWxfb3JpZ2luYWxUaW1lO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBsb3RSb3cuX2ludGVybmFsX2RhdGEsXG4gICAgICAgIHRpbWUsXG4gICAgfTtcbn1cblxuY29uc3QgY3Jvc3NoYWlyT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHZlcnRMaW5lOiB7XG4gICAgICAgIGNvbG9yOiAnIzk1OThBMScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHlsZTogMyAvKiBMaW5lU3R5bGUuTGFyZ2VEYXNoZWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ICcjMTMxNzIyJyxcbiAgICB9LFxuICAgIGhvcnpMaW5lOiB7XG4gICAgICAgIGNvbG9yOiAnIzk1OThBMScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHlsZTogMyAvKiBMaW5lU3R5bGUuTGFyZ2VEYXNoZWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ICcjMTMxNzIyJyxcbiAgICB9LFxuICAgIG1vZGU6IDEgLyogQ3Jvc3NoYWlyTW9kZS5NYWduZXQgKi8sXG59O1xuXG5jb25zdCBncmlkT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHZlcnRMaW5lczoge1xuICAgICAgICBjb2xvcjogJyNENkRDREUnLFxuICAgICAgICBzdHlsZTogMCAvKiBMaW5lU3R5bGUuU29saWQgKi8sXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgfSxcbiAgICBob3J6TGluZXM6IHtcbiAgICAgICAgY29sb3I6ICcjRDZEQ0RFJyxcbiAgICAgICAgc3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgIH0sXG59O1xuXG5jb25zdCBsYXlvdXRPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgICB0eXBlOiBcInNvbGlkXCIgLyogQ29sb3JUeXBlLlNvbGlkICovLFxuICAgICAgICBjb2xvcjogJyNGRkZGRkYnLFxuICAgIH0sXG4gICAgdGV4dENvbG9yOiAnIzE5MTkxOScsXG4gICAgZm9udFNpemU6IDEyLFxuICAgIGZvbnRGYW1pbHk6IGRlZmF1bHRGb250RmFtaWx5LFxuICAgIHBhbmVzOiB7XG4gICAgICAgIGVuYWJsZVJlc2l6ZTogdHJ1ZSxcbiAgICAgICAgc2VwYXJhdG9yQ29sb3I6ICcjRTBFM0VCJyxcbiAgICAgICAgc2VwYXJhdG9ySG92ZXJDb2xvcjogJ3JnYmEoMTc4LCAxODEsIDE4OSwgMC4yKScsXG4gICAgfSxcbiAgICBhdHRyaWJ1dGlvbkxvZ286IHRydWUsXG4gICAgY29sb3JTcGFjZTogJ3NyZ2InLFxuICAgIGNvbG9yUGFyc2VyczogW10sXG59O1xuXG5jb25zdCBwcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIGF1dG9TY2FsZTogdHJ1ZSxcbiAgICBtb2RlOiAwIC8qIFByaWNlU2NhbGVNb2RlLk5vcm1hbCAqLyxcbiAgICBpbnZlcnRTY2FsZTogZmFsc2UsXG4gICAgYWxpZ25MYWJlbHM6IHRydWUsXG4gICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgIGVudGlyZVRleHRPbmx5OiBmYWxzZSxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICB0aWNrc1Zpc2libGU6IGZhbHNlLFxuICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICBib3R0b206IDAuMSxcbiAgICAgICAgdG9wOiAwLjIsXG4gICAgfSxcbiAgICBtaW5pbXVtV2lkdGg6IDAsXG4gICAgZW5zdXJlRWRnZVRpY2tNYXJrc1Zpc2libGU6IGZhbHNlLFxufTtcblxuY29uc3QgdGltZVNjYWxlT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHJpZ2h0T2Zmc2V0OiAwLFxuICAgIGJhclNwYWNpbmc6IDYsXG4gICAgbWluQmFyU3BhY2luZzogMC41LFxuICAgIG1heEJhclNwYWNpbmc6IDAsXG4gICAgZml4TGVmdEVkZ2U6IGZhbHNlLFxuICAgIGZpeFJpZ2h0RWRnZTogZmFsc2UsXG4gICAgbG9ja1Zpc2libGVUaW1lUmFuZ2VPblJlc2l6ZTogZmFsc2UsXG4gICAgcmlnaHRCYXJTdGF5c09uU2Nyb2xsOiBmYWxzZSxcbiAgICBib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiAnIzJCMkI0MycsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICB0aW1lVmlzaWJsZTogZmFsc2UsXG4gICAgc2Vjb25kc1Zpc2libGU6IHRydWUsXG4gICAgc2hpZnRWaXNpYmxlUmFuZ2VPbk5ld0JhcjogdHJ1ZSxcbiAgICBhbGxvd1NoaWZ0VmlzaWJsZVJhbmdlT25XaGl0ZXNwYWNlUmVwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIHRpY2tzVmlzaWJsZTogZmFsc2UsXG4gICAgdW5pZm9ybURpc3RyaWJ1dGlvbjogZmFsc2UsXG4gICAgbWluaW11bUhlaWdodDogMCxcbiAgICBhbGxvd0JvbGRMYWJlbHM6IHRydWUsXG4gICAgaWdub3JlV2hpdGVzcGFjZUluZGljZXM6IGZhbHNlLFxufTtcblxuZnVuY3Rpb24gY2hhcnRPcHRpb25zRGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgYXV0b1NpemU6IGZhbHNlLFxuICAgICAgICBsYXlvdXQ6IGxheW91dE9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgY3Jvc3NoYWlyOiBjcm9zc2hhaXJPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIGdyaWQ6IGdyaWRPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIG92ZXJsYXlQcmljZVNjYWxlczoge1xuICAgICAgICAgICAgLi4ucHJpY2VTY2FsZU9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdFByaWNlU2NhbGU6IHtcbiAgICAgICAgICAgIC4uLnByaWNlU2NhbGVPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgICAgICAuLi5wcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZVNjYWxlOiB0aW1lU2NhbGVPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIGxvY2FsaXphdGlvbjoge1xuICAgICAgICAgICAgbG9jYWxlOiBpc1J1bm5pbmdPbkNsaWVudFNpZGUgPyBuYXZpZ2F0b3IubGFuZ3VhZ2UgOiAnJyxcbiAgICAgICAgICAgIGRhdGVGb3JtYXQ6ICdkZCBNTU0gXFwneXknLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVTY3JvbGw6IHtcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzc2VkTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgICAgICAgaG9yelRvdWNoRHJhZzogdHJ1ZSxcbiAgICAgICAgICAgIHZlcnRUb3VjaERyYWc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZVNjYWxlOiB7XG4gICAgICAgICAgICBheGlzUHJlc3NlZE1vdXNlTW92ZToge1xuICAgICAgICAgICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJpY2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXhpc0RvdWJsZUNsaWNrUmVzZXQ6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByaWNlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgICAgICBwaW5jaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAga2luZXRpY1Njcm9sbDoge1xuICAgICAgICAgICAgbW91c2U6IGZhbHNlLFxuICAgICAgICAgICAgdG91Y2g6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNraW5nTW9kZToge1xuICAgICAgICAgICAgZXhpdE1vZGU6IDEgLyogVHJhY2tpbmdNb2RlRXhpdE1vZGUuT25OZXh0VGFwICovLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNsYXNzIFByaWNlU2NhbGVBcGkge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0V2lkZ2V0LCBwcmljZVNjYWxlSWQsIHBhbmVJbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCA9IGNoYXJ0V2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQgPSBwcmljZVNjYWxlSWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVJbmRleCA9IHBhbmVJbmRleCA/PyAwO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYXBwbHlQcmljZVNjYWxlT3B0aW9ucyh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQsIG9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX3BhbmVJbmRleCk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKCkuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICB9XG4gICAgd2lkdGgoKSB7XG4gICAgICAgIGlmICghaXNEZWZhdWx0UHJpY2VTY2FsZSh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2dldFByaWNlQXhpc1dpZHRoKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVJZCk7XG4gICAgfVxuICAgIHNldFZpc2libGVSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLnNldEF1dG9TY2FsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfc2V0Q3VzdG9tUHJpY2VSYW5nZShuZXcgUHJpY2VSYW5nZUltcGwocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVJhbmdlKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfcHJpY2VSYW5nZSgpO1xuICAgICAgICByZXR1cm4gcmFuZ2UgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgICAgICAgZnJvbTogcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksXG4gICAgICAgICAgICB0bzogcmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldEF1dG9TY2FsZShvbikge1xuICAgICAgICB0aGlzLmFwcGx5T3B0aW9ucyh7IGF1dG9TY2FsZTogb24gfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19wcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZmluZFByaWNlU2NhbGUodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkLCB0aGlzLl9wcml2YXRlX19wYW5lSW5kZXgpKS5faW50ZXJuYWxfcHJpY2VTY2FsZTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVBcGkge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0V2lkZ2V0LCBzZXJpZXNBcGlHZXR0ZXIsIHBhbmUsIGNoYXJ0QXBpKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0ID0gY2hhcnRXaWRnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNBcGlHZXR0ZXIgPSBzZXJpZXNBcGlHZXR0ZXI7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jaGFydEFwaSA9IGNoYXJ0QXBpO1xuICAgIH1cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9oZWlnaHQoKTtcbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBjb25zdCBjaGFydE1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHBhbmVJbmRleCA9IGNoYXJ0TW9kZWwuX2ludGVybmFsX2dldFBhbmVJbmRleCh0aGlzLl9wcml2YXRlX19wYW5lKTtcbiAgICAgICAgY2hhcnRNb2RlbC5faW50ZXJuYWxfY2hhbmdlUGFuZXNIZWlnaHQocGFuZUluZGV4LCBoZWlnaHQpO1xuICAgIH1cbiAgICBwYW5lSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZ2V0UGFuZUluZGV4KHRoaXMuX3ByaXZhdGVfX3BhbmUpO1xuICAgIH1cbiAgICBtb3ZlVG8ocGFuZUluZGV4KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMucGFuZUluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHBhbmVJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChwYW5lSW5kZXggPj0gMCAmJiBwYW5lSW5kZXggPCB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfcGFuZVdpZGdldHMoKS5sZW5ndGgsICdJbnZhbGlkIHBhbmUgaW5kZXgnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3N3YXBQYW5lcyhjdXJyZW50SW5kZXgsIHBhbmVJbmRleCk7XG4gICAgfVxuICAgIGdldFNlcmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3NlcmllcygpLm1hcCgoc291cmNlKSA9PiB0aGlzLl9wcml2YXRlX19zZXJpZXNBcGlHZXR0ZXIoc291cmNlKSkgPz8gW107XG4gICAgfVxuICAgIGdldEhUTUxFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX3BhbmVXaWRnZXRzKClbdGhpcy5wYW5lSW5kZXgoKV0uX2ludGVybmFsX2dldEVsZW1lbnQoKTtcbiAgICB9XG4gICAgYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9hdHRhY2hQcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5hdHRhY2hlZCkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmF0dGFjaGVkKHtcbiAgICAgICAgICAgICAgICBjaGFydDogdGhpcy5faW50ZXJuYWxfX2NoYXJ0QXBpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcGRhdGU6ICgpID0+IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Z1bGxVcGRhdGUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfZGV0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgfVxuICAgIHByaWNlU2NhbGUocHJpY2VTY2FsZUlkKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9wcmljZVNjYWxlQnlJZChwcmljZVNjYWxlSWQpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwcmljZSBzY2FsZSB3aXRoIGlkOiAke3ByaWNlU2NhbGVJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByaWNlU2NhbGVBcGkodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQsIHByaWNlU2NhbGVJZCwgdGhpcy5wYW5lSW5kZXgoKSk7XG4gICAgfVxufVxuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIl9idWlsZC10aW1lLWNvbnN0YW50c1wiIC8+XG5mdW5jdGlvbiBjaGVja1ByaWNlTGluZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wcmljZSA9PT0gJ251bWJlcicsIGB0aGUgdHlwZSBvZiAncHJpY2UnIHByaWNlIGxpbmUncyBwcm9wZXJ0eSBtdXN0IGJlIGEgbnVtYmVyLCBnb3QgJyR7dHlwZW9mIG9wdGlvbnMucHJpY2V9J2ApO1xufVxuZnVuY3Rpb24gY2hlY2tJdGVtc0FyZU9yZGVyZWQoZGF0YSwgYmgsIGFsbG93RHVwbGljYXRlcyA9IGZhbHNlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZUaW1lID0gYmgua2V5KGRhdGFbMF0udGltZSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gYmgua2V5KGRhdGFbaV0udGltZSk7XG4gICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gYWxsb3dEdXBsaWNhdGVzID8gcHJldlRpbWUgPD0gY3VycmVudFRpbWUgOiBwcmV2VGltZSA8IGN1cnJlbnRUaW1lO1xuICAgICAgICBhc3NlcnQoY2hlY2tSZXN1bHQsIGBkYXRhIG11c3QgYmUgYXNjIG9yZGVyZWQgYnkgdGltZSwgaW5kZXg9JHtpfSwgdGltZT0ke2N1cnJlbnRUaW1lfSwgcHJldiB0aW1lPSR7cHJldlRpbWV9YCk7XG4gICAgICAgIHByZXZUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTZXJpZXNWYWx1ZXNUeXBlKHR5cGUsIGRhdGEpIHtcbiAgICBkYXRhLmZvckVhY2goZ2V0Q2hlY2tlcih0eXBlKSk7XG59XG5mdW5jdGlvbiBnZXRDaGVja2VyKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnQmFyJzpcbiAgICAgICAgY2FzZSAnQ2FuZGxlc3RpY2snOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQmFySXRlbS5iaW5kKG51bGwsIHR5cGUpO1xuICAgICAgICBjYXNlICdBcmVhJzpcbiAgICAgICAgY2FzZSAnQmFzZWxpbmUnOlxuICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgY2FzZSAnSGlzdG9ncmFtJzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0xpbmVJdGVtLmJpbmQobnVsbCwgdHlwZSk7XG4gICAgICAgIGNhc2UgJ0N1c3RvbSc6XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tDdXN0b21JdGVtLmJpbmQobnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tCYXJJdGVtKHR5cGUsIGJhckl0ZW0pIHtcbiAgICBpZiAoIWlzRnVsZmlsbGVkRGF0YShiYXJJdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFsnb3BlbicsICdoaWdoJywgJ2xvdycsICdjbG9zZSddLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGJhckl0ZW1ba2V5XSA9PT0gJ251bWJlcicsIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgb2YgJHtrZXl9IG11c3QgYmUgYSBudW1iZXIsIGdvdD0ke3R5cGVvZiBiYXJJdGVtW2tleV19LCB2YWx1ZT0ke2Jhckl0ZW1ba2V5XX1gKTtcbiAgICAgICAgYXNzZXJ0KGlzU2FmZVZhbHVlKGJhckl0ZW1ba2V5XSksIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgb2YgJHtrZXl9IG11c3QgYmUgYmV0d2VlbiAke01JTl9TQUZFX1ZBTFVFLnRvUHJlY2lzaW9uKDE2KX0gYW5kICR7TUFYX1NBRkVfVkFMVUUudG9QcmVjaXNpb24oMTYpfSwgZ290PSR7dHlwZW9mIGJhckl0ZW1ba2V5XX0sIHZhbHVlPSR7YmFySXRlbVtrZXldfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tMaW5lSXRlbSh0eXBlLCBsaW5lSXRlbSkge1xuICAgIGlmICghaXNGdWxmaWxsZWREYXRhKGxpbmVJdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2VydCh0eXBlb2YgbGluZUl0ZW0udmFsdWUgPT09ICdudW1iZXInLCBgJHt0eXBlfSBzZXJpZXMgaXRlbSBkYXRhIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIGdvdD0ke3R5cGVvZiBsaW5lSXRlbS52YWx1ZX0sIHZhbHVlPSR7bGluZUl0ZW0udmFsdWV9YCk7XG4gICAgYXNzZXJ0KGlzU2FmZVZhbHVlKGxpbmVJdGVtLnZhbHVlKSwgYCR7dHlwZX0gc2VyaWVzIGl0ZW0gZGF0YSB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gJHtNSU5fU0FGRV9WQUxVRS50b1ByZWNpc2lvbigxNil9IGFuZCAke01BWF9TQUZFX1ZBTFVFLnRvUHJlY2lzaW9uKDE2KX0sIGdvdD0ke3R5cGVvZiBsaW5lSXRlbS52YWx1ZX0sIHZhbHVlPSR7bGluZUl0ZW0udmFsdWV9YCk7XG59XG5mdW5jdGlvbiBjaGVja0N1c3RvbUl0ZW0oXG4vLyB0eXBlOiAnQ3VzdG9tJyxcbi8vIGN1c3RvbUl0ZW06IFNlcmllc0RhdGFJdGVtVHlwZU1hcFt0eXBlb2YgdHlwZV1cbikge1xuICAgIC8vIE5vdGhpbmcgdG8gY2hlY2sgeWV0Li4uXG4gICAgcmV0dXJuO1xufVxuY29uc3QgTUlOX1NBRkVfVkFMVUUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAvIDEwMDtcbmNvbnN0IE1BWF9TQUZFX1ZBTFVFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDA7XG5mdW5jdGlvbiBpc1NhZmVWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSBNSU5fU0FGRV9WQUxVRSAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9WQUxVRTtcbn1cblxuY29uc3QgcHJpY2VMaW5lT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIGNvbG9yOiAnI0ZGMDAwMCcsXG4gICAgcHJpY2U6IDAsXG4gICAgbGluZVN0eWxlOiAyIC8qIExpbmVTdHlsZS5EYXNoZWQgKi8sXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGxpbmVWaXNpYmxlOiB0cnVlLFxuICAgIGF4aXNMYWJlbFZpc2libGU6IHRydWUsXG4gICAgdGl0bGU6ICcnLFxuICAgIGF4aXNMYWJlbENvbG9yOiAnJyxcbiAgICBheGlzTGFiZWxUZXh0Q29sb3I6ICcnLFxufTtcblxuY2xhc3MgUHJpY2VMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmljZUxpbmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lID0gcHJpY2VMaW5lO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIGRhdGFVcGRhdGVzQ29uc3VtZXIsIHByaWNlU2NhbGVBcGlQcm92aWRlciwgY2hhcnRBcGksIGhvcnpTY2FsZUJlaGF2aW9yLCBwYW5lQXBpR2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3NlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGFVcGRhdGVzQ29uc3VtZXIgPSBkYXRhVXBkYXRlc0NvbnN1bWVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlQXBpUHJvdmlkZXIgPSBwcmljZVNjYWxlQXBpUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jaGFydEFwaSA9IGNoYXJ0QXBpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQXBpR2V0dGVyID0gcGFuZUFwaUdldHRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgcHJpY2VGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKTtcbiAgICB9XG4gICAgcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UpIHtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxuICAgIGNvb3JkaW5hdGVUb1ByaWNlKGNvb3JkaW5hdGUpIHtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKGNvb3JkaW5hdGUsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICB9XG4gICAgYmFyc0luTG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgdXNlIFRpbWVTY2FsZVZpc2libGVSYW5nZSBoZXJlIHRvIGNvbnZlcnQgTG9naWNhbFJhbmdlIHRvIHN0cmljdCByYW5nZSBwcm9wZXJseVxuICAgICAgICBjb25zdCBjb3JyZWN0ZWRSYW5nZSA9IG5ldyBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UobmV3IFJhbmdlSW1wbChyYW5nZS5mcm9tLCByYW5nZS50bykpLl9pbnRlcm5hbF9zdHJpY3RSYW5nZSgpO1xuICAgICAgICBjb25zdCBiYXJzID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpO1xuICAgICAgICBpZiAoYmFycy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhRmlyc3RCYXJJblJhbmdlID0gYmFycy5faW50ZXJuYWxfc2VhcmNoKGNvcnJlY3RlZFJhbmdlLl9pbnRlcm5hbF9sZWZ0KCksIDEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdFJpZ2h0ICovKTtcbiAgICAgICAgY29uc3QgZGF0YUxhc3RCYXJJblJhbmdlID0gYmFycy5faW50ZXJuYWxfc2VhcmNoKGNvcnJlY3RlZFJhbmdlLl9pbnRlcm5hbF9yaWdodCgpLCAtMSAvKiBNaXNtYXRjaERpcmVjdGlvbi5OZWFyZXN0TGVmdCAqLyk7XG4gICAgICAgIGNvbnN0IGRhdGFGaXJzdEluZGV4ID0gZW5zdXJlTm90TnVsbChiYXJzLl9pbnRlcm5hbF9maXJzdEluZGV4KCkpO1xuICAgICAgICBjb25zdCBkYXRhTGFzdEluZGV4ID0gZW5zdXJlTm90TnVsbChiYXJzLl9pbnRlcm5hbF9sYXN0SW5kZXgoKSk7XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSByZXF1ZXN0IGRhdGEgaW4gdGhlIGRhdGEgZ2FwXG4gICAgICAgIC8vIGUuZy4gbGV0J3Mgc2F5IHdlIGhhdmUgc2VyaWVzIHdpdGggZGF0YSBbMC4uMTAsIDMwLi42MF1cbiAgICAgICAgLy8gYW5kIHdlIHJlcXVlc3QgYmFycyBpbmZvIGluIHJhbmdlIFsxNSwgMjVdXG4gICAgICAgIC8vIHRodXMsIGRhdGFGaXJzdEJhckluUmFuZ2Ugd2lsbCBiZSB3aXRoIGluZGV4IDMwIGFuZCBkYXRhTGFzdEJhckluUmFuZ2Ugd2l0aCAxMFxuICAgICAgICBpZiAoZGF0YUZpcnN0QmFySW5SYW5nZSAhPT0gbnVsbCAmJiBkYXRhTGFzdEJhckluUmFuZ2UgIT09IG51bGwgJiYgZGF0YUZpcnN0QmFySW5SYW5nZS5faW50ZXJuYWxfaW5kZXggPiBkYXRhTGFzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJhcnNCZWZvcmU6IHJhbmdlLmZyb20gLSBkYXRhRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBiYXJzQWZ0ZXI6IGRhdGFMYXN0SW5kZXggLSByYW5nZS50byxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFyc0JlZm9yZSA9IChkYXRhRmlyc3RCYXJJblJhbmdlID09PSBudWxsIHx8IGRhdGFGaXJzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4ID09PSBkYXRhRmlyc3RJbmRleClcbiAgICAgICAgICAgID8gcmFuZ2UuZnJvbSAtIGRhdGFGaXJzdEluZGV4XG4gICAgICAgICAgICA6IGRhdGFGaXJzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4IC0gZGF0YUZpcnN0SW5kZXg7XG4gICAgICAgIGNvbnN0IGJhcnNBZnRlciA9IChkYXRhTGFzdEJhckluUmFuZ2UgPT09IG51bGwgfHwgZGF0YUxhc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCA9PT0gZGF0YUxhc3RJbmRleClcbiAgICAgICAgICAgID8gZGF0YUxhc3RJbmRleCAtIHJhbmdlLnRvXG4gICAgICAgICAgICA6IGRhdGFMYXN0SW5kZXggLSBkYXRhTGFzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGJhcnNCZWZvcmUsIGJhcnNBZnRlciB9O1xuICAgICAgICAvLyBhY3R1YWxseSB0aGV5IGNhbid0IGV4aXN0IHNlcGFyYXRlbHlcbiAgICAgICAgaWYgKGRhdGFGaXJzdEJhckluUmFuZ2UgIT09IG51bGwgJiYgZGF0YUxhc3RCYXJJblJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZnJvbSA9IGRhdGFGaXJzdEJhckluUmFuZ2UuX2ludGVybmFsX29yaWdpbmFsVGltZTtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IGRhdGFMYXN0QmFySW5SYW5nZS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjaGVja0l0ZW1zQXJlT3JkZXJlZChkYXRhLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIGNoZWNrU2VyaWVzVmFsdWVzVHlwZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCksIGRhdGEpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YVVwZGF0ZXNDb25zdW1lci5faW50ZXJuYWxfYXBwbHlOZXdEYXRhKHRoaXMuX2ludGVybmFsX19zZXJpZXMsIGRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbkRhdGFDaGFuZ2VkKCdmdWxsJyk7XG4gICAgfVxuICAgIHVwZGF0ZShiYXIsIGhpc3RvcmljYWxVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBjaGVja1Nlcmllc1ZhbHVlc1R5cGUodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpLCBbYmFyXSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhVXBkYXRlc0NvbnN1bWVyLl9pbnRlcm5hbF91cGRhdGVEYXRhKHRoaXMuX2ludGVybmFsX19zZXJpZXMsIGJhciwgaGlzdG9yaWNhbFVwZGF0ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uRGF0YUNoYW5nZWQoJ3VwZGF0ZScpO1xuICAgIH1cbiAgICBkYXRhQnlJbmRleChsb2dpY2FsSW5kZXgsIG1pc21hdGNoRGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3NlYXJjaChsb2dpY2FsSW5kZXgsIG1pc21hdGNoRGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGl0IGNhbiBiZSBhIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0b3IgPSBnZXRTZXJpZXNEYXRhQ3JlYXRvcih0aGlzLnNlcmllc1R5cGUoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdG9yKGRhdGEpO1xuICAgIH1cbiAgICBkYXRhKCkge1xuICAgICAgICBjb25zdCBzZXJpZXNDcmVhdG9yID0gZ2V0U2VyaWVzRGF0YUNyZWF0b3IodGhpcy5zZXJpZXNUeXBlKCkpO1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9yb3dzKCk7XG4gICAgICAgIHJldHVybiByb3dzLm1hcCgocm93KSA9PiBzZXJpZXNDcmVhdG9yKHJvdykpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVEYXRhQ2hhbmdlZChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVEYXRhQ2hhbmdlZChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUuX2ludGVybmFsX3Vuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBjbG9uZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkpO1xuICAgIH1cbiAgICBwcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUFwaVByb3ZpZGVyLnByaWNlU2NhbGUodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9pZCgpLCB0aGlzLmdldFBhbmUoKS5wYW5lSW5kZXgoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVByaWNlTGluZShvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrUHJpY2VMaW5lT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3RyaWN0T3B0aW9ucyA9IG1lcmdlKGNsb25lKHByaWNlTGluZU9wdGlvbnNEZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwcmljZUxpbmUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9jcmVhdGVQcmljZUxpbmUoc3RyaWN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VMaW5lKHByaWNlTGluZSk7XG4gICAgfVxuICAgIHJlbW92ZVByaWNlTGluZShsaW5lKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3JlbW92ZVByaWNlTGluZShsaW5lLl9pbnRlcm5hbF9wcmljZUxpbmUoKSk7XG4gICAgfVxuICAgIHByaWNlTGluZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZUxpbmVzKCkubWFwKChwcmljZUxpbmUpID0+IG5ldyBQcmljZUxpbmUocHJpY2VMaW5lKSk7XG4gICAgfVxuICAgIHNlcmllc1R5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCk7XG4gICAgfVxuICAgIGF0dGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBjYXN0IHRoZSBnZW5lcmljIHRvIHVua25vd24gYmVjYXVzZSB3ZVxuICAgICAgICAvLyBkb24ndCB3YW50IHRoZSBtb2RlbCB0byBrbm93IHRoZSB0eXBlcyBvZiB0aGUgQVBJICjil5Ff4peRKVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9hdHRhY2hQcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5hdHRhY2hlZCkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmF0dGFjaGVkKHtcbiAgICAgICAgICAgICAgICBjaGFydDogdGhpcy5faW50ZXJuYWxfX2NoYXJ0QXBpLFxuICAgICAgICAgICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXBkYXRlOiAoKSA9PiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCksXG4gICAgICAgICAgICAgICAgaG9yelNjYWxlQmVoYXZpb3I6IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9kZXRhY2hQcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5kZXRhY2hlZCkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmRldGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXRQYW5lKCkge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzO1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHNlcmllcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZUFwaUdldHRlcihwYW5lKTtcbiAgICB9XG4gICAgbW92ZVRvUGFuZShwYW5lSW5kZXgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfbW92ZVNlcmllc1RvUGFuZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLCBwYW5lSW5kZXgpO1xuICAgIH1cbiAgICBzZXJpZXNPcmRlcigpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3BhbmVGb3JTb3VyY2UodGhpcy5faW50ZXJuYWxfX3Nlcmllcyk7XG4gICAgICAgIGlmIChwYW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhbmUuX2ludGVybmFsX3NlcmllcygpLmluZGV4T2YodGhpcy5faW50ZXJuYWxfX3Nlcmllcyk7XG4gICAgfVxuICAgIHNldFNlcmllc09yZGVyKG9yZGVyKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHRoaXMuX2ludGVybmFsX19zZXJpZXMpO1xuICAgICAgICBpZiAocGFuZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3NldFNlcmllc09yZGVyKHRoaXMuX2ludGVybmFsX19zZXJpZXMsIG9yZGVyKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uRGF0YUNoYW5nZWQoc2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkRGVsZWdhdGUuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVGltZVNjYWxlQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgdGltZUF4aXNXaWRnZXQsIGhvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0ID0gdGltZUF4aXNXaWRnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZUJhcnNDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblZpc2libGVCYXJzQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfc2l6ZUNoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uU2l6ZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVCYXJzQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfc2l6ZUNoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbiwgYW5pbWF0ZWQpIHtcbiAgICAgICAgaWYgKCFhbmltYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvT2Zmc2V0QW5pbWF0ZWQocG9zaXRpb24sIDEwMDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvbkR1cmF0aW9uTXMgKi8pO1xuICAgIH1cbiAgICBzY3JvbGxUb1JlYWxUaW1lKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Njcm9sbFRvUmVhbFRpbWUoKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVJhbmdlKCkge1xuICAgICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVUaW1lUmFuZ2UoKTtcbiAgICAgICAgaWYgKHRpbWVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHRpbWVSYW5nZS5mcm9tLm9yaWdpbmFsVGltZSxcbiAgICAgICAgICAgIHRvOiB0aW1lUmFuZ2UudG8ub3JpZ2luYWxUaW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRWaXNpYmxlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkUmFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKHJhbmdlLmZyb20pLFxuICAgICAgICAgICAgdG86IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwocmFuZ2UudG8pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2dpY2FsUmFuZ2UgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2xvZ2ljYWxSYW5nZUZvclRpbWVSYW5nZShjb252ZXJ0ZWRSYW5nZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRUYXJnZXRMb2dpY2FsUmFuZ2UobG9naWNhbFJhbmdlKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgbG9naWNhbFJhbmdlID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlTG9naWNhbFJhbmdlKCk7XG4gICAgICAgIGlmIChsb2dpY2FsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBsb2dpY2FsUmFuZ2UuX2ludGVybmFsX2xlZnQoKSxcbiAgICAgICAgICAgIHRvOiBsb2dpY2FsUmFuZ2UuX2ludGVybmFsX3JpZ2h0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFZpc2libGVMb2dpY2FsUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0KHJhbmdlLmZyb20gPD0gcmFuZ2UudG8sICdUaGUgZnJvbSBpbmRleCBjYW5ub3QgYmUgYWZ0ZXIgdGhlIHRvIGluZGV4LicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0VGFyZ2V0TG9naWNhbFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgcmVzZXRUaW1lU2NhbGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpO1xuICAgIH1cbiAgICBmaXRDb250ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZml0Q29udGVudCgpO1xuICAgIH1cbiAgICBsb2dpY2FsVG9Db29yZGluYXRlKGxvZ2ljYWwpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUobG9naWNhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29vcmRpbmF0ZVRvTG9naWNhbCh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9JbmRleCh4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aW1lVG9JbmRleCh0aW1lLCBmaW5kTmVhcmVzdCkge1xuICAgICAgICBjb25zdCB0aW1lUG9pbnQgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKHRpbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF90aW1lVG9JbmRleCh0aW1lUG9pbnQsIGZpbmROZWFyZXN0KTtcbiAgICB9XG4gICAgdGltZVRvQ29vcmRpbmF0ZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVQb2ludEluZGV4ID0gdGhpcy50aW1lVG9JbmRleCh0aW1lLCBmYWxzZSk7XG4gICAgICAgIGlmICh0aW1lUG9pbnRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUodGltZVBvaW50SW5kZXgpO1xuICAgIH1cbiAgICBjb29yZGluYXRlVG9UaW1lKHgpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBjb25zdCB0aW1lUG9pbnRJbmRleCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvSW5kZXgoeCk7XG4gICAgICAgIGNvbnN0IHRpbWVQb2ludCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KHRpbWVQb2ludEluZGV4KTtcbiAgICAgICAgaWYgKHRpbWVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVQb2ludC5vcmlnaW5hbFRpbWU7XG4gICAgfVxuICAgIHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldFNpemUoKS53aWR0aDtcbiAgICB9XG4gICAgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldFNpemUoKS5oZWlnaHQ7XG4gICAgfVxuICAgIHN1YnNjcmliZVZpc2libGVUaW1lUmFuZ2VDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlVmlzaWJsZVRpbWVSYW5nZUNoYW5nZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQuX2ludGVybmFsX3Vuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVWaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlU2l6ZUNoYW5nZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlU2l6ZUNoYW5nZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jbG9uZSh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKSksXG4gICAgICAgICAgICBiYXJTcGFjaW5nOiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uVmlzaWJsZUJhcnNDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGltZVJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQuX2ludGVybmFsX2ZpcmUodGhpcy5nZXRWaXNpYmxlUmFuZ2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX29uVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSh0aGlzLmdldFZpc2libGVMb2dpY2FsUmFuZ2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX29uU2l6ZUNoYW5nZWQoc2l6ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfZmlyZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgfVxufVxuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIl9idWlsZC10aW1lLWNvbnN0YW50c1wiIC8+XG5mdW5jdGlvbiBwYXRjaFByaWNlRm9ybWF0KHByaWNlRm9ybWF0KSB7XG4gICAgaWYgKHByaWNlRm9ybWF0ID09PSB1bmRlZmluZWQgfHwgcHJpY2VGb3JtYXQudHlwZSA9PT0gJ2N1c3RvbScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmljZUZvcm1hdEJ1aWx0SW4gPSBwcmljZUZvcm1hdDtcbiAgICBpZiAocHJpY2VGb3JtYXRCdWlsdEluLm1pbk1vdmUgIT09IHVuZGVmaW5lZCAmJiBwcmljZUZvcm1hdEJ1aWx0SW4ucHJlY2lzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJpY2VGb3JtYXRCdWlsdEluLnByZWNpc2lvbiA9IHByZWNpc2lvbkJ5TWluTW92ZShwcmljZUZvcm1hdEJ1aWx0SW4ubWluTW92ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWlncmF0ZUhhbmRsZVNjYWxlU2Nyb2xsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKGlzQm9vbGVhbihvcHRpb25zWydoYW5kbGVTY2FsZSddKSkge1xuICAgICAgICBjb25zdCBoYW5kbGVTY2FsZSA9IG9wdGlvbnNbJ2hhbmRsZVNjYWxlJ107XG4gICAgICAgIG9wdGlvbnNbJ2hhbmRsZVNjYWxlJ10gPSB7XG4gICAgICAgICAgICBheGlzRG91YmxlQ2xpY2tSZXNldDoge1xuICAgICAgICAgICAgICAgIHRpbWU6IGhhbmRsZVNjYWxlLFxuICAgICAgICAgICAgICAgIHByaWNlOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBheGlzUHJlc3NlZE1vdXNlTW92ZToge1xuICAgICAgICAgICAgICAgIHRpbWU6IGhhbmRsZVNjYWxlLFxuICAgICAgICAgICAgICAgIHByaWNlOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZVdoZWVsOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgICAgIHBpbmNoOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uc1snaGFuZGxlU2NhbGUnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgYXhpc1ByZXNzZWRNb3VzZU1vdmUsIGF4aXNEb3VibGVDbGlja1Jlc2V0IH0gPSBvcHRpb25zWydoYW5kbGVTY2FsZSddO1xuICAgICAgICBpZiAoaXNCb29sZWFuKGF4aXNQcmVzc2VkTW91c2VNb3ZlKSkge1xuICAgICAgICAgICAgb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBheGlzUHJlc3NlZE1vdXNlTW92ZSxcbiAgICAgICAgICAgICAgICBwcmljZTogYXhpc1ByZXNzZWRNb3VzZU1vdmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oYXhpc0RvdWJsZUNsaWNrUmVzZXQpKSB7XG4gICAgICAgICAgICBvcHRpb25zWydoYW5kbGVTY2FsZSddLmF4aXNEb3VibGVDbGlja1Jlc2V0ID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IGF4aXNEb3VibGVDbGlja1Jlc2V0LFxuICAgICAgICAgICAgICAgIHByaWNlOiBheGlzRG91YmxlQ2xpY2tSZXNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gb3B0aW9uc1snaGFuZGxlU2Nyb2xsJ107XG4gICAgaWYgKGlzQm9vbGVhbihoYW5kbGVTY3JvbGwpKSB7XG4gICAgICAgIG9wdGlvbnNbJ2hhbmRsZVNjcm9sbCddID0ge1xuICAgICAgICAgICAgaG9yelRvdWNoRHJhZzogaGFuZGxlU2Nyb2xsLFxuICAgICAgICAgICAgdmVydFRvdWNoRHJhZzogaGFuZGxlU2Nyb2xsLFxuICAgICAgICAgICAgbW91c2VXaGVlbDogaGFuZGxlU2Nyb2xsLFxuICAgICAgICAgICAgcHJlc3NlZE1vdXNlTW92ZTogaGFuZGxlU2Nyb2xsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvSW50ZXJuYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBtaWdyYXRlSGFuZGxlU2NhbGVTY3JvbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuY2xhc3MgQ2hhcnRBcGkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgaG9yelNjYWxlQmVoYXZpb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyID0gbmV3IERhdGFMYXllcihob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGNsb25lKGNoYXJ0T3B0aW9uc0RlZmF1bHRzKCkpIDpcbiAgICAgICAgICAgIG1lcmdlKGNsb25lKGNoYXJ0T3B0aW9uc0RlZmF1bHRzKCkpLCB0b0ludGVybmFsT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCA9IG5ldyBDaGFydFdpZGdldChjb250YWluZXIsIGludGVybmFsT3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUoKHBhcmFtU3VwcGxpZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX2NvbnZlcnRNb3VzZVBhcmFtcyhwYXJhbVN1cHBsaWVyKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9kYmxDbGlja2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSgocGFyYW1TdXBwbGllcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX2ZpcmUodGhpcy5fcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zKHBhcmFtU3VwcGxpZXIoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkKCkuX2ludGVybmFsX3N1YnNjcmliZSgocGFyYW1TdXBwbGllcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZS5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19jb252ZXJ0TW91c2VQYXJhbXMocGFyYW1TdXBwbGllcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVBcGkgPSBuZXcgVGltZVNjYWxlQXBpKG1vZGVsLCB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfdGltZUF4aXNXaWRnZXQoKSwgdGhpcy5faW50ZXJuYWxfX2hvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlQXBpLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBmb3JjZVJlcGFpbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1NpemVBY3RpdmUoKSkge1xuICAgICAgICAgICAgLy8gV2UgcmV0dXJuIGVhcmx5IGhlcmUgaW5zdGVhZCBvZiBjaGVja2luZyB0aGlzIHdpdGhpbiB0aGUgYWN0dWFsIF9jaGFydFdpZGdldC5yZXNpemUgbWV0aG9kXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgYXBwbHkgdG8gZXh0ZXJuYWwgcmVzaXplIHJlcXVlc3RzLlxuICAgICAgICAgICAgd2FybihgSGVpZ2h0IGFuZCB3aWR0aCB2YWx1ZXMgaWdub3JlZCBiZWNhdXNlICdhdXRvU2l6ZScgb3B0aW9uIGlzIGVuYWJsZWQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBmb3JjZVJlcGFpbnQpO1xuICAgIH1cbiAgICBhZGRDdXN0b21TZXJpZXMoY3VzdG9tUGFuZVZpZXcsIG9wdGlvbnMgPSB7fSwgcGFuZUluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBwYW5lVmlldyA9IGVuc3VyZShjdXN0b21QYW5lVmlldyk7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjcmVhdGVDdXN0b21TZXJpZXNEZWZpbml0aW9uKHBhbmVWaWV3KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwoZGVmaW5pdGlvbiwgb3B0aW9ucywgcGFuZUluZGV4KTtcbiAgICB9XG4gICAgYWRkU2VyaWVzKGRlZmluaXRpb24sIG9wdGlvbnMgPSB7fSwgcGFuZUluZGV4ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbChkZWZpbml0aW9uLCBvcHRpb25zLCBwYW5lSW5kZXgpO1xuICAgIH1cbiAgICByZW1vdmVTZXJpZXMoc2VyaWVzQXBpKSB7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwLmdldChzZXJpZXNBcGkpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF9yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3JlbW92ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZW5kVXBkYXRlVG9DaGFydCh1cGRhdGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAuZGVsZXRlKHNlcmllc0FwaSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcFJldmVyc2VkLmRlbGV0ZShzZXJpZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlOZXdEYXRhKHNlcmllcywgZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZW5kVXBkYXRlVG9DaGFydCh0aGlzLl9wcml2YXRlX19kYXRhTGF5ZXIuX2ludGVybmFsX3NldFNlcmllc0RhdGEoc2VyaWVzLCBkYXRhKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVEYXRhKHNlcmllcywgZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZW5kVXBkYXRlVG9DaGFydCh0aGlzLl9wcml2YXRlX19kYXRhTGF5ZXIuX2ludGVybmFsX3VwZGF0ZVNlcmllc0RhdGEoc2VyaWVzLCBkYXRhLCBoaXN0b3JpY2FsVXBkYXRlKSk7XG4gICAgfVxuICAgIHN1YnNjcmliZUNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX3Vuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVDcm9zc2hhaXJNb3ZlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZS5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUNyb3NzaGFpck1vdmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlRGJsQ2xpY2soaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVEYmxDbGljayhoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHByaWNlU2NhbGUocHJpY2VTY2FsZUlkLCBwYW5lSW5kZXggPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VTY2FsZUFwaSh0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCwgcHJpY2VTY2FsZUlkLCBwYW5lSW5kZXgpO1xuICAgIH1cbiAgICB0aW1lU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVBcGk7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yU3BhY2UgPSBvcHRpb25zLmxheW91dD8uY29sb3JTcGFjZTtcbiAgICAgICAgICAgIGlmIChjb2xvclNwYWNlICE9PSB1bmRlZmluZWQgJiYgY29sb3JTcGFjZSAhPT0gdGhpcy5vcHRpb25zKCkubGF5b3V0LmNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbG9yU3BhY2Ugb3B0aW9uIHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHRoZSBjaGFydCBoYXMgYmVlbiBjcmVhdGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29sb3JQYXJzZXJzID0gb3B0aW9ucy5sYXlvdXQ/LmNvbG9yUGFyc2VycztcbiAgICAgICAgICAgIGlmIChjb2xvclBhcnNlcnMgIT09IHVuZGVmaW5lZCAmJiBjb2xvclBhcnNlcnMgIT09IHRoaXMub3B0aW9ucygpLmxheW91dC5jb2xvclBhcnNlcnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbG9yUGFyc2VycyBvcHRpb24gc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2UgdGhlIGNoYXJ0IGhhcyBiZWVuIGNyZWF0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2FwcGx5T3B0aW9ucyh0b0ludGVybmFsT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgIH1cbiAgICB0YWtlU2NyZWVuc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF90YWtlU2NyZWVuc2hvdCgpO1xuICAgIH1cbiAgICByZW1vdmVQYW5lKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9yZW1vdmVQYW5lKGluZGV4KTtcbiAgICB9XG4gICAgc3dhcFBhbmVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3N3YXBQYW5lcyhmaXJzdCwgc2Vjb25kKTtcbiAgICB9XG4gICAgYXV0b1NpemVBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfYXV0b1NpemVBY3RpdmUoKTtcbiAgICB9XG4gICAgY2hhcnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2VsZW1lbnQoKTtcbiAgICB9XG4gICAgcGFuZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZXMoKS5tYXAoKHBhbmUpID0+IHRoaXMuX3ByaXZhdGVfX2dldFBhbmVBcGkocGFuZSkpO1xuICAgIH1cbiAgICBwYW5lU2l6ZShwYW5lSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfcGFuZVNpemUocGFuZUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q3Jvc3NoYWlyUG9zaXRpb24ocHJpY2UsIGhvcml6b250YWxQb3NpdGlvbiwgc2VyaWVzQXBpKSB7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcC5nZXQoc2VyaWVzQXBpKTtcbiAgICAgICAgaWYgKHNlcmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHNlcmllcyk7XG4gICAgICAgIGlmIChwYW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3NldEFuZFNhdmVTeW50aGV0aWNQb3NpdGlvbihwcmljZSwgaG9yaXpvbnRhbFBvc2l0aW9uLCBwYW5lKTtcbiAgICB9XG4gICAgY2xlYXJDcm9zc2hhaXJQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2NsZWFyQ3VycmVudFBvc2l0aW9uKHRydWUpO1xuICAgIH1cbiAgICBob3J6QmVoYXZpb3VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX2hvcnpTY2FsZUJlaGF2aW9yO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWRkU2VyaWVzSW1wbChkZWZpbml0aW9uLCBvcHRpb25zID0ge30sIHBhbmVJbmRleCA9IDApIHtcbiAgICAgICAgYXNzZXJ0KGlzU2VyaWVzRGVmaW5pdGlvbihkZWZpbml0aW9uKSk7XG4gICAgICAgIHBhdGNoUHJpY2VGb3JtYXQob3B0aW9ucy5wcmljZUZvcm1hdCk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUgPT09ICdDYW5kbGVzdGljaycpIHtcbiAgICAgICAgICAgIGZpbGxVcERvd25DYW5kbGVzdGlja3NDb2xvcnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaWN0T3B0aW9ucyA9IG1lcmdlKGNsb25lKHNlcmllc09wdGlvbnNEZWZhdWx0cyksIGNsb25lKGRlZmluaXRpb24uZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY3JlYXRlUGFuZVZpZXcgPSBkZWZpbml0aW9uLl9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldztcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKSwgZGVmaW5pdGlvbi50eXBlLCBzdHJpY3RPcHRpb25zLCBjcmVhdGVQYW5lVmlldywgZGVmaW5pdGlvbi5faW50ZXJuYWxfY3VzdG9tUGFuZVZpZXcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfYWRkU2VyaWVzVG9QYW5lKHNlcmllcywgcGFuZUluZGV4KTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFNlcmllc0FwaShzZXJpZXMsIHRoaXMsIHRoaXMsIHRoaXMsIHRoaXMuX2ludGVybmFsX19ob3J6U2NhbGVCZWhhdmlvciwgKHBhbmUpID0+IHRoaXMuX3ByaXZhdGVfX2dldFBhbmVBcGkocGFuZSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAuc2V0KHJlcywgc2VyaWVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQuc2V0KHNlcmllcywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NlbmRVcGRhdGVUb0NoYXJ0KHVwZGF0ZSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfdXBkYXRlVGltZVNjYWxlKHVwZGF0ZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9iYXNlSW5kZXgsIHVwZGF0ZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9wb2ludHMsIHVwZGF0ZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9maXJzdENoYW5nZWRQb2ludEluZGV4KTtcbiAgICAgICAgdXBkYXRlLl9pbnRlcm5hbF9zZXJpZXMuZm9yRWFjaCgodmFsdWUsIHNlcmllcykgPT4gc2VyaWVzLl9pbnRlcm5hbF9zZXREYXRhKHZhbHVlLl9pbnRlcm5hbF9kYXRhLCB2YWx1ZS5faW50ZXJuYWxfaW5mbykpO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX3JlY2FsY3VsYXRlSW5kaWNlc1dpdGhEYXRhKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXBTZXJpZXNUb0FwaShzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQuZ2V0KHNlcmllcykpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zKHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHBhcmFtLl9pbnRlcm5hbF9zZXJpZXNEYXRhLmZvckVhY2goKHBsb3RSb3csIHNlcmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHNlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldFNlcmllc0RhdGFDcmVhdG9yKHNlcmllc1R5cGUpKHBsb3RSb3cpO1xuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgIT09ICdDdXN0b20nKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlzRnVsZmlsbGVkRGF0YShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzV2hpdGVzcGFjZUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KCFjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciB8fCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlcihkYXRhKSA9PT0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VyaWVzRGF0YS5zZXQodGhpcy5fcHJpdmF0ZV9fbWFwU2VyaWVzVG9BcGkoc2VyaWVzKSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBob3ZlcmVkU2VyaWVzID0gcGFyYW0uX2ludGVybmFsX2hvdmVyZWRTZXJpZXMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgIXRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcFJldmVyc2VkLmhhcyhwYXJhbS5faW50ZXJuYWxfaG92ZXJlZFNlcmllcylcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHRoaXMuX3ByaXZhdGVfX21hcFNlcmllc1RvQXBpKHBhcmFtLl9pbnRlcm5hbF9ob3ZlcmVkU2VyaWVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWU6IHBhcmFtLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWUsXG4gICAgICAgICAgICBsb2dpY2FsOiBwYXJhbS5faW50ZXJuYWxfaW5kZXgsXG4gICAgICAgICAgICBwb2ludDogcGFyYW0uX2ludGVybmFsX3BvaW50LFxuICAgICAgICAgICAgcGFuZUluZGV4OiBwYXJhbS5faW50ZXJuYWxfcGFuZUluZGV4LFxuICAgICAgICAgICAgaG92ZXJlZFNlcmllcyxcbiAgICAgICAgICAgIGhvdmVyZWRPYmplY3RJZDogcGFyYW0uX2ludGVybmFsX2hvdmVyZWRPYmplY3QsXG4gICAgICAgICAgICBzZXJpZXNEYXRhLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IHBhcmFtLl9pbnRlcm5hbF90b3VjaE1vdXNlRXZlbnREYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0UGFuZUFwaShwYW5lKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9wcml2YXRlX19wYW5lcy5nZXQocGFuZSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFuZUFwaSh0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCwgKHNlcmllcykgPT4gdGhpcy5fcHJpdmF0ZV9fbWFwU2VyaWVzVG9BcGkoc2VyaWVzKSwgcGFuZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5zZXQocGFuZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmV0Y2hIdG1sRWxlbWVudChjb250YWluZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyKTtcbiAgICAgICAgYXNzZXJ0KGVsZW1lbnQgIT09IG51bGwsIGBDYW5ub3QgZmluZCBlbGVtZW50IGluIERPTSB3aXRoIGlkPSR7Y29udGFpbmVyfWApO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBvZiB0aGUgTGlnaHR3ZWlnaHQgQ2hhcnRpbmcgTGlicmFyeS4gSWYgeW91IGFyZSB1c2luZyB0aW1lIHZhbHVlc1xuICogZm9yIHRoZSBob3Jpem9udGFsIHNjYWxlIHRoZW4gaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmF0aGVyIHVzZSB0aGUge0BsaW5rIGNyZWF0ZUNoYXJ0fSBmdW5jdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgSG9yelNjYWxlSXRlbSAtIHR5cGUgb2YgcG9pbnRzIG9uIHRoZSBob3Jpem9udGFsIHNjYWxlXG4gKiBAdGVtcGxhdGUgVEhvcnpTY2FsZUJlaGF2aW9yIC0gdHlwZSBvZiBob3Jpem9udGFsIGF4aXMgc3RyYXRlZ3kgdGhhdCBlbmNhcHN1bGF0ZSBhbGwgdGhlIHNwZWNpZmljIGJlaGF2aW9ycyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FsZSB0eXBlXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciAtIElEIG9mIEhUTUwgZWxlbWVudCBvciBlbGVtZW50IGl0c2VsZlxuICogQHBhcmFtIGhvcnpTY2FsZUJlaGF2aW9yIC0gSG9yaXpvbnRhbCBzY2FsZSBiZWhhdmlvclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbnkgc3Vic2V0IG9mIG9wdGlvbnMgdG8gYmUgYXBwbGllZCBhdCBzdGFydC5cbiAqIEByZXR1cm5zIEFuIGludGVyZmFjZSB0byB0aGUgY3JlYXRlZCBjaGFydFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFydEV4KGNvbnRhaW5lciwgaG9yelNjYWxlQmVoYXZpb3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGZldGNoSHRtbEVsZW1lbnQoY29udGFpbmVyKTtcbiAgICBjb25zdCByZXMgPSBuZXcgQ2hhcnRBcGkoaHRtbEVsZW1lbnQsIGhvcnpTY2FsZUJlaGF2aW9yLCBvcHRpb25zKTtcbiAgICBob3J6U2NhbGVCZWhhdmlvci5zZXRPcHRpb25zKHJlcy5vcHRpb25zKCkpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIHNpbXBsaWZpZWQgbWFpbiBlbnRyeSBwb2ludCBvZiB0aGUgTGlnaHR3ZWlnaHQgQ2hhcnRpbmcgTGlicmFyeSB3aXRoIHRpbWUgcG9pbnRzIGZvciB0aGUgaG9yaXpvbnRhbCBzY2FsZS5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIC0gSUQgb2YgSFRNTCBlbGVtZW50IG9yIGVsZW1lbnQgaXRzZWxmXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFueSBzdWJzZXQgb2Ygb3B0aW9ucyB0byBiZSBhcHBsaWVkIGF0IHN0YXJ0LlxuICogQHJldHVybnMgQW4gaW50ZXJmYWNlIHRvIHRoZSBjcmVhdGVkIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVDaGFydEV4KGNvbnRhaW5lciwgbmV3IEhvcnpTY2FsZUJlaGF2aW9yVGltZSgpLCBIb3J6U2NhbGVCZWhhdmlvclRpbWUuX2ludGVybmFsX2FwcGx5RGVmYXVsdHMob3B0aW9ucykpO1xufVxuLyoqXG4gKiBQcm92aWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgaG9yaXpvbnRhbCBzY2FsZSAodGltZS1iYXNlZCkgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGJhc2UgZm9yIGV4dGVuZGluZyB0aGUgaG9yaXpvbnRhbCBzY2FsZSB3aXRoIGN1c3RvbSBiZWhhdmlvci5cbiAqIFRoaXMgYWxsb3dzIGZvciB0aGUgaW50cm9kdWN0aW9uIG9mIGN1c3RvbSBmdW5jdGlvbmFsaXR5IHdpdGhvdXQgcmUtaW1wbGVtZW50aW5nIHRoZSBlbnRpcmUge0BsaW5rIElIb3J6U2NhbGVCZWhhdmlvcn0mbHQ7e0BsaW5rIFRpbWV9Jmd0OyBpbnRlcmZhY2UuXG4gKlxuICogRm9yIGZ1cnRoZXIgZGV0YWlscywgcmVmZXIgdG8gdGhlIHtAbGluayBjcmVhdGVDaGFydEV4fSBjaGFydCBjb25zdHJ1Y3RvciBtZXRob2QuXG4gKlxuICogQHJldHVybnMgQW4gdW5pbml0aWFsaXplZCBjbGFzcyBpbXBsZW1lbnRpbmcgdGhlIHtAbGluayBJSG9yelNjYWxlQmVoYXZpb3J9Jmx0O3tAbGluayBUaW1lfSZndDsgaW50ZXJmYWNlXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRIb3J6U2NhbGVCZWhhdmlvcigpIHtcbiAgICByZXR1cm4gSG9yelNjYWxlQmVoYXZpb3JUaW1lO1xufVxuXG5jbGFzcyBMaW5lUGFuZVZpZXdCYXNlIGV4dGVuZHMgU2VyaWVzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgbW9kZWwsIHRydWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NvbnZlcnRUb0Nvb3JkaW5hdGVzKHByaWNlU2NhbGUsIHRpbWVTY2FsZSwgZmlyc3RWYWx1ZSkge1xuICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4ZXNUb0Nvb3JkaW5hdGVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgdW5kZWZpbmVkSWZOdWxsKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSkpO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9wb2ludHNBcnJheVRvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCBmaXJzdFZhbHVlLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aW1lOiB0aW1lLFxuICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlOiBwcmljZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF94OiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfeTogTmFOLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2ZpbGxSYXdQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yZXIgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJDb2xvcmVyKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfcm93cygpLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdy5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0ocm93Ll9pbnRlcm5hbF9pbmRleCwgdmFsdWUsIGNvbG9yZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdTZXJpZXNQb2ludE1hcmtlcnMocmVuZGVyaW5nU2NvcGUsIGl0ZW1zLCBwb2ludE1hcmtlcnNSYWRpdXMsIHZpc2libGVSYW5nZSwgXG4vLyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHN0eWxlR2V0dGVyIGFyZSBjb21wYXJlZCB1c2luZyB0aGUgb3BlcmF0b3IgIT09LFxuLy8gc28gaWYgc3R5bGVHZXR0ZXIgcmV0dXJucyBvYmplY3RzLCB0aGVuIHN0eWxlR2V0dGVyIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgb2JqZWN0IGZvciBlcXVhbCBzdHlsZXNcbnN0eWxlR2V0dGVyKSB7XG4gICAgaWYgKHZpc2libGVSYW5nZS50byAtIHZpc2libGVSYW5nZS5mcm9tIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8sIGNvbnRleHQgfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgIGxldCBwcmV2U3R5bGUgPSBudWxsO1xuICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gKHRpY2tXaWR0aCAlIDIpIC8gMjtcbiAgICBjb25zdCByYWRpdXMgPSBwb2ludE1hcmtlcnNSYWRpdXMgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8gKyBjb3JyZWN0aW9uO1xuICAgIGZvciAobGV0IGkgPSB2aXNpYmxlUmFuZ2UudG8gLSAxOyBpID49IHZpc2libGVSYW5nZS5mcm9tOyAtLWkpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlR2V0dGVyKHJlbmRlcmluZ1Njb3BlLCBwb2ludCk7XG4gICAgICAgICAgICBpZiAoc3R5bGUgIT09IHByZXZTdHlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZTdHlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBNYXRoLnJvdW5kKHBvaW50Ll9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pICsgY29ycmVjdGlvbjsgLy8gY29ycmVjdCB4IGNvb3JkaW5hdGUgb25seVxuICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IHBvaW50Ll9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LmZpbGwoKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXMsIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHdhbGtMaW5lKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgbGluZVR5cGUsIHZpc2libGVSYW5nZSwgYmFyV2lkdGgsIFxuLy8gdGhlIHZhbHVlcyByZXR1cm5lZCBieSBzdHlsZUdldHRlciBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIG9wZXJhdG9yICE9PSxcbi8vIHNvIGlmIHN0eWxlR2V0dGVyIHJldHVybnMgb2JqZWN0cywgdGhlbiBzdHlsZUdldHRlciBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCBmb3IgZXF1YWwgc3R5bGVzXG5zdHlsZUdldHRlciwgZmluaXNoU3R5bGVkQXJlYSkge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDAgfHwgdmlzaWJsZVJhbmdlLmZyb20gPj0gaXRlbXMubGVuZ3RoIHx8IHZpc2libGVSYW5nZS50byA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgIGNvbnN0IGZpcnN0SXRlbSA9IGl0ZW1zW3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICBsZXQgY3VycmVudFN0eWxlID0gc3R5bGVHZXR0ZXIocmVuZGVyaW5nU2NvcGUsIGZpcnN0SXRlbSk7XG4gICAgbGV0IGN1cnJlbnRTdHlsZUZpcnN0SXRlbSA9IGZpcnN0SXRlbTtcbiAgICBpZiAodmlzaWJsZVJhbmdlLnRvIC0gdmlzaWJsZVJhbmdlLmZyb20gPCAyKSB7XG4gICAgICAgIGNvbnN0IGhhbGZCYXJXaWR0aCA9IGJhcldpZHRoIC8gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBpdGVtMSA9IHsgX2ludGVybmFsX3g6IGZpcnN0SXRlbS5faW50ZXJuYWxfeCAtIGhhbGZCYXJXaWR0aCwgX2ludGVybmFsX3k6IGZpcnN0SXRlbS5faW50ZXJuYWxfeSB9O1xuICAgICAgICBjb25zdCBpdGVtMiA9IHsgX2ludGVybmFsX3g6IGZpcnN0SXRlbS5faW50ZXJuYWxfeCArIGhhbGZCYXJXaWR0aCwgX2ludGVybmFsX3k6IGZpcnN0SXRlbS5faW50ZXJuYWxfeSB9O1xuICAgICAgICBjdHgubW92ZVRvKGl0ZW0xLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW0xLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmxpbmVUbyhpdGVtMi5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBpdGVtMi5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGZpbmlzaFN0eWxlZEFyZWEocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRTdHlsZSwgaXRlbTEsIGl0ZW0yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZVN0eWxlID0gKG5ld1N0eWxlLCBjdXJyZW50SXRlbSkgPT4ge1xuICAgICAgICAgICAgZmluaXNoU3R5bGVkQXJlYShyZW5kZXJpbmdTY29wZSwgY3VycmVudFN0eWxlLCBjdXJyZW50U3R5bGVGaXJzdEl0ZW0sIGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IG5ld1N0eWxlO1xuICAgICAgICAgICAgY3VycmVudFN0eWxlRmlyc3RJdGVtID0gY3VycmVudEl0ZW07XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50SXRlbSA9IGN1cnJlbnRTdHlsZUZpcnN0SXRlbTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZpcnN0SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBmaXJzdEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb20gKyAxOyBpIDwgdmlzaWJsZVJhbmdlLnRvOyArK2kpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBpdGVtU3R5bGUgPSBzdHlsZUdldHRlcihyZW5kZXJpbmdTY29wZSwgY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgc3dpdGNoIChsaW5lVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogTGluZVR5cGUuV2l0aFN0ZXBzICovOlxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW1zW2kgLSAxXS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3R5bGUgIT09IGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3R5bGUoaXRlbVN0eWxlLCBjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGl0ZW1zW2kgLSAxXS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjdXJyZW50SXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBMaW5lVHlwZS5DdXJ2ZWQgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NwMSwgY3AyXSA9IGdldENvbnRyb2xQb2ludHMoaXRlbXMsIGkgLSAxLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGNwMS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbywgY3AyLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGNwMi5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZVR5cGUgIT09IDEgLyogTGluZVR5cGUuV2l0aFN0ZXBzICovICYmIGl0ZW1TdHlsZSAhPT0gY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU3R5bGUoaXRlbVN0eWxlLCBjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjdXJyZW50SXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRTdHlsZUZpcnN0SXRlbSAhPT0gY3VycmVudEl0ZW0gfHwgY3VycmVudFN0eWxlRmlyc3RJdGVtID09PSBjdXJyZW50SXRlbSAmJiBsaW5lVHlwZSA9PT0gMSAvKiBMaW5lVHlwZS5XaXRoU3RlcHMgKi8pIHtcbiAgICAgICAgICAgIGZpbmlzaFN0eWxlZEFyZWEocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRTdHlsZSwgY3VycmVudFN0eWxlRmlyc3RJdGVtLCBjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBjdXJ2ZVRlbnNpb24gPSA2O1xuZnVuY3Rpb24gc3VidHJhY3QocDEsIHAyKSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX3g6IHAxLl9pbnRlcm5hbF94IC0gcDIuX2ludGVybmFsX3gsIF9pbnRlcm5hbF95OiBwMS5faW50ZXJuYWxfeSAtIHAyLl9pbnRlcm5hbF95IH07XG59XG5mdW5jdGlvbiBhZGQocDEsIHAyKSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX3g6IHAxLl9pbnRlcm5hbF94ICsgcDIuX2ludGVybmFsX3gsIF9pbnRlcm5hbF95OiBwMS5faW50ZXJuYWxfeSArIHAyLl9pbnRlcm5hbF95IH07XG59XG5mdW5jdGlvbiBkaXZpZGUocDEsIG4pIHtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfeDogcDEuX2ludGVybmFsX3ggLyBuLCBfaW50ZXJuYWxfeTogcDEuX2ludGVybmFsX3kgLyBuIH07XG59XG4vKipcbiAqIEByZXR1cm5zIFR3byBjb250cm9sIHBvaW50cyB0aGF0IGNhbiBiZSB1c2VkIGFzIGFyZ3VtZW50cyB0byB7QGxpbmsgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmJlemllckN1cnZlVG99IHRvIGRyYXcgYSBjdXJ2ZWQgbGluZSBiZXR3ZWVuIGBwb2ludHNbZnJvbVBvaW50SW5kZXhdYCBhbmQgYHBvaW50c1t0b1BvaW50SW5kZXhdYC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbFBvaW50cyhwb2ludHMsIGZyb21Qb2ludEluZGV4LCB0b1BvaW50SW5kZXgpIHtcbiAgICBjb25zdCBiZWZvcmVGcm9tUG9pbnRJbmRleCA9IE1hdGgubWF4KDAsIGZyb21Qb2ludEluZGV4IC0gMSk7XG4gICAgY29uc3QgYWZ0ZXJUb1BvaW50SW5kZXggPSBNYXRoLm1pbihwb2ludHMubGVuZ3RoIC0gMSwgdG9Qb2ludEluZGV4ICsgMSk7XG4gICAgY29uc3QgY3AxID0gYWRkKHBvaW50c1tmcm9tUG9pbnRJbmRleF0sIGRpdmlkZShzdWJ0cmFjdChwb2ludHNbdG9Qb2ludEluZGV4XSwgcG9pbnRzW2JlZm9yZUZyb21Qb2ludEluZGV4XSksIGN1cnZlVGVuc2lvbikpO1xuICAgIGNvbnN0IGNwMiA9IHN1YnRyYWN0KHBvaW50c1t0b1BvaW50SW5kZXhdLCBkaXZpZGUoc3VidHJhY3QocG9pbnRzW2FmdGVyVG9Qb2ludEluZGV4XSwgcG9pbnRzW2Zyb21Qb2ludEluZGV4XSksIGN1cnZlVGVuc2lvbikpO1xuICAgIHJldHVybiBbY3AxLCBjcDJdO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hTdHlsZWRBcmVhJDEoc2NvcGUsIHN0eWxlKSB7XG4gICAgY29uc3QgY3R4ID0gc2NvcGUuY29udGV4dDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBQYW5lUmVuZGVyZXJMaW5lQmFzZSBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbChyZW5kZXJpbmdTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9pdGVtczogaXRlbXMsIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHZpc2libGVSYW5nZSwgX2ludGVybmFsX2JhcldpZHRoOiBiYXJXaWR0aCwgX2ludGVybmFsX2xpbmVUeXBlOiBsaW5lVHlwZSwgX2ludGVybmFsX2xpbmVXaWR0aDogbGluZVdpZHRoLCBfaW50ZXJuYWxfbGluZVN0eWxlOiBsaW5lU3R5bGUsIF9pbnRlcm5hbF9wb2ludE1hcmtlcnNSYWRpdXM6IHBvaW50TWFya2Vyc1JhZGl1cyB9ID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSByZW5kZXJpbmdTY29wZS5jb250ZXh0O1xuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAqIHJlbmRlcmluZ1Njb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgbGluZVN0eWxlKTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgY29uc3Qgc3R5bGVHZXR0ZXIgPSB0aGlzLl9pbnRlcm5hbF9fc3Ryb2tlU3R5bGUuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKGxpbmVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhbGtMaW5lKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgbGluZVR5cGUsIHZpc2libGVSYW5nZSwgYmFyV2lkdGgsIHN0eWxlR2V0dGVyLCBmaW5pc2hTdHlsZWRBcmVhJDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludE1hcmtlcnNSYWRpdXMpIHtcbiAgICAgICAgICAgIGRyYXdTZXJpZXNQb2ludE1hcmtlcnMocmVuZGVyaW5nU2NvcGUsIGl0ZW1zLCBwb2ludE1hcmtlcnNSYWRpdXMsIHZpc2libGVSYW5nZSwgc3R5bGVHZXR0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBQYW5lUmVuZGVyZXJMaW5lIGV4dGVuZHMgUGFuZVJlbmRlcmVyTGluZUJhc2Uge1xuICAgIF9pbnRlcm5hbF9fc3Ryb2tlU3R5bGUocmVuZGVyaW5nU2NvcGUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uX2ludGVybmFsX2xpbmVDb2xvcjtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0xpbmVQYW5lVmlldyBleHRlbmRzIExpbmVQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVyTGluZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgcHJpY2UsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSh0aW1lLCBwcmljZSksXG4gICAgICAgICAgICAuLi5jb2xvcmVyLl9pbnRlcm5hbF9iYXJTdHlsZSh0aW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX19wcmVwYXJlUmVuZGVyZXJEYXRhKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2l0ZW1zOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lVHlwZTogb3B0aW9ucy5saW5lVmlzaWJsZSA/IG9wdGlvbnMubGluZVR5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wb2ludE1hcmtlcnNSYWRpdXM6IG9wdGlvbnMucG9pbnRNYXJrZXJzVmlzaWJsZSA/IChvcHRpb25zLnBvaW50TWFya2Vyc1JhZGl1cyB8fCBvcHRpb25zLmxpbmVXaWR0aCAvIDIgKyAyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoZGF0YSk7XG4gICAgfVxufVxuXG5jb25zdCBsaW5lU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyMTk2ZjMnLFxuICAgIGxpbmVTdHlsZTogMCAvKiBMaW5lU3R5bGUuU29saWQgKi8sXG4gICAgbGluZVdpZHRoOiAzLFxuICAgIGxpbmVUeXBlOiAwIC8qIExpbmVUeXBlLlNpbXBsZSAqLyxcbiAgICBsaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJWaXNpYmxlOiB0cnVlLFxuICAgIGNyb3NzaGFpck1hcmtlclJhZGl1czogNCxcbiAgICBjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvcjogJycsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyV2lkdGg6IDIsXG4gICAgY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBsYXN0UHJpY2VBbmltYXRpb246IDAgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5EaXNhYmxlZCAqLyxcbiAgICBwb2ludE1hcmtlcnNWaXNpYmxlOiBmYWxzZSxcbn07XG5jb25zdCBjcmVhdGVQYW5lVmlldyQ1ID0gKHNlcmllcywgbW9kZWwpID0+IG5ldyBTZXJpZXNMaW5lUGFuZVZpZXcoc2VyaWVzLCBtb2RlbCk7XG5jb25zdCBjcmVhdGVMaW5lU2VyaWVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdMaW5lJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogbGluZVN0eWxlRGVmYXVsdHMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIF9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldzogY3JlYXRlUGFuZVZpZXckNSxcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbmNvbnN0IGxpbmVTZXJpZXMgPSBjcmVhdGVMaW5lU2VyaWVzKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZURlYm91bmNlZE1pY3JvVGFza0hhbmRsZXIoY2FsbGJhY2spIHtcbiAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya1dpdGhHcmVhdGVyV2VpZ2h0JDEoYSwgYikge1xuICAgIHJldHVybiBhLndlaWdodCA+IGIud2VpZ2h0ID8gYSA6IGI7XG59XG5mdW5jdGlvbiB0b0ludGVybmFsSG9yelNjYWxlSXRlbShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBmcm9tSW50ZXJuYWxIb3J6U2NhbGVJdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbn1cbmNsYXNzIFlpZWxkQ3VydmVIb3J6U2NhbGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50c0NoYW5nZWREZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlV2hpdGVzcGFjZSA9IGNyZWF0ZURlYm91bmNlZE1pY3JvVGFza0hhbmRsZXIoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX2xhcmdlc3RJbmRleCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sYXJnZXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICAvKiogRGF0YSBjaGFuZ2VzIG1pZ2h0IHJlcXVpcmUgdGhhdCB0aGUgd2hpdGVzcGFjZSBiZSBnZW5lcmF0ZWQgYWdhaW4gKi9cbiAgICBfaW50ZXJuYWxfd2hpdGVzcGFjZUludmFsaWRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzQ2hhbmdlZERlbGVnYXRlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnRzQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHByZXByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gTm8gcHJlcHJvY2Vzc2luZyBuZWVkZWQgZm9yIHlpZWxkIGN1cnZlIGRhdGFcbiAgICB9XG4gICAgdXBkYXRlRm9ybWF0dGVyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24gPSBvcHRpb25zO1xuICAgIH1cbiAgICBjcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZVdoaXRlc3BhY2UoKTtcbiAgICAgICAgcmV0dXJuICh0aW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodGltZSA+IHRoaXMuX3ByaXZhdGVfX2xhcmdlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhcmdlc3RJbmRleCA9IHRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9JbnRlcm5hbEhvcnpTY2FsZUl0ZW0odGltZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGtleShpbnRlcm5hbEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsSXRlbTtcbiAgICB9XG4gICAgY2FjaGVLZXkoaW50ZXJuYWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBmcm9tSW50ZXJuYWxIb3J6U2NhbGVJdGVtKGludGVybmFsSXRlbSk7XG4gICAgfVxuICAgIGNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwoaXRlbSkge1xuICAgICAgICByZXR1cm4gdG9JbnRlcm5hbEhvcnpTY2FsZUl0ZW0oaXRlbSk7XG4gICAgfVxuICAgIGZvcm1hdEhvcnpJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFRpbWUoaXRlbSk7XG4gICAgfVxuICAgIGZvcm1hdFRpY2ttYXJrKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFRpbWUoaXRlbS50aW1lKTtcbiAgICB9XG4gICAgbWF4VGlja01hcmtXZWlnaHQobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzLnJlZHVjZShtYXJrV2l0aEdyZWF0ZXJXZWlnaHQkMSwgbWFya3NbMF0pLndlaWdodDtcbiAgICB9XG4gICAgZmlsbFdlaWdodHNGb3JQb2ludHMoc29ydGVkVGltZVBvaW50cywgc3RhcnRJbmRleCkge1xuICAgICAgICBjb25zdCB0aW1lV2VpZ2h0ID0gKHRpbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aW1lICUgMTIwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgJSA2MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgJSAzNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgJSAxMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgJSA2ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSAlIDMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgc29ydGVkVGltZVBvaW50c1tpbmRleF0udGltZVdlaWdodCA9IHRpbWVXZWlnaHQoZnJvbUludGVybmFsSG9yelNjYWxlSXRlbShzb3J0ZWRUaW1lUG9pbnRzW2luZGV4XS50aW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFyZ2VzdEluZGV4ID0gZnJvbUludGVybmFsSG9yelNjYWxlSXRlbShzb3J0ZWRUaW1lUG9pbnRzW3NvcnRlZFRpbWVQb2ludHMubGVuZ3RoIC0gMV0udGltZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVXaGl0ZXNwYWNlKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRUaW1lKG1vbnRocykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24/LnRpbWVGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvbi50aW1lRm9ybWF0dGVyKG1vbnRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocyA8IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bW9udGhzfU1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHllYXJzID0gTWF0aC5mbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ01vbnRocyA9IG1vbnRocyAlIDEyO1xuICAgICAgICBpZiAocmVtYWluaW5nTW9udGhzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7eWVhcnN9WWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3llYXJzfVkke3JlbWFpbmluZ01vbnRoc31NYDtcbiAgICB9XG59XG5cbmNvbnN0IHlpZWxkQ2hhcnRPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgYmFzZVJlc29sdXRpb246IDEsXG4gICAgbWluaW11bVRpbWVSYW5nZTogMTIwLFxuICAgIHN0YXJ0VGltZVJhbmdlOiAwLFxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVXaGl0ZXNwYWNlRGF0YSh7IF9pbnRlcm5hbF9zdGFydDogc3RhcnQsIF9pbnRlcm5hbF9lbmQ6IGVuZCwgX2ludGVybmFsX3Jlc29sdXRpb246IHJlc29sdXRpb24sIH0pIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogTWF0aC5mbG9vcigoZW5kIC0gc3RhcnQpIC8gcmVzb2x1dGlvbikgKyAxIH0sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZS1wcm9wc1xuICAgIChpdGVtLCBpKSA9PiAoeyAndGltZSc6IHN0YXJ0ICsgaSAqIHJlc29sdXRpb24gfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRXaGl0ZXNwYWNlU3RhdGUob3B0aW9ucywgbGFzdEluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0OiBNYXRoLm1heCgwLCBvcHRpb25zLnN0YXJ0VGltZVJhbmdlKSxcbiAgICAgICAgX2ludGVybmFsX2VuZDogTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5pbXVtVGltZVJhbmdlLCBsYXN0SW5kZXggfHwgMCksXG4gICAgICAgIF9pbnRlcm5hbF9yZXNvbHV0aW9uOiBNYXRoLm1heCgxLCBvcHRpb25zLmJhc2VSZXNvbHV0aW9uKSxcbiAgICB9O1xufVxuY29uc3QgZ2VuZXJhdGVXaGl0ZXNwYWNlSGFzaCA9ICh7IF9pbnRlcm5hbF9zdGFydDogc3RhcnQsIF9pbnRlcm5hbF9lbmQ6IGVuZCwgX2ludGVybmFsX3Jlc29sdXRpb246IHJlc29sdXRpb24sIH0pID0+IGAke3N0YXJ0fX4ke2VuZH1+JHtyZXNvbHV0aW9ufWA7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB5aWVsZEN1cnZlOiB5aWVsZENoYXJ0T3B0aW9uc0RlZmF1bHRzLFxuICAgIC8vIGFuZCBhZGQgc2Vuc2libGUgZGVmYXVsdCBvcHRpb25zIGZvciB5aWVsZCBjaGFydHMgd2hpY2hcbiAgICAvLyBhcmUgZGlmZmVyZW50IGZyb20gdGhlIHVzdWFsIGRlZmF1bHRzLlxuICAgIHRpbWVTY2FsZToge1xuICAgICAgICBpZ25vcmVXaGl0ZXNwYWNlSW5kaWNlczogdHJ1ZSxcbiAgICB9LFxuICAgIGxlZnRQcmljZVNjYWxlOiB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgfSxcbiAgICByaWdodFByaWNlU2NhbGU6IHtcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBsb2NhbGl6YXRpb246IHtcbiAgICAgICAgcHJpY2VGb3JtYXR0ZXI6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMykgKyAnJSc7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5jb25zdCBsaW5lU3R5bGVEZWZhdWx0T3B0aW9uT3ZlcnJpZGVzID0ge1xuICAgIGxhc3RWYWx1ZVZpc2libGU6IGZhbHNlLFxuICAgIHByaWNlTGluZVZpc2libGU6IGZhbHNlLFxufTtcbmNsYXNzIFlpZWxkQ2hhcnRBcGkgZXh0ZW5kcyBDaGFydEFwaSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxPcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBjb25zdCBob3J6QmVoYXZpb3VyID0gbmV3IFlpZWxkQ3VydmVIb3J6U2NhbGVCZWhhdmlvcigpO1xuICAgICAgICBzdXBlcihjb250YWluZXIsIGhvcnpCZWhhdmlvdXIsIGZ1bGxPcHRpb25zKTtcbiAgICAgICAgaG9yekJlaGF2aW91ci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucygpKTtcbiAgICAgICAgdGhpcy5faW5pdFdoaXRlc3BhY2VTZXJpZXMoKTtcbiAgICB9XG4gICAgYWRkU2VyaWVzKGRlZmluaXRpb24sIG9wdGlvbnMgPSB7fSwgcGFuZUluZGV4ID0gMCkge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5pc0J1aWx0SW4gJiYgWydBcmVhJywgJ0xpbmUnXS5pbmNsdWRlcyhkZWZpbml0aW9uLnR5cGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZaWVsZCBjdXJ2ZSBvbmx5IHN1cHBvcnQgQXJlYSBhbmQgTGluZSBzZXJpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25PdmVycmlkZXMgPSB7XG4gICAgICAgICAgICAuLi5saW5lU3R5bGVEZWZhdWx0T3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZFNlcmllcyhkZWZpbml0aW9uLCBvcHRpb25PdmVycmlkZXMsIHBhbmVJbmRleCk7XG4gICAgfVxuICAgIF9pbml0V2hpdGVzcGFjZVNlcmllcygpIHtcbiAgICAgICAgY29uc3QgaG9yekJlaGF2aW91ciA9IHRoaXMuaG9yekJlaGF2aW91cigpO1xuICAgICAgICBjb25zdCB3aGl0ZVNwYWNlU2VyaWVzID0gdGhpcy5hZGRTZXJpZXMobGluZVNlcmllcyk7XG4gICAgICAgIGxldCBjdXJyZW50V2hpdGVzcGFjZUhhc2g7XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdoaXRlc3BhY2UobGFzdEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdXaGl0ZXNwYWNlU3RhdGUgPSBidWlsZFdoaXRlc3BhY2VTdGF0ZShob3J6QmVoYXZpb3VyLm9wdGlvbnMoKS55aWVsZEN1cnZlLCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbmV3V2hpdGVzcGFjZUhhc2ggPSBnZW5lcmF0ZVdoaXRlc3BhY2VIYXNoKG5ld1doaXRlc3BhY2VTdGF0ZSk7XG4gICAgICAgICAgICBpZiAobmV3V2hpdGVzcGFjZUhhc2ggIT09IGN1cnJlbnRXaGl0ZXNwYWNlSGFzaCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlSGFzaCA9IG5ld1doaXRlc3BhY2VIYXNoO1xuICAgICAgICAgICAgICAgIHdoaXRlU3BhY2VTZXJpZXMuc2V0RGF0YShnZW5lcmF0ZVdoaXRlc3BhY2VEYXRhKG5ld1doaXRlc3BhY2VTdGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVdoaXRlc3BhY2UoMCk7XG4gICAgICAgIGhvcnpCZWhhdmlvdXIuX2ludGVybmFsX3doaXRlc3BhY2VJbnZhbGlkYXRlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodXBkYXRlV2hpdGVzcGFjZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB5aWVsZCBjdXJ2ZSBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqXG4gKiBBIHlpZWxkIGN1cnZlIGNoYXJ0IGRpZmZlcnMgZnJvbSB0aGUgZGVmYXVsdCBjaGFydCB0eXBlXG4gKiBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEhvcml6b250YWwgc2NhbGUgaXMgbGluZWFybHkgc3BhY2VkLCBhbmQgZGVmaW5lZCBpbiBtb250aGx5XG4gKiB0aW1lIGR1cmF0aW9uIHVuaXRzXG4gKiAtIFdoaXRlc3BhY2UgaXMgaWdub3JlZCBmb3IgdGhlIGNyb3NzaGFpciBhbmQgZ3JpZCBsaW5lc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXIgLSBJRCBvZiBIVE1MIGVsZW1lbnQgb3IgZWxlbWVudCBpdHNlbGZcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHlpZWxkIGNoYXJ0IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBpbnRlcmZhY2UgdG8gdGhlIGNyZWF0ZWQgY2hhcnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlWWllbGRDdXJ2ZUNoYXJ0KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZmV0Y2hIdG1sRWxlbWVudChjb250YWluZXIpO1xuICAgIGNvbnN0IGNoYXJ0QXBpID0gbmV3IFlpZWxkQ2hhcnRBcGkoaHRtbEVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjaGFydEFwaTtcbn1cblxuZnVuY3Rpb24gbWFya1dpdGhHcmVhdGVyV2VpZ2h0KGEsIGIpIHtcbiAgICByZXR1cm4gYS53ZWlnaHQgPiBiLndlaWdodCA/IGEgOiBiO1xufVxuY2xhc3MgSG9yelNjYWxlQmVoYXZpb3JQcmljZSB7XG4gICAgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgcHJlcHJvY2Vzc0RhdGEoZGF0YSkgeyB9XG4gICAgdXBkYXRlRm9ybWF0dGVyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24gPSBvcHRpb25zO1xuICAgIH1cbiAgICBjcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChwcmljZSkgPT4gcHJpY2U7XG4gICAgfVxuICAgIGtleShpbnRlcm5hbEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsSXRlbTtcbiAgICB9XG4gICAgY2FjaGVLZXkoaW50ZXJuYWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbEl0ZW07XG4gICAgfVxuICAgIGNvbnZlcnRIb3J6SXRlbVRvSW50ZXJuYWwoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgZm9ybWF0SG9yekl0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0ZpeGVkKHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbigpKTtcbiAgICB9XG4gICAgZm9ybWF0VGlja21hcmsoaXRlbSwgbG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaXRlbS50aW1lLnRvRml4ZWQodGhpcy5fcHJpdmF0ZV9fcHJlY2lzaW9uKCkpO1xuICAgIH1cbiAgICBtYXhUaWNrTWFya1dlaWdodChtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MucmVkdWNlKG1hcmtXaXRoR3JlYXRlcldlaWdodCwgbWFya3NbMF0pLndlaWdodDtcbiAgICB9XG4gICAgZmlsbFdlaWdodHNGb3JQb2ludHMoc29ydGVkVGltZVBvaW50cywgc3RhcnRJbmRleCkge1xuICAgICAgICBjb25zdCBwcmljZVdlaWdodCA9IChwcmljZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UgLyAxMDApICogMTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpY2UgPT09IE1hdGguY2VpbChwcmljZSAvIDUwKSAqIDUwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpY2UgPT09IE1hdGguY2VpbChwcmljZSAvIDI1KSAqIDI1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpY2UgPT09IE1hdGguY2VpbChwcmljZSAvIDEwKSAqIDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpY2UgPT09IE1hdGguY2VpbChwcmljZSAvIDUpICogNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpY2UgKiAyID09PSBNYXRoLmNlaWwocHJpY2UgKiAyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgc29ydGVkVGltZVBvaW50c1tpbmRleF0udGltZVdlaWdodCA9IHByaWNlV2VpZ2h0KHNvcnRlZFRpbWVQb2ludHNbaW5kZXhdLnRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19wcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmxvY2FsaXphdGlvblxuICAgICAgICAgICAgLnByZWNpc2lvbjtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiAnb3B0aW9ucycgY2hhcnQgd2l0aCBwcmljZSB2YWx1ZXMgb24gdGhlIGhvcml6b250YWwgc2NhbGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWxpemVkIGNoYXJ0IHR5cGUgd2hlcmUgdGhlIGhvcml6b250YWwgc2NhbGVcbiAqIHJlcHJlc2VudHMgcHJpY2UgdmFsdWVzIGluc3RlYWQgb2YgdGltZS4gSXQncyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB2aXN1YWxpemluZ1xuICogb3B0aW9uIGNoYWlucywgcHJpY2UgZGlzdHJpYnV0aW9ucywgb3IgYW55IGRhdGEgd2hlcmUgcHJpY2UgaXMgdGhlIHByaW1hcnkgeC1heGlzIG1ldHJpYy5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIERPTSBlbGVtZW50IG9yIGl0cyBpZCB3aGVyZSB0aGUgY2hhcnQgd2lsbCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJpY2UgY2hhcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBJQ2hhcnRBcGlCYXNlIGNvbmZpZ3VyZWQgZm9yIHByaWNlLWJhc2VkIGhvcml6b250YWwgc2NhbGluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc0NoYXJ0KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVDaGFydEV4KGNvbnRhaW5lciwgbmV3IEhvcnpTY2FsZUJlaGF2aW9yUHJpY2UoKSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFN0eWxlZEFyZWEoYmFzZUxldmVsQ29vcmRpbmF0ZSwgc2NvcGUsIHN0eWxlLCBhcmVhRmlyc3RJdGVtLCBuZXdBcmVhRmlyc3RJdGVtKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0gPSBzY29wZTtcbiAgICBjb250ZXh0LmxpbmVUbyhuZXdBcmVhRmlyc3RJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGJhc2VMZXZlbENvb3JkaW5hdGUgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGFyZWFGaXJzdEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgYmFzZUxldmVsQ29vcmRpbmF0ZSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlO1xuICAgIGNvbnRleHQuZmlsbCgpO1xufVxuY2xhc3MgUGFuZVJlbmRlcmVyQXJlYUJhc2UgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfaXRlbXM6IGl0ZW1zLCBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB2aXNpYmxlUmFuZ2UsIF9pbnRlcm5hbF9iYXJXaWR0aDogYmFyV2lkdGgsIF9pbnRlcm5hbF9saW5lV2lkdGg6IGxpbmVXaWR0aCwgX2ludGVybmFsX2xpbmVTdHlsZTogbGluZVN0eWxlLCBfaW50ZXJuYWxfbGluZVR5cGU6IGxpbmVUeXBlIH0gPSB0aGlzLl9pbnRlcm5hbF9fZGF0YTtcbiAgICAgICAgY29uc3QgYmFzZUxldmVsQ29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX19kYXRhLl9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlID8/XG4gICAgICAgICAgICAodGhpcy5faW50ZXJuYWxfX2RhdGEuX2ludGVybmFsX2ludmVydEZpbGxlZEFyZWEgPyAwIDogcmVuZGVyaW5nU2NvcGUubWVkaWFTaXplLmhlaWdodCk7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSByZW5kZXJpbmdTY29wZS5jb250ZXh0O1xuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgbGluZVN0eWxlKTtcbiAgICAgICAgLy8gd2FsayBsaW5lcyB3aXRoIHdpZHRoPTEgdG8gaGF2ZSBtb3JlIGFjY3VyYXRlIGdyYWRpZW50J3MgZmlsbGluZ1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgd2Fsa0xpbmUocmVuZGVyaW5nU2NvcGUsIGl0ZW1zLCBsaW5lVHlwZSwgdmlzaWJsZVJhbmdlLCBiYXJXaWR0aCwgdGhpcy5faW50ZXJuYWxfX2ZpbGxTdHlsZS5iaW5kKHRoaXMpLCBmaW5pc2hTdHlsZWRBcmVhLmJpbmQobnVsbCwgYmFzZUxldmVsQ29vcmRpbmF0ZSkpO1xuICAgIH1cbn1cblxuY2xhc3MgR3JhZGllbnRTdHlsZUNhY2hlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9pbnRlcm5hbF9nZXQoc2NvcGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjYWNoZWRQYXJhbXMgPSB0aGlzLl9wcml2YXRlX19wYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX3RvcENvbG9yMTogdG9wQ29sb3IxLCBfaW50ZXJuYWxfdG9wQ29sb3IyOiB0b3BDb2xvcjIsIF9pbnRlcm5hbF9ib3R0b21Db2xvcjE6IGJvdHRvbUNvbG9yMSwgX2ludGVybmFsX2JvdHRvbUNvbG9yMjogYm90dG9tQ29sb3IyLCBfaW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZTogYmFzZUxldmVsQ29vcmRpbmF0ZSwgX2ludGVybmFsX3RvcENvb3JkaW5hdGU6IHRvcENvb3JkaW5hdGUsIF9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlOiBib3R0b21Db29yZGluYXRlLCB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGVkVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2FjaGVkUGFyYW1zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfdG9wQ29sb3IxICE9PSB0b3BDb2xvcjEgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfdG9wQ29sb3IyICE9PSB0b3BDb2xvcjIgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfYm90dG9tQ29sb3IxICE9PSBib3R0b21Db2xvcjEgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfYm90dG9tQ29sb3IyICE9PSBib3R0b21Db2xvcjIgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZSAhPT0gYmFzZUxldmVsQ29vcmRpbmF0ZSB8fFxuICAgICAgICAgICAgY2FjaGVkUGFyYW1zLl9pbnRlcm5hbF90b3BDb29yZGluYXRlICE9PSB0b3BDb29yZGluYXRlIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGUgIT09IGJvdHRvbUNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmVydGljYWxQaXhlbFJhdGlvIH0gPSBzY29wZTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBiYXNlTGV2ZWxDb29yZGluYXRlIHx8IHRvcENvb3JkaW5hdGUgPiAwID8gdmVydGljYWxQaXhlbFJhdGlvIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRvcENvb3JkaW5hdGUgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gYm90dG9tQ29vcmRpbmF0ZSA9PT0gc2NvcGUuYml0bWFwU2l6ZS5oZWlnaHQgPyBib3R0b21Db29yZGluYXRlIDogYm90dG9tQ29vcmRpbmF0ZSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICBjb25zdCBiYXNlbGluZSA9IChiYXNlTGV2ZWxDb29yZGluYXRlID8/IDApICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gc2NvcGUuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCB0b3AsIDAsIGJvdHRvbSk7XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgdG9wQ29sb3IxKTtcbiAgICAgICAgICAgIGlmIChiYXNlTGV2ZWxDb29yZGluYXRlICE9PSBudWxsICYmIGJhc2VMZXZlbENvb3JkaW5hdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VsaW5lUmF0aW8gPSBjbGFtcCgoKGJhc2VsaW5lIC0gdG9wKSAvIHJhbmdlKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGJhc2VsaW5lUmF0aW8sIHRvcENvbG9yMik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGJhc2VsaW5lUmF0aW8sIGJvdHRvbUNvbG9yMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgYm90dG9tQ29sb3IyKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZFZhbHVlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhY2hlZFZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyQmFzZWxpbmVBcmVhIGV4dGVuZHMgUGFuZVJlbmRlcmVyQXJlYUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19maWxsQ2FjaGUgPSBuZXcgR3JhZGllbnRTdHlsZUNhY2hlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFN0eWxlKHJlbmRlcmluZ1Njb3BlLCBpdGVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9pbnRlcm5hbF9fZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2ZpbGxDYWNoZS5faW50ZXJuYWxfZ2V0KHJlbmRlcmluZ1Njb3BlLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF90b3BGaWxsQ29sb3IxLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMjogaXRlbS5faW50ZXJuYWxfdG9wRmlsbENvbG9yMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db2xvcjE6IGl0ZW0uX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29vcmRpbmF0ZTogZGF0YS5faW50ZXJuYWxfdG9wQ29vcmRpbmF0ZSA/PyAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGUgPz8gcmVuZGVyaW5nU2NvcGUuYml0bWFwU2l6ZS5oZWlnaHQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyQmFzZWxpbmVMaW5lIGV4dGVuZHMgUGFuZVJlbmRlcmVyTGluZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHJva2VDYWNoZSA9IG5ldyBHcmFkaWVudFN0eWxlQ2FjaGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19zdHJva2VTdHlsZShyZW5kZXJpbmdTY29wZSwgaXRlbSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zdHJva2VDYWNoZS5faW50ZXJuYWxfZ2V0KHJlbmRlcmluZ1Njb3BlLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZTogZGF0YS5faW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb29yZGluYXRlOiBkYXRhLl9pbnRlcm5hbF90b3BDb29yZGluYXRlID8/IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZTogZGF0YS5faW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZSA/PyByZW5kZXJpbmdTY29wZS5iaXRtYXBTaXplLmhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNCYXNlbGluZVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IENvbXBvc2l0ZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lQXJlYVJlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckJhc2VsaW5lQXJlYSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlbGluZUxpbmVSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJCYXNlbGluZUxpbmUoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXRSZW5kZXJlcnMoW3RoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lQXJlYVJlbmRlcmVyLCB0aGlzLl9wcml2YXRlX19iYXNlbGluZUxpbmVSZW5kZXJlcl0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgcHJpY2UsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSh0aW1lLCBwcmljZSksXG4gICAgICAgICAgICAuLi5jb2xvcmVyLl9pbnRlcm5hbF9iYXJTdHlsZSh0aW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX19wcmVwYXJlUmVuZGVyZXJEYXRhKCkge1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGJhc2VMZXZlbENvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKG9wdGlvbnMuYmFzZVZhbHVlLnByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGJhcldpZHRoID0gdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID09PSBudWxsIHx8IHRoaXMuX2ludGVybmFsX19pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9wQ29vcmRpbmF0ZTtcbiAgICAgICAgbGV0IGJvdHRvbUNvb3JkaW5hdGU7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlR3JhZGllbnQpIHtcbiAgICAgICAgICAgIHRvcENvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9faXRlbXNbdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLmZyb21dLl9pbnRlcm5hbF95O1xuICAgICAgICAgICAgYm90dG9tQ29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX19pdGVtc1t0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UuZnJvbV0uX2ludGVybmFsX3k7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pbnRlcm5hbF9faXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2ludGVybmFsX3kgPCB0b3BDb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcENvb3JkaW5hdGUgPSBpdGVtLl9pbnRlcm5hbF95O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5faW50ZXJuYWxfeSA+IGJvdHRvbUNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tQ29vcmRpbmF0ZSA9IGl0ZW0uX2ludGVybmFsX3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VsaW5lQXJlYVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lVHlwZTogb3B0aW9ucy5saW5lVHlwZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlOiBiYXNlTGV2ZWxDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvb3JkaW5hdGU6IHRvcENvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZTogYm90dG9tQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbnZlcnRGaWxsZWRBcmVhOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlbGluZUxpbmVSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogb3B0aW9ucy5saW5lU3R5bGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVR5cGU6IG9wdGlvbnMubGluZVZpc2libGUgPyBvcHRpb25zLmxpbmVUeXBlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX3BvaW50TWFya2Vyc1JhZGl1czogb3B0aW9ucy5wb2ludE1hcmtlcnNWaXNpYmxlID8gKG9wdGlvbnMucG9pbnRNYXJrZXJzUmFkaXVzIHx8IG9wdGlvbnMubGluZVdpZHRoIC8gMiArIDIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGJhc2VMZXZlbENvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29vcmRpbmF0ZTogdG9wQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlOiBib3R0b21Db29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBiYXNlbGluZVN0eWxlRGVmYXVsdHMgPSB7XG4gICAgYmFzZVZhbHVlOiB7XG4gICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgIHByaWNlOiAwLFxuICAgIH0sXG4gICAgcmVsYXRpdmVHcmFkaWVudDogZmFsc2UsXG4gICAgdG9wRmlsbENvbG9yMTogJ3JnYmEoMzgsIDE2NiwgMTU0LCAwLjI4KScsXG4gICAgdG9wRmlsbENvbG9yMjogJ3JnYmEoMzgsIDE2NiwgMTU0LCAwLjA1KScsXG4gICAgdG9wTGluZUNvbG9yOiAncmdiYSgzOCwgMTY2LCAxNTQsIDEpJyxcbiAgICBib3R0b21GaWxsQ29sb3IxOiAncmdiYSgyMzksIDgzLCA4MCwgMC4wNSknLFxuICAgIGJvdHRvbUZpbGxDb2xvcjI6ICdyZ2JhKDIzOSwgODMsIDgwLCAwLjI4KScsXG4gICAgYm90dG9tTGluZUNvbG9yOiAncmdiYSgyMzksIDgzLCA4MCwgMSknLFxuICAgIGxpbmVXaWR0aDogMyxcbiAgICBsaW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgIGxpbmVUeXBlOiAwIC8qIExpbmVUeXBlLlNpbXBsZSAqLyxcbiAgICBsaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJWaXNpYmxlOiB0cnVlLFxuICAgIGNyb3NzaGFpck1hcmtlclJhZGl1czogNCxcbiAgICBjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvcjogJycsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyV2lkdGg6IDIsXG4gICAgY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBsYXN0UHJpY2VBbmltYXRpb246IDAgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5EaXNhYmxlZCAqLyxcbiAgICBwb2ludE1hcmtlcnNWaXNpYmxlOiBmYWxzZSxcbn07XG5jb25zdCBjcmVhdGVQYW5lVmlldyQ0ID0gKHNlcmllcywgbW9kZWwpID0+IG5ldyBTZXJpZXNCYXNlbGluZVBhbmVWaWV3KHNlcmllcywgbW9kZWwpO1xuY29uc3QgY3JlYXRlU2VyaWVzJDQgPSAoKSA9PiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ0Jhc2VsaW5lJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogYmFzZWxpbmVTdHlsZURlZmF1bHRzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3JDQsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG5jb25zdCBiYXNlbGluZVNlcmllcyA9IGNyZWF0ZVNlcmllcyQ0KCk7XG5cbmNsYXNzIFBhbmVSZW5kZXJlckFyZWEgZXh0ZW5kcyBQYW5lUmVuZGVyZXJBcmVhQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpbGxDYWNoZSA9IG5ldyBHcmFkaWVudFN0eWxlQ2FjaGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19maWxsU3R5bGUocmVuZGVyaW5nU2NvcGUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2ZpbGxDYWNoZS5faW50ZXJuYWxfZ2V0KHJlbmRlcmluZ1Njb3BlLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF90b3BDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjI6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMTogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IyOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21Db2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb29yZGluYXRlOiB0aGlzLl9pbnRlcm5hbF9fZGF0YT8uX2ludGVybmFsX3RvcENvb3JkaW5hdGUgPz8gMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlOiByZW5kZXJpbmdTY29wZS5iaXRtYXBTaXplLmhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNBcmVhUGFuZVZpZXcgZXh0ZW5kcyBMaW5lUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgbW9kZWwpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgQ29tcG9zaXRlUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXJlYVJlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckFyZWEoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGluZVJlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckxpbmUoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXRSZW5kZXJlcnMoW3RoaXMuX3ByaXZhdGVfX2FyZWFSZW5kZXJlciwgdGhpcy5fcHJpdmF0ZV9fbGluZVJlbmRlcmVyXSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBwcmljZSwgY29sb3Jlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW1CYXNlKHRpbWUsIHByaWNlKSxcbiAgICAgICAgICAgIC4uLmNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHRpbWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UgPT09IG51bGwgfHwgdGhpcy5faW50ZXJuYWxfX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3BDb29yZGluYXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZUdyYWRpZW50KSB7XG4gICAgICAgICAgICB0b3BDb29yZGluYXRlID0gdGhpcy5faW50ZXJuYWxfX2l0ZW1zW3RoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZS5mcm9tXS5faW50ZXJuYWxfeTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2ludGVybmFsX19pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5faW50ZXJuYWxfeSA8IHRvcENvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQ29vcmRpbmF0ZSA9IGl0ZW0uX2ludGVybmFsX3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FyZWFSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVR5cGU6IG9wdGlvbnMubGluZVR5cGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IG9wdGlvbnMubGluZVN0eWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZTogbnVsbCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb29yZGluYXRlOiB0b3BDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX2ludmVydEZpbGxlZEFyZWE6IG9wdGlvbnMuaW52ZXJ0RmlsbGVkQXJlYSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGluZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lVHlwZTogb3B0aW9ucy5saW5lVmlzaWJsZSA/IG9wdGlvbnMubGluZVR5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IG9wdGlvbnMubGluZVN0eWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyV2lkdGg6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wb2ludE1hcmtlcnNSYWRpdXM6IG9wdGlvbnMucG9pbnRNYXJrZXJzVmlzaWJsZSA/IChvcHRpb25zLnBvaW50TWFya2Vyc1JhZGl1cyB8fCBvcHRpb25zLmxpbmVXaWR0aCAvIDIgKyAyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBhcmVhU3R5bGVEZWZhdWx0cyA9IHtcbiAgICB0b3BDb2xvcjogJ3JnYmEoIDQ2LCAyMjAsIDEzNSwgMC40KScsXG4gICAgYm90dG9tQ29sb3I6ICdyZ2JhKCA0MCwgMjIxLCAxMDAsIDApJyxcbiAgICBpbnZlcnRGaWxsZWRBcmVhOiBmYWxzZSxcbiAgICByZWxhdGl2ZUdyYWRpZW50OiBmYWxzZSxcbiAgICBsaW5lQ29sb3I6ICcjMzNENzc4JyxcbiAgICBsaW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgIGxpbmVXaWR0aDogMyxcbiAgICBsaW5lVHlwZTogMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi8sXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJSYWRpdXM6IDQsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3I6ICcnLFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoOiAyLFxuICAgIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjogJycsXG4gICAgbGFzdFByaWNlQW5pbWF0aW9uOiAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi8sXG4gICAgcG9pbnRNYXJrZXJzVmlzaWJsZTogZmFsc2UsXG59O1xuY29uc3QgY3JlYXRlUGFuZVZpZXckMyA9IChzZXJpZXMsIG1vZGVsKSA9PiBuZXcgU2VyaWVzQXJlYVBhbmVWaWV3KHNlcmllcywgbW9kZWwpO1xuY29uc3QgY3JlYXRlU2VyaWVzJDMgPSAoKSA9PiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ0FyZWEnLFxuICAgICAgICBpc0J1aWx0SW46IHRydWUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBhcmVhU3R5bGVEZWZhdWx0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2ludGVybmFsX2NyZWF0ZVBhbmVWaWV3OiBjcmVhdGVQYW5lVmlldyQzLFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuY29uc3QgYXJlYVNlcmllcyA9IGNyZWF0ZVNlcmllcyQzKCk7XG5cbmZ1bmN0aW9uIG9wdGltYWxCYXJXaWR0aChiYXJTcGFjaW5nLCBwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYmFyU3BhY2luZyAqIDAuMyAqIHBpeGVsUmF0aW8pO1xufVxuZnVuY3Rpb24gb3B0aW1hbENhbmRsZXN0aWNrV2lkdGgoYmFyU3BhY2luZywgcGl4ZWxSYXRpbykge1xuICAgIGNvbnN0IGJhclNwYWNpbmdTcGVjaWFsQ2FzZUZyb20gPSAyLjU7XG4gICAgY29uc3QgYmFyU3BhY2luZ1NwZWNpYWxDYXNlVG8gPSA0O1xuICAgIGNvbnN0IGJhclNwYWNpbmdTcGVjaWFsQ2FzZUNvZWZmID0gMztcbiAgICBpZiAoYmFyU3BhY2luZyA+PSBiYXJTcGFjaW5nU3BlY2lhbENhc2VGcm9tICYmIGJhclNwYWNpbmcgPD0gYmFyU3BhY2luZ1NwZWNpYWxDYXNlVG8pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYmFyU3BhY2luZ1NwZWNpYWxDYXNlQ29lZmYgKiBwaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgLy8gY29lZmYgc2hvdWxkIGJlIDEgb24gc21hbGwgYmFyc3BhY2luZyBhbmQgZ28gdG8gMC44IHdoaWxlIGdyb2luZyBiYXIgc3BhY2luZ1xuICAgIGNvbnN0IGJhclNwYWNpbmdSZWR1Y2luZ0NvZWZmID0gMC4yO1xuICAgIGNvbnN0IGNvZWZmID0gMSAtIGJhclNwYWNpbmdSZWR1Y2luZ0NvZWZmICogTWF0aC5hdGFuKE1hdGgubWF4KGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvLCBiYXJTcGFjaW5nKSAtIGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvKSAvIChNYXRoLlBJICogMC41KTtcbiAgICBjb25zdCByZXMgPSBNYXRoLmZsb29yKGJhclNwYWNpbmcgKiBjb2VmZiAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHNjYWxlZEJhclNwYWNpbmcgPSBNYXRoLmZsb29yKGJhclNwYWNpbmcgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBvcHRpbWFsID0gTWF0aC5taW4ocmVzLCBzY2FsZWRCYXJTcGFjaW5nKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgb3B0aW1hbCk7XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckJhcnMgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA9IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhcnMubGVuZ3RoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY0JhcldpZHRoKGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gZ3JpZCBhbmQgY3Jvc3NoYWlyIGhhdmUgbGluZSB3aWR0aCA9IE1hdGguZmxvb3IocGl4ZWxSYXRpbylcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBvZGQsIHdlIGhhdmUgdG8gbWFrZSBiYXJzJyB3aWR0aCBvZGRcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBldmVuLCB3ZSBoYXZlIHRvIG1ha2UgYmFycycgd2lkdGggZXZlblxuICAgICAgICAvLyBpbiBvcmRlciBvZiBrZWVwaW5nIGNyb3NzaGFpci1vdmVyLWJhciBkcmF3aW5nIHN5bW1ldHJpY1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgaWYgKChsaW5lV2lkdGggJSAyKSAhPT0gKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICUgMikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNjYWxlIGlzIGNvbXByZXNzZWQsIGJhciBjb3VsZCBiZWNvbWUgbGVzcyB0aGFuIDEgQ1NTIHBpeGVsXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RoaW5CYXJzID8gTWF0aC5taW4odGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGgsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKSA6IHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoO1xuICAgICAgICBsZXQgcHJldkNvbG9yID0gbnVsbDtcbiAgICAgICAgY29uc3QgZHJhd09wZW5DbG9zZSA9IHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCA8PSB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAmJiB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nID49IE1hdGguZmxvb3IoMS41ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q29sb3IgIT09IGJhci5faW50ZXJuYWxfYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgICAgICBwcmV2Q29sb3IgPSBiYXIuX2ludGVybmFsX2JhckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keVdpZHRoSGFsZiA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyTGluZVdpZHRoICogMC41KTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlDZW50ZXIgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlMZWZ0ID0gYm9keUNlbnRlciAtIGJvZHlXaWR0aEhhbGY7XG4gICAgICAgICAgICBjb25zdCBib2R5V2lkdGggPSB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBib2R5UmlnaHQgPSBib2R5TGVmdCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gTWF0aC5taW4oYmFyLl9pbnRlcm5hbF9oaWdoWSwgYmFyLl9pbnRlcm5hbF9sb3dZKTtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IE1hdGgubWF4KGJhci5faW50ZXJuYWxfaGlnaFksIGJhci5faW50ZXJuYWxfbG93WSk7XG4gICAgICAgICAgICBjb25zdCBib2R5VG9wID0gTWF0aC5yb3VuZChoaWdoICogdmVydGljYWxQaXhlbFJhdGlvKSAtIGJvZHlXaWR0aEhhbGY7XG4gICAgICAgICAgICBjb25zdCBib2R5Qm90dG9tID0gTWF0aC5yb3VuZChsb3cgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pICsgYm9keVdpZHRoSGFsZjtcbiAgICAgICAgICAgIGNvbnN0IGJvZHlIZWlnaHQgPSBNYXRoLm1heCgoYm9keUJvdHRvbSAtIGJvZHlUb3ApLCB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGgpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJvZHlMZWZ0LCBib2R5VG9wLCBib2R5V2lkdGgsIGJvZHlIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3Qgc2lkZVdpZHRoID0gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICogMS41KTtcbiAgICAgICAgICAgIGlmIChkcmF3T3BlbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX29wZW5WaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5MZWZ0ID0gYm9keUNlbnRlciAtIHNpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wZW5Ub3AgPSBNYXRoLm1heChib2R5VG9wLCBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfb3BlblkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pIC0gYm9keVdpZHRoSGFsZik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcGVuQm90dG9tID0gb3BlblRvcCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuQm90dG9tID4gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQm90dG9tID0gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRvcCA9IG9wZW5Cb3R0b20gLSBib2R5V2lkdGggKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChvcGVuTGVmdCwgb3BlblRvcCwgYm9keUxlZnQgLSBvcGVuTGVmdCwgb3BlbkJvdHRvbSAtIG9wZW5Ub3AgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VSaWdodCA9IGJvZHlDZW50ZXIgKyBzaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3NlVG9wID0gTWF0aC5tYXgoYm9keVRvcCwgTWF0aC5yb3VuZChiYXIuX2ludGVybmFsX2Nsb3NlWSAqIHZlcnRpY2FsUGl4ZWxSYXRpbykgLSBib2R5V2lkdGhIYWxmKTtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VCb3R0b20gPSBjbG9zZVRvcCArIGJvZHlXaWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlQm90dG9tID4gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQm90dG9tID0gYm9keVRvcCArIGJvZHlIZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVRvcCA9IGNsb3NlQm90dG9tIC0gYm9keVdpZHRoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJvZHlSaWdodCArIDEsIGNsb3NlVG9wLCBjbG9zZVJpZ2h0IC0gYm9keVJpZ2h0LCBjbG9zZUJvdHRvbSAtIGNsb3NlVG9wICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2NhbGNCYXJXaWR0aChwaXhlbFJhdGlvKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5mbG9vcihwaXhlbFJhdGlvKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxpbWl0LCBNYXRoLmZsb29yKG9wdGltYWxCYXJXaWR0aChlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpLl9pbnRlcm5hbF9iYXJTcGFjaW5nLCBwaXhlbFJhdGlvKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgQmFyc1BhbmVWaWV3QmFzZSBleHRlbmRzIFNlcmllc1BhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsLCBmYWxzZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY29udmVydFRvQ29vcmRpbmF0ZXMocHJpY2VTY2FsZSwgdGltZVNjYWxlLCBmaXJzdFZhbHVlKSB7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2JhclByaWNlc1RvQ29vcmRpbmF0ZXModGhpcy5faW50ZXJuYWxfX2l0ZW1zLCBmaXJzdFZhbHVlLCB1bmRlZmluZWRJZk51bGwodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlRGVmYXVsdEl0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogdGltZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9vcGVuOiBiYXIuX2ludGVybmFsX3ZhbHVlWzAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlnaDogYmFyLl9pbnRlcm5hbF92YWx1ZVsxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi9dLFxuICAgICAgICAgICAgX2ludGVybmFsX2xvdzogYmFyLl9pbnRlcm5hbF92YWx1ZVsyIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkxvdyAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfY2xvc2U6IGJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX29wZW5ZOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlnaFk6IE5hTixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9sb3dZOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfY2xvc2VZOiBOYU4sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cygpIHtcbiAgICAgICAgY29uc3QgY29sb3JlciA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhckNvbG9yZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9yb3dzKCkubWFwKChyb3cpID0+IHRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHJvdy5faW50ZXJuYWxfaW5kZXgsIHJvdywgY29sb3JlcikpO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQmFyc1BhbmVWaWV3IGV4dGVuZHMgQmFyc1BhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJCYXJzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19jcmVhdGVEZWZhdWx0SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpLFxuICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYmFyU3R5bGVQcm9wcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJzOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX29wZW5WaXNpYmxlOiBiYXJTdHlsZVByb3BzLm9wZW5WaXNpYmxlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RoaW5CYXJzOiBiYXJTdHlsZVByb3BzLnRoaW5CYXJzLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGJhclN0eWxlRGVmYXVsdHMgPSB7XG4gICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgIG9wZW5WaXNpYmxlOiB0cnVlLFxuICAgIHRoaW5CYXJzOiB0cnVlLFxufTtcbmNvbnN0IGNyZWF0ZVBhbmVWaWV3JDIgPSAoc2VyaWVzLCBtb2RlbCkgPT4gbmV3IFNlcmllc0JhcnNQYW5lVmlldyhzZXJpZXMsIG1vZGVsKTtcbmNvbnN0IGNyZWF0ZVNlcmllcyQyID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdCYXInLFxuICAgICAgICBpc0J1aWx0SW46IHRydWUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBiYXJTdHlsZURlZmF1bHRzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3JDIsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG5jb25zdCBiYXJTZXJpZXMgPSBjcmVhdGVTZXJpZXMkMigpO1xuXG5jbGFzcyBQYW5lUmVuZGVyZXJDYW5kbGVzdGlja3MgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgICAgICAvLyBzY2FsZWQgd2l0aCBwaXhlbFJhdGlvXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID0gMDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbChyZW5kZXJpbmdTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGhvcml6b250YWxQaXhlbFJhdGlvIH0gPSByZW5kZXJpbmdTY29wZTtcbiAgICAgICAgLy8gbm93IHdlIGtub3cgcGl4ZWxSYXRpbyBhbmQgd2UgY291bGQgY2FsY3VsYXRlIGJhcldpZHRoIGVmZmVjdGl2ZWx5XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID0gb3B0aW1hbENhbmRsZXN0aWNrV2lkdGgodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyU3BhY2luZywgaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAvLyBncmlkIGFuZCBjcm9zc2hhaXIgaGF2ZSBsaW5lIHdpZHRoID0gTWF0aC5mbG9vcihwaXhlbFJhdGlvKVxuICAgICAgICAvLyBpZiB0aGlzIHZhbHVlIGlzIG9kZCwgd2UgaGF2ZSB0byBtYWtlIGNhbmRsZXN0aWNrcycgd2lkdGggb2RkXG4gICAgICAgIC8vIGlmIHRoaXMgdmFsdWUgaXMgZXZlbiwgd2UgaGF2ZSB0byBtYWtlIGNhbmRsZXN0aWNrcycgd2lkdGggZXZlblxuICAgICAgICAvLyBpbiBvcmRlciBvZiBrZWVwaW5nIGNyb3NzaGFpci1vdmVyLWNhbmRsZXN0aWNrcyBkcmF3aW5nIHN5bW1ldHJpY1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPj0gMikge1xuICAgICAgICAgICAgY29uc3Qgd2lja1dpZHRoID0gTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBpZiAoKHdpY2tXaWR0aCAlIDIpICE9PSAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggJSAyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFycyA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhcnM7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF93aWNrVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1dpY2tzKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Qm9yZGVyKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JvcmRlclZpc2libGUgfHwgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPiBib3JkZXJXaWR0aCAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdDYW5kbGVzKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3V2lja3MocmVuZGVyaW5nU2NvcGUsIGJhcnMsIHZpc2libGVSYW5nZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0gPSByZW5kZXJpbmdTY29wZTtcbiAgICAgICAgbGV0IHByZXZXaWNrQ29sb3IgPSAnJztcbiAgICAgICAgbGV0IHdpY2tXaWR0aCA9IE1hdGgubWluKE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pLCBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICB3aWNrV2lkdGggPSBNYXRoLm1heChNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSwgTWF0aC5taW4od2lja1dpZHRoLCB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCkpO1xuICAgICAgICBjb25zdCB3aWNrT2Zmc2V0ID0gTWF0aC5mbG9vcih3aWNrV2lkdGggKiAwLjUpO1xuICAgICAgICBsZXQgcHJldkVkZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb207IGkgPCB2aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFyc1tpXTtcbiAgICAgICAgICAgIGlmIChiYXIuX2ludGVybmFsX2JhcldpY2tDb2xvciAhPT0gcHJldldpY2tDb2xvcikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYXIuX2ludGVybmFsX2JhcldpY2tDb2xvcjtcbiAgICAgICAgICAgICAgICBwcmV2V2lja0NvbG9yID0gYmFyLl9pbnRlcm5hbF9iYXJXaWNrQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBNYXRoLnJvdW5kKE1hdGgubWluKGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gTWF0aC5yb3VuZChiYXIuX2ludGVybmFsX2hpZ2hZICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF9sb3dZICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZFggPSBNYXRoLnJvdW5kKGhvcml6b250YWxQaXhlbFJhdGlvICogYmFyLl9pbnRlcm5hbF94KTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2NhbGVkWCAtIHdpY2tPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGxlZnQgKyB3aWNrV2lkdGggLSAxO1xuICAgICAgICAgICAgaWYgKHByZXZFZGdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KHByZXZFZGdlICsgMSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCBoaWdoLCB3aWR0aCwgdG9wIC0gaGlnaCk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgYm90dG9tICsgMSwgd2lkdGgsIGxvdyAtIGJvdHRvbSk7XG4gICAgICAgICAgICBwcmV2RWRnZSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19jYWxjdWxhdGVCb3JkZXJXaWR0aChwaXhlbFJhdGlvKSB7XG4gICAgICAgIGxldCBib3JkZXJXaWR0aCA9IE1hdGguZmxvb3IoMSAvKiBDb25zdGFudHMuQmFyQm9yZGVyV2lkdGggKi8gKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoIDw9IDIgKiBib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgYm9yZGVyV2lkdGggPSBNYXRoLmZsb29yKCh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAtIDEpICogMC41KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBNYXRoLm1heChNYXRoLmZsb29yKHBpeGVsUmF0aW8pLCBib3JkZXJXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA8PSByZXMgKiAyKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgZHJhdyBib2RpZXMsIHJlc3RvcmUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmZsb29yKHBpeGVsUmF0aW8pLCBNYXRoLmZsb29yKDEgLyogQ29uc3RhbnRzLkJhckJvcmRlcldpZHRoICovICogcGl4ZWxSYXRpbykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Qm9yZGVyKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIGxldCBwcmV2Qm9yZGVyQ29sb3IgPSAnJztcbiAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0aGlzLl9wcml2YXRlX19jYWxjdWxhdGVCb3JkZXJXaWR0aChob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGxldCBwcmV2RWRnZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHZpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiYXIgPSBiYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGJhci5faW50ZXJuYWxfYmFyQm9yZGVyQ29sb3IgIT09IHByZXZCb3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYXIuX2ludGVybmFsX2JhckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIHByZXZCb3JkZXJDb2xvciA9IGJhci5faW50ZXJuYWxfYmFyQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGVmdCA9IE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pIC0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAqIDAuNSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCB0byBjYWxjdWxhdGUgcmlnaHQgYmVmb3JlIHBhdGNoaW5nIGxlZnRcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGgucm91bmQoTWF0aC5taW4oYmFyLl9pbnRlcm5hbF9vcGVuWSwgYmFyLl9pbnRlcm5hbF9jbG9zZVkpICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgucm91bmQoTWF0aC5tYXgoYmFyLl9pbnRlcm5hbF9vcGVuWSwgYmFyLl9pbnRlcm5hbF9jbG9zZVkpICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGlmIChwcmV2RWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChwcmV2RWRnZSArIDEsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyU3BhY2luZyAqIGhvcml6b250YWxQaXhlbFJhdGlvID4gMiAqIGJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgZmlsbFJlY3RJbm5lckJvcmRlcihjdHgsIGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0ICsgMSwgYm90dG9tIC0gdG9wICsgMSwgYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20gLSB0b3AgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFZGdlID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdDYW5kbGVzKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIGxldCBwcmV2QmFyQ29sb3IgPSAnJztcbiAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0aGlzLl9wcml2YXRlX19jYWxjdWxhdGVCb3JkZXJXaWR0aChob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHZpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiYXIgPSBiYXJzW2ldO1xuICAgICAgICAgICAgbGV0IHRvcCA9IE1hdGgucm91bmQoTWF0aC5taW4oYmFyLl9pbnRlcm5hbF9vcGVuWSwgYmFyLl9pbnRlcm5hbF9jbG9zZVkpICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pIC0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAqIDAuNSk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggLSAxO1xuICAgICAgICAgICAgaWYgKGJhci5faW50ZXJuYWxfYmFyQ29sb3IgIT09IHByZXZCYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhckNvbG9yID0gYmFyLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgcHJldkJhckNvbG9yID0gYmFyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYm9yZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgdG9wICs9IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0IC09IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIGJvdHRvbSAtPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiBib3R0b20pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCArIDEsIGJvdHRvbSAtIHRvcCArIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNDYW5kbGVzdGlja3NQYW5lVmlldyBleHRlbmRzIEJhcnNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVyQ2FuZGxlc3RpY2tzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19jcmVhdGVEZWZhdWx0SXRlbSh0aW1lLCBiYXIsIGNvbG9yZXIpLFxuICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgY2FuZGxlc3RpY2tTdHlsZVByb3BzID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoe1xuICAgICAgICAgICAgX2ludGVybmFsX2JhcnM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJTcGFjaW5nOiB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfd2lja1Zpc2libGU6IGNhbmRsZXN0aWNrU3R5bGVQcm9wcy53aWNrVmlzaWJsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlOiBjYW5kbGVzdGlja1N0eWxlUHJvcHMuYm9yZGVyVmlzaWJsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBjYW5kbGVzdGlja1N0eWxlRGVmYXVsdHMgPSB7XG4gICAgdXBDb2xvcjogJyMyNmE2OWEnLFxuICAgIGRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgIHdpY2tWaXNpYmxlOiB0cnVlLFxuICAgIGJvcmRlclZpc2libGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6ICcjMzc4NjU4JyxcbiAgICBib3JkZXJVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgYm9yZGVyRG93bkNvbG9yOiAnI2VmNTM1MCcsXG4gICAgd2lja0NvbG9yOiAnIzczNzM3NScsXG4gICAgd2lja1VwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICB3aWNrRG93bkNvbG9yOiAnI2VmNTM1MCcsXG59O1xuY29uc3QgY3JlYXRlUGFuZVZpZXckMSA9IChzZXJpZXMsIG1vZGVsKSA9PiBuZXcgU2VyaWVzQ2FuZGxlc3RpY2tzUGFuZVZpZXcoc2VyaWVzLCBtb2RlbCk7XG5jb25zdCBjcmVhdGVTZXJpZXMkMSA9ICgpID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiAnQ2FuZGxlc3RpY2snLFxuICAgICAgICBpc0J1aWx0SW46IHRydWUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBjYW5kbGVzdGlja1N0eWxlRGVmYXVsdHMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIF9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldzogY3JlYXRlUGFuZVZpZXckMSxcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbmNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzID0gY3JlYXRlU2VyaWVzJDEoKTtcblxuY29uc3Qgc2hvd1NwYWNpbmdNaW5pbWFsQmFyV2lkdGggPSAxO1xuY29uc3QgYWxpZ25Ub01pbmltYWxXaWR0aExpbWl0ID0gNDtcbmNsYXNzIFBhbmVSZW5kZXJlckhpc3RvZ3JhbSBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZSA9IFtdO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpbGxQcmVjYWxjdWxhdGVkQ2FjaGUoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGNvbnN0IGhpc3RvZ3JhbUJhc2UgPSBNYXRoLnJvdW5kKCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9oaXN0b2dyYW1CYXNlKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnN0IHRvcEhpc3RvZ3JhbUJhc2UgPSBoaXN0b2dyYW1CYXNlIC0gTWF0aC5mbG9vcih0aWNrV2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgYm90dG9tSGlzdG9ncmFtQmFzZSA9IHRvcEhpc3RvZ3JhbUJhc2UgKyB0aWNrV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChpdGVtLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgIGxldCB0b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tO1xuICAgICAgICAgICAgaWYgKHkgPD0gdG9wSGlzdG9ncmFtQmFzZSkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gYm90dG9tSGlzdG9ncmFtQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRvcEhpc3RvZ3JhbUJhc2U7XG4gICAgICAgICAgICAgICAgYm90dG9tID0geSAtIE1hdGguZmxvb3IodGlja1dpZHRoIC8gMikgKyB0aWNrV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoY3VycmVudC5faW50ZXJuYWxfbGVmdCwgdG9wLCBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCAtIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgKyAxLCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX2ZpbGxQcmVjYWxjdWxhdGVkQ2FjaGUocGl4ZWxSYXRpbykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFjaW5nID0gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBwaXhlbFJhdGlvKSA8PSBzaG93U3BhY2luZ01pbmltYWxCYXJXaWR0aCA/IDAgOiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHBpeGVsUmF0aW8pKTtcbiAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBwaXhlbFJhdGlvKSAtIHNwYWNpbmc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZSA9IG5ldyBBcnJheSh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG8gLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICAvLyBmb3JjZSBjYXN0IHRvIGF2b2lkIGVuc3VyZURlZmluZWQgY2FsbFxuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoaXRlbS5faW50ZXJuYWxfeCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQ7XG4gICAgICAgICAgICBpZiAoY29sdW1uV2lkdGggJSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZldpZHRoID0gKGNvbHVtbldpZHRoIC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB4IC0gaGFsZldpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0geCArIGhhbGZXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBpeGVsIHRvIGxlZnRcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmV2lkdGggPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHggLSBoYWxmV2lkdGg7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB4ICsgaGFsZldpZHRoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dID0ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9yaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3JvdW5kZWRDZW50ZXI6IHgsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NlbnRlcjogKGl0ZW0uX2ludGVybmFsX3ggKiBwaXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogaXRlbS5faW50ZXJuYWxfdGltZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29ycmVjdCBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tICsgMTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbSAtIDFdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuX2ludGVybmFsX3RpbWUgIT09IHByZXYuX2ludGVybmFsX3RpbWUgKyAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudC5faW50ZXJuYWxfbGVmdCAtIHByZXYuX2ludGVybmFsX3JpZ2h0ICE9PSAoc3BhY2luZyArIDEpKSB7XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBhbGlnblxuICAgICAgICAgICAgICAgIGlmIChwcmV2Ll9pbnRlcm5hbF9yb3VuZGVkQ2VudGVyID4gcHJldi5faW50ZXJuYWxfY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXYgd2Fzc2hpZnRlZCB0byBsZWZ0LCBzbyBhZGQgcGl4ZWwgdG8gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgcHJldi5faW50ZXJuYWxfcmlnaHQgPSBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0IC0gc3BhY2luZyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmQgY3VycmVudCB0byBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgPSBwcmV2Ll9pbnRlcm5hbF9yaWdodCArIHNwYWNpbmcgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWluV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyU3BhY2luZyAqIHBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dO1xuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgYmFyc3BhY2luZyA8IDFcbiAgICAgICAgICAgIGlmIChjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCA8IGN1cnJlbnQuX2ludGVybmFsX2xlZnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCA9IGN1cnJlbnQuX2ludGVybmFsX2xlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC0gY3VycmVudC5faW50ZXJuYWxfbGVmdCArIDE7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IE1hdGgubWluKHdpZHRoLCBtaW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNpbmcgPiAwICYmIG1pbldpZHRoIDwgYWxpZ25Ub01pbmltYWxXaWR0aExpbWl0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGVbaSAtIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC0gY3VycmVudC5faW50ZXJuYWxfbGVmdCArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gbWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuX2ludGVybmFsX3JvdW5kZWRDZW50ZXIgPiBjdXJyZW50Ll9pbnRlcm5hbF9jZW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX2ludGVybmFsX3JpZ2h0IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0hpc3RvZ3JhbVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJIaXN0b2dyYW0oKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHRpbWUsIHByaWNlLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpLFxuICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhclNwYWNpbmc6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9oaXN0b2dyYW1CYXNlOiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5iYXNlLCBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKSkuX2ludGVybmFsX3ZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgIH1cbn1cblxuY29uc3QgaGlzdG9ncmFtU3R5bGVEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyMyNmE2OWEnLFxuICAgIGJhc2U6IDAsXG59O1xuY29uc3QgY3JlYXRlUGFuZVZpZXcgPSAoc2VyaWVzLCBtb2RlbCkgPT4gbmV3IFNlcmllc0hpc3RvZ3JhbVBhbmVWaWV3KHNlcmllcywgbW9kZWwpO1xuY29uc3QgY3JlYXRlU2VyaWVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdIaXN0b2dyYW0nLFxuICAgICAgICBpc0J1aWx0SW46IHRydWUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBoaXN0b2dyYW1TdHlsZURlZmF1bHRzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3LFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuY29uc3QgaGlzdG9ncmFtU2VyaWVzID0gY3JlYXRlU2VyaWVzKCk7XG5cbmNsYXNzIFBhbmVQcmltaXRpdmVXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lLCBwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0YWNoKCk7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5kZXRhY2hQcmltaXRpdmUodGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlKTtcbiAgICB9XG4gICAgZ2V0UGFuZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmU7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zPy4ob3B0aW9ucyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hdHRhY2goKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuYXR0YWNoUHJpbWl0aXZlKHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSk7XG4gICAgfVxufVxuXG5jb25zdCB0ZXh0V2F0ZXJtYXJrT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHZpc2libGU6IHRydWUsXG4gICAgaG9yekFsaWduOiAnY2VudGVyJyxcbiAgICB2ZXJ0QWxpZ246ICdjZW50ZXInLFxuICAgIGxpbmVzOiBbXSxcbn07XG5jb25zdCB0ZXh0V2F0ZXJtYXJrTGluZU9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgZm9udFNpemU6IDQ4LFxuICAgIGZvbnRGYW1pbHk6IGRlZmF1bHRGb250RmFtaWx5LFxuICAgIGZvbnRTdHlsZTogJycsXG4gICAgdGV4dDogJycsXG59O1xuXG5jbGFzcyBUZXh0V2F0ZXJtYXJrUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWV0cmljc0NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gb3B0aW9ucztcbiAgICB9XG4gICAgZHJhdyh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCwgbWVkaWFTaXplIH0gPSBzY29wZTtcbiAgICAgICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhLmxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gbGluZS5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0aGlzLl9wcml2YXRlX19tZXRyaWNzKGN0eCwgbGluZS50ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dFdpZHRoID4gbWVkaWFTaXplLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuX2ludGVybmFsX3pvb20gPSBtZWRpYVNpemUud2lkdGggLyB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLl9pbnRlcm5hbF96b29tID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dEhlaWdodCArPSBsaW5lLmxpbmVIZWlnaHQgKiBsaW5lLl9pbnRlcm5hbF96b29tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZlcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19kYXRhLnZlcnRBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHZlcnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ID0gTWF0aC5tYXgoKG1lZGlhU2l6ZS5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ID0gTWF0aC5tYXgobWVkaWFTaXplLmhlaWdodCAtIHRleHRIZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhLmxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGluZS5jb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgaG9yek9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19kYXRhLmhvcnpBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3J6T2Zmc2V0ID0gbGluZS5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9yek9mZnNldCA9IG1lZGlhU2l6ZS53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3J6T2Zmc2V0ID0gbWVkaWFTaXplLndpZHRoIC0gMSAtIGxpbmUubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShob3J6T2Zmc2V0LCB2ZXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBsaW5lLl9pbnRlcm5hbF9mb250O1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShsaW5lLl9pbnRlcm5hbF96b29tLCBsaW5lLl9pbnRlcm5hbF96b29tKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGluZS50ZXh0LCAwLCBsaW5lLl9pbnRlcm5hbF92ZXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHZlcnRPZmZzZXQgKz0gbGluZS5saW5lSGVpZ2h0ICogbGluZS5faW50ZXJuYWxfem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tZXRyaWNzKGN0eCwgdGV4dCkge1xuICAgICAgICBjb25zdCBmb250Q2FjaGUgPSB0aGlzLl9wcml2YXRlX19mb250Q2FjaGUoY3R4LmZvbnQpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZm9udENhY2hlLmdldCh0ZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgICAgICBmb250Q2FjaGUuc2V0KHRleHQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZvbnRDYWNoZShmb250KSB7XG4gICAgICAgIGxldCBmb250Q2FjaGUgPSB0aGlzLl9wcml2YXRlX19tZXRyaWNzQ2FjaGUuZ2V0KGZvbnQpO1xuICAgICAgICBpZiAoZm9udENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21ldHJpY3NDYWNoZS5zZXQoZm9udCwgZm9udENhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udENhY2hlO1xuICAgIH1cbn1cblxuY2xhc3MgVGV4dFdhdGVybWFya1BhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBidWlsZFJlbmRlcmVyT3B0aW9ucyQxKG9wdGlvbnMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IGJ1aWxkUmVuZGVyZXJPcHRpb25zJDEob3B0aW9ucyk7XG4gICAgfVxuICAgIHJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRXYXRlcm1hcmtSZW5kZXJlcih0aGlzLl9wcml2YXRlX19vcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJlbmRlcmVyTGluZU9wdGlvbnMobGluZU9wdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxpbmVPcHRpb24sXG4gICAgICAgIF9pbnRlcm5hbF9mb250OiBtYWtlRm9udChsaW5lT3B0aW9uLmZvbnRTaXplLCBsaW5lT3B0aW9uLmZvbnRGYW1pbHksIGxpbmVPcHRpb24uZm9udFN0eWxlKSxcbiAgICAgICAgbGluZUhlaWdodDogbGluZU9wdGlvbi5saW5lSGVpZ2h0IHx8IGxpbmVPcHRpb24uZm9udFNpemUgKiAxLjIsXG4gICAgICAgIF9pbnRlcm5hbF92ZXJ0T2Zmc2V0OiAwLFxuICAgICAgICBfaW50ZXJuYWxfem9vbTogMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRSZW5kZXJlck9wdGlvbnMkMShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbGluZXM6IG9wdGlvbnMubGluZXMubWFwKGJ1aWxkUmVuZGVyZXJMaW5lT3B0aW9ucyksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VMaW5lT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGV4dFdhdGVybWFya0xpbmVPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50ZXh0V2F0ZXJtYXJrT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBsaW5lczogb3B0aW9ucy5saW5lcz8ubWFwKG1lcmdlTGluZU9wdGlvbnNXaXRoRGVmYXVsdHMpID8/IFtdLFxuICAgIH07XG59XG5jbGFzcyBUZXh0V2F0ZXJtYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBtZXJnZU9wdGlvbnNXaXRoRGVmYXVsdHMkMihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzID0gW25ldyBUZXh0V2F0ZXJtYXJrUGFuZVZpZXcodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyldO1xuICAgIH1cbiAgICB1cGRhdGVBbGxWaWV3cygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzLmZvckVhY2goKHB3KSA9PiBwdy5faW50ZXJuYWxfdXBkYXRlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpKTtcbiAgICB9XG4gICAgcGFuZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzO1xuICAgIH1cbiAgICBhdHRhY2hlZCh7IHJlcXVlc3RVcGRhdGUgfSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlID0gcmVxdWVzdFVwZGF0ZTtcbiAgICB9XG4gICAgZGV0YWNoZWQoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzJDIoeyAuLi50aGlzLl9wcml2YXRlX19vcHRpb25zLCAuLi5vcHRpb25zIH0pO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGltYWdlIHdhdGVybWFyay5cbiAqXG4gKiBAcGFyYW0gcGFuZSAtIFRhcmdldCBwYW5lLlxuICogQHBhcmFtIG9wdGlvbnMgLSBXYXRlcm1hcmsgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBJbWFnZSB3YXRlcm1hcmsgd3JhcHBlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IGNyZWF0ZVRleHRXYXRlcm1hcmsgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuICpcbiAqIGNvbnN0IGZpcnN0UGFuZSA9IGNoYXJ0LnBhbmVzKClbMF07XG4gKiBjb25zdCB0ZXh0V2F0ZXJtYXJrID0gY3JlYXRlVGV4dFdhdGVybWFyayhmaXJzdFBhbmUsIHtcbiAqIFx0ICBob3J6QWxpZ246ICdjZW50ZXInLFxuICogXHQgIHZlcnRBbGlnbjogJ2NlbnRlcicsXG4gKiBcdCAgbGluZXM6IFtcbiAqIFx0ICAgIHtcbiAqIFx0ICAgICAgdGV4dDogJ0hlbGxvJyxcbiAqIFx0ICAgICAgY29sb3I6ICdyZ2JhKDI1NSwwLDAsMC41KScsXG4gKiBcdCAgICAgIGZvbnRTaXplOiAxMDAsXG4gKiBcdCAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICogXHQgICAgfSxcbiAqIFx0ICAgIHtcbiAqIFx0ICAgICAgdGV4dDogJ1RoaXMgaXMgYSB0ZXh0IHdhdGVybWFyaycsXG4gKiBcdCAgICAgIGNvbG9yOiAncmdiYSgwLDAsMjU1LDAuNSknLFxuICogXHQgICAgICBmb250U2l6ZTogNTAsXG4gKiBcdCAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gKiBcdCAgICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICogXHQgICAgfSxcbiAqIFx0ICBdLFxuICogfSk7XG4gKiAvLyB0byBjaGFuZ2Ugb3B0aW9uc1xuICogdGV4dFdhdGVybWFyay5hcHBseU9wdGlvbnMoeyBob3J6QWxpZ246ICdsZWZ0JyB9KTtcbiAqIC8vIHRvIHJlbW92ZSB3YXRlcm1hcmsgZnJvbSB0aGUgcGFuZVxuICogdGV4dFdhdGVybWFyay5kZXRhY2goKTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0V2F0ZXJtYXJrKHBhbmUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhbmVQcmltaXRpdmVXcmFwcGVyKHBhbmUsIG5ldyBUZXh0V2F0ZXJtYXJrKG9wdGlvbnMpKTtcbn1cblxuY29uc3QgaW1hZ2VXYXRlcm1hcmtPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgYWxwaGE6IDEsXG4gICAgcGFkZGluZzogMCxcbn07XG5cbmNsYXNzIEltYWdlV2F0ZXJtYXJrUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGRyYXcodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHNjb3BlLmNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9wcml2YXRlX19kZXRlcm1pbmVQbGFjZW1lbnQodGhpcy5fcHJpdmF0ZV9fZGF0YSwgc2NvcGUubWVkaWFTaXplKTtcbiAgICAgICAgICAgIGlmICghcG9zIHx8ICF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pbWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5hbHBoYSA/PyAxO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pbWdFbGVtZW50LCBwb3MuX2ludGVybmFsX3gsIHBvcy5faW50ZXJuYWxfeSwgcG9zLl9pbnRlcm5hbF93aWR0aCwgcG9zLl9pbnRlcm5hbF9oZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RldGVybWluZVBsYWNlbWVudChkYXRhLCBwYW5lU2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1heEhlaWdodCwgbWF4V2lkdGgsIF9pbnRlcm5hbF9pbWdIZWlnaHQ6IGltZ0hlaWdodCwgX2ludGVybmFsX2ltZ1dpZHRoOiBpbWdXaWR0aCwgcGFkZGluZyB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgcGxvdENlbnRyZVggPSBNYXRoLnJvdW5kKHBhbmVTaXplLndpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IHBsb3RDZW50cmVZID0gTWF0aC5yb3VuZChwYW5lU2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1NpemUgPSBwYWRkaW5nID8/IDA7XG4gICAgICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IHBhbmVTaXplLndpZHRoIC0gMiAqIHBhZGRpbmdTaXplO1xuICAgICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gcGFuZVNpemUuaGVpZ2h0IC0gMiAqIHBhZGRpbmdTaXplO1xuICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1pbihhdmFpbGFibGVIZWlnaHQsIG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NhbGVYID0gYXZhaWxhYmxlV2lkdGggLyBpbWdXaWR0aDtcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gYXZhaWxhYmxlSGVpZ2h0IC8gaW1nSGVpZ2h0O1xuICAgICAgICBjb25zdCBzY2FsZVRvVXNlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBjb25zdCBkcmF3V2lkdGggPSBpbWdXaWR0aCAqIHNjYWxlVG9Vc2U7XG4gICAgICAgIGNvbnN0IGRyYXdIZWlnaHQgPSBpbWdIZWlnaHQgKiBzY2FsZVRvVXNlO1xuICAgICAgICBjb25zdCB4ID0gcGxvdENlbnRyZVggLSAwLjUgKiBkcmF3V2lkdGg7XG4gICAgICAgIGNvbnN0IHkgPSBwbG90Q2VudHJlWSAtIDAuNSAqIGRyYXdIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogeCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiB5LFxuICAgICAgICAgICAgX2ludGVybmFsX2hlaWdodDogZHJhd0hlaWdodCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aDogZHJhd1dpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXYXRlcm1hcmtQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltYWdlV2lkdGggPSAwOyAvLyBkb24ndCBkcmF3IHVudGlsIGxvYWRlZFxuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSBidWlsZFJlbmRlcmVyT3B0aW9ucyh0aGlzLl9wcml2YXRlX19vcHRpb25zLCB0aGlzLl9wcml2YXRlX19pbWFnZSwgdGhpcy5fcHJpdmF0ZV9faW1hZ2VXaWR0aCwgdGhpcy5fcHJpdmF0ZV9faW1hZ2VIZWlnaHQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLl9pbnRlcm5hbF9pbWFnZVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltYWdlV2lkdGggPSBzdGF0ZS5faW50ZXJuYWxfaW1hZ2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuX2ludGVybmFsX2ltYWdlSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltYWdlSGVpZ2h0ID0gc3RhdGUuX2ludGVybmFsX2ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5faW50ZXJuYWxfaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1hZ2UgPSBzdGF0ZS5faW50ZXJuYWxfaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zVXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICB6T3JkZXIoKSB7XG4gICAgICAgIHJldHVybiAnYm90dG9tJztcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID0gYnVpbGRSZW5kZXJlck9wdGlvbnModGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgdGhpcy5fcHJpdmF0ZV9faW1hZ2UsIHRoaXMuX3ByaXZhdGVfX2ltYWdlV2lkdGgsIHRoaXMuX3ByaXZhdGVfX2ltYWdlSGVpZ2h0KTtcbiAgICB9XG4gICAgcmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VXYXRlcm1hcmtSZW5kZXJlcih0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUmVuZGVyZXJPcHRpb25zKG9wdGlvbnMsIGltZ0VsZW1lbnQsIGltZ1dpZHRoLCBpbWdIZWlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBfaW50ZXJuYWxfaW1nRWxlbWVudDogaW1nRWxlbWVudCxcbiAgICAgICAgX2ludGVybmFsX2ltZ1dpZHRoOiBpbWdXaWR0aCxcbiAgICAgICAgX2ludGVybmFsX2ltZ0hlaWdodDogaW1nSGVpZ2h0LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQxKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbWFnZVdhdGVybWFya09wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xufVxuY2xhc3MgSW1hZ2VXYXRlcm1hcmsge1xuICAgIGNvbnN0cnVjdG9yKGltYWdlVXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZVVybCA9IGltYWdlVXJsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzJDEob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cyA9IFtuZXcgSW1hZ2VXYXRlcm1hcmtQYW5lVmlldyh0aGlzLl9wcml2YXRlX19vcHRpb25zKV07XG4gICAgfVxuICAgIHVwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MuZm9yRWFjaCgocHcpID0+IHB3Ll9pbnRlcm5hbF91cGRhdGUoKSk7XG4gICAgfVxuICAgIHBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cztcbiAgICB9XG4gICAgYXR0YWNoZWQoYXR0YWNoZWRQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyByZXF1ZXN0VXBkYXRlIH0gPSBhdHRhY2hlZFBhcmFtcztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSA9IHJlcXVlc3RVcGRhdGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1nRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUhlaWdodCA9IHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQ/Lm5hdHVyYWxIZWlnaHQgPz8gMTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlV2lkdGggPSB0aGlzLl9wcml2YXRlX19pbWdFbGVtZW50Py5uYXR1cmFsV2lkdGggPz8gMTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cy5mb3JFYWNoKChwdikgPT4gcHYuX2ludGVybmFsX3N0YXRlVXBkYXRlKHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW1hZ2VIZWlnaHQ6IGltYWdlSGVpZ2h0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9pbWFnZVdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9pbWFnZTogdGhpcy5fcHJpdmF0ZV9faW1nRWxlbWVudCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWdFbGVtZW50LnNyYyA9IHRoaXMuX3ByaXZhdGVfX2ltYWdlVXJsO1xuICAgIH1cbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1nRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzJDEoeyAuLi50aGlzLl9wcml2YXRlX19vcHRpb25zLCAuLi5vcHRpb25zIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVPcHRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cy5mb3JFYWNoKChwdykgPT4gcHcuX2ludGVybmFsX29wdGlvbnNVcGRhdGUodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbWFnZSB3YXRlcm1hcmsuXG4gKlxuICogQHBhcmFtIHBhbmUgLSBUYXJnZXQgcGFuZS5cbiAqIEBwYXJhbSBpbWFnZVVybCAtIEltYWdlIFVSTC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gV2F0ZXJtYXJrIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgSW1hZ2Ugd2F0ZXJtYXJrIHdyYXBwZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjcmVhdGVJbWFnZVdhdGVybWFyayB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG4gKlxuICogY29uc3QgZmlyc3RQYW5lID0gY2hhcnQucGFuZXMoKVswXTtcbiAqIGNvbnN0IGltYWdlV2F0ZXJtYXJrID0gY3JlYXRlSW1hZ2VXYXRlcm1hcmsoZmlyc3RQYW5lLCAnL2ltYWdlcy9teS1pbWFnZS5wbmcnLCB7XG4gKiAgIGFscGhhOiAwLjUsXG4gKiAgIHBhZGRpbmc6IDIwLFxuICogfSk7XG4gKiAvLyB0byBjaGFuZ2Ugb3B0aW9uc1xuICogaW1hZ2VXYXRlcm1hcmsuYXBwbHlPcHRpb25zKHsgcGFkZGluZzogMTAgfSk7XG4gKiAvLyB0byByZW1vdmUgd2F0ZXJtYXJrIGZyb20gdGhlIHBhbmVcbiAqIGltYWdlV2F0ZXJtYXJrLmRldGFjaCgpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUltYWdlV2F0ZXJtYXJrKHBhbmUsIGltYWdlVXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYW5lUHJpbWl0aXZlV3JhcHBlcihwYW5lLCBuZXcgSW1hZ2VXYXRlcm1hcmsoaW1hZ2VVcmwsIG9wdGlvbnMpKTtcbn1cblxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3NlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0YWNoKCk7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5kZXRhY2hQcmltaXRpdmUodGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZSk7XG4gICAgfVxuICAgIGdldFNlcmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19zZXJpZXM7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlICYmIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX2FwcGx5T3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19hdHRhY2goKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuYXR0YWNoUHJpbWl0aXZlKHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUpO1xuICAgIH1cbn1cblxuY29uc3Qgc2VyaWVzTWFya2VyT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHpPcmRlcjogJ25vcm1hbCcsXG59O1xuXG5mdW5jdGlvbiBzaXplKGJhclNwYWNpbmcsIGNvZWZmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gTWF0aC5taW4oTWF0aC5tYXgoYmFyU3BhY2luZywgMTIgLyogQ29uc3RhbnRzLk1pblNoYXBlU2l6ZSAqLyksIDMwIC8qIENvbnN0YW50cy5NYXhTaGFwZVNpemUgKi8pICogY29lZmY7XG4gICAgcmV0dXJuIGNlaWxlZE9kZChyZXN1bHQpO1xufVxuZnVuY3Rpb24gc2hhcGVTaXplKHNoYXBlLCBvcmlnaW5hbFNpemUpIHtcbiAgICBzd2l0Y2ggKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ2Fycm93RG93bic6XG4gICAgICAgIGNhc2UgJ2Fycm93VXAnOlxuICAgICAgICAgICAgcmV0dXJuIHNpemUob3JpZ2luYWxTaXplLCAxKTtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIHJldHVybiBzaXplKG9yaWdpbmFsU2l6ZSwgMC44KTtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgIHJldHVybiBzaXplKG9yaWdpbmFsU2l6ZSwgMC43KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaGFwZUhlaWdodChiYXJTcGFjaW5nKSB7XG4gICAgcmV0dXJuIGNlaWxlZEV2ZW4oc2l6ZShiYXJTcGFjaW5nLCAxKSk7XG59XG5mdW5jdGlvbiBzaGFwZU1hcmdpbihiYXJTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNpemUoYmFyU3BhY2luZywgMC4xKSwgMyAvKiBDb25zdGFudHMuTWluU2hhcGVNYXJnaW4gKi8pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQWRqdXN0ZWRNYXJnaW4obWFyZ2luLCBoYXNTaWRlLCBoYXNJbkJhcikge1xuICAgIGlmIChoYXNTaWRlKSB7XG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0luQmFyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobWFyZ2luIC8gMik7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJyb3codXAsIGN0eCwgY29vcmRzLCBzaXplKSB7XG4gICAgY29uc3QgYXJyb3dTaXplID0gc2hhcGVTaXplKCdhcnJvd1VwJywgc2l6ZSk7XG4gICAgY29uc3QgaGFsZkFycm93U2l6ZSA9ICgoYXJyb3dTaXplIC0gMSkgLyAyKSAqIGNvb3Jkcy5faW50ZXJuYWxfcGl4ZWxSYXRpbztcbiAgICBjb25zdCBiYXNlU2l6ZSA9IGNlaWxlZE9kZChzaXplIC8gMik7XG4gICAgY29uc3QgaGFsZkJhc2VTaXplID0gKChiYXNlU2l6ZSAtIDEpIC8gMikgKiBjb29yZHMuX2ludGVybmFsX3BpeGVsUmF0aW87XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmICh1cCkge1xuICAgICAgICBjdHgubW92ZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCAtIGhhbGZBcnJvd1NpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94LCBjb29yZHMuX2ludGVybmFsX3kgLSBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggKyBoYWxmQXJyb3dTaXplLCBjb29yZHMuX2ludGVybmFsX3kpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCArIGhhbGZCYXNlU2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggKyBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSArIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCAtIGhhbGZCYXNlU2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95ICsgaGFsZkFycm93U2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94IC0gaGFsZkJhc2VTaXplLCBjb29yZHMuX2ludGVybmFsX3kpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhjb29yZHMuX2ludGVybmFsX3ggLSBoYWxmQXJyb3dTaXplLCBjb29yZHMuX2ludGVybmFsX3kpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCwgY29vcmRzLl9pbnRlcm5hbF95ICsgaGFsZkFycm93U2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94ICsgaGFsZkFycm93U2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggKyBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94ICsgaGFsZkJhc2VTaXplLCBjb29yZHMuX2ludGVybmFsX3kgLSBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggLSBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSAtIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCAtIGhhbGZCYXNlU2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICB9XG4gICAgY3R4LmZpbGwoKTtcbn1cbmZ1bmN0aW9uIGhpdFRlc3RBcnJvdyh1cCwgY2VudGVyWCwgY2VudGVyWSwgc2l6ZSwgeCwgeSkge1xuICAgIGNvbnN0IGFycm93U2l6ZSA9IHNoYXBlU2l6ZSgnYXJyb3dVcCcsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZBcnJvd1NpemUgPSAoYXJyb3dTaXplIC0gMSkgLyAyO1xuICAgIGNvbnN0IGJhc2VTaXplID0gY2VpbGVkT2RkKHNpemUgLyAyKTtcbiAgICBjb25zdCBoYWxmQmFzZVNpemUgPSAoYmFzZVNpemUgLSAxKSAvIDI7XG4gICAgY29uc3QgdHJpYW5nbGVUb2xlcmFuY2UgPSAzO1xuICAgIGNvbnN0IHJlY3RUb2xlcmFuY2UgPSAyO1xuICAgIGNvbnN0IGJhc2VMZWZ0ID0gY2VudGVyWCAtIGhhbGZCYXNlU2l6ZSAtIHJlY3RUb2xlcmFuY2U7XG4gICAgY29uc3QgYmFzZVJpZ2h0ID0gY2VudGVyWCArIGhhbGZCYXNlU2l6ZSArIHJlY3RUb2xlcmFuY2U7XG4gICAgY29uc3QgYmFzZVRvcCA9IHVwID8gY2VudGVyWSA6IGNlbnRlclkgLSBoYWxmQXJyb3dTaXplO1xuICAgIGNvbnN0IGJhc2VCb3R0b20gPSB1cCA/IGNlbnRlclkgKyBoYWxmQXJyb3dTaXplIDogY2VudGVyWTtcbiAgICBpZiAoeCA+PSBiYXNlTGVmdCAmJiB4IDw9IGJhc2VSaWdodCAmJlxuICAgICAgICB5ID49IGJhc2VUb3AgLSByZWN0VG9sZXJhbmNlICYmIHkgPD0gYmFzZUJvdHRvbSArIHJlY3RUb2xlcmFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzSW5UcmlhbmdsZUJvdW5kcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZExlZnQgPSBjZW50ZXJYIC0gaGFsZkFycm93U2l6ZSAtIHRyaWFuZ2xlVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBoZWFkUmlnaHQgPSBjZW50ZXJYICsgaGFsZkFycm93U2l6ZSArIHRyaWFuZ2xlVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBoZWFkVG9wID0gdXAgPyBjZW50ZXJZIC0gaGFsZkFycm93U2l6ZSAtIHRyaWFuZ2xlVG9sZXJhbmNlIDogY2VudGVyWTtcbiAgICAgICAgY29uc3QgaGVhZEJvdHRvbSA9IHVwID8gY2VudGVyWSA6IGNlbnRlclkgKyBoYWxmQXJyb3dTaXplICsgdHJpYW5nbGVUb2xlcmFuY2U7XG4gICAgICAgIGlmICh4IDwgaGVhZExlZnQgfHwgeCA+IGhlYWRSaWdodCB8fFxuICAgICAgICAgICAgeSA8IGhlYWRUb3AgfHwgeSA+IGhlYWRCb3R0b20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkeCA9IE1hdGguYWJzKHggLSBjZW50ZXJYKTtcbiAgICAgICAgY29uc3QgZHkgPSB1cFxuICAgICAgICAgICAgPyBNYXRoLmFicyh5IC0gY2VudGVyWSkgLy8gdXAgYXJyb3dcbiAgICAgICAgICAgIDogTWF0aC5hYnMoeSAtIGNlbnRlclkpOyAvLyBkb3duIGFycm93XG4gICAgICAgIHJldHVybiBkeSArIHRyaWFuZ2xlVG9sZXJhbmNlID49IGR4IC8gMjtcbiAgICB9O1xuICAgIHJldHVybiBpc0luVHJpYW5nbGVCb3VuZHMoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0NpcmNsZShjdHgsIGNvb3Jkcywgc2l6ZSkge1xuICAgIGNvbnN0IGNpcmNsZVNpemUgPSBzaGFwZVNpemUoJ2NpcmNsZScsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gKGNpcmNsZVNpemUgLSAxKSAvIDI7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoY29vcmRzLl9pbnRlcm5hbF94LCBjb29yZHMuX2ludGVybmFsX3ksIGhhbGZTaXplICogY29vcmRzLl9pbnRlcm5hbF9waXhlbFJhdGlvLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eC5maWxsKCk7XG59XG5mdW5jdGlvbiBoaXRUZXN0Q2lyY2xlKGNlbnRlclgsIGNlbnRlclksIHNpemUsIHgsIHkpIHtcbiAgICBjb25zdCBjaXJjbGVTaXplID0gc2hhcGVTaXplKCdjaXJjbGUnLCBzaXplKTtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSAyICsgY2lyY2xlU2l6ZSAvIDI7XG4gICAgY29uc3QgeE9mZnNldCA9IGNlbnRlclggLSB4O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBjZW50ZXJZIC0geTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KHhPZmZzZXQgKiB4T2Zmc2V0ICsgeU9mZnNldCAqIHlPZmZzZXQpO1xuICAgIHJldHVybiBkaXN0IDw9IHRvbGVyYW5jZTtcbn1cblxuZnVuY3Rpb24gZHJhd1NxdWFyZShjdHgsIGNvb3Jkcywgc2l6ZSkge1xuICAgIGNvbnN0IHNxdWFyZVNpemUgPSBzaGFwZVNpemUoJ3NxdWFyZScsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gKChzcXVhcmVTaXplIC0gMSkgKiBjb29yZHMuX2ludGVybmFsX3BpeGVsUmF0aW8pIC8gMjtcbiAgICBjb25zdCBsZWZ0ID0gY29vcmRzLl9pbnRlcm5hbF94IC0gaGFsZlNpemU7XG4gICAgY29uc3QgdG9wID0gY29vcmRzLl9pbnRlcm5hbF95IC0gaGFsZlNpemU7XG4gICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgc3F1YXJlU2l6ZSAqIGNvb3Jkcy5faW50ZXJuYWxfcGl4ZWxSYXRpbywgc3F1YXJlU2l6ZSAqIGNvb3Jkcy5faW50ZXJuYWxfcGl4ZWxSYXRpbyk7XG59XG5mdW5jdGlvbiBoaXRUZXN0U3F1YXJlKGNlbnRlclgsIGNlbnRlclksIHNpemUsIHgsIHkpIHtcbiAgICBjb25zdCBzcXVhcmVTaXplID0gc2hhcGVTaXplKCdzcXVhcmUnLCBzaXplKTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IChzcXVhcmVTaXplIC0gMSkgLyAyO1xuICAgIGNvbnN0IGxlZnQgPSBjZW50ZXJYIC0gaGFsZlNpemU7XG4gICAgY29uc3QgdG9wID0gY2VudGVyWSAtIGhhbGZTaXplO1xuICAgIHJldHVybiB4ID49IGxlZnQgJiYgeCA8PSBsZWZ0ICsgc3F1YXJlU2l6ZSAmJlxuICAgICAgICB5ID49IHRvcCAmJiB5IDw9IHRvcCArIHNxdWFyZVNpemU7XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgdGV4dCwgeCwgeSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbykge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNjYWxlKGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gaGl0VGVzdFRleHQodGV4dFgsIHRleHRZLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHgsIHkpIHtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGV4dEhlaWdodCAvIDI7XG4gICAgcmV0dXJuIHggPj0gdGV4dFggJiYgeCA8PSB0ZXh0WCArIHRleHRXaWR0aCAmJlxuICAgICAgICB5ID49IHRleHRZIC0gaGFsZkhlaWdodCAmJiB5IDw9IHRleHRZICsgaGFsZkhlaWdodDtcbn1cblxuY2xhc3MgU2VyaWVzTWFya2Vyc1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplID0gLTE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRGYW1pbHkgPSAnJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9ICcnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX196T3JkZXIgPSAnbm9ybWFsJztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFBhcmFtcyhmb250U2l6ZSwgZm9udEZhbWlseSwgek9yZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgdGhpcy5fcHJpdmF0ZV9fZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udCA9IG1ha2VGb250KGZvbnRTaXplLCBmb250RmFtaWx5KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlLl9pbnRlcm5hbF9yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3pPcmRlciA9IHpPcmRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2hpdFRlc3QoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaSA8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBoaXRUZXN0SXRlbShpdGVtLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHpPcmRlcjogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsSWQ6IGl0ZW0uX2ludGVybmFsX2V4dGVybmFsSWQgPz8gJycsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZHJhdyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3pPcmRlciA9PT0gJ2Fib3ZlU2VyaWVzJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZHJhd0ltcGwoc2NvcGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd0JhY2tncm91bmQodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX196T3JkZXIgIT09ICdhYm92ZVNlcmllcycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RyYXdJbXBsKHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5fcHJpdmF0ZV9fZm9udDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaW5kZXggPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoaXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfd2lkdGggPSB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9jb250ZW50KTtcbiAgICAgICAgICAgICAgICBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9oZWlnaHQgPSB0aGlzLl9wcml2YXRlX19mb250U2l6ZTtcbiAgICAgICAgICAgICAgICBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF94ID0gaXRlbS5faW50ZXJuYWxfeCAtIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3dpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYXdJdGVtKGl0ZW0sIGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBiaXRtYXBTaGFwZUl0ZW1Db29yZGluYXRlcyhpdGVtLCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvKSB7XG4gICAgY29uc3QgdGlja1dpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgIGNvbnN0IGNvcnJlY3Rpb24gPSAodGlja1dpZHRoICUgMikgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF94OiBNYXRoLnJvdW5kKGl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbykgKyBjb3JyZWN0aW9uLFxuICAgICAgICBfaW50ZXJuYWxfeTogaXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyxcbiAgICAgICAgX2ludGVybmFsX3BpeGVsUmF0aW86IGhvcml6b250YWxQaXhlbFJhdGlvLFxuICAgIH07XG59XG5mdW5jdGlvbiBkcmF3SXRlbShpdGVtLCBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pIHtcbiAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5faW50ZXJuYWxfY29sb3I7XG4gICAgaWYgKGl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkcmF3VGV4dChjdHgsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX2NvbnRlbnQsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3ksIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBkcmF3U2hhcGUoaXRlbSwgY3R4LCBiaXRtYXBTaGFwZUl0ZW1Db29yZGluYXRlcyhpdGVtLCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvKSk7XG59XG5mdW5jdGlvbiBkcmF3U2hhcGUoaXRlbSwgY3R4LCBjb29yZGluYXRlcykge1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF9zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChpdGVtLl9pbnRlcm5hbF9zaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJvd0Rvd24nOlxuICAgICAgICAgICAgZHJhd0Fycm93KGZhbHNlLCBjdHgsIGNvb3JkaW5hdGVzLCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnYXJyb3dVcCc6XG4gICAgICAgICAgICBkcmF3QXJyb3codHJ1ZSwgY3R4LCBjb29yZGluYXRlcywgaXRlbS5faW50ZXJuYWxfc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICBkcmF3Q2lyY2xlKGN0eCwgY29vcmRpbmF0ZXMsIGl0ZW0uX2ludGVybmFsX3NpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgZHJhd1NxdWFyZShjdHgsIGNvb3JkaW5hdGVzLCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTmV2ZXIoaXRlbS5faW50ZXJuYWxfc2hhcGUpO1xufVxuZnVuY3Rpb24gaGl0VGVzdEl0ZW0oaXRlbSwgeCwgeSkge1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF90ZXh0ICE9PSB1bmRlZmluZWQgJiYgaGl0VGVzdFRleHQoaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfd2lkdGgsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX2hlaWdodCwgeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoaXRUZXN0U2hhcGUoaXRlbSwgeCwgeSk7XG59XG5mdW5jdGlvbiBoaXRUZXN0U2hhcGUoaXRlbSwgeCwgeSkge1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF9zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChpdGVtLl9pbnRlcm5hbF9zaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJvd0Rvd24nOlxuICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RBcnJvdyh0cnVlLCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplLCB4LCB5KTtcbiAgICAgICAgY2FzZSAnYXJyb3dVcCc6XG4gICAgICAgICAgICByZXR1cm4gaGl0VGVzdEFycm93KGZhbHNlLCBpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplLCB4LCB5KTtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIHJldHVybiBoaXRUZXN0Q2lyY2xlKGl0ZW0uX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3ksIGl0ZW0uX2ludGVybmFsX3NpemUsIHgsIHkpO1xuICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RTcXVhcmUoaXRlbS5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfc2l6ZSwgeCwgeSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1ByaWNlTWFya2VyKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAnYXRQcmljZVRvcCcgfHwgcG9zaXRpb24gPT09ICdhdFByaWNlQm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2F0UHJpY2VNaWRkbGUnO1xufVxuZnVuY3Rpb24gZ2V0UHJpY2Uoc2VyaWVzRGF0YSwgbWFya2VyKSB7XG4gICAgaWYgKGlzUHJpY2VNYXJrZXIobWFya2VyLnBvc2l0aW9uKSAmJiBtYXJrZXIucHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWFya2VyLnByaWNlO1xuICAgIH1cbiAgICBpZiAoaXNWYWx1ZURhdGEoc2VyaWVzRGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGEudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc09obGNEYXRhKHNlcmllc0RhdGEpKSB7XG4gICAgICAgIGlmIChtYXJrZXIucG9zaXRpb24gPT09ICdpbkJhcicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNEYXRhLmNsb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXIucG9zaXRpb24gPT09ICdhYm92ZUJhcicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNEYXRhLmhpZ2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlci5wb3NpdGlvbiA9PT0gJ2JlbG93QmFyJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0RhdGEubG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zLCBjb21wbGV4aXR5XG5mdW5jdGlvbiBmaWxsU2l6ZUFuZFkocmVuZGVyZXJJdGVtLCBtYXJrZXIsIHNlcmllc0RhdGEsIG9mZnNldHMsIHRleHRIZWlnaHQsIHNoYXBlTWFyZ2luLCBzZXJpZXMsIGNoYXJ0KSB7XG4gICAgY29uc3QgcHJpY2UgPSBnZXRQcmljZShzZXJpZXNEYXRhLCBtYXJrZXIpO1xuICAgIGlmIChwcmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaWdub3JlT2Zmc2V0ID0gaXNQcmljZU1hcmtlcihtYXJrZXIucG9zaXRpb24pO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGNoYXJ0LnRpbWVTY2FsZSgpO1xuICAgIGNvbnN0IHNpemVNdWx0aXBsaWVyID0gaXNOdW1iZXIobWFya2VyLnNpemUpID8gTWF0aC5tYXgobWFya2VyLnNpemUsIDApIDogMTtcbiAgICBjb25zdCBzaGFwZVNpemUgPSBjYWxjdWxhdGVTaGFwZUhlaWdodCh0aW1lU2NhbGUub3B0aW9ucygpLmJhclNwYWNpbmcpICogc2l6ZU11bHRpcGxpZXI7XG4gICAgY29uc3QgaGFsZlNpemUgPSBzaGFwZVNpemUgLyAyO1xuICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfc2l6ZSA9IHNoYXBlU2l6ZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1hcmtlci5wb3NpdGlvbjtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2luQmFyJzpcbiAgICAgICAgY2FzZSAnYXRQcmljZU1pZGRsZSc6IHtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSA9IGVuc3VyZU5vdE51bGwoc2VyaWVzLnByaWNlVG9Db29yZGluYXRlKHByaWNlKSk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXJJdGVtLl9pbnRlcm5hbF90ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3kgPSByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgKyBoYWxmU2l6ZSArIHNoYXBlTWFyZ2luICsgdGV4dEhlaWdodCAqICgwLjUgKyAwLjEgLyogQ29uc3RhbnRzLlRleHRNYXJnaW4gKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Fib3ZlQmFyJzpcbiAgICAgICAgY2FzZSAnYXRQcmljZVRvcCc6IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGlnbm9yZU9mZnNldCA/IDAgOiBvZmZzZXRzLl9pbnRlcm5hbF9hYm92ZUJhcjtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSA9IChlbnN1cmVOb3ROdWxsKHNlcmllcy5wcmljZVRvQ29vcmRpbmF0ZShwcmljZSkpIC0gaGFsZlNpemUgLSBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF95ID0gcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF95IC0gaGFsZlNpemUgLSB0ZXh0SGVpZ2h0ICogKDAuNSArIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYWJvdmVCYXIgKz0gdGV4dEhlaWdodCAqICgxICsgMiAqIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlnbm9yZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldHMuX2ludGVybmFsX2Fib3ZlQmFyICs9IHNoYXBlU2l6ZSArIHNoYXBlTWFyZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2JlbG93QmFyJzpcbiAgICAgICAgY2FzZSAnYXRQcmljZUJvdHRvbSc6IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGlnbm9yZU9mZnNldCA/IDAgOiBvZmZzZXRzLl9pbnRlcm5hbF9iZWxvd0JhcjtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSA9IChlbnN1cmVOb3ROdWxsKHNlcmllcy5wcmljZVRvQ29vcmRpbmF0ZShwcmljZSkpICsgaGFsZlNpemUgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF95ID0gKHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSArIGhhbGZTaXplICsgc2hhcGVNYXJnaW4gKyB0ZXh0SGVpZ2h0ICogKDAuNSArIDAuMSAvKiBDb25zdGFudHMuVGV4dE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMuX2ludGVybmFsX2JlbG93QmFyICs9IHRleHRIZWlnaHQgKiAoMSArIDIgKiAwLjEgLyogQ29uc3RhbnRzLlRleHRNYXJnaW4gKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9iZWxvd0JhciArPSBzaGFwZVNpemUgKyBzaGFwZU1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsdWVEYXRhKGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICByZXR1cm4gJ3ZhbHVlJyBpbiBkYXRhICYmIHR5cGVvZiBkYXRhLnZhbHVlID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzT2hsY0RhdGEoZGF0YSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIHJldHVybiAnb3BlbicgaW4gZGF0YSAmJiAnaGlnaCcgaW4gZGF0YSAmJiAnbG93JyBpbiBkYXRhICYmICdjbG9zZScgaW4gZGF0YTtcbn1cbmNsYXNzIFNlcmllc01hcmtlcnNQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBjaGFydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgU2VyaWVzTWFya2Vyc1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogW10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLm9wdGlvbnMoKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19tYWtlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9wcml2YXRlX19jaGFydC5vcHRpb25zKClbJ2xheW91dCddO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UGFyYW1zKGxheW91dC5mb250U2l6ZSwgbGF5b3V0LmZvbnRGYW1pbHksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuek9yZGVyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldE1hcmtlcnMobWFya2Vycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzID0gbWFya2VycztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCdkYXRhJyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUodXBkYXRlVHlwZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh1cGRhdGVUeXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICB6T3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnpPcmRlciA9PT0gJ2Fib3ZlU2VyaWVzJyA/ICd0b3AnIDogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy56T3JkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fbWFrZVZhbGlkKCkge1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jaGFydC50aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzTWFya2VycyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnM7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zID0gc2VyaWVzTWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogbWFya2VyLnRpbWUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3g6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3NpemU6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3NoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiBtYXJrZXIuY29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2V4dGVybmFsSWQ6IG1hcmtlci5pZCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW50ZXJuYWxJZDogbWFya2VyLl9pbnRlcm5hbF9pbnRlcm5hbElkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQub3B0aW9ucygpWydsYXlvdXQnXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gbnVsbDtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aW1lU2NhbGUuZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlQmFyc1JhbmdlID0gbmV3IFJhbmdlSW1wbChNYXRoLmZsb29yKHZpc2libGVCYXJzLmZyb20pLCBNYXRoLmNlaWwodmlzaWJsZUJhcnMudG8pKTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5kYXRhKClbMF07XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2VGltZUluZGV4ID0gTmFOO1xuICAgICAgICBjb25zdCBzaGFwZU1hcmdpbiQxID0gc2hhcGVNYXJnaW4odGltZVNjYWxlLm9wdGlvbnMoKS5iYXJTcGFjaW5nKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hYm92ZUJhcjogc2hhcGVNYXJnaW4kMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iZWxvd0Jhcjogc2hhcGVNYXJnaW4kMSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gdmlzaWJsZVRpbWVkVmFsdWVzKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zLCB2aXNpYmxlQmFyc1JhbmdlLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbTsgaW5kZXggPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHNlcmllc01hcmtlcnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50aW1lICE9PSBwcmV2VGltZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IGJhciwgcmVzZXQgc3RhY2sgY291bnRlclxuICAgICAgICAgICAgICAgIG9mZnNldHMuX2ludGVybmFsX2Fib3ZlQmFyID0gc2hhcGVNYXJnaW4kMTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9iZWxvd0JhciA9IHNoYXBlTWFyZ2luJDE7XG4gICAgICAgICAgICAgICAgcHJldlRpbWVJbmRleCA9IG1hcmtlci50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJJdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF94ID0gZW5zdXJlTm90TnVsbCh0aW1lU2NhbGUubG9naWNhbFRvQ29vcmRpbmF0ZShtYXJrZXIudGltZSkpO1xuICAgICAgICAgICAgaWYgKG1hcmtlci50ZXh0ICE9PSB1bmRlZmluZWQgJiYgbWFya2VyLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbnRlbnQ6IG1hcmtlci50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeDogMCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2hlaWdodDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUF0ID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLmRhdGFCeUluZGV4KG1hcmtlci50aW1lLCAwIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5vbmUgKi8pO1xuICAgICAgICAgICAgaWYgKGRhdGFBdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbFNpemVBbmRZKHJlbmRlcmVySXRlbSwgbWFya2VyLCBkYXRhQXQsIG9mZnNldHMsIGxheW91dE9wdGlvbnMuZm9udFNpemUsIHNoYXBlTWFyZ2luJDEsIHRoaXMuX3ByaXZhdGVfX3NlcmllcywgdGhpcy5fcHJpdmF0ZV9fY2hhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNlcmllc01hcmtlck9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xufVxuY2xhc3MgU2VyaWVzTWFya2Vyc1ByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXhlZE1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1Bvc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZEJhclNwYWNpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBhdHRhY2hlZChwYXJhbSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBwYXJhbS5jaGFydDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gcGFyYW0uc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBTZXJpZXNNYXJrZXJzUGFuZVZpZXcodGhpcy5fcHJpdmF0ZV9fc2VyaWVzLCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2NoYXJ0KSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUgPSBwYXJhbS5yZXF1ZXN0VXBkYXRlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMuc3Vic2NyaWJlRGF0YUNoYW5nZWQoKHNjb3BlKSA9PiB0aGlzLl9wcml2YXRlX19vbkRhdGFDaGFuZ2VkKHNjb3BlKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXMgJiYgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWRIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMudW5zdWJzY3JpYmVEYXRhQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZEhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0TWFya2VycyhtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMgPSBtYXJrZXJzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1Bvc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXJrZXJzO1xuICAgIH1cbiAgICBwYW5lVmlld3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA/IFt0aGlzLl9wcml2YXRlX19wYW5lVmlld10gOiBbXTtcbiAgICB9XG4gICAgdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUFsbFZpZXdzKCk7XG4gICAgfVxuICAgIGhpdFRlc3QoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5yZW5kZXJlcigpPy5faW50ZXJuYWxfaGl0VGVzdCh4LCB5KSA/PyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdXRvc2NhbGVJbmZvKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3KSB7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5zID0gdGhpcy5fcHJpdmF0ZV9fZ2V0QXV0b1NjYWxlTWFyZ2lucygpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5zOiBtYXJnaW5zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzKHsgLi4udGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0QXV0b1NjYWxlTWFyZ2lucygpIHtcbiAgICAgICAgY29uc3QgY2hhcnQgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2NoYXJ0KTtcbiAgICAgICAgY29uc3QgYmFyU3BhY2luZyA9IGNoYXJ0LnRpbWVTY2FsZSgpLm9wdGlvbnMoKS5iYXJTcGFjaW5nO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkIHx8IGJhclNwYWNpbmcgIT09IHRoaXMuX3ByaXZhdGVfX2NhY2hlZEJhclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZEJhclNwYWNpbmcgPSBiYXJTcGFjaW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlTWFyZ2luJDEgPSBzaGFwZU1hcmdpbihiYXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW5WYWx1ZSA9IGNhbGN1bGF0ZVNoYXBlSGVpZ2h0KGJhclNwYWNpbmcpICogMS41ICsgc2hhcGVNYXJnaW4kMSAqIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5fcHJpdmF0ZV9fZ2V0TWFya2VyUG9zaXRpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2lucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmU6IGNhbGN1bGF0ZUFkanVzdGVkTWFyZ2luKG1hcmdpblZhbHVlLCBwb3NpdGlvbnMuYWJvdmVCYXIsIHBvc2l0aW9ucy5pbkJhciksXG4gICAgICAgICAgICAgICAgICAgIGJlbG93OiBjYWxjdWxhdGVBZGp1c3RlZE1hcmdpbihtYXJnaW5WYWx1ZSwgcG9zaXRpb25zLmJlbG93QmFyLCBwb3NpdGlvbnMuaW5CYXIpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0TWFya2VyUG9zaXRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1Bvc2l0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1Bvc2l0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnMucmVkdWNlKChhY2MsIG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYWNjW21hcmtlci5wb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW21hcmtlci5wb3NpdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGluQmFyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYm92ZUJhcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmVsb3dCYXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0UHJpY2VUb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0UHJpY2VCb3R0b206IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0UHJpY2VNaWRkbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQb3NpdGlvbnM7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGlvblJlcXVpcmVkIHx8ICF0aGlzLl9wcml2YXRlX19jaGFydCB8fCAhdGhpcy5fcHJpdmF0ZV9fc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQudGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSB0aGlzLl9wcml2YXRlX19zZXJpZXM/LmRhdGEoKTtcbiAgICAgICAgaWYgKHRpbWVTY2FsZS5nZXRWaXNpYmxlTG9naWNhbFJhbmdlKCkgPT0gbnVsbCB8fCAhdGhpcy5fcHJpdmF0ZV9fc2VyaWVzIHx8IHNlcmllc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleGVkTWFya2VycyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0RGF0YUluZGV4ID0gdGltZVNjYWxlLnRpbWVUb0luZGV4KGVuc3VyZU5vdE51bGwoc2VyaWVzRGF0YVswXS50aW1lKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGV4ZWRNYXJrZXJzID0gdGhpcy5fcHJpdmF0ZV9fbWFya2Vycy5tYXAoKG1hcmtlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVQb2ludEluZGV4ID0gdGltZVNjYWxlLnRpbWVUb0luZGV4KG1hcmtlci50aW1lLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaE1vZGUgPSB0aW1lUG9pbnRJbmRleCA8IGZpcnN0RGF0YUluZGV4ID8gMSAvKiBNaXNtYXRjaERpcmVjdGlvbi5OZWFyZXN0UmlnaHQgKi8gOiAtMSAvKiBNaXNtYXRjaERpcmVjdGlvbi5OZWFyZXN0TGVmdCAqLztcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0RhdGFCeUluZGV4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zZXJpZXMpLmRhdGFCeUluZGV4KHRpbWVQb2ludEluZGV4LCBzZWFyY2hNb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsSW5kZXggPSB0aW1lU2NhbGUudGltZVRvSW5kZXgoZW5zdXJlTm90TnVsbChzZXJpZXNEYXRhQnlJbmRleCkudGltZSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gWW91IG11c3QgZXhwbGljaXRseSBkZWZpbmUgdGhlIHR5cGVzIHNvIHRoYXQgdGhlIG1pbmlmaWNhdGlvbiBidWlsZCBwcm9jZXNzZXMgdGhlIGZpZWxkIG5hbWVzIGNvcnJlY3RseVxuICAgICAgICAgICAgY29uc3QgYmFzZU1hcmtlciA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBmaW5hbEluZGV4LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtYXJrZXIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogbWFya2VyLmNvbG9yLFxuICAgICAgICAgICAgICAgIGlkOiBtYXJrZXIuaWQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ludGVybmFsSWQ6IGluZGV4LFxuICAgICAgICAgICAgICAgIHRleHQ6IG1hcmtlci50ZXh0LFxuICAgICAgICAgICAgICAgIHNpemU6IG1hcmtlci5zaXplLFxuICAgICAgICAgICAgICAgIHByaWNlOiBtYXJrZXIucHJpY2UsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX29yaWdpbmFsVGltZTogbWFya2VyLnRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1hcmtlci5wb3NpdGlvbiA9PT0gJ2F0UHJpY2VUb3AnIHx8XG4gICAgICAgICAgICAgICAgbWFya2VyLnBvc2l0aW9uID09PSAnYXRQcmljZUJvdHRvbScgfHxcbiAgICAgICAgICAgICAgICBtYXJrZXIucG9zaXRpb24gPT09ICdhdFByaWNlTWlkZGxlJykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIucHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByaWNlIGlzIHJlcXVpcmVkIGZvciBwb3NpdGlvbiAke21hcmtlci5wb3NpdGlvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZU1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG1hcmtlci5wb3NpdGlvbiwgLy8gVHlwZVNjcmlwdCBrbm93cyB0aGlzIGlzIFNlcmllc01hcmtlclByaWNlUG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG1hcmtlci5wcmljZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZU1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG1hcmtlci5wb3NpdGlvbiwgLy8gVHlwZVNjcmlwdCBrbm93cyB0aGlzIGlzIFNlcmllc01hcmtlckJhclBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBtYXJrZXIucHJpY2UsIC8vIE9wdGlvbmFsIGZvciBiYXIgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlQWxsVmlld3ModXBkYXRlVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRlTWFya2VycygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3NldE1hcmtlcnModGhpcy5fcHJpdmF0ZV9faW5kZXhlZE1hcmtlcnMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZU9wdGlvbnModGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKHVwZGF0ZVR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19vbkRhdGFDaGFuZ2VkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc01hcmtlcnNQcmltaXRpdmVXcmFwcGVyIGV4dGVuZHMgU2VyaWVzUHJpbWl0aXZlQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBwcmltaXRpdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzLCBwcmltaXRpdmUpO1xuICAgICAgICBpZiAobWFya2Vycykge1xuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE1hcmtlcnMobWFya2Vycykge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF9zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgIH1cbiAgICBtYXJrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfbWFya2VycygpO1xuICAgIH1cbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjcmVhdGUgYSBzZXJpZXMgbWFya2VycyBwcmltaXRpdmUuXG4gKlxuICogQHBhcmFtIHNlcmllcyAtIFRoZSBzZXJpZXMgdG8gd2hpY2ggdGhlIHByaW1pdGl2ZSB3aWxsIGJlIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSBtYXJrZXJzIC0gQW4gYXJyYXkgb2YgbWFya2VycyB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIHNlcmllcy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBzZXJpZXMgbWFya2VycyBwbHVnaW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjcmVhdGVTZXJpZXNNYXJrZXJzIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbiAqXG4gKlx0Y29uc3Qgc2VyaWVzTWFya2VycyA9IGNyZWF0ZVNlcmllc01hcmtlcnMoXG4gKlx0XHRzZXJpZXMsXG4gKlx0XHRbXG4gKlx0XHRcdHtcbiAqXHRcdFx0XHRjb2xvcjogJ2dyZWVuJyxcbiAqXHRcdFx0XHRwb3NpdGlvbjogJ2luQmFyJyxcbiAqIFx0XHRcdFx0c2hhcGU6ICdhcnJvd0Rvd24nLFxuICpcdFx0XHRcdHRpbWU6IDE1NTY4ODA5MDAsXG4gKlx0XHRcdH0sXG4gKlx0XHRdXG4gKlx0KTtcbiAqICAvLyBhbmQgdGhlbiB5b3UgY2FuIG1vZGlmeSB0aGUgbWFya2Vyc1xuICogIC8vIHNldCBpdCB0byBlbXB0eSBhcnJheSB0byByZW1vdmUgYWxsIG1hcmtlcnNcbiAqICBzZXJpZXNNYXJrZXJzLnNldE1hcmtlcnMoW10pO1xuICpcbiAqICAvLyBgc2VyaWVzTWFya2Vycy5tYXJrZXJzKClgIHJldHVybnMgY3VycmVudCBtYXJrZXJzXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VyaWVzTWFya2VycyhzZXJpZXMsIG1hcmtlcnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IFNlcmllc01hcmtlcnNQcmltaXRpdmVXcmFwcGVyKHNlcmllcywgbmV3IFNlcmllc01hcmtlcnNQcmltaXRpdmUob3B0aW9ucyA/PyB7fSkpO1xuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICAgIHdyYXBwZXIuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmNsYXNzIEV4cGlyaW5nTWFya2VyTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlQ2FsbGJhY2sgPSB1cGRhdGVDYWxsYmFjaztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldE1hcmtlcihtYXJrZXIsIGtleSwgdGltZW91dCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9jbGVhck1hcmtlcihrZXkpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX190cmlnZ2VyVXBkYXRlKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcldpdGhUaW1lb3V0ID0ge1xuICAgICAgICAgICAgICAgIC4uLm1hcmtlcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZW91dElkOiB0aW1lb3V0SWQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2V4cGlyZXNBdDogRGF0ZS5ub3coKSArIHRpbWVvdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vycy5zZXQoa2V5LCBtYXJrZXJXaXRoVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgbWFya2VycyB3aXRob3V0IHRpbWVvdXQsIHdlIHNldCB0aW1lb3V0SWQgYW5kIGV4cGlyZXNBdCB0byB1bmRlZmluZWRcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMuc2V0KGtleSwge1xuICAgICAgICAgICAgICAgIC4uLm1hcmtlcixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZW91dElkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2V4cGlyZXNBdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJpZ2dlclVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xlYXJNYXJrZXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChtYXJrZXIgJiYgbWFya2VyLl9pbnRlcm5hbF90aW1lb3V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChtYXJrZXIuX2ludGVybmFsX3RpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vycy5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJpZ2dlclVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xlYXJBbGxNYXJrZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtwb2ludF0gb2YgdGhpcy5fcHJpdmF0ZV9fbWFya2Vycykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfY2xlYXJNYXJrZXIocG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRNYXJrZXJzKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBhY3RpdmVNYXJrZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW3RpbWUsIG1hcmtlcl0gb2YgdGhpcy5fcHJpdmF0ZV9fbWFya2Vycykge1xuICAgICAgICAgICAgaWYgKCFtYXJrZXIuX2ludGVybmFsX2V4cGlyZXNBdCB8fCBtYXJrZXIuX2ludGVybmFsX2V4cGlyZXNBdCA+IG5vdykge1xuICAgICAgICAgICAgICAgIGFjdGl2ZU1hcmtlcnMucHVzaCh7IHRpbWU6IG1hcmtlci50aW1lLCBzaWduOiBtYXJrZXIuc2lnbiwgdmFsdWU6IG1hcmtlci52YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2NsZWFyTWFya2VyKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmVNYXJrZXJzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VXBkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RyaWdnZXJVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191cGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgdXBEb3duTWFya2Vyc1BsdWdpbk9wdGlvbkRlZmF1bHRzID0ge1xuICAgIHBvc2l0aXZlQ29sb3I6ICcjMjJBQjk0JyxcbiAgICBuZWdhdGl2ZUNvbG9yOiAnI0Y3NTI1RicsXG4gICAgdXBkYXRlVmlzaWJpbGl0eUR1cmF0aW9uOiA1MDAwLFxufTtcblxuY2xhc3MgTWFya2Vyc1ByaW1pdGl2ZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBuZXV0cmFsQ29sb3IsIG5lZ2F0aXZlQ29sb3IsIHBvc2l0aXZlQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX25ldXRyYWxDb2xvciA9IG5ldXRyYWxDb2xvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbmVnYXRpdmVDb2xvciA9IG5lZ2F0aXZlQ29sb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aXZlQ29sb3IgPSBwb3NpdGl2ZUNvbG9yO1xuICAgIH1cbiAgICBkcmF3KHRhcmdldCkge1xuICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gc2NvcGUuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Ioc2NvcGUuaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSAodGlja1dpZHRoICUgMikgLyAyO1xuICAgICAgICAgICAgY29uc3QgcmFkID0gNCAvKiBDb25zdGFudHMuUmFkaXVzICovICogc2NvcGUudmVydGljYWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyZVggPSBNYXRoLnJvdW5kKGl0ZW0uX2ludGVybmFsX3ggKiBzY29wZS5ob3Jpem9udGFsUGl4ZWxSYXRpbykgKyBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX3ByaXZhdGVfX2dldENvbG9yKGl0ZW0uX2ludGVybmFsX3NpZ24pO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguYXJjKGNlbnRyZVgsIGl0ZW0uX2ludGVybmFsX3kgKiBzY29wZS52ZXJ0aWNhbFBpeGVsUmF0aW8sIHJhZCwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLl9pbnRlcm5hbF9zaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5mbG9vcigyIC8qIENvbnN0YW50cy5BcnJvd0xpbmVXaWR0aCAqLyAqIHNjb3BlLmhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKChpdGVtLl9pbnRlcm5hbF94IC0gNC43IC8qIENvbnN0YW50cy5BcnJvd1NpemUgKi8pICogc2NvcGUuaG9yaXpvbnRhbFBpeGVsUmF0aW8gKyBjb3JyZWN0aW9uLCAoaXRlbS5faW50ZXJuYWxfeSAtIDcgLyogQ29uc3RhbnRzLkFycm93T2Zmc2V0ICovICogaXRlbS5faW50ZXJuYWxfc2lnbikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhpdGVtLl9pbnRlcm5hbF94ICogc2NvcGUuaG9yaXpvbnRhbFBpeGVsUmF0aW8gKyBjb3JyZWN0aW9uLCAoaXRlbS5faW50ZXJuYWxfeSAtXG4gICAgICAgICAgICAgICAgICAgICAgICA3IC8qIENvbnN0YW50cy5BcnJvd09mZnNldCAqLyAqIGl0ZW0uX2ludGVybmFsX3NpZ24gLVxuICAgICAgICAgICAgICAgICAgICAgICAgNyAvKiBDb25zdGFudHMuQXJyb3dPZmZzZXQgKi8gKiBpdGVtLl9pbnRlcm5hbF9zaWduICogMC41IC8qIENvbnN0YW50cy5WZXJ0aWNhbFNjYWxlICovKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS52ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKChpdGVtLl9pbnRlcm5hbF94ICsgNC43IC8qIENvbnN0YW50cy5BcnJvd1NpemUgKi8pICogc2NvcGUuaG9yaXpvbnRhbFBpeGVsUmF0aW8gKyBjb3JyZWN0aW9uLCAoaXRlbS5faW50ZXJuYWxfeSAtIDcgLyogQ29uc3RhbnRzLkFycm93T2Zmc2V0ICovICogaXRlbS5faW50ZXJuYWxfc2lnbikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldENvbG9yKHNpZ24pIHtcbiAgICAgICAgaWYgKHNpZ24gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19uZXV0cmFsQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gPiAwID8gdGhpcy5fcHJpdmF0ZV9fcG9zaXRpdmVDb2xvciA6IHRoaXMuX3ByaXZhdGVfX25lZ2F0aXZlQ29sb3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZWFTdHlsZU9wdGlvbnMob3B0cywgc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiBzZXJpZXNUeXBlID09PSAnQXJlYSc7XG59XG5mdW5jdGlvbiBnZXROZXV0cmFsQ29sb3Iob3B0cywgc2VyaWVzVHlwZSkge1xuICAgIGlmIChpc0FyZWFTdHlsZU9wdGlvbnMob3B0cywgc2VyaWVzVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMubGluZUNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5jb2xvcjtcbn1cbmNsYXNzIE1hcmtlcnNQcmltaXRpdmVQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCB0aW1lU2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUobWFya2Vycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbWFya2Vycy5tYXAoKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5wcmljZVRvQ29vcmRpbmF0ZShtYXJrZXIudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS50aW1lVG9Db29yZGluYXRlKG1hcmtlci50aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94OiB4LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95OiB5LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9zaWduOiBtYXJrZXIuc2lnbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKG5vdE51bGwpO1xuICAgIH1cbiAgICByZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuc2VyaWVzVHlwZSgpO1xuICAgICAgICBjb25zdCBuZXV0cmFsQ29sb3IgPSBnZXROZXV0cmFsQ29sb3Iob3B0aW9ucywgc2VyaWVzVHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgTWFya2Vyc1ByaW1pdGl2ZVJlbmRlcmVyKHRoaXMuX3ByaXZhdGVfX2RhdGEsIG5ldXRyYWxDb2xvciwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5uZWdhdGl2ZUNvbG9yLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnBvc2l0aXZlQ29sb3IpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNMaW5lRGF0YShpdGVtLCB0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdMaW5lJyB8fCB0eXBlID09PSAnQXJlYSc7XG59XG5jbGFzcyBVcERvd25NYXJrZXJzUHJpbWl0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hbmFnZWREYXRhUG9pbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzTWFuYWdlciA9IG5ldyBFeHBpcmluZ01hcmtlck1hbmFnZXIoKCkgPT4gdGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnVwRG93bk1hcmtlcnNQbHVnaW5PcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldE1hcmtlcnMobWFya2Vycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzTWFuYWdlci5faW50ZXJuYWxfY2xlYXJBbGxNYXJrZXJzKCk7XG4gICAgICAgIGNvbnN0IGhvcnpCZWhhdmlvdXIgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgaWYgKCFob3J6QmVoYXZpb3VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNNYW5hZ2VyLl9pbnRlcm5hbF9zZXRNYXJrZXIobWFya2VyLCBob3J6QmVoYXZpb3VyLmtleShtYXJrZXIudGltZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXJrZXJzTWFuYWdlci5faW50ZXJuYWxfZ2V0TWFya2VycygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZT8uKCk7XG4gICAgfVxuICAgIGF0dGFjaGVkKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGNoYXJ0LCBzZXJpZXMsIHJlcXVlc3RVcGRhdGUsIGhvcnpTY2FsZUJlaGF2aW9yLCB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IGNoYXJ0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuc2VyaWVzVHlwZSgpO1xuICAgICAgICBpZiAoc2VyaWVzVHlwZSAhPT0gJ0FyZWEnICYmIHNlcmllc1R5cGUgIT09ICdMaW5lJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcERvd25NYXJrZXJzUHJpbWl0aXZlIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBBcmVhIGFuZCBMaW5lIHNlcmllcyB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cyA9IFtcbiAgICAgICAgICAgIG5ldyBNYXJrZXJzUHJpbWl0aXZlUGFuZVZpZXcodGhpcy5fcHJpdmF0ZV9fc2VyaWVzLCB0aGlzLl9wcml2YXRlX19jaGFydC50aW1lU2NhbGUoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyksXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUgPSByZXF1ZXN0VXBkYXRlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGRldGFjaGVkKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2hhcnQoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX2NoYXJ0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NlcmllcygpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cy5mb3JFYWNoKChwdykgPT4gcHcuX2ludGVybmFsX3VwZGF0ZSh0aGlzLl9pbnRlcm5hbF9tYXJrZXJzKCkpKTtcbiAgICB9XG4gICAgcGFuZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2VyaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1pdGl2ZSBub3QgYXR0YWNoZWQgdG8gc2VyaWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5zZXJpZXNUeXBlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hbmFnZWREYXRhUG9pbnRzLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IGhvcnpCZWhhdmlvdXIgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgaWYgKGhvcnpCZWhhdmlvdXIpIHtcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bGZpbGxlZERhdGEoZCkgJiYgaXNMaW5lRGF0YShkLCBzZXJpZXNUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYW5hZ2VkRGF0YVBvaW50cy5zZXQoaG9yekJlaGF2aW91ci5rZXkoZC50aW1lKSwgZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19zZXJpZXMpLnNldERhdGEoZGF0YSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3NlcmllcyB8fCAhdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWl0aXZlIG5vdCBhdHRhY2hlZCB0byBzZXJpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLnNlcmllc1R5cGUoKTtcbiAgICAgICAgY29uc3QgaG9yektleSA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShkYXRhLnRpbWUpO1xuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlRGF0YShkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFuYWdlZERhdGFQb2ludHMuZGVsZXRlKGhvcnpLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bGZpbGxlZERhdGEoZGF0YSkgJiYgaXNMaW5lRGF0YShkYXRhLCBzZXJpZXNUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQcmljZSA9IHRoaXMuX3ByaXZhdGVfX21hbmFnZWREYXRhUG9pbnRzLmdldChob3J6S2V5KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc01hbmFnZXIuX2ludGVybmFsX3NldE1hcmtlcih7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGRhdGEudGltZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ246IGdldFNpZ24oZGF0YS52YWx1ZSwgZXhpc3RpbmdQcmljZSksXG4gICAgICAgICAgICAgICAgfSwgaG9yektleSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy51cGRhdGVWaXNpYmlsaXR5RHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzKS51cGRhdGUoZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbGVhck1hcmtlcnMoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNNYW5hZ2VyLl9pbnRlcm5hbF9jbGVhckFsbE1hcmtlcnMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTaWduKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZSAtIG9sZFZhbHVlID4gMCA/IDEgOiAtMTtcbn1cblxuY2xhc3MgU2VyaWVzVXBEb3duTWFya2VyUHJpbWl0aXZlV3JhcHBlciBleHRlbmRzIFNlcmllc1ByaW1pdGl2ZUFkYXB0ZXIge1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEsIGhpc3RvcmljYWxVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX3VwZGF0ZShkYXRhLCBoaXN0b3JpY2FsVXBkYXRlKTtcbiAgICB9XG4gICAgbWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX21hcmtlcnMoKTtcbiAgICB9XG4gICAgc2V0TWFya2VycyhtYXJrZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF9zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgIH1cbiAgICBjbGVhck1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF9jbGVhck1hcmtlcnMoKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIGF0dGFjaGVzIHRoZSBTZXJpZXMgVXAgRG93biBNYXJrZXJzIFBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gc2VyaWVzIC0gU2VyaWVzIHRvIHdoaWNoIGF0dGFjaCB0aGUgVXAgRG93biBNYXJrZXJzIFBsdWdpblxuICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgVXAgRG93biBNYXJrZXJzIFBsdWdpblxuICpcbiAqIEByZXR1cm5zIEFwaSBmb3IgU2VyaWVzIFVwIERvd24gTWFya2VyIFBsdWdpbi4ge0BsaW5rIElTZXJpZXNVcERvd25NYXJrZXJQbHVnaW5BcGl9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjcmVhdGVVcERvd25NYXJrZXJzLCBjcmVhdGVDaGFydCwgTGluZVNlcmllcyB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG4gKlxuICogY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydCgnY29udGFpbmVyJyk7XG4gKiBjb25zdCBsaW5lU2VyaWVzID0gY2hhcnQuYWRkU2VyaWVzKExpbmVTZXJpZXMpO1xuICogY29uc3QgdXBEb3duTWFya2VycyA9IGNyZWF0ZVVwRG93bk1hcmtlcnMobGluZVNlcmllcywge1xuICogICAgIHBvc2l0aXZlQ29sb3I6ICcjMjJBQjk0JyxcbiAqICAgICBuZWdhdGl2ZUNvbG9yOiAnI0Y3NTI1RicsXG4gKiAgICAgdXBkYXRlVmlzaWJpbGl0eUR1cmF0aW9uOiA1MDAwLFxuICogfSk7XG4gKiAvLyB0byBhZGQgc29tZSBkYXRhXG4gKiB1cERvd25NYXJrZXJzLnNldERhdGEoXG4gKiAgICAgW1xuICogICAgICAgICB7IHRpbWU6ICcyMDIwLTAyLTAyJywgdmFsdWU6IDEyLjM0IH0sXG4gKiAgICAgICAgIC8vLi4uIG1vcmUgbGluZSBzZXJpZXMgZGF0YVxuICogICAgIF1cbiAqICk7XG4gKiAvLyAuLi4gVXBkYXRlIHNvbWUgdmFsdWVzXG4gKiB1cERvd25NYXJrZXJzLnVwZGF0ZSh7IHRpbWU6ICcyMDIwLTAyLTAyJywgdmFsdWU6IDEzLjU0IH0sIHRydWUpO1xuICogLy8gdG8gcmVtb3ZlIHBsdWdpbiBmcm9tIHRoZSBzZXJpZXNcbiAqIHVwRG93bk1hcmtlcnMuZGV0YWNoKCk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXBEb3duTWFya2VycyhzZXJpZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgU2VyaWVzVXBEb3duTWFya2VyUHJpbWl0aXZlV3JhcHBlcihzZXJpZXMsIG5ldyBVcERvd25NYXJrZXJzUHJpbWl0aXZlKG9wdGlvbnMpKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuY29uc3QgY3VzdG9tU2VyaWVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uc2VyaWVzT3B0aW9uc0RlZmF1bHRzLFxuICAgIC4uLmN1c3RvbVN0eWxlRGVmYXVsdHMkMSxcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmVyc2lvbiBhcyBhIHN0cmluZy4gRm9yIGV4YW1wbGUgYCczLjMuMCdgLlxuICovXG5mdW5jdGlvbiB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjUuMC43XCI7XG59XG5cbmV4cG9ydCB7IGFyZWFTZXJpZXMgYXMgQXJlYVNlcmllcywgYmFyU2VyaWVzIGFzIEJhclNlcmllcywgYmFzZWxpbmVTZXJpZXMgYXMgQmFzZWxpbmVTZXJpZXMsIGNhbmRsZXN0aWNrU2VyaWVzIGFzIENhbmRsZXN0aWNrU2VyaWVzLCBDb2xvclR5cGUsIENyb3NzaGFpck1vZGUsIGhpc3RvZ3JhbVNlcmllcyBhcyBIaXN0b2dyYW1TZXJpZXMsIExhc3RQcmljZUFuaW1hdGlvbk1vZGUsIGxpbmVTZXJpZXMgYXMgTGluZVNlcmllcywgTGluZVN0eWxlLCBMaW5lVHlwZSwgTWlzbWF0Y2hEaXJlY3Rpb24sIFByaWNlTGluZVNvdXJjZSwgUHJpY2VTY2FsZU1vZGUsIFRpY2tNYXJrVHlwZSwgVHJhY2tpbmdNb2RlRXhpdE1vZGUsIGNyZWF0ZUNoYXJ0LCBjcmVhdGVDaGFydEV4LCBjcmVhdGVJbWFnZVdhdGVybWFyaywgY3JlYXRlT3B0aW9uc0NoYXJ0LCBjcmVhdGVTZXJpZXNNYXJrZXJzLCBjcmVhdGVUZXh0V2F0ZXJtYXJrLCBjcmVhdGVVcERvd25NYXJrZXJzLCBjcmVhdGVZaWVsZEN1cnZlQ2hhcnQsIGN1c3RvbVNlcmllc0RlZmF1bHRPcHRpb25zLCBkZWZhdWx0SG9yelNjYWxlQmVoYXZpb3IsIGlzQnVzaW5lc3NEYXksIGlzVVRDVGltZXN0YW1wLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsic2l6ZSIsInNpemUkMSIsImJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvIiwiZXF1YWxTaXplcyIsInRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIiwiY3VzdG9tU3R5bGVEZWZhdWx0cyQxIiwiY29sb3IiLCJzZXJpZXNPcHRpb25zRGVmYXVsdHMiLCJ0aXRsZSIsInZpc2libGUiLCJsYXN0VmFsdWVWaXNpYmxlIiwicHJpY2VMaW5lVmlzaWJsZSIsInByaWNlTGluZVNvdXJjZSIsInByaWNlTGluZVdpZHRoIiwicHJpY2VMaW5lQ29sb3IiLCJwcmljZUxpbmVTdHlsZSIsImJhc2VMaW5lVmlzaWJsZSIsImJhc2VMaW5lV2lkdGgiLCJiYXNlTGluZUNvbG9yIiwiYmFzZUxpbmVTdHlsZSIsInByaWNlRm9ybWF0IiwidHlwZSIsInByZWNpc2lvbiIsIm1pbk1vdmUiLCJMaW5lVHlwZSIsIkxpbmVTdHlsZSIsInNldExpbmVTdHlsZSIsImN0eCIsInN0eWxlIiwiZGFzaFBhdHRlcm5zIiwibGluZVdpZHRoIiwiZGFzaFBhdHRlcm4iLCJzZXRMaW5lRGFzaCIsImRyYXdIb3Jpem9udGFsTGluZSIsInkiLCJsZWZ0IiwicmlnaHQiLCJiZWdpblBhdGgiLCJjb3JyZWN0aW9uIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZHJhd1ZlcnRpY2FsTGluZSIsIngiLCJ0b3AiLCJib3R0b20iLCJzdHJva2VJblBpeGVsIiwiZHJhd0Z1bmN0aW9uIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJlc3RvcmUiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJlbnN1cmVEZWZpbmVkIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbnN1cmVOb3ROdWxsIiwiZW5zdXJlIiwiZW5zdXJlTmV2ZXIiLCJEZWxlZ2F0ZSIsIl9pbnRlcm5hbF9zdWJzY3JpYmUiLCJjYWxsYmFjayIsImxpbmtlZE9iamVjdCIsInNpbmdsZXNob3QiLCJsaXN0ZW5lciIsIl9pbnRlcm5hbF9jYWxsYmFjayIsIl9pbnRlcm5hbF9saW5rZWRPYmplY3QiLCJfaW50ZXJuYWxfc2luZ2xlc2hvdCIsIl9wcml2YXRlX19saXN0ZW5lcnMiLCJwdXNoIiwiX2ludGVybmFsX3Vuc3Vic2NyaWJlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJfaW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwiLCJmaWx0ZXIiLCJfaW50ZXJuYWxfZmlyZSIsInBhcmFtMSIsInBhcmFtMiIsInBhcmFtMyIsImxpc3RlbmVyc1NuYXBzaG90IiwiZm9yRWFjaCIsIl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMiLCJsZW5ndGgiLCJfaW50ZXJuYWxfZGVzdHJveSIsImNvbnN0cnVjdG9yIiwibWVyZ2UiLCJkc3QiLCJzb3VyY2VzIiwic3JjIiwiaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluY2x1ZGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNOdW1iZXIiLCJpc0Zpbml0ZSIsImlzSW50ZWdlciIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiY2xvbmUiLCJvYmplY3QiLCJvIiwiYyIsInAiLCJ2Iiwibm90TnVsbCIsInQiLCJ1bmRlZmluZWRJZk51bGwiLCJkZWZhdWx0Rm9udEZhbWlseSIsIm1ha2VGb250IiwiZmFtaWx5IiwiUHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zUHJvdmlkZXIiLCJfaW50ZXJuYWxfb3B0aW9ucyIsInJlbmRlcmVyT3B0aW9ucyIsIl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMiLCJjdXJyZW50Rm9udFNpemUiLCJfcHJpdmF0ZV9fZm9udFNpemUiLCJjdXJyZW50Rm9udEZhbWlseSIsIl9wcml2YXRlX19mb250RmFtaWx5IiwiX2ludGVybmFsX2ZvbnRTaXplIiwiX2ludGVybmFsX2ZvbnRGYW1pbHkiLCJfaW50ZXJuYWxfZm9udCIsIl9pbnRlcm5hbF9wYWRkaW5nVG9wIiwiX2ludGVybmFsX3BhZGRpbmdCb3R0b20iLCJfaW50ZXJuYWxfcGFkZGluZ0lubmVyIiwiX2ludGVybmFsX3RpY2tMZW5ndGgiLCJfaW50ZXJuYWxfcGFkZGluZ091dGVyIiwiX2ludGVybmFsX2Jhc2VsaW5lT2Zmc2V0IiwiX2ludGVybmFsX2NvbG9yIiwiX3ByaXZhdGVfX3RleHRDb2xvciIsIl9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yIiwiX3ByaXZhdGVfX3BhbmVCYWNrZ3JvdW5kQ29sb3IiLCJfcHJpdmF0ZV9fY2hhcnRNb2RlbCIsInRleHRDb2xvciIsIl9pbnRlcm5hbF9iYWNrZ3JvdW5kVG9wQ29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjaGFydE1vZGVsIiwiX2ludGVybmFsX2JvcmRlclNpemUiLCJOYU4iLCJub3JtYWxpemVSZ2JDb21wb25lbnQiLCJjb21wb25lbnQiLCJNYXRoIiwicm91bmQiLCJub3JtYWxpemVBbHBoYUNvbXBvbmVudCIsIm1pbiIsIm1heCIsInJnYmFUb0dyYXlzY2FsZSIsInJnYlZhbHVlIiwicmVkQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0IiwiZ3JlZW5Db21wb25lbnRHcmF5c2NhbGVXZWlnaHQiLCJibHVlQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0IiwiZ2V0UmdiU3RyaW5nVmlhQnJvd3NlciIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29tcHV0ZWQiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwicmVtb3ZlQ2hpbGQiLCJDb2xvclBhcnNlciIsIl9pbnRlcm5hbF9hcHBseUFscGhhIiwiYWxwaGEiLCJvcmlnaW5SZ2JhIiwiX3ByaXZhdGVfX3BhcnNlQ29sb3IiLCJvcmlnaW5BbHBoYSIsIl9pbnRlcm5hbF9nZW5lcmF0ZUNvbnRyYXN0Q29sb3JzIiwiYmFja2dyb3VuZCIsInJnYmEiLCJfaW50ZXJuYWxfYmFja2dyb3VuZCIsIl9pbnRlcm5hbF9mb3JlZ3JvdW5kIiwiX2ludGVybmFsX2NvbG9yU3RyaW5nVG9HcmF5c2NhbGUiLCJfaW50ZXJuYWxfZ3JhZGllbnRDb2xvckF0UGVyY2VudCIsInRvcENvbG9yIiwiYm90dG9tQ29sb3IiLCJwZXJjZW50IiwidG9wUiIsInRvcEciLCJ0b3BCIiwidG9wQSIsImJvdHRvbVIiLCJib3R0b21HIiwiYm90dG9tQiIsImJvdHRvbUEiLCJyZXN1bHRSZ2JhIiwiY2FjaGVkIiwiX3ByaXZhdGVfX3JnYmFDYWNoZSIsImdldCIsIm1hdGNoIiwiX3ByaXZhdGVfX2N1c3RvbVBhcnNlcnMiLCJwYXJzZXIiLCJyZXN1bHQiLCJzZXQiLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJjdXN0b21QYXJzZXJzIiwiaW5pdGlhbENhY2hlIiwiTWFwIiwiQ29tcG9zaXRlUmVuZGVyZXIiLCJfaW50ZXJuYWxfc2V0UmVuZGVyZXJzIiwicmVuZGVyZXJzIiwiX3ByaXZhdGVfX3JlbmRlcmVycyIsIl9pbnRlcm5hbF9kcmF3IiwidGFyZ2V0IiwiaXNIb3ZlcmVkIiwiaGl0VGVzdERhdGEiLCJyIiwiQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIiLCJ1c2VCaXRtYXBDb29yZGluYXRlU3BhY2UiLCJzY29wZSIsIl9pbnRlcm5hbF9fZHJhd0ltcGwiLCJQYW5lUmVuZGVyZXJNYXJrcyIsIl9pbnRlcm5hbF9zZXREYXRhIiwiZGF0YSIsIl9pbnRlcm5hbF9fZGF0YSIsImNvbnRleHQiLCJob3Jpem9udGFsUGl4ZWxSYXRpbyIsInZlcnRpY2FsUGl4ZWxSYXRpbyIsIl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UiLCJ2aXNpYmxlUmFuZ2UiLCJ0aWNrV2lkdGgiLCJmbG9vciIsImRyYXciLCJyYWRpdXNNZWRpYSIsInRvIiwiZnJvbSIsInBvaW50IiwiX2ludGVybmFsX2l0ZW1zIiwiY2VudGVyWCIsIl9pbnRlcm5hbF94IiwiY2VudGVyWSIsIl9pbnRlcm5hbF95IiwicmFkaXVzIiwiYXJjIiwiUEkiLCJmaWxsIiwiX2ludGVybmFsX2xpbmVXaWR0aCIsImZpbGxTdHlsZSIsIl9pbnRlcm5hbF9iYWNrQ29sb3IiLCJfaW50ZXJuYWxfcmFkaXVzIiwiX2ludGVybmFsX2xpbmVDb2xvciIsImFyZ3VtZW50cyIsImNyZWF0ZUVtcHR5TWFya2VyRGF0YSIsIl9pbnRlcm5hbF90aW1lIiwiX2ludGVybmFsX3ByaWNlIiwicmFuZ2VGb3JTaW5nbGVQb2ludCIsIkNyb3NzaGFpck1hcmtzUGFuZVZpZXciLCJfaW50ZXJuYWxfdXBkYXRlIiwidXBkYXRlVHlwZSIsIl9wcml2YXRlX19jcmVhdGVNYXJrZXJSZW5kZXJlcnNJZk5lZWRlZCIsIl9wcml2YXRlX19pbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF9yZW5kZXJlciIsIl9wcml2YXRlX191cGRhdGVJbXBsIiwiX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyIiwic2VyaWVzZXMiLCJfcHJpdmF0ZV9fcGFuZSIsIl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcyIsIl9wcml2YXRlX19tYXJrZXJzUmVuZGVyZXJzIiwiX3ByaXZhdGVfX21hcmtlcnNEYXRhIiwibWFwIiwicmVzIiwiZm9yY2VIaWRkZW4iLCJfcHJpdmF0ZV9fY3Jvc3NoYWlyIiwibW9kZSIsIl9pbnRlcm5hbF92aXNpYmxlIiwiX2ludGVybmFsX29yZGVyZWRTZXJpZXMiLCJ0aW1lUG9pbnRJbmRleCIsIl9pbnRlcm5hbF9hcHBsaWVkSW5kZXgiLCJ0aW1lU2NhbGUiLCJfaW50ZXJuYWxfdGltZVNjYWxlIiwicyIsInNlcmllc0RhdGEiLCJfaW50ZXJuYWxfbWFya2VyRGF0YUF0SW5kZXgiLCJmaXJzdFZhbHVlIiwiX2ludGVybmFsX2ZpcnN0VmFsdWUiLCJfaW50ZXJuYWxfYmFja2dyb3VuZENvbG9yIiwiX2ludGVybmFsX2JvcmRlcldpZHRoIiwiX2ludGVybmFsX3ByaWNlU2NhbGUiLCJfaW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUiLCJfaW50ZXJuYWxfdmFsdWUiLCJfaW50ZXJuYWxfYm9yZGVyQ29sb3IiLCJfaW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AiLCJfaW50ZXJuYWxfaGVpZ2h0IiwiX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlIiwiY3Jvc3NoYWlyIiwicGFuZSIsIkNyb3NzaGFpclJlbmRlcmVyIiwiYml0bWFwU2l6ZSIsIl9wcml2YXRlX19kYXRhIiwidmVydExpbmVzVmlzaWJsZSIsIl9pbnRlcm5hbF92ZXJ0TGluZSIsImhvcnpMaW5lc1Zpc2libGUiLCJfaW50ZXJuYWxfaG9yekxpbmUiLCJsaW5lQ2FwIiwic3Ryb2tlU3R5bGUiLCJfaW50ZXJuYWxfbGluZVN0eWxlIiwiaGVpZ2h0Iiwid2lkdGgiLCJDcm9zc2hhaXJQYW5lVmlldyIsIl9wcml2YXRlX19yZW5kZXJlciIsIl9wcml2YXRlX19zb3VyY2UiLCJjcm9zc2hhaXJPcHRpb25zIiwiX2ludGVybmFsX21vZGVsIiwiX3ByaXZhdGVfX3JlbmRlcmVyRGF0YSIsIl9pbnRlcm5hbF9ob3J6TGluZVZpc2libGUiLCJfaW50ZXJuYWxfdmVydExpbmVWaXNpYmxlIiwiaG9yekxpbmUiLCJ2ZXJ0TGluZSIsIl9pbnRlcm5hbF9hcHBsaWVkWCIsIl9pbnRlcm5hbF9hcHBsaWVkWSIsInNvdXJjZSIsImZpbGxSZWN0SW5uZXJCb3JkZXIiLCJib3JkZXJXaWR0aCIsImZpbGxSZWN0IiwiY2xlYXJSZWN0IiwidyIsImgiLCJjbGVhckNvbG9yIiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiY2hhbmdlQm9yZGVyUmFkaXVzIiwiYm9yZGVyUmFkaXVzIiwib2Zmc2V0IiwiZHJhd1JvdW5kUmVjdCIsInJhZGlpIiwicm91bmRSZWN0IiwiYXJjVG8iLCJkcmF3Um91bmRSZWN0V2l0aEJvcmRlciIsImJhY2tncm91bmRDb2xvciIsIm91dGVyQm9yZGVyUmFkaXVzIiwiYm9yZGVyQ29sb3IiLCJoYWxmQm9yZGVyV2lkdGgiLCJjbG9zZVBhdGgiLCJjbGVhclJlY3RXaXRoR3JhZGllbnQiLCJncmFkaWVudCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiUHJpY2VBeGlzVmlld1JlbmRlcmVyIiwiY29tbW9uRGF0YSIsIl9wcml2YXRlX19jb21tb25EYXRhIiwidXNlU2Vjb25kTGluZSIsInRleHRXaWR0aENhY2hlIiwiYWxpZ24iLCJfaW50ZXJuYWxfdGV4dCIsImdlb21ldHJ5IiwiZm9udCIsImdlb20iLCJfcHJpdmF0ZV9fY2FsY3VsYXRlR2VvbWV0cnkiLCJnYiIsIl9pbnRlcm5hbF9iaXRtYXAiLCJfaW50ZXJuYWxfYWxpZ25SaWdodCIsIl9pbnRlcm5hbF94T3V0c2lkZSIsIl9pbnRlcm5hbF95VG9wIiwiX2ludGVybmFsX3RvdGFsV2lkdGgiLCJfaW50ZXJuYWxfdG90YWxIZWlnaHQiLCJfaW50ZXJuYWxfaG9yekJvcmRlciIsIl9pbnRlcm5hbF94SW5zaWRlIiwiX2ludGVybmFsX3RpY2tWaXNpYmxlIiwiX2ludGVybmFsX3lNaWQiLCJfaW50ZXJuYWxfeFRpY2siLCJfaW50ZXJuYWxfdGlja0hlaWdodCIsIl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlIiwiX2ludGVybmFsX3JpZ2h0IiwiX2ludGVybmFsX3lCb3R0b20iLCJ1c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSIsImdtIiwiX2ludGVybmFsX21lZGlhIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJfaW50ZXJuYWxfeFRleHQiLCJfaW50ZXJuYWxfdGV4dE1pZENvcnJlY3Rpb24iLCJtZWRpYVNpemUiLCJ0aWNrU2l6ZSIsIl9pbnRlcm5hbF9tb3ZlVGV4dFRvSW52aXNpYmxlVGljayIsImhvcnpCb3JkZXIiLCJfaW50ZXJuYWxfc2VwYXJhdG9yVmlzaWJsZSIsInBhZGRpbmdUb3AiLCJfaW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nQm90dG9tIiwicGFkZGluZ0lubmVyIiwicGFkZGluZ091dGVyIiwidGV4dCIsImFjdHVhbFRleHRIZWlnaHQiLCJ0ZXh0TWlkQ29ycmVjdGlvbiIsIl9pbnRlcm5hbF95TWlkQ29ycmVjdGlvbiIsInRleHRXaWR0aCIsImNlaWwiLCJfaW50ZXJuYWxfbWVhc3VyZVRleHQiLCJ0b3RhbEhlaWdodCIsInRvdGFsV2lkdGgiLCJ0aWNrSGVpZ2h0Qml0bWFwIiwidG90YWxIZWlnaHRCaXRtYXAiLCJob3J6Qm9yZGVyQml0bWFwIiwidG90YWxXaWR0aEJpdG1hcCIsInRpY2tTaXplQml0bWFwIiwieU1pZCIsIl9pbnRlcm5hbF9maXhlZENvb3JkaW5hdGUiLCJfaW50ZXJuYWxfY29vcmRpbmF0ZSIsInlNaWRCaXRtYXAiLCJ5VG9wQml0bWFwIiwieUJvdHRvbUJpdG1hcCIsImFsaWduUmlnaHQiLCJ4SW5zaWRlIiwieEluc2lkZUJpdG1hcCIsInhPdXRzaWRlQml0bWFwIiwieFRpY2tCaXRtYXAiLCJ4VGV4dCIsIlByaWNlQXhpc1ZpZXciLCJfcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQiLCJfcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSIsIl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEiLCJfcHJpdmF0ZV9fYXhpc1JlbmRlcmVyIiwiX3ByaXZhdGVfX3BhbmVSZW5kZXJlciIsIl9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUiLCJfaW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlIiwiX2ludGVybmFsX2lzVmlzaWJsZSIsIl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhIiwiX2ludGVybmFsX2lzQXhpc0xhYmVsVmlzaWJsZSIsInByaWNlU2NhbGUiLCJ0aWNrc1Zpc2libGUiLCJfaW50ZXJuYWxfcGFuZVJlbmRlcmVyIiwiX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEiLCJjdG9yIiwiQ3Jvc3NoYWlyUHJpY2VBeGlzVmlldyIsImF4aXNSZW5kZXJlckRhdGEiLCJwYW5lUmVuZGVyZXJEYXRhIiwiY29tbW9uUmVuZGVyZXJEYXRhIiwib3B0aW9ucyIsImxhYmVsVmlzaWJsZSIsIl9wcml2YXRlX19wcmljZVNjYWxlIiwiX2ludGVybmFsX2lzRW1wdHkiLCJjb2xvcnMiLCJfaW50ZXJuYWxfY29sb3JQYXJzZXIiLCJsYWJlbEJhY2tncm91bmRDb2xvciIsImFkZGl0aW9uYWxQYWRkaW5nIiwiX3ByaXZhdGVfX3ZhbHVlUHJvdmlkZXIiLCJfaW50ZXJuYWxfZm9ybWF0UHJpY2UiLCJ2YWx1ZVByb3ZpZGVyIiwib3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSIsInJhZGl1cyQxIiwiVGltZUF4aXNWaWV3UmVuZGVyZXIiLCJfaW50ZXJuYWxfd2lkdGhDYWNoZSIsImhvcnpNYXJnaW4iLCJfaW50ZXJuYWxfcGFkZGluZ0hvcml6b250YWwiLCJsYWJlbFdpZHRoIiwibGFiZWxXaWR0aEhhbGYiLCJ0aW1lU2NhbGVXaWR0aCIsIl9pbnRlcm5hbF93aWR0aCIsImNvb3JkaW5hdGUiLCJ4MSIsImFicyIsIngyIiwieTEiLCJ5MiIsIngxc2NhbGVkIiwieTFzY2FsZWQiLCJ4MnNjYWxlZCIsInkyc2NhbGVkIiwicmFkaXVzU2NhbGVkIiwidGlja1giLCJ0aWNrVG9wIiwidGlja0JvdHRvbSIsInRpY2tPZmZzZXQiLCJ5VGV4dCIsInRleHRZQ29ycmVjdGlvbiIsIkNyb3NzaGFpclRpbWVBeGlzVmlldyIsIl9wcml2YXRlX19tb2RlbCIsImN1cnJlbnRUaW1lIiwiX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludCIsIl9pbnRlcm5hbF9mb3JtYXREYXRlVGltZSIsIm1vZGVsIiwiRGF0YVNvdXJjZSIsIl9pbnRlcm5hbF96b3JkZXIiLCJfcHJpdmF0ZV9fem9yZGVyIiwiX2ludGVybmFsX3NldFpvcmRlciIsInpvcmRlciIsIl9pbnRlcm5hbF9fcHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9zZXRQcmljZVNjYWxlIiwiX2ludGVybmFsX2xhYmVsUGFuZVZpZXdzIiwiX2ludGVybmFsX3RpbWVBeGlzVmlld3MiLCJDcm9zc2hhaXJNb2RlIiwiQ3Jvc3NoYWlyIiwiX3ByaXZhdGVfX29wdGlvbnMiLCJfaW50ZXJuYWxfc2F2ZU9yaWdpbkNvb3JkIiwiX3ByaXZhdGVfX29yaWdpblgiLCJfcHJpdmF0ZV9fb3JpZ2luWSIsIl9pbnRlcm5hbF9jbGVhck9yaWdpbkNvb3JkIiwiX2ludGVybmFsX29yaWdpbkNvb3JkWCIsIl9pbnRlcm5hbF9vcmlnaW5Db29yZFkiLCJfaW50ZXJuYWxfc2V0UG9zaXRpb24iLCJwcmljZSIsIl9wcml2YXRlX19zdWJzY3JpYmVkIiwiX3ByaXZhdGVfX3Zpc2libGUiLCJfcHJpdmF0ZV9fdHJ5VG9VcGRhdGVWaWV3cyIsIl9wcml2YXRlX19pbmRleCIsIl9wcml2YXRlX194IiwiX3ByaXZhdGVfX3kiLCJfaW50ZXJuYWxfY2xlYXJQb3NpdGlvbiIsIl9wcml2YXRlX19zZXRJbmRleFRvTGFzdFNlcmllc0JhckluZGV4IiwiX3ByaXZhdGVfX3ByaWNlIiwiX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzIiwiX2ludGVybmFsX3BhbmVWaWV3cyIsImNyb3NzaGFpclBhbmVWaWV3IiwiX3ByaXZhdGVfX2Nyb3NzaGFpclBhbmVWaWV3Q2FjaGUiLCJtYXJrZXJzUGFuZVZpZXciLCJfcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3Q2FjaGUiLCJfaW50ZXJuYWxfcHJpY2VBeGlzVmlld3MiLCJfcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3MiLCJjbGVhciIsInZpZXdzIiwiX3ByaXZhdGVfX2NyZWF0ZVByaWNlQXhpc1ZpZXdPbkRlbWFuZCIsIl9wcml2YXRlX19jdXJyZW50UG9zUHJpY2VQcm92aWRlciIsIl9wcml2YXRlX190aW1lQXhpc1ZpZXciLCJfaW50ZXJuYWxfcGFuZSIsIl9pbnRlcm5hbF9wYW5lcyIsIl9wcml2YXRlX19wcmljZVNjYWxlQnlQYW5lIiwiX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlIiwiX3ByaXZhdGVfX3RyeVRvVXBkYXRlRGF0YSIsIm5ld0luZGV4IiwibmV3UHJpY2UiLCJuZXdQYW5lIiwib2xkWCIsIm9sZFkiLCJvbGRQcmljZSIsIm9sZEluZGV4Iiwib2xkUGFuZSIsImlzTmFOIiwibGFzdEluZGV4ZXMiLCJfaW50ZXJuYWxfc2VyaWVzZXMiLCJfaW50ZXJuYWxfYmFycyIsIl9pbnRlcm5hbF9sYXN0SW5kZXgiLCJsYXN0QmFySW5kZXgiLCJ2aWV3IiwiV2Vha01hcCIsInZhbHVlUHJpY2VQcm92aWRlciIsInJhd1ByaWNlUHJvdmlkZXIiLCJyYXdDb29yZGluYXRlUHJvdmlkZXIiLCJyYXdQcmljZSIsIl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZSIsInZhbHVlVGltZVByb3ZpZGVyIiwicmF3SW5kZXhQcm92aWRlciIsInRpbWUiLCJfaW50ZXJuYWxfaW5kZXhUb1RpbWUiLCJOdW1iZXIiLCJjdXJyZW50UG9zVGltZVByb3ZpZGVyIiwiaXNEZWZhdWx0UHJpY2VTY2FsZSIsInByaWNlU2NhbGVJZCIsIm1lcmdlUGFuZUludmFsaWRhdGlvbiIsImJlZm9yZVZhbHVlIiwibmV3VmFsdWUiLCJsZXZlbCIsIl9pbnRlcm5hbF9sZXZlbCIsImF1dG9TY2FsZSIsIl9pbnRlcm5hbF9hdXRvU2NhbGUiLCJJbnZhbGlkYXRlTWFzayIsIl9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZSIsInBhbmVJbmRleCIsImludmFsaWRhdGlvbiIsInByZXZWYWx1ZSIsIl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzIiwiX2ludGVybmFsX2Z1bGxJbnZhbGlkYXRpb24iLCJfcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwiLCJfaW50ZXJuYWxfaW52YWxpZGF0ZUZvclBhbmUiLCJwYW5lSW52YWxpZGF0aW9uIiwiX2ludGVybmFsX3NldEZpdENvbnRlbnQiLCJfaW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbiIsIl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zIiwiX2ludGVybmFsX3R5cGUiLCJfaW50ZXJuYWxfYXBwbHlSYW5nZSIsInJhbmdlIiwiX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbiIsImFuaW1hdGlvbiIsIl9wcml2YXRlX19yZW1vdmVUaW1lU2NhbGVBbmltYXRpb24iLCJfaW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUiLCJfaW50ZXJuYWxfc2V0QmFyU3BhY2luZyIsImJhclNwYWNpbmciLCJfaW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQiLCJfaW50ZXJuYWxfdGltZVNjYWxlSW52YWxpZGF0aW9ucyIsIl9pbnRlcm5hbF9tZXJnZSIsIm90aGVyIiwidHNJbnZhbGlkYXRpb24iLCJfcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb24iLCJfaW50ZXJuYWxfbGlnaHQiLCJfaW50ZXJuYWxfZnVsbCIsImludiIsImdsb2JhbExldmVsIiwiZm9ybWF0dGVyT3B0aW9ucyIsIl9pbnRlcm5hbF9kZWNpbWFsU2lnbiIsIm51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvIiwiVHlwZUVycm9yIiwidG9TdHJpbmciLCJkdW1teVN0cmluZyIsInNsaWNlIiwiUHJpY2VGb3JtYXR0ZXIiLCJmb3JtYXQiLCJzaWduIiwiX3ByaXZhdGVfX2Zvcm1hdEFzRGVjaW1hbCIsIl9wcml2YXRlX19jYWxjdWxhdGVEZWNpbWFsIiwiX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoIiwiX3ByaXZhdGVfX21pbk1vdmUiLCJiYXNlIiwiaW50UGFydCIsImZyYWNTdHJpbmciLCJmcmFjTGVuZ3RoIiwiZnJhY1BhcnQiLCJ0b0ZpeGVkIiwiUGVyY2VudGFnZUZvcm1hdHRlciIsIlZvbHVtZUZvcm1hdHRlciIsInZvbCIsIl9wcml2YXRlX19mb3JtYXROdW1iZXIiLCJwb3ciLCJfcHJpdmF0ZV9fcHJlY2lzaW9uIiwicmVwbGFjZSIsIlN0cmluZyIsImUiLCJwMSIsImRlZmF1bHRSZXBsYWNlbWVudFJlIiwiVGV4dFdpZHRoQ2FjaGUiLCJfaW50ZXJuYWxfcmVzZXQiLCJfcHJpdmF0ZV9fYWN0dWFsU2l6ZSIsIl9wcml2YXRlX19jYWNoZSIsIl9wcml2YXRlX191c2FnZVRpY2siLCJfcHJpdmF0ZV9fb2xkZXN0VGljayIsIl9wcml2YXRlX190aWNrMkxhYmVscyIsIl9wcml2YXRlX19nZXRNZXRyaWNzIiwibWV0cmljcyIsImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwicmUiLCJjYWNoZVN0cmluZyIsImhhcyIsIl9pbnRlcm5hbF9tZXRyaWNzIiwiX3ByaXZhdGVfX21heFNpemUiLCJvbGRlc3RWYWx1ZSIsImRlbGV0ZSIsIm1lYXN1cmVUZXh0IiwiX2ludGVybmFsX3RpY2siLCJQYW5lUHJpY2VBeGlzVmlld1JlbmRlcmVyIiwiX2ludGVybmFsX3NldFBhcmFtcyIsInByaWNlQXhpc1ZpZXdSZW5kZXJlciIsIl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIiLCJfcHJpdmF0ZV9fYWxpZ24iLCJfcHJpdmF0ZV9fdGV4dFdpZHRoQ2FjaGUiLCJQYW5lUHJpY2VBeGlzVmlldyIsIl9pbnRlcm5hbF9wYW5lRm9yU291cmNlIiwiX3ByaXZhdGVfX2RhdGFTb3VyY2UiLCJfaW50ZXJuYWxfaXNPdmVybGF5IiwiX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZSIsInBvc2l0aW9uIiwiX2ludGVybmFsX3ByaWNlU2NhbGVQb3NpdGlvbiIsIl9pbnRlcm5hbF9wcmljZUF4aXNSZW5kZXJlck9wdGlvbnMiLCJfcHJpdmF0ZV9fcHJpY2VBeGlzVmlldyIsInByaWNlQXhpc1ZpZXciLCJkYXRhU291cmNlIiwiSG9yaXpvbnRhbExpbmVSZW5kZXJlciIsIl9pbnRlcm5hbF9oaXRUZXN0IiwiaXRlbVkiLCJfaW50ZXJuYWxfZXh0ZXJuYWxJZCIsImV4dGVybmFsSWQiLCJfaW50ZXJuYWxfaGl0VGVzdERhdGEiLCJTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IiwiX2ludGVybmFsX19zZXJpZXMiLCJfaW50ZXJuYWxfX3VwZGF0ZUltcGwiLCJfaW50ZXJuYWxfX2xpbmVSZW5kZXJlciIsInNlcmllcyIsIl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YSIsIl9pbnRlcm5hbF9fbW9kZWwiLCJTZXJpZXNIb3Jpem9udGFsQmFzZUxpbmVQYW5lVmlldyIsIl9pbnRlcm5hbF9tb2RlIiwic2VyaWVzT3B0aW9ucyIsIlNlcmllc0xhc3RQcmljZUFuaW1hdGlvblJlbmRlcmVyIiwiX2ludGVybmFsX2RhdGEiLCJfaW50ZXJuYWxfY2VudGVyIiwiX2ludGVybmFsX3Nlcmllc0xpbmVDb2xvciIsImNlbnRlclBvaW50UmFkaXVzIiwiX2ludGVybmFsX3Nlcmllc0xpbmVXaWR0aCIsIl9pbnRlcm5hbF9maWxsQ29sb3IiLCJfaW50ZXJuYWxfc3Ryb2tlQ29sb3IiLCJhbmltYXRpb25TdGFnZXNEYXRhIiwiX2ludGVybmFsX3N0YXJ0IiwiX2ludGVybmFsX2VuZCIsIl9pbnRlcm5hbF9zdGFydFJhZGl1cyIsIl9pbnRlcm5hbF9lbmRSYWRpdXMiLCJfaW50ZXJuYWxfc3RhcnRGaWxsQWxwaGEiLCJfaW50ZXJuYWxfZW5kRmlsbEFscGhhIiwiX2ludGVybmFsX3N0YXJ0U3Ryb2tlQWxwaGEiLCJfaW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGEiLCJzdGFnZSIsInN0YXJ0UmFkaXVzIiwiZW5kUmFkaXVzIiwiU2VyaWVzTGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXciLCJfaW50ZXJuYWxfb25EYXRhQ2xlYXJlZCIsIl9wcml2YXRlX19lbmRUaW1lIiwiX3ByaXZhdGVfX3N0YXJ0VGltZSIsIl9pbnRlcm5hbF9vbk5ld1JlYWx0aW1lRGF0YVJlY2VpdmVkIiwiX3ByaXZhdGVfX3NlcmllcyIsImxhc3RQcmljZUFuaW1hdGlvbiIsIm5vdyIsInBlcmZvcm1hbmNlIiwidGltZVRvQW5pbWF0aW9uRW5kIiwiX2ludGVybmFsX2ludmFsaWRhdGVTdGFnZSIsIl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkIiwiX2ludGVybmFsX2FuaW1hdGlvbkFjdGl2ZSIsIl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFTdGFnZSIsIl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UiLCJsYXN0VmFsdWUiLCJfaW50ZXJuYWxfbGFzdFZhbHVlRGF0YSIsIl9pbnRlcm5hbF9ub0RhdGEiLCJfaW50ZXJuYWxfY29udGFpbnMiLCJfaW50ZXJuYWxfaW5kZXgiLCJsYXN0VmFsdWVQb2ludCIsInNlcmllc0xpbmVDb2xvciIsInNlcmllc0xpbmVXaWR0aCIsIl9wcml2YXRlX19hbmltYXRpb25EYXRhIiwiX3ByaXZhdGVfX2R1cmF0aW9uIiwicmVuZGVyZXJEYXRhIiwiX3ByaXZhdGVfX2NvbG9yIiwic3RhcnRBbHBoYSIsImVuZEFscGhhIiwiZHVyYXRpb25TaW5jZVN0YXJ0IiwibGluZUNvbG9yIiwiZ2xvYmFsU3RhZ2UiLCJjdXJyZW50U3RhZ2VEYXRhIiwic3RhZ2VEYXRhIiwic3ViU3RhZ2UiLCJTZXJpZXNQcmljZUxpbmVQYW5lVmlldyIsImxhc3RWYWx1ZURhdGEiLCJfaW50ZXJuYWxfcHJpY2VMaW5lQ29sb3IiLCJTZXJpZXNQcmljZUF4aXNWaWV3Iiwic2hvd1Nlcmllc0xhc3RWYWx1ZSIsInNob3dTeW1ib2xMYWJlbCIsIl9pbnRlcm5hbF90aXRsZSIsInNob3dQcmljZUFuZFBlcmNlbnRhZ2UiLCJzZXJpZXNMYXN0VmFsdWVNb2RlIiwiX2ludGVybmFsX19heGlzVGV4dCIsIl9pbnRlcm5hbF9fcGFuZVRleHQiLCJsYXN0VmFsdWVDb2xvciIsIl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UiLCJfaW50ZXJuYWxfZm9ybWF0dGVkUHJpY2VBYnNvbHV0ZSIsIl9pbnRlcm5hbF9mb3JtYXR0ZWRQcmljZVBlcmNlbnRhZ2UiLCJ0cmltIiwiY29tcHV0ZUZpbml0ZVJlc3VsdCIsIm1ldGhvZCIsInZhbHVlT25lIiwidmFsdWVUd28iLCJmYWxsYmFjayIsImZpcnN0RmluaXRlIiwic2Vjb25kRmluaXRlIiwiUHJpY2VSYW5nZUltcGwiLCJfaW50ZXJuYWxfZXF1YWxzIiwicHIiLCJfcHJpdmF0ZV9fbWluVmFsdWUiLCJfcHJpdmF0ZV9fbWF4VmFsdWUiLCJfaW50ZXJuYWxfY2xvbmUiLCJfaW50ZXJuYWxfbWluVmFsdWUiLCJfaW50ZXJuYWxfbWF4VmFsdWUiLCJfaW50ZXJuYWxfbGVuZ3RoIiwiYW5vdGhlclJhbmdlIiwiSW5maW5pdHkiLCJfaW50ZXJuYWxfc2NhbGVBcm91bmRDZW50ZXIiLCJjb2VmZiIsImRlbHRhIiwiY2VudGVyIiwibWF4RGVsdGEiLCJtaW5EZWx0YSIsIl9pbnRlcm5hbF9zaGlmdCIsIl9pbnRlcm5hbF90b1JhdyIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJfaW50ZXJuYWxfZnJvbVJhdyIsInJhdyIsIkF1dG9zY2FsZUluZm9JbXBsIiwiX2ludGVybmFsX3ByaWNlUmFuZ2UiLCJfcHJpdmF0ZV9fcHJpY2VSYW5nZSIsIl9pbnRlcm5hbF9tYXJnaW5zIiwiX3ByaXZhdGVfX21hcmdpbnMiLCJwcmljZVJhbmdlIiwibWFyZ2lucyIsIkN1c3RvbVByaWNlTGluZVBhbmVWaWV3IiwibGluZU9wdGlvbnMiLCJfcHJpdmF0ZV9fcHJpY2VMaW5lIiwibGluZVZpc2libGUiLCJfaW50ZXJuYWxfeUNvb3JkIiwibGluZVN0eWxlIiwiaWQiLCJwcmljZUxpbmUiLCJDdXN0b21QcmljZUxpbmVQcmljZUF4aXNWaWV3IiwiYXhpc0xhYmVsVmlzaWJsZSIsInNob3dQYW5lTGFiZWwiLCJfcHJpdmF0ZV9fZm9ybWF0UHJpY2UiLCJheGlzTGFiZWxDb2xvciIsImF4aXNMYWJlbFRleHRDb2xvciIsIkN1c3RvbVByaWNlTGluZSIsIl9pbnRlcm5hbF9hcHBseU9wdGlvbnMiLCJfaW50ZXJuYWxfbGlnaHRVcGRhdGUiLCJfaW50ZXJuYWxfcGFuZVZpZXciLCJfcHJpdmF0ZV9fcHJpY2VMaW5lVmlldyIsIl9pbnRlcm5hbF9sYWJlbFBhbmVWaWV3IiwiX3ByaXZhdGVfX3BhbmVQcmljZUF4aXNWaWV3IiwiX2ludGVybmFsX3ByaWNlQXhpc1ZpZXciLCJQcmljZURhdGFTb3VyY2UiLCJiYXJTdHlsZUZuTWFwIiwiQmFyIiwiZmluZEJhciIsImJhclN0eWxlIiwiYmFySW5kZXgiLCJwcmVjb21wdXRlZEJhcnMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiY3VycmVudEJhciIsImlzVXAiLCJfaW50ZXJuYWxfYmFyQ29sb3IiLCJDYW5kbGVzdGljayIsImNhbmRsZXN0aWNrU3R5bGUiLCJib3JkZXJVcENvbG9yIiwiYm9yZGVyRG93bkNvbG9yIiwid2lja1VwQ29sb3IiLCJ3aWNrRG93bkNvbG9yIiwiX2ludGVybmFsX2JhckJvcmRlckNvbG9yIiwiX2ludGVybmFsX2JhcldpY2tDb2xvciIsIl9pbnRlcm5hbF93aWNrQ29sb3IiLCJDdXN0b20iLCJjdXN0b21TdHlsZSIsIkFyZWEiLCJhcmVhU3R5bGUiLCJfaW50ZXJuYWxfdG9wQ29sb3IiLCJfaW50ZXJuYWxfYm90dG9tQ29sb3IiLCJCYXNlbGluZSIsImJhc2VsaW5lU3R5bGUiLCJpc0Fib3ZlQmFzZWxpbmUiLCJiYXNlVmFsdWUiLCJ0b3BMaW5lQ29sb3IiLCJib3R0b21MaW5lQ29sb3IiLCJfaW50ZXJuYWxfdG9wTGluZUNvbG9yIiwiX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvciIsIl9pbnRlcm5hbF90b3BGaWxsQ29sb3IxIiwidG9wRmlsbENvbG9yMSIsIl9pbnRlcm5hbF90b3BGaWxsQ29sb3IyIiwidG9wRmlsbENvbG9yMiIsIl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxIiwiYm90dG9tRmlsbENvbG9yMSIsIl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IyIiwiYm90dG9tRmlsbENvbG9yMiIsIkxpbmUiLCJIaXN0b2dyYW0iLCJoaXN0b2dyYW1TdHlsZSIsIlNlcmllc0JhckNvbG9yZXIiLCJfaW50ZXJuYWxfYmFyU3R5bGUiLCJfcHJpdmF0ZV9fc3R5bGVHZXR0ZXIiLCJfcHJpdmF0ZV9fZmluZEJhciIsIl9pbnRlcm5hbF92YWx1ZUF0IiwiX2ludGVybmFsX3Nlcmllc1R5cGUiLCJib3VuZENvbXBhcmUiLCJsb3dlciIsImFyciIsImNvbXBhcmUiLCJzdGFydCIsImNvdW50IiwiY291bnQyIiwibWlkIiwibG93ZXJCb3VuZCIsImJpbmQiLCJ1cHBlckJvdW5kIiwiTWlzbWF0Y2hEaXJlY3Rpb24iLCJDSFVOS19TSVpFIiwiUGxvdExpc3QiLCJfaW50ZXJuYWxfbGFzdCIsIl9pbnRlcm5hbF9zaXplIiwiX3ByaXZhdGVfX2l0ZW1zIiwiX2ludGVybmFsX2ZpcnN0SW5kZXgiLCJfcHJpdmF0ZV9faW5kZXhBdCIsIl9wcml2YXRlX19zZWFyY2giLCJfaW50ZXJuYWxfc2VhcmNoIiwic2VhcmNoTW9kZSIsInBvcyIsIl9wcml2YXRlX192YWx1ZUF0IiwiX2ludGVybmFsX3Jvd3MiLCJfaW50ZXJuYWxfbWluTWF4T25SYW5nZUNhY2hlZCIsImVuZCIsInBsb3RzIiwicGxvdCIsInBsb3RNaW5NYXgiLCJfcHJpdmF0ZV9fbWluTWF4T25SYW5nZUNhY2hlZEltcGwiLCJtZXJnZU1pbk1heCIsInBsb3RSb3dzIiwiX3ByaXZhdGVfX3Jvd1NlYXJjaENhY2hlIiwiX3ByaXZhdGVfX21pbk1heENhY2hlIiwiX3ByaXZhdGVfX2luZGljZXMiLCJwbG90Um93IiwiX2ludGVybmFsX2luZGljZXMiLCJleGFjdFBvcyIsIl9wcml2YXRlX19ic2VhcmNoIiwiX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RMZWZ0IiwiX3ByaXZhdGVfX3NlYXJjaE5lYXJlc3RSaWdodCIsIm5lYXJlc3RMZWZ0UG9zIiwiX3ByaXZhdGVfX2xvd2VyYm91bmQiLCJuZWFyZXN0UmlnaHRQb3MiLCJfcHJpdmF0ZV9fdXBwZXJib3VuZCIsImEiLCJiIiwiX3ByaXZhdGVfX3Bsb3RNaW5NYXgiLCJzdGFydEluZGV4IiwiZW5kSW5kZXhFeGNsdXNpdmUiLCJwbG90SW5kZXgiLCJ2YWx1ZXMiLCJfaW50ZXJuYWxfbWluIiwiX2ludGVybmFsX21heCIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJjYWNoZWRMb3ciLCJjYWNoZWRIaWdoIiwiZW5kSW5kZXgiLCJtaW5NYXhDYWNoZSIsImNodW5rSW5kZXgiLCJjaHVua01pbk1heCIsImNodW5rU3RhcnQiLCJjaHVua0VuZCIsImZpcnN0Iiwic2Vjb25kIiwiY3JlYXRlU2VyaWVzUGxvdExpc3QiLCJQcmltaXRpdmVSZW5kZXJlcldyYXBwZXIiLCJfcHJpdmF0ZV9fYmFzZVJlbmRlcmVyIiwiX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kIiwiZHJhd0JhY2tncm91bmQiLCJiYXNlUmVuZGVyZXIiLCJQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIiLCJfcHJpdmF0ZV9fcGFuZVZpZXciLCJyZW5kZXJlciIsIl9pbnRlcm5hbF9iYXNlIiwiX2ludGVybmFsX3dyYXBwZXIiLCJ3cmFwcGVyIiwiX2ludGVybmFsX3pPcmRlciIsInpPcmRlciIsInBhbmVWaWV3IiwiUHJpbWl0aXZlV3JhcHBlciIsIl9pbnRlcm5hbF9wcmltaXRpdmUiLCJfaW50ZXJuYWxfX3ByaW1pdGl2ZSIsInVwZGF0ZUFsbFZpZXdzIiwicGFuZVZpZXdzIiwiX3ByaXZhdGVfX3BhbmVWaWV3c0NhY2hlIiwicHciLCJoaXRUZXN0IiwicHJpbWl0aXZlIiwiUGFuZVByaW1pdGl2ZVdyYXBwZXIkMSIsIlBhbmVQcmltaXRpdmVXcmFwcGVyIiwiU2VyaWVzUHJpbWl0aXZlUmVuZGVyZXJXcmFwcGVyIiwiU2VyaWVzUHJpbWl0aXZlUGFuZVZpZXdXcmFwcGVyIiwiZ2V0QXhpc1ZpZXdEYXRhIiwiYmFzZVZpZXciLCJmaXhlZENvb3JkaW5hdGUiLCJiYWNrQ29sb3IiLCJ0aWNrVmlzaWJsZSIsIlNlcmllc1ByaW1pdGl2ZVRpbWVBeGlzVmlld1dyYXBwZXIiLCJfcHJpdmF0ZV9fdGltZVNjYWxlIiwiX3ByaXZhdGVfX2Jhc2VWaWV3IiwiU2VyaWVzUHJpbWl0aXZlUHJpY2VBeGlzVmlld1dyYXBwZXIiLCJTZXJpZXNQcmltaXRpdmVXcmFwcGVyIiwidGltZUF4aXNWaWV3cyIsIl9wcml2YXRlX190aW1lQXhpc1ZpZXdzQ2FjaGUiLCJhdyIsInByaWNlQXhpc1ZpZXdzIiwiX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzQ2FjaGUiLCJfaW50ZXJuYWxfcHJpY2VBeGlzUGFuZVZpZXdzIiwicHJpY2VBeGlzUGFuZVZpZXdzIiwiX3ByaXZhdGVfX3ByaWNlQXhpc1BhbmVWaWV3c0NhY2hlIiwiX2ludGVybmFsX3RpbWVBeGlzUGFuZVZpZXdzIiwidGltZUF4aXNQYW5lVmlld3MiLCJfcHJpdmF0ZV9fdGltZUF4aXNQYW5lVmlld3NDYWNoZSIsIl9pbnRlcm5hbF9hdXRvc2NhbGVJbmZvIiwic3RhcnRUaW1lUG9pbnQiLCJlbmRUaW1lUG9pbnQiLCJhdXRvc2NhbGVJbmZvIiwiZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyIsInByaW1pdGl2ZXMiLCJleHRyYWN0b3IiLCJkZXN0aW5hdGlvbiIsInByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3RvciIsInByaW1pdGl2ZVByaWNlUGFuZVZpZXdzRXh0cmFjdG9yIiwicHJpbWl0aXZlVGltZVBhbmVWaWV3c0V4dHJhY3RvciIsImxpbmVCYXNlZFNlcmllcyIsIlNlcmllcyIsIl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJsYXN0QmFyQ29sb3IiLCJnbG9iYWxMYXN0Iiwibm9EYXRhUmVzIiwidmlzaWJsZUJhcnMiLCJiYXIiLCJsYXN0QmFyIiwiZW5kQmFyIiwiYmFyQ29sb3JlciIsIl9pbnRlcm5hbF9iYXJDb2xvcmVyIiwiX2ludGVybmFsX2Zvcm1hdFByaWNlQWJzb2x1dGUiLCJfaW50ZXJuYWxfZm9ybWF0UHJpY2VQZXJjZW50YWdlIiwiX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSIsInRhcmdldFByaWNlU2NhbGVJZCIsIl9pbnRlcm5hbF9tb3ZlU2VyaWVzVG9TY2FsZSIsIl9wcml2YXRlX19yZWNyZWF0ZUZvcm1hdHRlciIsIl9pbnRlcm5hbF9mdWxsVXBkYXRlIiwiX2ludGVybmFsX3VwZGF0ZVNvdXJjZSIsIl9pbnRlcm5hbF91cGRhdGVDcm9zc2hhaXIiLCJ1cGRhdGVJbmZvIiwiX3ByaXZhdGVfX2xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3IiwiX2ludGVybmFsX2xhc3RCYXJVcGRhdGVkT3JOZXdCYXJzQWRkZWRUb1RoZVJpZ2h0Iiwic291cmNlUGFuZSIsIl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVBhbmUiLCJfaW50ZXJuYWxfY3JlYXRlUHJpY2VMaW5lIiwiX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMiLCJfaW50ZXJuYWxfcmVtb3ZlUHJpY2VMaW5lIiwibGluZSIsImluZGV4T2YiLCJfaW50ZXJuYWxfcHJpY2VMaW5lcyIsIl9wcml2YXRlX19zZXJpZXNUeXBlIiwiX2ludGVybmFsX2ZpcnN0QmFyIiwiX2ludGVybmFsX3RpbWVQb2ludCIsIl9pbnRlcm5hbF9sZWZ0IiwiX2ludGVybmFsX2RhdGFBdCIsInByaWNlcyIsIl9pbnRlcm5hbF9vcGVuIiwiX2ludGVybmFsX2hpZ2giLCJfaW50ZXJuYWxfbG93IiwiX2ludGVybmFsX2Nsb3NlIiwiX2ludGVybmFsX3RvcFBhbmVWaWV3cyIsIl9wcml2YXRlX19wcmltaXRpdmVzIiwiYW5pbWF0aW9uUGFuZVZpZXciLCJzZXRUaW1lb3V0IiwiX2ludGVybmFsX2N1cnNvclVwZGF0ZSIsInVuc2hpZnQiLCJfcHJpdmF0ZV9faXNPdmVybGF5IiwiX3ByaXZhdGVfX2Jhc2VIb3Jpem9udGFsTGluZVZpZXciLCJwcmljZUxpbmVWaWV3cyIsIl9pbnRlcm5hbF9ib3R0b21QYW5lVmlld3MiLCJfcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyIsIl9pbnRlcm5hbF9wcmljZVBhbmVWaWV3cyIsIl9pbnRlcm5hbF90aW1lUGFuZVZpZXdzIiwiX2ludGVybmFsX3ByaW1pdGl2ZUhpdFRlc3QiLCJjdXN0b21QcmljZUxpbmUiLCJhdXRvc2NhbGVJbmZvUHJvdmlkZXIiLCJfcHJpdmF0ZV9fYXV0b3NjYWxlSW5mb0ltcGwiLCJfaW50ZXJuYWxfbWluTW92ZSIsIl9pbnRlcm5hbF9mb3JtYXR0ZXIiLCJfcHJpdmF0ZV9fZm9ybWF0dGVyIiwiZ2V0VmFsdWUiLCJjcm9zc2hhaXJNYXJrZXJWaXNpYmxlIiwiX3ByaXZhdGVfX21hcmtlclJhZGl1cyIsIl9wcml2YXRlX19tYXJrZXJCb3JkZXJDb2xvciIsIl9wcml2YXRlX19tYXJrZXJCb3JkZXJXaWR0aCIsIl9wcml2YXRlX19tYXJrZXJCYWNrZ3JvdW5kQ29sb3IiLCJfaW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlIiwiX2ludGVybmFsX2RldGFjaFByaW1pdGl2ZSIsIl9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlciIsIl9pbnRlcm5hbF9wcmljZVZhbHVlQnVpbGRlciIsIl9pbnRlcm5hbF9jdXN0b21TZXJpZXNXaGl0ZXNwYWNlQ2hlY2siLCJfaW50ZXJuYWxfaXNXaGl0ZXNwYWNlIiwiX2ludGVybmFsX2Z1bGZpbGxlZEluZGljZXMiLCJfaW50ZXJuYWxfaWQiLCJiYXJzTWluTWF4IiwicmFuZ2VXaXRoQmFzZSIsInByaW1pdGl2ZUF1dG9zY2FsZSIsInByaW1pdGl2ZVJhbmdlIiwiY3Jvc3NoYWlyTWFya2VyUmFkaXVzIiwiY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3IiLCJjcm9zc2hhaXJNYXJrZXJCb3JkZXJXaWR0aCIsImNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvciIsImZvcm1hdHRlciIsIl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIiLCJzZXJpZXNUeXBlIiwiY3JlYXRlUGFuZVZpZXciLCJjdXN0b21QYW5lVmlldyIsIm1hZ25ldFBsb3RSb3dLZXlzIiwibWFnbmV0T0hMQ1Bsb3RSb3dLZXlzIiwiTWFnbmV0IiwiX2ludGVybmFsX2FsaWduIiwiZGVmYXVsdFByaWNlU2NhbGUiLCJfaW50ZXJuYWxfZGF0YVNvdXJjZXMiLCJkcyIsImNhbmRpZGF0ZXMiLCJyZWR1Y2UiLCJhY2MiLCJwcyIsImJhcnMiLCJmaXJzdFByaWNlIiwicGxvdFJvd0tleXMiLCJjb25jYXQiLCJrZXkiLCJzb3J0IiwibmVhcmVzdCIsImNsYW1wIiwibWluVmFsIiwibWF4VmFsIiwiaXNCYXNlRGVjaW1hbCIsImN1cnJlbnQiLCJncmVhdGVyT3JFcXVhbCIsImVwc2lsb24iLCJlcXVhbCIsImNlaWxlZEV2ZW4iLCJjZWlsZWQiLCJjZWlsZWRPZGQiLCJHcmlkUmVuZGVyZXIiLCJfaW50ZXJuYWxfdmVydExpbmVzVmlzaWJsZSIsIl9pbnRlcm5hbF92ZXJ0TGluZXNDb2xvciIsIl9pbnRlcm5hbF92ZXJ0TGluZVN0eWxlIiwidGltZU1hcmsiLCJfaW50ZXJuYWxfdGltZU1hcmtzIiwiX2ludGVybmFsX2Nvb3JkIiwiX2ludGVybmFsX2hvcnpMaW5lc1Zpc2libGUiLCJfaW50ZXJuYWxfaG9yekxpbmVzQ29sb3IiLCJfaW50ZXJuYWxfaG9yekxpbmVTdHlsZSIsInByaWNlTWFyayIsIl9pbnRlcm5hbF9wcmljZU1hcmtzIiwiR3JpZFBhbmVWaWV3IiwiZ3JpZE9wdGlvbnMiLCJncmlkIiwiaG9yekxpbmVzIiwidmVydExpbmVzIiwiX2ludGVybmFsX21hcmtzIiwidG0iLCJjb29yZCIsIkdyaWQiLCJkZWZMb2dGb3JtdWxhIiwiX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQiLCJfaW50ZXJuYWxfY29vcmRPZmZzZXQiLCJmcm9tUGVyY2VudCIsInRvUGVyY2VudCIsInRvUGVyY2VudFJhbmdlIiwibWluUGVyY2VudCIsIm1heFBlcmNlbnQiLCJmcm9tSW5kZXhlZFRvMTAwIiwidG9JbmRleGVkVG8xMDAiLCJ0b0luZGV4ZWRUbzEwMFJhbmdlIiwidG9Mb2ciLCJsb2dGb3JtdWxhIiwibSIsImxvZzEwIiwiZnJvbUxvZyIsImxvZ2ljYWwiLCJjb252ZXJ0UHJpY2VSYW5nZVRvTG9nIiwiY2FuQ29udmVydFByaWNlUmFuZ2VGcm9tTG9nIiwiY29udmVydFByaWNlUmFuZ2VGcm9tTG9nIiwibG9nRm9ybXVsYUZvclByaWNlUmFuZ2UiLCJkaWZmIiwiZGlnaXRzIiwibG9naWNhbE9mZnNldCIsImNvb3JkT2Zmc2V0IiwibG9nRm9ybXVsYXNBcmVTYW1lIiwiZjEiLCJmMiIsIlByaWNlVGlja1NwYW5DYWxjdWxhdG9yIiwiX2ludGVybmFsX3RpY2tTcGFuIiwiaGlnaCIsImxvdyIsIm1heFRpY2tTcGFuIiwibWluTW92ZW1lbnQiLCJfcHJpdmF0ZV9fYmFzZSIsInJlc3VsdFRpY2tTcGFuIiwiX3ByaXZhdGVfX2ludGVncmFsRGl2aWRlcnMiLCJyZXN1bHRUaWNrU3Bhbkxhcmdlck1pbk1vdmVtZW50IiwicmVzdWx0VGlja1NwYW5MYXJnZXJNYXhUaWNrU3BhbiIsInJlc3VsdFRpY2tTcGFuTGFyZ2VyMSIsImhhdmVUb0NvbnRpbnVlIiwiX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycyIsImludGVncmFsRGl2aWRlcnMiLCJiYXNlUmVzdCIsIlRJQ0tfREVOU0lUWSIsIlByaWNlVGlja01hcmtCdWlsZGVyIiwic2NhbGVIZWlnaHQiLCJtYXJrSGVpZ2h0IiwiX3ByaXZhdGVfX3RpY2tNYXJrSGVpZ2h0Iiwic3BhbkNhbGN1bGF0b3IxIiwic3BhbkNhbGN1bGF0b3IyIiwic3BhbkNhbGN1bGF0b3IzIiwic3BhbnMiLCJfaW50ZXJuYWxfcmVidWlsZFRpY2tNYXJrcyIsIl9wcml2YXRlX19tYXJrcyIsIl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsRnVuYyIsImV4dHJhVG9wQm90dG9tTWFyZ2luIiwiZW50aXJlVGV4dE9ubHkiLCJfcHJpdmF0ZV9fZm9udEhlaWdodCIsIm1pbkNvb3JkIiwibWF4Q29vcmQiLCJzcGFuIiwiX3ByaXZhdGVfX3VwZGF0ZU1hcmtzIiwiX2ludGVybmFsX2hhc1Zpc2libGVFZGdlTWFya3MiLCJfcHJpdmF0ZV9fc2hvdWxkQXBwbHlFZGdlTWFya3MiLCJwYWRkaW5nIiwiX2ludGVybmFsX2dldEVkZ2VNYXJrc1BhZGRpbmciLCJfcHJpdmF0ZV9fYXBwbHlFZGdlTWFya3MiLCJtYXJrcyIsIm1vZCIsInByZXZDb29yZCIsInRhcmdldEluZGV4IiwiX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jIiwiX2ludGVybmFsX2xhYmVsIiwiX2ludGVybmFsX2Zvcm1hdExvZ2ljYWwiLCJfaW50ZXJuYWxfaXNMb2ciLCJtaW5QYWRkaW5nIiwibWF4UGFkZGluZyIsInRvcE1hcmsiLCJfcHJpdmF0ZV9fY29tcHV0ZUJvdW5kYXJ5UHJpY2VNYXJrIiwiYm90dG9tTWFyayIsInNwYW5QeCIsInNoaWZ0IiwicG9wIiwiYXZnUGFkZGluZyIsInZhbHVlMSIsInZhbHVlMiIsInZhbHVlU3BhbiIsInJvdW5kZWRWYWx1ZSIsInJvdW5kZWRDb29yZCIsIl9pbnRlcm5hbF9nZXRMb2dGb3JtdWxhIiwiY29vcmRpbmF0ZVRvTG9naWNhbEZ1bmMiLCJsb2dpY2FsVG9Db29yZGluYXRlRnVuYyIsInNvcnRTb3VyY2VzIiwiczEiLCJzMiIsIlByaWNlU2NhbGVNb2RlIiwicGVyY2VudGFnZUZvcm1hdHRlciIsImRlZmF1bHRQcmljZUZvcm1hdHRlciIsIlByaWNlU2NhbGUiLCJfcHJpdmF0ZV9faWQiLCJfaW50ZXJuYWxfc2V0TW9kZSIsInNjYWxlTWFyZ2lucyIsIl9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSIsIl9wcml2YXRlX19tYXJrc0NhY2hlIiwiX2ludGVybmFsX2lzQXV0b1NjYWxlIiwiX2ludGVybmFsX2lzQ3VzdG9tUHJpY2VSYW5nZSIsIl9wcml2YXRlX19pc0N1c3RvbVByaWNlUmFuZ2UiLCJfaW50ZXJuYWxfaXNJbmRleGVkVG8xMDAiLCJfcHJpdmF0ZV9fbG9nRm9ybXVsYSIsIl9pbnRlcm5hbF9pc0ludmVydGVkIiwiaW52ZXJ0U2NhbGUiLCJuZXdNb2RlIiwib2xkTW9kZSIsIl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlIiwiX2ludGVybmFsX2lzVmFsaWQiLCJfaW50ZXJuYWxfc2V0UHJpY2VSYW5nZSIsIm1vZGVDaGFuZ2VkIiwiX3ByaXZhdGVfX29uSXNJbnZlcnRlZENoYW5nZWQiLCJfcHJpdmF0ZV9fbW9kZUNoYW5nZWQiLCJfaW50ZXJuYWxfbW9kZUNoYW5nZWQiLCJfcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucyIsIl9wcml2YXRlX19oZWlnaHQiLCJfaW50ZXJuYWxfc2V0SGVpZ2h0IiwiX2ludGVybmFsX2ludGVybmFsSGVpZ2h0IiwiX3ByaXZhdGVfX2ludGVybmFsSGVpZ2h0Q2FjaGUiLCJfcHJpdmF0ZV9fdG9wTWFyZ2luUHgiLCJfcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgiLCJfcHJpdmF0ZV9fbWFrZVN1cmVJdElzVmFsaWQiLCJuZXdQcmljZVJhbmdlIiwiaXNGb3JjZVNldFZhbHVlIiwib2xkUHJpY2VSYW5nZSIsIl9pbnRlcm5hbF9zZXRDdXN0b21QcmljZVJhbmdlIiwiX3ByaXZhdGVfX3RvZ2dsZUN1c3RvbVByaWNlUmFuZ2UiLCJfaW50ZXJuYWxfaW52ZXJ0ZWRDb29yZGluYXRlIiwiX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGUiLCJfaW50ZXJuYWxfcG9pbnRzQXJyYXlUb0Nvb3JkaW5hdGVzIiwicG9pbnRzIiwiYmgiLCJpaCIsImlzSW52ZXJ0ZWQiLCJobW0iLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwidHJhbnNmb3JtRm4iLCJfcHJpdmF0ZV9fZ2V0Q29vcmRpbmF0ZVRyYW5zZm9ybWVyIiwiaW52Q29vcmRpbmF0ZSIsIl9pbnRlcm5hbF9iYXJQcmljZXNUb0Nvb3JkaW5hdGVzIiwicHJpY2VzTGlzdCIsIm9wZW5Mb2dpY2FsIiwiaGlnaExvZ2ljYWwiLCJsb3dMb2dpY2FsIiwiY2xvc2VMb2dpY2FsIiwiX2ludGVybmFsX29wZW5ZIiwiX2ludGVybmFsX2hpZ2hZIiwiX2ludGVybmFsX2xvd1kiLCJfaW50ZXJuYWxfY2xvc2VZIiwiX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwiLCJfaW50ZXJuYWxfbG9naWNhbFRvUHJpY2UiLCJfcHJpdmF0ZV9fZGF0YVNvdXJjZXMiLCJfcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMiLCJfaW50ZXJuYWxfYWRkRGF0YVNvdXJjZSIsIl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlIiwiX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2UiLCJmaXJzdFZhbHVlSXNOdWxsIiwiX2ludGVybmFsX2ZpcnN0VmFsdWVJc051bGwiLCJfcHJpdmF0ZV9fbWFya0J1aWxkZXIiLCJfcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQiLCJfaW50ZXJuYWxfb25NYXJrc0NoYW5nZWQiLCJfaW50ZXJuYWxfc3RhcnRTY2FsZSIsIl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQiLCJfcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90IiwiX2ludGVybmFsX3NjYWxlVG8iLCJzY2FsZUNvZWZmIiwiX2ludGVybmFsX2VuZFNjYWxlIiwiX2ludGVybmFsX3N0YXJ0U2Nyb2xsIiwiX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQiLCJfaW50ZXJuYWxfc2Nyb2xsVG8iLCJwcmljZVVuaXRzUGVyUGl4ZWwiLCJwaXhlbERlbHRhIiwicHJpY2VEZWx0YSIsIl9pbnRlcm5hbF9lbmRTY3JvbGwiLCJfcHJpdmF0ZV9fZm9ybWF0UGVyY2VudGFnZSIsIl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UiLCJfaW50ZXJuYWxfc291cmNlc0ZvckF1dG9TY2FsZSIsIl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlUmFuZ2UiLCJfaW50ZXJuYWxfdmlzaWJsZUJhcnMiLCJlbnN1cmVFZGdlVGlja01hcmtzVmlzaWJsZSIsIl9wcml2YXRlX19jb2xvclBhcnNlciIsIl9wcml2YXRlX19tYXJnaW5CZWxvdyIsIl9wcml2YXRlX19tYXJnaW5BYm92ZSIsIl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlUmFuZ2VJbXBsIiwibWFyZ2luQWJvdmUiLCJtYXJnaW5CZWxvdyIsImF1dG9TY2FsZUluZm8iLCJzb3VyY2VSYW5nZSIsImFib3ZlIiwiYmVsb3ciLCJmb3JtYXR0ZXJTb3VyY2UiLCJleHRlbmRWYWx1ZSIsInJhd1JhbmdlIiwibmV3TG9nRm9ybXVsYSIsInJhd1NuYXBzaG90IiwiX3ByaXZhdGVfX2Zvcm1hdFZhbHVlIiwiZmFsbGJhY2tGb3JtYXR0ZXIiLCJfcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyIsInByaWNlRm9ybWF0dGVyIiwicGVyY2VudGFnZSIsImxheW91dE9wdGlvbnMiLCJsb2NhbGl6YXRpb25PcHRpb25zIiwiY29sb3JQYXJzZXIiLCJpc1NlcmllcyIsIkRFRkFVTFRfU1RSRVRDSF9GQUNUT1IiLCJNSU5fUEFORV9IRUlHSFQiLCJQYW5lIiwiX2ludGVybmFsX2FwcGx5U2NhbGVPcHRpb25zIiwibGVmdFByaWNlU2NhbGUiLCJfcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUiLCJyaWdodFByaWNlU2NhbGUiLCJfcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlIiwibG9jYWxpemF0aW9uIiwib3ZlcmxheVByaWNlU2NhbGVzIiwic291cmNlQXJyYXlzIiwiX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkIiwiX2ludGVybmFsX3ByaWNlU2NhbGVCeUlkIiwiX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQiLCJkZXRhY2hlZCIsIl9wcml2YXRlX19kZXN0cm95ZWQiLCJfaW50ZXJuYWxfc3RyZXRjaEZhY3RvciIsIl9wcml2YXRlX19zdHJldGNoRmFjdG9yIiwiX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IiLCJmYWN0b3IiLCJfcHJpdmF0ZV9fd2lkdGgiLCJfaW50ZXJuYWxfc2V0V2lkdGgiLCJfaW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcyIsIl9pbnRlcm5hbF9zZXJpZXMiLCJ0YXJnZXRTY2FsZUlkIiwia2VlcFNvdXJjZXNPcmRlciIsIl9wcml2YXRlX19pbnNlcnREYXRhU291cmNlIiwia2VlcFNvdXJjZU9yZGVyIiwib3ZlcmxheVNvdXJjZXMiLCJvdmVybGF5SW5kZXgiLCJfaW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlIiwiX2ludGVybmFsX2xlZnRQcmljZVNjYWxlIiwiX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSIsIl9pbnRlcm5hbF9zdGFydFNjYWxlUHJpY2UiLCJfaW50ZXJuYWxfc2NhbGVQcmljZVRvIiwiX2ludGVybmFsX2VuZFNjYWxlUHJpY2UiLCJfaW50ZXJuYWxfc3RhcnRTY3JvbGxQcmljZSIsIl9pbnRlcm5hbF9zY3JvbGxQcmljZVRvIiwiX2ludGVybmFsX2VuZFNjcm9sbFByaWNlIiwiX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VTY2FsZUltcGwiLCJfaW50ZXJuYWxfcmVzZXRQcmljZVNjYWxlIiwiX2ludGVybmFsX21vbWVudGFyeUF1dG9TY2FsZSIsIl9pbnRlcm5hbF9yZWNhbGN1bGF0ZSIsIl9pbnRlcm5hbF9zZXRTZXJpZXNPcmRlciIsIm9yZGVyIiwiX2ludGVybmFsX29uRGVzdHJveWVkIiwiX2ludGVybmFsX2dyaWQiLCJfcHJpdmF0ZV9fZ3JpZCIsIl9pbnRlcm5hbF9wcmltaXRpdmVzIiwic291cmNlRm9yQXV0b1NjYWxlIiwiX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUiLCJfcHJpdmF0ZV9fb25QcmljZVNjYWxlTW9kZUNoYW5nZWQiLCJhY3R1YWxPcHRpb25zIiwiY29tcGFyZVByaW1pdGl2ZVpPcmRlciIsIml0ZW0iLCJyZWZlcmVuY2UiLCJmaW5kQmVzdFByaW1pdGl2ZUhpdFRlc3QiLCJiZXN0UHJpbWl0aXZlSGl0IiwiYmVzdEhpdFNvdXJjZSIsInByaW1pdGl2ZUhpdFJlc3VsdHMiLCJoaXRSZXN1bHQiLCJfaW50ZXJuYWxfaGl0IiwiX2ludGVybmFsX3NvdXJjZSIsImNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQiLCJwcmltaXRpdmVIaXQiLCJfaW50ZXJuYWxfb2JqZWN0IiwiX2ludGVybmFsX2N1cnNvclN0eWxlIiwiY3Vyc29yU3R5bGUiLCJoaXRUZXN0UGFuZVZpZXciLCJfaW50ZXJuYWxfdmlldyIsImlzRGF0YVNvdXJjZSIsImhpdFRlc3RQYW5lIiwiaXNCYWNrZ3JvdW5kIiwic291cmNlUmVzdWx0IiwiRm9ybWF0dGVkTGFiZWxzQ2FjaGUiLCJfaW50ZXJuYWxfZm9ybWF0IiwidGlja01hcmsiLCJjYWNoZUtleSIsIl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciIsInRpY2siLCJfaW50ZXJuYWxfc3RyaW5nIiwic3RyIiwiX3ByaXZhdGVfX2Zvcm1hdCIsImhvcnpTY2FsZUJlaGF2aW9yIiwiUmFuZ2VJbXBsIiwiX3ByaXZhdGVfX2xlZnQiLCJfcHJpdmF0ZV9fcmlnaHQiLCJfaW50ZXJuYWxfY291bnQiLCJhcmVSYW5nZXNFcXVhbCIsIlRpY2tNYXJrcyIsIl9pbnRlcm5hbF9zZXRVbmlmb3JtRGlzdHJpYnV0aW9uIiwidmFsIiwiX3ByaXZhdGVfX3VuaWZvcm1EaXN0cmlidXRpb24iLCJfaW50ZXJuYWxfc2V0VGltZVNjYWxlUG9pbnRzIiwibmV3UG9pbnRzIiwiZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCIsIl9wcml2YXRlX19yZW1vdmVNYXJrc1NpbmNlSW5kZXgiLCJtYXJrc0ZvcldlaWdodCIsIl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0IiwidGltZVdlaWdodCIsIndlaWdodCIsIm9yaWdpbmFsVGltZSIsIl9pbnRlcm5hbF9idWlsZCIsInNwYWNpbmciLCJtYXhXaWR0aCIsImNoZWNrSW5kaWNlc0ZvckRhdGEiLCJpbmRpY2VzV2l0aERhdGFNYXAiLCJpbmRpY2VzV2l0aERhdGFJZCIsIm1heEluZGV4ZXNQZXJNYXJrIiwiX2ludGVybmFsX21heEluZGV4ZXNQZXJNYXJrIiwiX2ludGVybmFsX2luZGljZXNXaXRoRGF0YUlkIiwiX2ludGVybmFsX2NoZWNrSW5kaWNlc0ZvckRhdGEiLCJfcHJpdmF0ZV9fYnVpbGRNYXJrc0ltcGwiLCJzaW5jZUluZGV4Iiwid2VpZ2h0c1RvQ2xlYXIiLCJjYW5CZUluY2x1ZGVkIiwibWFyayIsImtleXMiLCJwcmV2TWFya3MiLCJwcmV2TWFya3NMZW5ndGgiLCJwcmV2TWFya3NQb2ludGVyIiwiY3VycmVudFdlaWdodCIsImN1cnJlbnRXZWlnaHRMZW5ndGgiLCJyaWdodEluZGV4IiwibGVmdEluZGV4IiwiY3VycmVudEluZGV4IiwibGFzdE1hcmsiLCJUaW1lU2NhbGVWaXNpYmxlUmFuZ2UiLCJfaW50ZXJuYWxfc3RyaWN0UmFuZ2UiLCJfcHJpdmF0ZV9fbG9naWNhbFJhbmdlIiwiX2ludGVybmFsX2xvZ2ljYWxSYW5nZSIsIl9pbnRlcm5hbF9pbnZhbGlkIiwibG9naWNhbFJhbmdlIiwiZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoIiwibWFya1dpdGhHcmVhdGVyV2VpZ2h0JDIiLCJUaW1lU2NhbGUiLCJfaW50ZXJuYWxfYXBwbHlMb2NhbGl6YXRpb25PcHRpb25zIiwiX3ByaXZhdGVfX2ludmFsaWRhdGVUaWNrTWFya3MiLCJfcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIiLCJmaXhMZWZ0RWRnZSIsIl9wcml2YXRlX19kb0ZpeExlZnRFZGdlIiwiZml4UmlnaHRFZGdlIiwiX3ByaXZhdGVfX2RvRml4UmlnaHRFZGdlIiwicmlnaHRPZmZzZXQiLCJtaW5CYXJTcGFjaW5nIiwibWF4QmFyU3BhY2luZyIsIl9wcml2YXRlX19iYXJTcGFjaW5nIiwiaWdub3JlV2hpdGVzcGFjZUluZGljZXMiLCJfaW50ZXJuYWxfcmVjYWxjdWxhdGVJbmRpY2VzV2l0aERhdGEiLCJfcHJpdmF0ZV9fb3B0aW9uc0FwcGxpZWQiLCJfcHJpdmF0ZV9fcG9pbnRzIiwiX2ludGVybmFsX3RpbWVUb0luZGV4IiwiZmluZE5lYXJlc3QiLCJfcHJpdmF0ZV9fYmFzZUluZGV4T3JOdWxsIiwiX2ludGVybmFsX2hhc1BvaW50cyIsIl9wcml2YXRlX191cGRhdGVWaXNpYmxlUmFuZ2UiLCJfcHJpdmF0ZV9fdmlzaWJsZVJhbmdlIiwiX2ludGVybmFsX3Zpc2libGVMb2dpY2FsUmFuZ2UiLCJfaW50ZXJuYWxfdmlzaWJsZVRpbWVSYW5nZSIsIl9pbnRlcm5hbF90aW1lUmFuZ2VGb3JMb2dpY2FsUmFuZ2UiLCJfcHJpdmF0ZV9fZmlyc3RJbmRleCIsIl9wcml2YXRlX19sYXN0SW5kZXgiLCJfaW50ZXJuYWxfbG9naWNhbFJhbmdlRm9yVGltZVJhbmdlIiwibmV3V2lkdGgiLCJwcmV2aW91c1Zpc2libGVSYW5nZSIsIm9sZFdpZHRoIiwiX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkIiwibG9ja1Zpc2libGVUaW1lUmFuZ2VPblJlc2l6ZSIsIm5ld0JhclNwYWNpbmciLCJfcHJpdmF0ZV9fcmlnaHRPZmZzZXQiLCJfcHJpdmF0ZV9fY29ycmVjdEJhclNwYWNpbmciLCJfcHJpdmF0ZV9fY29ycmVjdE9mZnNldCIsImJhc2VJbmRleCIsIl9pbnRlcm5hbF9iYXNlSW5kZXgiLCJkZWx0YUZyb21SaWdodCIsIl9pbnRlcm5hbF9pbmRleGVzVG9Db29yZGluYXRlcyIsImluZGV4RnJvbSIsImluZGV4VG8iLCJfaW50ZXJuYWxfY29vcmRpbmF0ZVRvSW5kZXgiLCJjb25zaWRlcklnbm9yZVdoaXRlc3BhY2UiLCJfcHJpdmF0ZV9fY29vcmRpbmF0ZVRvRmxvYXRJbmRleCIsIl9wcml2YXRlX19zaG91bGRDb25zaWRlckluZGV4IiwiX3ByaXZhdGVfX2ZpbmROZWFyZXN0SW5kZXhXaXRoRGF0YSIsIl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzIiwiX2ludGVybmFsX2JhclNwYWNpbmciLCJfcHJpdmF0ZV9fc2V0QmFyU3BhY2luZyIsIl9pbnRlcm5hbF9yaWdodE9mZnNldCIsIl9wcml2YXRlX190aW1lTWFya3NDYWNoZSIsInBpeGVsc1BlcjhDaGFyYWN0ZXJzIiwicGl4ZWxzUGVyQ2hhcmFjdGVyIiwibWF4TGFiZWxXaWR0aCIsInRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoIiwiaW5kZXhQZXJMYWJlbCIsImZpcnN0QmFyIiwiaXRlbXMiLCJfcHJpdmF0ZV9fdGlja01hcmtzIiwiX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YSIsIl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGFVcGRhdGVJZCIsImVhcmxpZXN0SW5kZXhPZlNlY29uZExhYmVsIiwiaW5kZXhPZlNlY29uZExhc3RMYWJlbCIsImlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkIiwiX3ByaXZhdGVfX2lzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkIiwiaXNMZWZ0RWRnZUZpeGVkIiwiaXNSaWdodEVkZ2VGaXhlZCIsImxhYmVsIiwiX3ByaXZhdGVfX2xhYmVscyIsIl9wcml2YXRlX19mb3JtYXRMYWJlbCIsIm5lZWRBbGlnbkNvb3JkaW5hdGUiLCJfaW50ZXJuYWxfcmVzdG9yZURlZmF1bHQiLCJfaW50ZXJuYWxfc2V0QmFzZUluZGV4IiwiX2ludGVybmFsX3pvb20iLCJ6b29tUG9pbnQiLCJzY2FsZSIsImZsb2F0SW5kZXhBdFpvb21Qb2ludCIsInJpZ2h0QmFyU3RheXNPblNjcm9sbCIsIl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSIsIl9wcml2YXRlX19zYXZlQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlIiwic3RhcnRMZW5ndGhGcm9tUmlnaHQiLCJjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0IiwiX3ByaXZhdGVfX2NsZWFyQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlIiwic2hpZnRJbkxvZ2ljYWwiLCJfaW50ZXJuYWxfc2Nyb2xsVG9SZWFsVGltZSIsIl9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJSYW5nZUVycm9yIiwiYW5pbWF0aW9uU3RhcnQiLCJfaW50ZXJuYWxfZmluaXNoZWQiLCJfaW50ZXJuYWxfZ2V0UG9zaXRpb24iLCJhbmltYXRpb25Qcm9ncmVzcyIsImZpbmlzaEFuaW1hdGlvbiIsIl9pbnRlcm5hbF92aXNpYmxlQmFyc0NoYW5nZWQiLCJfcHJpdmF0ZV9fdmlzaWJsZUJhcnNDaGFuZ2VkIiwiX2ludGVybmFsX2xvZ2ljYWxSYW5nZUNoYW5nZWQiLCJfcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZCIsIl9pbnRlcm5hbF9vcHRpb25zQXBwbGllZCIsIl9pbnRlcm5hbF9zZXRWaXNpYmxlUmFuZ2UiLCJfaW50ZXJuYWxfZml0Q29udGVudCIsImxhc3QiLCJfaW50ZXJuYWxfc2V0TG9naWNhbFJhbmdlIiwiYmFyUmFuZ2UiLCJ0aW1lU2NhbGVQb2ludCIsInRpbWVGb3JtYXR0ZXIiLCJmb3JtYXRIb3J6SXRlbSIsImhhbmRsZVNjcm9sbCIsImhhbmRsZVNjYWxlIiwiaG9yelRvdWNoRHJhZyIsIm1vdXNlV2hlZWwiLCJwcmVzc2VkTW91c2VNb3ZlIiwidmVydFRvdWNoRHJhZyIsImF4aXNEb3VibGVDbGlja1Jlc2V0IiwiYXhpc1ByZXNzZWRNb3VzZU1vdmUiLCJwaW5jaCIsIl9wcml2YXRlX19yaWdodE9mZnNldEZvckNvb3JkaW5hdGUiLCJvbGRCYXJTcGFjaW5nIiwiX3ByaXZhdGVfX3Jlc2V0VGltZU1hcmtzQ2FjaGUiLCJfcHJpdmF0ZV9fc2V0VmlzaWJsZVJhbmdlIiwibmV3QmFyc0xlbmd0aCIsInJpZ2h0Qm9yZGVyIiwibGVmdEJvcmRlciIsIl9wcml2YXRlX19taW5CYXJTcGFjaW5nIiwiX3ByaXZhdGVfX21heEJhclNwYWNpbmciLCJtaW5SaWdodE9mZnNldCIsIl9wcml2YXRlX19taW5SaWdodE9mZnNldCIsIm1heFJpZ2h0T2Zmc2V0IiwiX3ByaXZhdGVfX21heFJpZ2h0T2Zmc2V0IiwiYmFyc0VzdGltYXRpb24iLCJfcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQiLCJfcHJpdmF0ZV9fZm9ybWF0TGFiZWxJbXBsIiwiZm9ybWF0VGlja21hcmsiLCJuZXdWaXNpYmxlUmFuZ2UiLCJvbGRWaXNpYmxlUmFuZ2UiLCJ1cGRhdGVGb3JtYXR0ZXIiLCJsZWZ0RWRnZU9mZnNldCIsImdlbiIsInRlc3ROZWFyZXN0SW50ZWdlcnMiLCJtYXhJbmRleCIsIm5leHQiLCJ1bmlmb3JtRGlzdHJpYnV0aW9uIiwibnVtIiwicm91bmRlZCIsImlzUm91bmRlZERvd24iLCJUcmFja2luZ01vZGVFeGl0TW9kZSIsImlzUGFuZVByaW1pdGl2ZSIsIkNoYXJ0TW9kZWwiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZSIsIl9wcml2YXRlX19pbnZhbGlkYXRpb25NYXNrRm9yU291cmNlIiwiX2ludGVybmFsX2hvdmVyZWRTb3VyY2UiLCJfcHJpdmF0ZV9faG92ZXJlZFNvdXJjZSIsIl9pbnRlcm5hbF9zZXRIb3ZlcmVkU291cmNlIiwicHJldlNvdXJjZSIsIl9wcml2YXRlX19wYW5lcyIsIl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkIiwiX3ByaXZhdGVfX2JhY2tncm91bmRUb3BDb2xvciIsIl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IiLCJfcHJpdmF0ZV9fYmFja2dyb3VuZEJvdHRvbUNvbG9yIiwiX2ludGVybmFsX2FwcGx5UHJpY2VTY2FsZU9wdGlvbnMiLCJfaW50ZXJuYWxfZmluZFByaWNlU2NhbGUiLCJfaW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlIiwiX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkIiwiX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkIiwiX2ludGVybmFsX3NldFBhbmVIZWlnaHQiLCJfaW50ZXJuYWxfcmVtb3ZlUGFuZSIsIl9pbnRlcm5hbF9jaGFuZ2VQYW5lc0hlaWdodCIsInRhcmdldFBhbmUiLCJ0b3RhbFN0cmV0Y2giLCJtYXhQYW5lSGVpZ2h0IiwicGl4ZWxTdHJldGNoRmFjdG9yIiwib2xkSGVpZ2h0Iiwib3RoZXJQYW5lc0NoYW5nZSIsInBhbmVzQ291bnQiLCJuZXdQYW5lSGVpZ2h0IiwibmV3U3RyZXRjaEZhY3RvciIsIl9pbnRlcm5hbF9zd2FwUGFuZXMiLCJmaXJzdFBhbmUiLCJzZWNvbmRQYW5lIiwiX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrIiwiX2ludGVybmFsX3N0YXJ0U2NhbGVUaW1lIiwiX2ludGVybmFsX3pvb21UaW1lIiwicG9pbnRYIiwiX2ludGVybmFsX3Njcm9sbENoYXJ0IiwiX2ludGVybmFsX3N0YXJ0U2Nyb2xsVGltZSIsIl9pbnRlcm5hbF9zY3JvbGxUaW1lVG8iLCJfaW50ZXJuYWxfZW5kU2Nyb2xsVGltZSIsIl9pbnRlcm5hbF9zY2FsZVRpbWVUbyIsIl9pbnRlcm5hbF9lbmRTY2FsZVRpbWUiLCJfcHJpdmF0ZV9fc2VyaWVzZXMiLCJfaW50ZXJuYWxfc2V0QW5kU2F2ZUN1cnJlbnRQb3NpdGlvbiIsImV2ZW50Iiwic2tpcEV2ZW50IiwiX3ByaXZhdGVfX21hZ25ldCIsIl9pbnRlcm5hbF9zZXRBbmRTYXZlU3ludGhldGljUG9zaXRpb24iLCJob3Jpem9udGFsUG9zaXRpb24iLCJfaW50ZXJuYWxfY2xlYXJDdXJyZW50UG9zaXRpb24iLCJfaW50ZXJuYWxfdXBkYXRlVGltZVNjYWxlIiwibmV3QmFzZUluZGV4Iiwib2xkRmlyc3RUaW1lIiwibmV3Rmlyc3RUaW1lIiwiY3VycmVudEJhc2VJbmRleCIsImlzTGFzdFNlcmllc0JhclZpc2libGUiLCJpc0xlZnRCYXJTaGlmdFRvTGVmdCIsImlzU2VyaWVzUG9pbnRzQWRkZWQiLCJpc1Nlcmllc1BvaW50c0FkZGVkVG9SaWdodCIsImFsbG93U2hpZnRXaGVuUmVwbGFjaW5nV2hpdGVzcGFjZSIsImFsbG93U2hpZnRWaXNpYmxlUmFuZ2VPbldoaXRlc3BhY2VSZXBsYWNlbWVudCIsInJlcGxhY2VkRXhpc3RpbmdXaGl0ZXNwYWNlIiwibmVlZFNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXIiLCJzaGlmdFZpc2libGVSYW5nZU9uTmV3QmFyIiwiY29tcGVuc2F0aW9uU2hpZnQiLCJmaW5kIiwiX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIiwiX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIiwiX2ludGVybmFsX2FkZFNlcmllc1RvUGFuZSIsIl9wcml2YXRlX19nZXRPckNyZWF0ZVBhbmUiLCJfcHJpdmF0ZV9fYWRkU2VyaWVzVG9QYW5lIiwiX2ludGVybmFsX3JlbW92ZVNlcmllcyIsInNlcmllc0luZGV4IiwicGFuZUltcGwiLCJfcHJpdmF0ZV9fY2xlYW51cElmUGFuZUlzRW1wdHkiLCJtYXNrIiwiX2ludGVybmFsX3NldFRhcmdldExvZ2ljYWxSYW5nZSIsIl9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGVJZCIsIl9pbnRlcm5hbF9tb3ZlU2VyaWVzVG9QYW5lIiwibmV3UGFuZUluZGV4IiwiZnJvbVBhbmVJbmRleCIsIl9wcml2YXRlX19zZXJpZXNQYW5lSW5kZXgiLCJwcmV2aW91c1BhbmUiLCJfaW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yIiwiX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUiLCJfaW50ZXJuYWxfY29sb3JzIiwiY2FjaGVkVmFsdWUiLCJfaW50ZXJuYWxfZ2V0UGFuZUluZGV4IiwiaW52YWxpZGF0ZVR5cGUiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIiLCJzaWRlIiwiaW52YWxpZGF0ZUhhbmRsZXIiLCJsYXlvdXQiLCJjb2xvclBhcnNlcnMiLCJmaWxsVXBEb3duQ2FuZGxlc3RpY2tzQ29sb3JzIiwid2lja0NvbG9yIiwiTGFzdFByaWNlQW5pbWF0aW9uTW9kZSIsInByZWNpc2lvbkJ5TWluTW92ZSIsImZyYWN0UGFydCIsIlByaWNlTGluZVNvdXJjZSIsIkNvbG9yVHlwZSIsImlzQnVzaW5lc3NEYXkiLCJpc1VUQ1RpbWVzdGFtcCIsIlRpY2tNYXJrVHlwZSIsImdldE1vbnRoIiwiZGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0RGF5IiwiZ2V0VVRDRGF0ZSIsImdldFllYXIiLCJnZXRVVENGdWxsWWVhciIsImRkIiwiTU1NTSIsImxvY2FsZSIsIkRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsIm1vbnRoIiwiTU1NIiwiTU0iLCJ5eSIsInl5eXkiLCJmb3JtYXREYXRlIiwiRGF0ZUZvcm1hdHRlciIsIl9wcml2YXRlX19kYXRlRm9ybWF0IiwiX3ByaXZhdGVfX2xvY2FsZSIsImRhdGVGb3JtYXQiLCJUaW1lRm9ybWF0dGVyIiwiX3ByaXZhdGVfX2Zvcm1hdFN0ciIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJkZWZhdWx0UGFyYW1zIiwiX2ludGVybmFsX2RhdGVGb3JtYXQiLCJfaW50ZXJuYWxfdGltZUZvcm1hdCIsIl9pbnRlcm5hbF9kYXRlVGltZVNlcGFyYXRvciIsIl9pbnRlcm5hbF9sb2NhbGUiLCJEYXRlVGltZUZvcm1hdHRlciIsImRhdGVUaW1lIiwiX3ByaXZhdGVfX2RhdGVGb3JtYXR0ZXIiLCJfcHJpdmF0ZV9fc2VwYXJhdG9yIiwiX3ByaXZhdGVfX3RpbWVGb3JtYXR0ZXIiLCJwYXJhbXMiLCJmb3JtYXR0ZXJQYXJhbXMiLCJkZWZhdWx0VGlja01hcmtGb3JtYXR0ZXIiLCJ0aW1lUG9pbnQiLCJ0aWNrTWFya1R5cGUiLCJmb3JtYXRPcHRpb25zIiwieWVhciIsImRheSIsImhvdXIxMiIsImhvdXIiLCJtaW51dGUiLCJfaW50ZXJuYWxfYnVzaW5lc3NEYXkiLCJfaW50ZXJuYWxfdGltZXN0YW1wIiwiVVRDIiwibG9jYWxEYXRlRnJvbVV0YyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJpbnRyYWRheVdlaWdodERpdmlzb3JzIiwiX2ludGVybmFsX2Rpdmlzb3IiLCJfaW50ZXJuYWxfd2VpZ2h0Iiwid2VpZ2h0QnlUaW1lIiwiY3VycmVudERhdGUiLCJwcmV2RGF0ZSIsImdldFRpbWUiLCJjYXN0IiwiZmlsbFdlaWdodHNGb3JQb2ludHMiLCJzb3J0ZWRUaW1lUG9pbnRzIiwicHJldlRpbWUiLCJ0b3RhbFRpbWVEaWZmIiwiY3VycmVudFBvaW50IiwiYXZlcmFnZVRpbWVEaWZmIiwiYXBwcm94UHJldkRhdGUiLCJidXNpbmVzc0RheUNvbnZlcnRlciIsImJ1c2luZXNzRGF5Iiwic3RyaW5nVG9CdXNpbmVzc0RheSIsInRpbWVzdGFtcENvbnZlcnRlciIsInNlbGVjdFRpbWVDb252ZXJ0ZXIiLCJ2YWxpZERhdGVSZWdleCIsImNvbnZlcnRUaW1lIiwidGVzdCIsImQiLCJjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheSIsImNvbnZlcnRTdHJpbmdzVG9CdXNpbmVzc0RheXMiLCJ3ZWlnaHRUb1RpY2tNYXJrVHlwZSIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJIb3J6U2NhbGVCZWhhdmlvclRpbWUiLCJzZXRPcHRpb25zIiwicHJlcHJvY2Vzc0RhdGEiLCJjcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqIiwiY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbCIsIl9wcml2YXRlX19kYXRlVGltZUZvcm1hdHRlciIsInRwIiwidGlja01hcmtGb3JtYXR0ZXIiLCJ0aWNrTWFya1N0cmluZyIsIm1heFRpY2tNYXJrV2VpZ2h0IiwidGlja01hcmtzIiwibWF4V2VpZ2h0IiwiX2ludGVybmFsX2FwcGx5RGVmYXVsdHMiLCJpc1J1bm5pbmdPbkNsaWVudFNpZGUiLCJpc0ZGIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJpc0lPUyIsInBsYXRmb3JtIiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJpc1dpbmRvd3MiLCJ1c2VyQWdlbnREYXRhIiwiaXNDaHJvbWl1bUJhc2VkIiwiYnJhbmRzIiwic29tZSIsImJyYW5kIiwid2FybiIsIm1zZyIsImNvbnNvbGUiLCJzdWdnZXN0Q2hhcnRTaXplIiwib3JpZ2luYWxTaXplIiwiaW50ZWdlcldpZHRoIiwiaW50ZWdlckhlaWdodCIsInN1Z2dlc3RUaW1lU2NhbGVIZWlnaHQiLCJvcmlnaW5hbEhlaWdodCIsInN1Z2dlc3RQcmljZVNjYWxlV2lkdGgiLCJvcmlnaW5hbFdpZHRoIiwicHJldmVudFNjcm9sbEJ5V2hlZWxDbGljayIsImVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1dHRvbiIsInByZXZlbnREZWZhdWx0IiwiTW91c2VFdmVudEhhbmRsZXIiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMiLCJfcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMiLCJfcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCIsIl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCIsIl9wcml2YXRlX19tb3VzZUVudGVySGFuZGxlciIsImVudGVyRXZlbnQiLCJib3VuZE1vdXNlTW92ZUhhbmRsZXIiLCJfcHJpdmF0ZV9fbW91c2VNb3ZlSGFuZGxlciIsIl9wcml2YXRlX190YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMiLCJjb21wYXRFdmVudCIsIl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQiLCJfcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQiLCJfcHJpdmF0ZV9faGFuZGxlciIsIl9pbnRlcm5hbF9tb3VzZUVudGVyRXZlbnQiLCJfcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSIsIl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCIsIl9wcml2YXRlX19jbGlja0NvdW50IiwiX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24iLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCIsIl9wcml2YXRlX190YXBUaW1lb3V0SWQiLCJfcHJpdmF0ZV9fdGFwQ291bnQiLCJfcHJpdmF0ZV9fdGFwUG9zaXRpb24iLCJtb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VQcmVzc2VkIiwiX3ByaXZhdGVfX3RvdWNoTW92ZVN0YXJ0UG9zaXRpb24iLCJfaW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fdG91Y2hNb3ZlSGFuZGxlciIsInRvdWNoIiwidG91Y2hXaXRoSWQiLCJjaGFuZ2VkVG91Y2hlcyIsIl9wcml2YXRlX19hY3RpdmVUb3VjaElkIiwiX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wIiwiZXZlbnRUaW1lU3RhbXAiLCJfcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50IiwiX3ByaXZhdGVfX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzIiwiX3ByaXZhdGVfX3BpbmNoUHJldmVudGVkIiwibW92ZUluZm8iLCJfcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8iLCJnZXRQb3NpdGlvbiIsIl9pbnRlcm5hbF94T2Zmc2V0IiwieE9mZnNldCIsIl9pbnRlcm5hbF95T2Zmc2V0IiwieU9mZnNldCIsIl9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZSIsIm1hbmhhdHRhbkRpc3RhbmNlIiwiX3ByaXZhdGVfX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UiLCJjb3JyZWN0ZWRYT2Zmc2V0IiwiaXNWZXJ0RHJhZyIsIl9pbnRlcm5hbF90cmVhdFZlcnRUb3VjaERyYWdBc1BhZ2VTY3JvbGwiLCJpc0hvcnpEcmFnIiwiX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbCIsIl9wcml2YXRlX19jYW5jZWxUYXAiLCJfcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQiLCJfaW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VNb3ZlV2l0aERvd25IYW5kbGVyIiwiX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24iLCJfcHJpdmF0ZV9fY2FuY2VsQ2xpY2siLCJfaW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50IiwiY3VycmVudFBvc2l0aW9uIiwic3RhcnRQb3NpdGlvbiIsIl9wcml2YXRlX190b3VjaEVuZEhhbmRsZXIiLCJ0b3VjaEVuZEV2ZW50IiwidG91Y2hlcyIsIl9pbnRlcm5hbF90b3VjaEVuZEV2ZW50IiwiX2ludGVybmFsX2RvdWJsZVRhcEV2ZW50IiwiX2ludGVybmFsX3RhcEV2ZW50IiwiX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUiLCJfcHJpdmF0ZV9fbW91c2VVcEhhbmRsZXIiLCJtb3VzZVVwRXZlbnQiLCJyb290RWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJfcHJpdmF0ZV9fb25GaXJlZm94T3V0c2lkZU1vdXNlVXAiLCJfaW50ZXJuYWxfbW91c2VVcEV2ZW50IiwiX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudCIsIl9pbnRlcm5hbF9tb3VzZUNsaWNrRXZlbnQiLCJfcHJpdmF0ZV9fbG9uZ1RhcFRpbWVvdXRJZCIsIl9wcml2YXRlX190b3VjaFN0YXJ0SGFuZGxlciIsImRvd25FdmVudCIsImlkZW50aWZpZXIiLCJib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlciIsImJvdW5kVG91Y2hFbmRIYW5kbGVyIiwicGFzc2l2ZSIsIl9wcml2YXRlX19sb25nVGFwSGFuZGxlciIsIl9pbnRlcm5hbF90b3VjaFN0YXJ0RXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VEb3duSGFuZGxlciIsImJvdW5kTW91c2VNb3ZlV2l0aERvd25IYW5kbGVyIiwiYm91bmRNb3VzZVVwSGFuZGxlciIsIl9pbnRlcm5hbF9tb3VzZURvd25FdmVudCIsIl9wcml2YXRlX19pbml0IiwiZG9jIiwib3V0c2lkZUhhbmRsZXIiLCJfaW50ZXJuYWxfbW91c2VEb3duT3V0c2lkZUV2ZW50IiwiY29tcG9zZWQiLCJjb250YWlucyIsImNvbXBvc2VkUGF0aCIsIl9wcml2YXRlX19vbk1vYmlsZVNhZmFyaURvdWJsZUNsaWNrIiwiX3ByaXZhdGVfX21vdXNlTGVhdmVIYW5kbGVyIiwiX3ByaXZhdGVfX2luaXRQaW5jaCIsIl9pbnRlcm5hbF9waW5jaFN0YXJ0RXZlbnQiLCJfaW50ZXJuYWxfcGluY2hFdmVudCIsIl9pbnRlcm5hbF9waW5jaEVuZEV2ZW50IiwiX3ByaXZhdGVfX2NoZWNrUGluY2hTdGF0ZSIsImN1cnJlbnREaXN0YW5jZSIsImdldERpc3RhbmNlIiwiX3ByaXZhdGVfX3N0YXJ0UGluY2hEaXN0YW5jZSIsIl9wcml2YXRlX19zdG9wUGluY2giLCJfcHJpdmF0ZV9fc3RhcnRQaW5jaCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwiX2ludGVybmFsX21vdXNlTGVhdmVFdmVudCIsIl9pbnRlcm5hbF9sb25nVGFwRXZlbnQiLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwiZXZlbnRMaWtlIiwicGFnZVgiLCJwYWdlWSIsInNjcmVlblgiLCJzY3JlZW5ZIiwibG9jYWxYIiwibG9jYWxZIiwiY3RybEtleSIsImFsdEtleSIsInNoaWZ0S2V5IiwibWV0YUtleSIsIl9pbnRlcm5hbF9pc1RvdWNoIiwic3RhcnRzV2l0aCIsIl9pbnRlcm5hbF9zcmNUeXBlIiwiX2ludGVybmFsX3RhcmdldCIsIl9pbnRlcm5hbF9wcmV2ZW50RGVmYXVsdCIsImhhbmRsZXIiLCJkYmxDbGlja0V2ZW50IiwicDIiLCJ4RGlmZiIsInlEaWZmIiwic3FydCIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJQYW5lU2VwYXJhdG9yIiwiX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyIiwiX2ludGVybmFsX2dldEVsZW1lbnQiLCJfcHJpdmF0ZV9fcm93RWxlbWVudCIsIl9pbnRlcm5hbF9nZXRTaXplIiwiX3ByaXZhdGVfX3RvcFBhbmUiLCJfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSIsImRldmljZVBpeGVsUmF0aW8iLCJfaW50ZXJuYWxfZHJhd0JpdG1hcCIsIl9wcml2YXRlX19jaGFydFdpZGdldCIsInBhbmVzIiwic2VwYXJhdG9yQ29sb3IiLCJfcHJpdmF0ZV9fdXBkYXRlQm9yZGVyQ29sb3IiLCJlbmFibGVSZXNpemUiLCJfcHJpdmF0ZV9fcmVzaXplRW5hYmxlZCIsIl9wcml2YXRlX19hZGRSZXNpemFibGVIYW5kbGUiLCJfcHJpdmF0ZV9faGFuZGxlIiwiX3ByaXZhdGVfX2NlbGwiLCJfaW50ZXJuYWxfYmFja2dyb3VuZEVsZW1lbnQiLCJfaW50ZXJuYWxfZWxlbWVudCIsImJhY2tncm91bmRFbGVtZW50IiwiYmdTdHlsZSIsInpJbmRleCIsImN1cnNvciIsImhhbmRsZXJzIiwiX3ByaXZhdGVfX21vdXNlT3ZlckV2ZW50IiwiX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudCIsIl9wcml2YXRlX19tb3VzZURvd25FdmVudCIsIl9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VVcEV2ZW50Iiwic2VwYXJhdG9ySG92ZXJDb2xvciIsIl9wcml2YXRlX19yZXNpemVJbmZvIiwiX2ludGVybmFsX3N0YXRlIiwiX3ByaXZhdGVfX2JvdHRvbVBhbmUiLCJtaW5QYW5lU3RyZXRjaCIsIl9pbnRlcm5hbF9zdGFydFkiLCJfaW50ZXJuYWxfcHJldlN0cmV0Y2hUb3BQYW5lIiwiX2ludGVybmFsX21heFBhbmVTdHJldGNoIiwiX2ludGVybmFsX3RvdGFsU3RyZXRjaCIsIl9pbnRlcm5hbF9waXhlbFN0cmV0Y2hGYWN0b3IiLCJfaW50ZXJuYWxfbWluUGFuZVN0cmV0Y2giLCJyZXNpemVJbmZvIiwiZGVsdGFZIiwiZGVsdGFTdHJldGNoRmFjdG9yIiwidXBwZXJQYW5lTmV3U3RyZXRjaCIsImNoYXJ0V2lkZ2V0IiwidG9wUGFuZUluZGV4IiwiYm90dG9tUGFuZUluZGV4IiwiX2ludGVybmFsX3BhbmVXaWRnZXRzIiwibWFyZ2luIiwic2V0QXR0cmlidXRlIiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwicG9zMSIsInBvczIiLCJfaW50ZXJuYWxfcG9zaXRpb24iLCJzcGVlZFB4UGVyTVNlYyIsIm1heFNwZWVkIiwic3BlZWQiLCJkdXJhdGlvbk1TZWMiLCJkdW1waW5nQ29lZmYiLCJsbkR1bXBpbmdDb2VmZiIsImxvZyIsIktpbmV0aWNBbmltYXRpb24iLCJfaW50ZXJuYWxfYWRkUG9zaXRpb24iLCJfcHJpdmF0ZV9fcG9zaXRpb24xIiwiX3ByaXZhdGVfX3Bvc2l0aW9uNCIsIl9wcml2YXRlX19wb3NpdGlvbjMiLCJfcHJpdmF0ZV9fcG9zaXRpb24yIiwidG90YWxEaXN0YW5jZSIsInNwZWVkMSIsIl9wcml2YXRlX19tYXhTcGVlZCIsImRpc3RhbmNlMSIsInNwZWVkSXRlbXMiLCJkaXN0YW5jZUl0ZW1zIiwic3BlZWQyIiwiZGlzdGFuY2UyIiwic3BlZWQzIiwiZGlzdGFuY2UzIiwicmVzdWx0U3BlZWQiLCJfcHJpdmF0ZV9fbWluU3BlZWQiLCJfcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbiIsIl9wcml2YXRlX19zcGVlZFB4UGVyTXNlYyIsIl9wcml2YXRlX19kdXJhdGlvbk1zZWNzIiwiX3ByaXZhdGVfX2R1bXBpbmdDb2VmZiIsImR1cmF0aW9uTXNlY3MiLCJfcHJpdmF0ZV9fcHJvZ3Jlc3NEdXJhdGlvbiIsInByb2dyZXNzIiwibWluU3BlZWQiLCJzdmciLCJjc3MiLCJBdHRyaWJ1dGlvbkxvZ29XaWRnZXQiLCJfcHJpdmF0ZV9fcmVuZGVyIiwiX2ludGVybmFsX3JlbW92ZUVsZW1lbnQiLCJfcHJpdmF0ZV9fZWxlbWVudCIsIl9wcml2YXRlX19jb250YWluZXIiLCJfcHJpdmF0ZV9fY3NzRWxlbWVudCIsIl9wcml2YXRlX19zaG91bGRVcGRhdGUiLCJfcHJpdmF0ZV9fc2hvdWxkQmVWaXNpYmxlIiwiX3ByaXZhdGVfX3RoZW1lIiwiX3ByaXZhdGVfX3RoZW1lVG9Vc2UiLCJfcHJpdmF0ZV9fY2hhcnQiLCJhdHRyaWJ1dGlvbkxvZ28iLCJfcHJpdmF0ZV9fZ2V0VVRNU291cmNlIiwidXJsIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsImlubmVyVGV4dCIsImlubmVySFRNTCIsInRvZ2dsZUF0dHJpYnV0ZSIsImNvbnRhaW5lciIsImNoYXJ0IiwiY3JlYXRlQm91bmRDYW52YXMiLCJwYXJlbnRFbGVtZW50IiwiY2FudmFzIiwiYmluZGluZyIsImFsbG93UmVzaXplT2JzZXJ2ZXIiLCJ0cmFuc2Zvcm0iLCJjYW52YXNFbGVtZW50Q2xpZW50U2l6ZSIsInJlc2l6ZUNhbnZhc0VsZW1lbnQiLCJyZWxlYXNlQ2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdGb3JlZ3JvdW5kIiwiZHJhd1NvdXJjZVZpZXdzIiwicGFuZVZpZXdzR2V0dGVyIiwiZHJhd1JlbmRlcmVyRm4iLCJoYXNQcmljZVNjYWxlIiwiYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlciIsInBzSWQiLCJyZWNhbGN1bGF0ZU92ZXJsYXBwaW5nIiwiZGlyZWN0aW9uIiwiY3VycmVudEdyb3VwU3RhcnQiLCJpbml0TGFiZWxIZWlnaHQiLCJzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCIsInByZXYiLCJwcmV2Rml4ZWRDb29yZGluYXRlIiwib3ZlcmxhcCIsImVkZ2VQb2ludCIsIm91dE9mVmlld3BvcnQiLCJkZXNpcmVkR3JvdXBTaGlmdCIsInBvc3NpYmxlU2hpZnQiLCJrIiwicHJpY2VTY2FsZUNyb3NzaGFpckxhYmVsVmlzaWJsZSIsIlByaWNlQXhpc1dpZGdldCIsIl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nIiwidW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCIsIl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIiLCJjYW52YXNFbGVtZW50IiwiZGlzcG9zZSIsIl9wcml2YXRlX19jYW52YXNCaW5kaW5nIiwiX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciIsIl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMiLCJpc0ZvbnRDaGFuZ2VkIiwiX3ByaXZhdGVfX2ZvbnQiLCJfcHJpdmF0ZV9fd2lkdGhDYWNoZSIsIl9pbnRlcm5hbF9vcHRpbWFsV2lkdGgiLCJ0aWNrTWFya01heFdpZHRoIiwiY29sb3JTcGFjZSIsIl9pbnRlcm5hbF9jaGFydCIsIl9wcml2YXRlX19iYXNlRm9udCIsIl9wcml2YXRlX19iYWNrTGFiZWxzIiwiaiIsIl9wcml2YXRlX19zaXplIiwidG9wVmFsdWUiLCJib3R0b21WYWx1ZSIsInJlc3VsdFRpY2tNYXJrc01heFdpZHRoIiwiX2ludGVybmFsX3NldFNpemUiLCJuZXdTaXplIiwiX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUiLCJfaW50ZXJuYWxfZ2V0V2lkdGgiLCJfaW50ZXJuYWxfcGFpbnQiLCJjYW52YXNPcHRpb25zIiwiX3ByaXZhdGVfX2FsaWduTGFiZWxzIiwiYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplIiwiX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kIiwiX3ByaXZhdGVfX2RyYXdCb3JkZXIiLCJfaW50ZXJuYWxfZHJhd0FkZGl0aW9uYWxTb3VyY2VzIiwiX3ByaXZhdGVfX3NvdXJjZUJvdHRvbVBhbmVWaWV3cyIsIl9wcml2YXRlX19kcmF3VGlja01hcmtzIiwiX3ByaXZhdGVfX3NvdXJjZVBhbmVWaWV3cyIsIl9wcml2YXRlX19kcmF3QmFja0xhYmVscyIsInRvcFRhcmdldCIsIl9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyTGFiZWwiLCJfcHJpdmF0ZV9fc291cmNlVG9wUGFuZVZpZXdzIiwiZHJhd0ltYWdlIiwiX3ByaXZhdGVfX21vdXNlZG93biIsIl9wcml2YXRlX19tb3VzZURvd25PdXRzaWRlRXZlbnQiLCJfcHJpdmF0ZV9fbW91c2VEb3VibGVDbGlja0V2ZW50IiwiX3ByaXZhdGVfX21vdXNlRW50ZXJFdmVudCIsIl9wcml2YXRlX19zZXRDdXJzb3IiLCJhZGRWaWV3c0ZvclNvdXJjZXMiLCJib3JkZXJWaXNpYmxlIiwiYm9yZGVyU2l6ZSIsIl9wcml2YXRlX19pc0xlZnQiLCJwcmljZVNjYWxlT3B0aW9ucyIsInRpY2tNYXJrTGVmdFgiLCJ0aWNrSGVpZ2h0IiwidGlja0xlbmd0aCIsInJlY3QiLCJ0ZXh0TGVmdFgiLCJ5TWlkQ29ycmVjdGlvbnMiLCJvcmRlcmVkU291cmNlcyIsInBhbmVTdGF0ZSIsImlzRGVmYXVsdCIsImNlbnRlclNvdXJjZSIsInVwZGF0ZUZvclNvdXJjZXMiLCJzb3VyY2VWaWV3cyIsImFsaWduTGFiZWxzIiwiX3ByaXZhdGVfX2ZpeExhYmVsT3ZlcmxhcCIsImwiLCJoYWxmSGVpZ2h0Iiwicm8iLCJfcHJpdmF0ZV9fcHJldk9wdGltYWxXaWR0aCIsInJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyIiwib3ZlcmZsb3ciLCJzdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCIsInRvcENhbnZhcyIsInNvdXJjZUJvdHRvbVBhbmVWaWV3cyQxIiwic291cmNlUGFuZVZpZXdzJDEiLCJzb3VyY2VMYWJlbFBhbmVWaWV3cyIsInNvdXJjZVRvcFBhbmVWaWV3cyQxIiwiUGFuZVdpZGdldCIsIl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0IiwiX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0IiwiX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCIsIl9wcml2YXRlX19zdGF0ZSIsIl9pbnRlcm5hbF9zZXRTdGF0ZSIsIl9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkIiwiX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMiLCJfcHJpdmF0ZV9fcGFuZUNlbGwiLCJfcHJpdmF0ZV9fcmVjcmVhdGVQcmljZUF4aXNXaWRnZXRzIiwiX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHMiLCJzdHJldGNoRmFjdG9yIiwiX3ByaXZhdGVfX29uTW91c2VFdmVudCIsIl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbiIsIl9wcml2YXRlX19tb3VzZVRvdWNoRG93bkV2ZW50IiwiX3ByaXZhdGVfX2ZpcmVDbGlja2VkRGVsZWdhdGUiLCJfcHJpdmF0ZV9fZmlyZU1vdXNlQ2xpY2tEZWxlZ2F0ZSIsIl9wcml2YXRlX19kYmxDbGlja2VkIiwiX3ByaXZhdGVfX3ByZXNzZWRNb3VzZVRvdWNoTW92ZUV2ZW50IiwiX3ByaXZhdGVfX2xvbmdUYXAiLCJfcHJpdmF0ZV9fZW5kU2Nyb2xsIiwiX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCIsIl9wcml2YXRlX19zdGFydFRyYWNraW5nTW9kZSIsIl9wcml2YXRlX19jbGVhckNyb3NzaGFpclBvc2l0aW9uIiwiX2ludGVybmFsX2NsaWNrZWQiLCJfcHJpdmF0ZV9fY2xpY2tlZCIsIl9pbnRlcm5hbF9kYmxDbGlja2VkIiwiX3ByaXZhdGVfX3ByZXZQaW5jaFNjYWxlIiwibWlkZGxlUG9pbnQiLCJ6b29tU2NhbGUiLCJfcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSIsIl9wcml2YXRlX19pbml0Q3Jvc3NoYWlyUG9zaXRpb24iLCJvcmlnUG9pbnQiLCJuZXdYIiwibmV3WSIsInRyYWNraW5nTW9kZSIsImV4aXRNb2RlIiwiX3ByaXZhdGVfX3RyeUV4aXRUcmFja2luZ01vZGUiLCJzdGF0ZSIsIl9pbnRlcm5hbF9zZXRQcmljZUF4aXNTaXplIiwicHJpY2VBeGlzV2lkZ2V0IiwiX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZXMiLCJfcHJpdmF0ZV9fZHJhd1NvdXJjZXMiLCJfcHJpdmF0ZV9fZHJhd0dyaWQiLCJfcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpciIsIl9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0IiwiX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0IiwiZGVsZWdhdGUiLCJfcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwiLCJwYW5lUHJpbWl0aXZlcyIsInBhbmVQcmltaXRpdmUiLCJkcmF3Rm4iLCJob3ZlcmVkU291cmNlIiwib2JqZWNJZCIsImxlZnRBeGlzVmlzaWJsZSIsInJpZ2h0QXhpc1Zpc2libGUiLCJfcHJpdmF0ZV9fbGVmdEF4aXNDZWxsIiwiX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwiLCJfcHJpdmF0ZV9fcHJldmVudFNjcm9sbCIsIl9wcml2YXRlX19jb3JyZWN0WENvb3JkIiwiX3ByaXZhdGVfX2NvcnJlY3RZQ29vcmQiLCJzdGFydFRyYWNrUG9pbnQiLCJjcm9zc0hhaXJQb3NpdGlvbiIsIl9wcml2YXRlX19pc1Njcm9sbGluZyIsIl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyIsIl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uIiwic3RhcnRBbmltYXRpb25UaW1lIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJjaGFydE9wdGlvbnMiLCJzY3JvbGxPcHRpb25zIiwia2luZXRpY1Njcm9sbE9wdGlvbnMiLCJraW5ldGljU2Nyb2xsIiwiX2ludGVybmFsX2xvY2FsWCIsIl9pbnRlcm5hbF9sb2NhbFkiLCJtb3VzZSIsInBhbmVXcmFwcGVyIiwiUHJpY2VBeGlzU3R1YiIsIl9wcml2YXRlX19ib3JkZXJWaXNpYmxlIiwiaG9yekJvcmRlclNpemUiLCJ2ZXJ0Qm9yZGVyU2l6ZSIsIl9wcml2YXRlX19ib3R0b21Db2xvciIsImJ1aWxkVGltZUF4aXNWaWV3c0dldHRlciIsInNvdXJjZVBhbmVWaWV3cyIsInNvdXJjZVRvcFBhbmVWaWV3cyIsInNvdXJjZUJvdHRvbVBhbmVWaWV3cyIsIlRpbWVBeGlzV2lkZ2V0IiwiX3ByaXZhdGVfX2xlZnRTdHViIiwiX3ByaXZhdGVfX3JpZ2h0U3R1YiIsIl9pbnRlcm5hbF9sZWZ0U3R1YiIsIl9pbnRlcm5hbF9yaWdodFN0dWIiLCJfcHJpdmF0ZV9fbW91c2VEb3duIiwiX2ludGVybmFsX3NpemVDaGFuZ2VkIiwiX3ByaXZhdGVfX3NpemVDaGFuZ2VkIiwiX2ludGVybmFsX3NldFNpemVzIiwidGltZUF4aXNTaXplIiwibGVmdFN0dWJXaWR0aCIsInJpZ2h0U3R1YldpZHRoIiwiX2ludGVybmFsX29wdGltYWxIZWlnaHQiLCJfcHJpdmF0ZV9fZ2V0UmVuZGVyZXJPcHRpb25zIiwiX2ludGVybmFsX2xhYmVsQm90dG9tT2Zmc2V0IiwiX3ByaXZhdGVfX2RyYXdBZGRpdGlvbmFsU291cmNlcyIsIl9wcml2YXRlX19kcmF3TGFiZWxzIiwiYXhpc1ZpZXdzR2V0dGVyIiwiX3ByaXZhdGVfX2xpbmVDb2xvciIsInRpY2tMZW4iLCJfcHJpdmF0ZV9fYWxpZ25UaWNrTWFya0xhYmVsQ29vcmRpbmF0ZSIsImFsbG93Qm9sZExhYmVscyIsIl9wcml2YXRlX19iYXNlQm9sZEZvbnQiLCJsYWJlbFRleHQiLCJsZWZ0VGV4dENvb3JkaW5hdGUiLCJuZXdGb250IiwiX3ByaXZhdGVfX3JlY3JlYXRlU3R1YnMiLCJfcHJpdmF0ZV9fbGVmdFN0dWJDZWxsIiwiX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwiLCJib3JkZXJWaXNpYmxlR2V0dGVyIiwiYm90dG9tQ29sb3JHZXR0ZXIiLCJfcHJpdmF0ZV9fZHYiLCJ3aW5kb3dzQ2hyb21lIiwiQ2hhcnRXaWRnZXQiLCJfcHJpdmF0ZV9fcGFuZVdpZGdldHMiLCJfaW50ZXJuYWxfdGltZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQiLCJfcHJpdmF0ZV9fc2V0TW91c2VXaGVlbEV2ZW50TGlzdGVuZXIiLCJfcHJpdmF0ZV9fZHJhd1JhZklkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJwYW5lV2lkZ2V0IiwiX3ByaXZhdGVfX3RhYmxlRWxlbWVudCIsInBhbmVTZXBhcmF0b3IiLCJfcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMiLCJfcHJpdmF0ZV9fZGVzdHJveVNlcGFyYXRvciIsIl9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlciIsIl9pbnRlcm5hbF9yZXNpemUiLCJmb3JjZVJlcGFpbnQiLCJzaXplSGludCIsImhlaWdodFN0ciIsIndpZHRoU3RyIiwiX3ByaXZhdGVfX2RyYXdJbXBsIiwiaW52YWxpZGF0ZU1hc2siLCJjdXJyZW50bHlIYXNNb3VzZVdoZWVsTGlzdGVuZXIiLCJzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsIiwic2hvdWxkSGF2ZU1vdXNlV2hlZWxMaXN0ZW5lciIsIl9wcml2YXRlX19hcHBseVBhbmVzT3B0aW9ucyIsIl9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkiLCJfcHJpdmF0ZV9fYXBwbHlBdXRvU2l6ZU9wdGlvbnMiLCJfaW50ZXJuYWxfdGFrZVNjcmVlbnNob3QiLCJfcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2siLCJzY3JlZXNob3RCaXRtYXBTaXplIiwiX3ByaXZhdGVfX3RyYXZlcnNlTGF5b3V0Iiwic2NyZWVuc2hvdENhbnZhcyIsIl9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aCIsIl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSIsIl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUiLCJfaW50ZXJuYWxfYXV0b1NpemVBY3RpdmUiLCJhdXRvU2l6ZSIsIl9wcml2YXRlX19vYnNlcnZlciIsIl9pbnRlcm5hbF9zZXRDdXJzb3JTdHlsZSIsIl9wcml2YXRlX19jdXJzb3JTdHlsZU92ZXJyaWRlIiwic2V0UHJvcGVydHkiLCJyZW1vdmVQcm9wZXJ0eSIsIl9pbnRlcm5hbF9nZXRDdXJzb3JPdmVycmlkZVN0eWxlIiwiX2ludGVybmFsX3BhbmVTaXplIiwic2VwYXJhdG9yIiwiX3ByaXZhdGVfX2luc3RhbGxPYnNlcnZlciIsImRyYXdQcmljZUF4aXNlcyIsInRhcmdldFgiLCJ0YXJnZXRZIiwic2VwYXJhdG9yQml0bWFwU2l6ZSIsImxlZnRBeGlzQml0bWFwV2lkdGgiLCJmaXJzdFBhbmVCaXRtYXBXaWR0aCIsInJpZ2h0QXhpc0JpdG1hcFdpZHRoIiwiZHJhd1N0dWIiLCJzdHViIiwidGltZUF4aXNCaXRtYXBTaXplIiwiX3ByaXZhdGVfX2FkanVzdFNpemVJbXBsIiwibGVmdFByaWNlQXhpc1dpZHRoIiwicmlnaHRQcmljZUF4aXNXaWR0aCIsIm1pbmltdW1XaWR0aCIsInBhbmVXaWR0aCIsInNlcGFyYXRvckNvdW50Iiwic2VwYXJhdG9ySGVpZ2h0Iiwic2VwYXJhdG9yc0hlaWdodCIsInRpbWVBeGlzVmlzaWJsZSIsInRpbWVBeGlzSGVpZ2h0IiwibWluaW11bUhlaWdodCIsIm90aGVyV2lkZ2V0SGVpZ2h0IiwidG90YWxQYW5lSGVpZ2h0Iiwic3RyZXRjaFBpeGVscyIsImFjY3VtdWxhdGVkSGVpZ2h0IiwicGl4ZWxSYXRpbyIsInBhbmVIZWlnaHQiLCJjYWxjdWxhdGVQYW5lSGVpZ2h0IiwiX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWR0aCIsIl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZHRoIiwiYWRkIiwiX3ByaXZhdGVfX29uV2hlZWxCb3VuZCIsIl9wcml2YXRlX19kZXRlcm1pbmVXaGVlbFNwZWVkQWRqdXN0bWVudCIsImRlbHRhTW9kZSIsIkRPTV9ERUxUQV9QQUdFIiwiRE9NX0RFTFRBX0xJTkUiLCJfcHJpdmF0ZV9fb25Nb3VzZXdoZWVsIiwiZGVsdGFYIiwic2Nyb2xsU3BlZWRBZGp1c3RtZW50Iiwic2Nyb2xsUG9zaXRpb24iLCJpbnZhbGlkYXRpb25UeXBlIiwiX3ByaXZhdGVfX3VwZGF0ZUd1aSIsIl9wcml2YXRlX19hcHBseU1vbWVudGFyeUF1dG9TY2FsZSIsIl9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbnMiLCJfcHJpdmF0ZV9fZHJhd1BsYW5uZWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfcHJpdmF0ZV9fc3luY0d1aVdpdGhNb2RlbCIsInRhcmdldFBhbmVXaWRnZXRzQ291bnQiLCJhY3R1YWxQYW5lV2lkZ2V0c0NvdW50IiwiX3ByaXZhdGVfX29uUGFuZVdpZGdldENsaWNrZWQiLCJfcHJpdmF0ZV9fb25QYW5lV2lkZ2V0RGJsQ2xpY2tlZCIsImluc2VydEJlZm9yZSIsIl9wcml2YXRlX19nZXRNb3VzZUV2ZW50UGFyYW1zSW1wbCIsImNsaWVudFRpbWUiLCJob3ZlcmVkU2VyaWVzIiwiaG92ZXJlZE9iamVjdCIsIl9wcml2YXRlX19nZXRQYW5lSW5kZXgiLCJfaW50ZXJuYWxfb3JpZ2luYWxUaW1lIiwiX2ludGVybmFsX3BvaW50IiwiX2ludGVybmFsX3BhbmVJbmRleCIsIl9pbnRlcm5hbF9ob3ZlcmVkU2VyaWVzIiwiX2ludGVybmFsX3Nlcmllc0RhdGEiLCJfaW50ZXJuYWxfaG92ZXJlZE9iamVjdCIsIl9pbnRlcm5hbF90b3VjaE1vdXNlRXZlbnREYXRhIiwiY3Jvc3NoYWlyUGFuZSIsIl9wcml2YXRlX19vblBhbmVXaWRnZXRDcm9zc2hhaXJNb3ZlZCIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsImNvbnRhaW5lckVudHJ5IiwiY29udGVudFJlY3QiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsImNsYXNzTGlzdCIsImRpc2FibGVTZWxlY3Rpb24iLCJ1c2VkT2JzZXJ2ZXIiLCJjb250YWluZXJSZWN0IiwidXNlclNlbGVjdCIsIndlYmtpdFVzZXJTZWxlY3QiLCJtc1VzZXJTZWxlY3QiLCJNb3pVc2VyU2VsZWN0Iiwid2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IiLCJCb29sZWFuIiwiaXNXaGl0ZXNwYWNlRGF0YSIsIm9wZW4iLCJpc0Z1bGZpbGxlZERhdGEiLCJpc0Z1bGZpbGxlZEJhckRhdGEiLCJpc0Z1bGZpbGxlZExpbmVEYXRhIiwiZ2V0Q29sb3JlZExpbmVCYXNlZFNlcmllc1Bsb3RSb3ciLCJnZXRBcmVhU2VyaWVzUGxvdFJvdyIsImdldEJhc2VsaW5lU2VyaWVzUGxvdFJvdyIsImdldEJhclNlcmllc1Bsb3RSb3ciLCJjbG9zZSIsImdldENhbmRsZXN0aWNrU2VyaWVzUGxvdFJvdyIsImdldEN1c3RvbVNlcmllc1Bsb3RSb3ciLCJkYXRhVG9QbG90Um93IiwiZXhjbHVkZWRUaW1lIiwiaXNTZXJpZXNQbG90Um93Iiwicm93Iiwid3JhcEN1c3RvbVZhbHVlcyIsImN1c3RvbVZhbHVlcyIsIl9pbnRlcm5hbF9jdXN0b21WYWx1ZXMiLCJpc1doaXRlc3BhY2VEYXRhV2l0aEN1c3RvbUNoZWNrIiwiY3VzdG9tSXNXaGl0ZXNwYWNlIiwid3JhcFdoaXRlc3BhY2VEYXRhIiwiY3JlYXRlUGxvdFJvd0ZuIiwiZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3IiLCJzZXJpZXNQbG90Um93Rm5NYXAiLCJjcmVhdGVFbXB0eVRpbWVQb2ludERhdGEiLCJfaW50ZXJuYWxfbWFwcGluZyIsInNlcmllc1Jvd3NGaXJzdEFuZExhc3RUaW1lIiwic2VyaWVzUm93cyIsIl9pbnRlcm5hbF9maXJzdFRpbWUiLCJfaW50ZXJuYWxfbGFzdFRpbWUiLCJzZXJpZXNVcGRhdGVJbmZvIiwicHJldlNlcmllc1Jvd3MiLCJmaXJzdEFuZExhc3RUaW1lIiwicHJldkZpcnN0QW5kTGFzdFRpbWUiLCJfaW50ZXJuYWxfaGlzdG9yaWNhbFVwZGF0ZSIsInRpbWVTY2FsZVBvaW50VGltZSIsIm1lcmdlZFBvaW50RGF0YSIsInNhdmVPcmlnaW5hbFRpbWUiLCJEYXRhTGF5ZXIiLCJfcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQiLCJfcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzIiwiX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQiLCJfcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cyIsIl9pbnRlcm5hbF9zZXRTZXJpZXNEYXRhIiwibmVlZENsZWFudXBQb2ludHMiLCJpc1RpbWVTY2FsZUFmZmVjdGVkIiwicG9pbnREYXRhIiwib3JpZ2luYWxUaW1lcyIsInRpbWVDb252ZXJ0ZXIiLCJjcmVhdGVQbG90Um93IiwiY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIiLCJob3J6SXRlbUtleSIsInRpbWVQb2ludERhdGEiLCJfcHJpdmF0ZV9fY2xlYW51cFBvaW50c0RhdGEiLCJfcHJpdmF0ZV9fc2V0Um93c1RvU2VyaWVzIiwibmV3VGltZVNjYWxlUG9pbnRzIiwidDEiLCJ0MiIsIl9wcml2YXRlX19yZXBsYWNlVGltZVNjYWxlUG9pbnRzIiwiX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlIiwiX2ludGVybmFsX3VwZGF0ZVNlcmllc0RhdGEiLCJoaXN0b3JpY2FsVXBkYXRlIiwiZXh0ZW5kZWREYXRhIiwibGFzdFNlcmllc1RpbWUiLCJwb2ludERhdGFBdFRpbWUiLCJhZmZlY3RzVGltZVNjYWxlIiwiX3ByaXZhdGVfX3VwZGF0ZUhpc3RvcmljYWxTZXJpZXNSb3ciLCJfcHJpdmF0ZV9fdXBkYXRlTGFzdFNlcmllc1JvdyIsImluZm8iLCJuZXdQb2ludCIsImluc2VydEluZGV4IiwiYXNzaWduSW5kZXhUb1BvaW50RGF0YSIsImxhc3RTZXJpZXNSb3ciLCJwb2ludERhdGFJbmRleCIsIm5ld1RpbWVQb2ludHMiLCJvbGRQb2ludCIsIl9wcml2YXRlX19nZXRCYXNlSW5kZXgiLCJ1cGRhdGVkU2VyaWVzIiwiZGF0YVVwZGF0ZVJlc3BvbnNlIiwiX2ludGVybmFsX2luZm8iLCJfaW50ZXJuYWxfcG9pbnRzIiwiX2ludGVybmFsX2ZpcnN0Q2hhbmdlZFBvaW50SW5kZXgiLCJzZXJpZXNSb3ciLCJsb3dlckJvdW5kSXRlbXNDb21wYXJlIiwidXBwZXJCb3VuZEl0ZW1zQ29tcGFyZSIsInZpc2libGVUaW1lZFZhbHVlcyIsImV4dGVuZGVkUmFuZ2UiLCJleHRlbmRlZEZyb20iLCJleHRlbmRlZFRvIiwiU2VyaWVzUGFuZVZpZXdCYXNlIiwiX2ludGVybmFsX19pbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF9fZGF0YUludmFsaWRhdGVkIiwiX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQiLCJfcHJpdmF0ZV9fbWFrZVZhbGlkIiwiX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSIsIl9pbnRlcm5hbF9fcmVuZGVyZXIiLCJfaW50ZXJuYWxfX3VwZGF0ZU9wdGlvbnMiLCJfaW50ZXJuYWxfX2l0ZW1zIiwiX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSIsIl9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cyIsIl9wcml2YXRlX19tYWtlVmFsaWRJbXBsIiwiX3ByaXZhdGVfX2V4dGVuZGVkVmlzaWJsZVJhbmdlIiwiX2ludGVybmFsX19jb252ZXJ0VG9Db29yZGluYXRlcyIsIl9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSIsImV4dGVuZGVkVmlzaWJsZVJhbmdlIiwiQ3VzdG9tU2VyaWVzUGFuZVJlbmRlcmVyV3JhcHBlciIsIl9wcml2YXRlX19zb3VyY2VSZW5kZXJlciIsInNvdXJjZVJlbmRlcmVyIiwiU2VyaWVzQ3VzdG9tUGFuZVZpZXciLCJwcmljZVZhbHVlQnVpbGRlciIsImlzV2hpdGVzcGFjZSIsImNvbG9yZXIiLCJfaW50ZXJuYWxfb3JpZ2luYWxEYXRhIiwidXBkYXRlIiwidW53cmFwSXRlbURhdGEiLCJvcmlnaW5hbERhdGEiLCJiYXJDb2xvciIsImN1c3RvbVN0eWxlRGVmYXVsdHMiLCJjcmVhdGVQYW5lVmlldyQ2IiwiY3JlYXRlQ3VzdG9tU2VyaWVzRGVmaW5pdGlvbiIsImRlZmluaXRpb24iLCJpc0J1aWx0SW4iLCJkZWZhdWx0T3B0aW9ucyIsIl9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldyIsIl9pbnRlcm5hbF9jdXN0b21QYW5lVmlldyIsImlzU2VyaWVzRGVmaW5pdGlvbiIsInNpbmdsZVZhbHVlRGF0YSIsImxpbmVEYXRhIiwiYXJlYURhdGEiLCJiYXNlbGluZURhdGEiLCJvaGxjRGF0YSIsImJhckRhdGEiLCJjYW5kbGVzdGlja0RhdGEiLCJnZXRTZXJpZXNEYXRhQ3JlYXRvciIsInNlcmllc1Bsb3RSb3dUb0RhdGFNYXAiLCJjdXN0b21EYXRhIiwiY3Jvc3NoYWlyT3B0aW9uc0RlZmF1bHRzIiwiZ3JpZE9wdGlvbnNEZWZhdWx0cyIsImxheW91dE9wdGlvbnNEZWZhdWx0cyIsInByaWNlU2NhbGVPcHRpb25zRGVmYXVsdHMiLCJ0aW1lU2NhbGVPcHRpb25zRGVmYXVsdHMiLCJjaGFydE9wdGlvbnNEZWZhdWx0cyIsImxhbmd1YWdlIiwiUHJpY2VTY2FsZUFwaSIsImFwcGx5T3B0aW9ucyIsIl9wcml2YXRlX19wcmljZVNjYWxlSWQiLCJfcHJpdmF0ZV9fcGFuZUluZGV4Iiwic2V0VmlzaWJsZVJhbmdlIiwic2V0QXV0b1NjYWxlIiwiZ2V0VmlzaWJsZVJhbmdlIiwib24iLCJQYW5lQXBpIiwiZ2V0SGVpZ2h0Iiwic2V0SGVpZ2h0IiwiZ2V0U2VyaWVzIiwiX3ByaXZhdGVfX3Nlcmllc0FwaUdldHRlciIsImdldEhUTUxFbGVtZW50IiwiYXR0YWNoUHJpbWl0aXZlIiwiYXR0YWNoZWQiLCJfaW50ZXJuYWxfX2NoYXJ0QXBpIiwicmVxdWVzdFVwZGF0ZSIsImRldGFjaFByaW1pdGl2ZSIsInNlcmllc0FwaUdldHRlciIsImNoYXJ0QXBpIiwiY2hlY2tQcmljZUxpbmVPcHRpb25zIiwiY2hlY2tJdGVtc0FyZU9yZGVyZWQiLCJhbGxvd0R1cGxpY2F0ZXMiLCJjaGVja1Jlc3VsdCIsImNoZWNrU2VyaWVzVmFsdWVzVHlwZSIsImdldENoZWNrZXIiLCJjaGVja0Jhckl0ZW0iLCJjaGVja0xpbmVJdGVtIiwiY2hlY2tDdXN0b21JdGVtIiwiYmFySXRlbSIsImlzU2FmZVZhbHVlIiwiTUlOX1NBRkVfVkFMVUUiLCJNQVhfU0FGRV9WQUxVRSIsInRvUHJlY2lzaW9uIiwibGluZUl0ZW0iLCJNSU5fU0FGRV9JTlRFR0VSIiwiTUFYX1NBRkVfSU5URUdFUiIsInByaWNlTGluZU9wdGlvbnNEZWZhdWx0cyIsIlByaWNlTGluZSIsIl9pbnRlcm5hbF9wcmljZUxpbmUiLCJTZXJpZXNBcGkiLCJfcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZSIsInByaWNlVG9Db29yZGluYXRlIiwiY29vcmRpbmF0ZVRvUHJpY2UiLCJiYXJzSW5Mb2dpY2FsUmFuZ2UiLCJjb3JyZWN0ZWRSYW5nZSIsImRhdGFGaXJzdEJhckluUmFuZ2UiLCJkYXRhTGFzdEJhckluUmFuZ2UiLCJkYXRhRmlyc3RJbmRleCIsImRhdGFMYXN0SW5kZXgiLCJiYXJzQmVmb3JlIiwiYmFyc0FmdGVyIiwic2V0RGF0YSIsIl9pbnRlcm5hbF9fZGF0YVVwZGF0ZXNDb25zdW1lciIsIl9pbnRlcm5hbF9hcHBseU5ld0RhdGEiLCJfcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZCIsIl9pbnRlcm5hbF91cGRhdGVEYXRhIiwiZGF0YUJ5SW5kZXgiLCJsb2dpY2FsSW5kZXgiLCJtaXNtYXRjaERpcmVjdGlvbiIsImNyZWF0b3IiLCJzZXJpZXNDcmVhdG9yIiwicm93cyIsInN1YnNjcmliZURhdGFDaGFuZ2VkIiwidW5zdWJzY3JpYmVEYXRhQ2hhbmdlZCIsIl9wcml2YXRlX19wcmljZVNjYWxlQXBpUHJvdmlkZXIiLCJnZXRQYW5lIiwiY3JlYXRlUHJpY2VMaW5lIiwic3RyaWN0T3B0aW9ucyIsInJlbW92ZVByaWNlTGluZSIsInByaWNlTGluZXMiLCJfcHJpdmF0ZV9fcGFuZUFwaUdldHRlciIsIm1vdmVUb1BhbmUiLCJzZXJpZXNPcmRlciIsInNldFNlcmllc09yZGVyIiwiZGF0YVVwZGF0ZXNDb25zdW1lciIsInByaWNlU2NhbGVBcGlQcm92aWRlciIsInBhbmVBcGlHZXR0ZXIiLCJUaW1lU2NhbGVBcGkiLCJfcHJpdmF0ZV9fdGltZVJhbmdlQ2hhbmdlZCIsInNjcm9sbFRvUG9zaXRpb24iLCJhbmltYXRlZCIsInNjcm9sbFRvUmVhbFRpbWUiLCJ0aW1lUmFuZ2UiLCJjb252ZXJ0ZWRSYW5nZSIsImdldFZpc2libGVMb2dpY2FsUmFuZ2UiLCJzZXRWaXNpYmxlTG9naWNhbFJhbmdlIiwicmVzZXRUaW1lU2NhbGUiLCJmaXRDb250ZW50IiwibG9naWNhbFRvQ29vcmRpbmF0ZSIsImNvb3JkaW5hdGVUb0xvZ2ljYWwiLCJ0aW1lVG9JbmRleCIsInRpbWVUb0Nvb3JkaW5hdGUiLCJjb29yZGluYXRlVG9UaW1lIiwic3Vic2NyaWJlVmlzaWJsZVRpbWVSYW5nZUNoYW5nZSIsInVuc3Vic2NyaWJlVmlzaWJsZVRpbWVSYW5nZUNoYW5nZSIsInN1YnNjcmliZVZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2UiLCJ1bnN1YnNjcmliZVZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2UiLCJzdWJzY3JpYmVTaXplQ2hhbmdlIiwidW5zdWJzY3JpYmVTaXplQ2hhbmdlIiwiX3ByaXZhdGVfX29uVmlzaWJsZUJhcnNDaGFuZ2VkIiwiX3ByaXZhdGVfX29uVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZWQiLCJfcHJpdmF0ZV9fb25TaXplQ2hhbmdlZCIsInRpbWVBeGlzV2lkZ2V0IiwicGF0Y2hQcmljZUZvcm1hdCIsInByaWNlRm9ybWF0QnVpbHRJbiIsIm1pZ3JhdGVIYW5kbGVTY2FsZVNjcm9sbE9wdGlvbnMiLCJ0b0ludGVybmFsT3B0aW9ucyIsIkNoYXJ0QXBpIiwicmVtb3ZlIiwiX3ByaXZhdGVfX3RpbWVTY2FsZUFwaSIsIl9wcml2YXRlX19zZXJpZXNNYXAiLCJfcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQiLCJfcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlIiwiX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZSIsIl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlIiwiX3ByaXZhdGVfX2RhdGFMYXllciIsInJlc2l6ZSIsImF1dG9TaXplQWN0aXZlIiwiYWRkQ3VzdG9tU2VyaWVzIiwiX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwiLCJhZGRTZXJpZXMiLCJyZW1vdmVTZXJpZXMiLCJzZXJpZXNBcGkiLCJfcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQiLCJzdWJzY3JpYmVDbGljayIsInVuc3Vic2NyaWJlQ2xpY2siLCJzdWJzY3JpYmVDcm9zc2hhaXJNb3ZlIiwidW5zdWJzY3JpYmVDcm9zc2hhaXJNb3ZlIiwic3Vic2NyaWJlRGJsQ2xpY2siLCJ1bnN1YnNjcmliZURibENsaWNrIiwidGFrZVNjcmVlbnNob3QiLCJyZW1vdmVQYW5lIiwic3dhcFBhbmVzIiwiY2hhcnRFbGVtZW50IiwiX3ByaXZhdGVfX2dldFBhbmVBcGkiLCJwYW5lU2l6ZSIsInNldENyb3NzaGFpclBvc2l0aW9uIiwiY2xlYXJDcm9zc2hhaXJQb3NpdGlvbiIsImhvcnpCZWhhdmlvdXIiLCJfaW50ZXJuYWxfX2hvcnpTY2FsZUJlaGF2aW9yIiwiX3ByaXZhdGVfX21hcFNlcmllc1RvQXBpIiwiX3ByaXZhdGVfX2NvbnZlcnRNb3VzZVBhcmFtcyIsInBhcmFtIiwiaG92ZXJlZE9iamVjdElkIiwic291cmNlRXZlbnQiLCJpbnRlcm5hbE9wdGlvbnMiLCJwYXJhbVN1cHBsaWVyIiwiZmV0Y2hIdG1sRWxlbWVudCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlQ2hhcnRFeCIsImh0bWxFbGVtZW50IiwiY3JlYXRlQ2hhcnQiLCJkZWZhdWx0SG9yelNjYWxlQmVoYXZpb3IiLCJMaW5lUGFuZVZpZXdCYXNlIiwiX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSIsIl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSIsImRyYXdTZXJpZXNQb2ludE1hcmtlcnMiLCJyZW5kZXJpbmdTY29wZSIsInBvaW50TWFya2Vyc1JhZGl1cyIsInN0eWxlR2V0dGVyIiwicHJldlN0eWxlIiwid2Fsa0xpbmUiLCJsaW5lVHlwZSIsImJhcldpZHRoIiwiZmluaXNoU3R5bGVkQXJlYSIsImZpcnN0SXRlbSIsImN1cnJlbnRTdHlsZSIsImN1cnJlbnRTdHlsZUZpcnN0SXRlbSIsImhhbGZCYXJXaWR0aCIsIml0ZW0xIiwiaXRlbTIiLCJjaGFuZ2VTdHlsZSIsIm5ld1N0eWxlIiwiY3VycmVudEl0ZW0iLCJpdGVtU3R5bGUiLCJjcDEiLCJjcDIiLCJnZXRDb250cm9sUG9pbnRzIiwiYmV6aWVyQ3VydmVUbyIsImN1cnZlVGVuc2lvbiIsInN1YnRyYWN0IiwiZGl2aWRlIiwibiIsImZyb21Qb2ludEluZGV4IiwidG9Qb2ludEluZGV4IiwiYmVmb3JlRnJvbVBvaW50SW5kZXgiLCJhZnRlclRvUG9pbnRJbmRleCIsImZpbmlzaFN0eWxlZEFyZWEkMSIsIlBhbmVSZW5kZXJlckxpbmVCYXNlIiwiX2ludGVybmFsX2JhcldpZHRoIiwiX2ludGVybmFsX2xpbmVUeXBlIiwiX2ludGVybmFsX3BvaW50TWFya2Vyc1JhZGl1cyIsImxpbmVKb2luIiwiX2ludGVybmFsX19zdHJva2VTdHlsZSIsIlBhbmVSZW5kZXJlckxpbmUiLCJTZXJpZXNMaW5lUGFuZVZpZXciLCJwb2ludE1hcmtlcnNWaXNpYmxlIiwibGluZVN0eWxlRGVmYXVsdHMiLCJjcmVhdGVQYW5lVmlldyQ1IiwiY3JlYXRlTGluZVNlcmllcyIsImxpbmVTZXJpZXMiLCJjcmVhdGVEZWJvdW5jZWRNaWNyb1Rhc2tIYW5kbGVyIiwic2NoZWR1bGVkIiwiYXJncyIsInF1ZXVlTWljcm90YXNrIiwibWFya1dpdGhHcmVhdGVyV2VpZ2h0JDEiLCJ0b0ludGVybmFsSG9yelNjYWxlSXRlbSIsImZyb21JbnRlcm5hbEhvcnpTY2FsZUl0ZW0iLCJZaWVsZEN1cnZlSG9yelNjYWxlQmVoYXZpb3IiLCJfaW50ZXJuYWxfd2hpdGVzcGFjZUludmFsaWRhdGVkIiwiX3ByaXZhdGVfX3BvaW50c0NoYW5nZWREZWxlZ2F0ZSIsIl9wcml2YXRlX19pbnZhbGlkYXRlV2hpdGVzcGFjZSIsIl9wcml2YXRlX19sYXJnZXN0SW5kZXgiLCJpbnRlcm5hbEl0ZW0iLCJfcHJpdmF0ZV9fZm9ybWF0VGltZSIsIm1vbnRocyIsInllYXJzIiwicmVtYWluaW5nTW9udGhzIiwieWllbGRDaGFydE9wdGlvbnNEZWZhdWx0cyIsImJhc2VSZXNvbHV0aW9uIiwibWluaW11bVRpbWVSYW5nZSIsInN0YXJ0VGltZVJhbmdlIiwiZ2VuZXJhdGVXaGl0ZXNwYWNlRGF0YSIsIl9pbnRlcm5hbF9yZXNvbHV0aW9uIiwicmVzb2x1dGlvbiIsImJ1aWxkV2hpdGVzcGFjZVN0YXRlIiwiZ2VuZXJhdGVXaGl0ZXNwYWNlSGFzaCIsInlpZWxkQ3VydmUiLCJsaW5lU3R5bGVEZWZhdWx0T3B0aW9uT3ZlcnJpZGVzIiwiWWllbGRDaGFydEFwaSIsIm9wdGlvbk92ZXJyaWRlcyIsIl9pbml0V2hpdGVzcGFjZVNlcmllcyIsIndoaXRlU3BhY2VTZXJpZXMiLCJjdXJyZW50V2hpdGVzcGFjZUhhc2giLCJ1cGRhdGVXaGl0ZXNwYWNlIiwibmV3V2hpdGVzcGFjZVN0YXRlIiwibmV3V2hpdGVzcGFjZUhhc2giLCJmdWxsT3B0aW9ucyIsImNyZWF0ZVlpZWxkQ3VydmVDaGFydCIsIm1hcmtXaXRoR3JlYXRlcldlaWdodCIsIkhvcnpTY2FsZUJlaGF2aW9yUHJpY2UiLCJwcmljZVdlaWdodCIsImNyZWF0ZU9wdGlvbnNDaGFydCIsImJhc2VMZXZlbENvb3JkaW5hdGUiLCJhcmVhRmlyc3RJdGVtIiwibmV3QXJlYUZpcnN0SXRlbSIsIlBhbmVSZW5kZXJlckFyZWFCYXNlIiwiX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUiLCJfaW50ZXJuYWxfaW52ZXJ0RmlsbGVkQXJlYSIsIl9pbnRlcm5hbF9fZmlsbFN0eWxlIiwiR3JhZGllbnRTdHlsZUNhY2hlIiwiX2ludGVybmFsX2dldCIsImNhY2hlZFBhcmFtcyIsIl9wcml2YXRlX19wYXJhbXMiLCJfaW50ZXJuYWxfdG9wQ29sb3IxIiwidG9wQ29sb3IxIiwiX2ludGVybmFsX3RvcENvbG9yMiIsInRvcENvbG9yMiIsIl9pbnRlcm5hbF9ib3R0b21Db2xvcjEiLCJib3R0b21Db2xvcjEiLCJfaW50ZXJuYWxfYm90dG9tQ29sb3IyIiwiYm90dG9tQ29sb3IyIiwiX2ludGVybmFsX3RvcENvb3JkaW5hdGUiLCJ0b3BDb29yZGluYXRlIiwiX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGUiLCJib3R0b21Db29yZGluYXRlIiwiX3ByaXZhdGVfX2NhY2hlZFZhbHVlIiwibXVsdGlwbGllciIsImJhc2VsaW5lIiwiYmFzZWxpbmVSYXRpbyIsIlBhbmVSZW5kZXJlckJhc2VsaW5lQXJlYSIsIl9wcml2YXRlX19maWxsQ2FjaGUiLCJQYW5lUmVuZGVyZXJCYXNlbGluZUxpbmUiLCJfcHJpdmF0ZV9fc3Ryb2tlQ2FjaGUiLCJTZXJpZXNCYXNlbGluZVBhbmVWaWV3IiwicmVsYXRpdmVHcmFkaWVudCIsIl9wcml2YXRlX19iYXNlbGluZUFyZWFSZW5kZXJlciIsIl9wcml2YXRlX19iYXNlbGluZUxpbmVSZW5kZXJlciIsImJhc2VsaW5lU3R5bGVEZWZhdWx0cyIsImNyZWF0ZVBhbmVWaWV3JDQiLCJjcmVhdGVTZXJpZXMkNCIsImJhc2VsaW5lU2VyaWVzIiwiUGFuZVJlbmRlcmVyQXJlYSIsIlNlcmllc0FyZWFQYW5lVmlldyIsIl9wcml2YXRlX19hcmVhUmVuZGVyZXIiLCJpbnZlcnRGaWxsZWRBcmVhIiwiX3ByaXZhdGVfX2xpbmVSZW5kZXJlciIsImFyZWFTdHlsZURlZmF1bHRzIiwiY3JlYXRlUGFuZVZpZXckMyIsImNyZWF0ZVNlcmllcyQzIiwiYXJlYVNlcmllcyIsIm9wdGltYWxCYXJXaWR0aCIsIm9wdGltYWxDYW5kbGVzdGlja1dpZHRoIiwiYmFyU3BhY2luZ1NwZWNpYWxDYXNlRnJvbSIsImJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvIiwiYmFyU3BhY2luZ1NwZWNpYWxDYXNlQ29lZmYiLCJiYXJTcGFjaW5nUmVkdWNpbmdDb2VmZiIsImF0YW4iLCJzY2FsZWRCYXJTcGFjaW5nIiwib3B0aW1hbCIsIlBhbmVSZW5kZXJlckJhcnMiLCJfcHJpdmF0ZV9fYmFyV2lkdGgiLCJfcHJpdmF0ZV9fY2FsY0JhcldpZHRoIiwiX3ByaXZhdGVfX2JhckxpbmVXaWR0aCIsIl9pbnRlcm5hbF90aGluQmFycyIsInByZXZDb2xvciIsImRyYXdPcGVuQ2xvc2UiLCJib2R5V2lkdGhIYWxmIiwiYm9keUNlbnRlciIsImJvZHlMZWZ0IiwiYm9keVdpZHRoIiwiYm9keVJpZ2h0IiwiYm9keVRvcCIsImJvZHlCb3R0b20iLCJib2R5SGVpZ2h0Iiwic2lkZVdpZHRoIiwiX2ludGVybmFsX29wZW5WaXNpYmxlIiwib3BlbkxlZnQiLCJvcGVuVG9wIiwib3BlbkJvdHRvbSIsImNsb3NlUmlnaHQiLCJjbG9zZVRvcCIsImNsb3NlQm90dG9tIiwibGltaXQiLCJCYXJzUGFuZVZpZXdCYXNlIiwiX2ludGVybmFsX19jcmVhdGVEZWZhdWx0SXRlbSIsIlNlcmllc0JhcnNQYW5lVmlldyIsImJhclN0eWxlUHJvcHMiLCJvcGVuVmlzaWJsZSIsInRoaW5CYXJzIiwiYmFyU3R5bGVEZWZhdWx0cyIsImNyZWF0ZVBhbmVWaWV3JDIiLCJjcmVhdGVTZXJpZXMkMiIsImJhclNlcmllcyIsIlBhbmVSZW5kZXJlckNhbmRsZXN0aWNrcyIsIndpY2tXaWR0aCIsIl9pbnRlcm5hbF93aWNrVmlzaWJsZSIsIl9wcml2YXRlX19kcmF3V2lja3MiLCJfcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgiLCJfcHJpdmF0ZV9fZHJhd0NhbmRsZXMiLCJwcmV2V2lja0NvbG9yIiwid2lja09mZnNldCIsInByZXZFZGdlIiwic2NhbGVkWCIsInByZXZCb3JkZXJDb2xvciIsInByZXZCYXJDb2xvciIsIlNlcmllc0NhbmRsZXN0aWNrc1BhbmVWaWV3IiwiY2FuZGxlc3RpY2tTdHlsZVByb3BzIiwid2lja1Zpc2libGUiLCJjYW5kbGVzdGlja1N0eWxlRGVmYXVsdHMiLCJjcmVhdGVQYW5lVmlldyQxIiwiY3JlYXRlU2VyaWVzJDEiLCJjYW5kbGVzdGlja1NlcmllcyIsInNob3dTcGFjaW5nTWluaW1hbEJhcldpZHRoIiwiYWxpZ25Ub01pbmltYWxXaWR0aExpbWl0IiwiUGFuZVJlbmRlcmVySGlzdG9ncmFtIiwiX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZSIsIl9wcml2YXRlX19maWxsUHJlY2FsY3VsYXRlZENhY2hlIiwiaGlzdG9ncmFtQmFzZSIsIl9pbnRlcm5hbF9oaXN0b2dyYW1CYXNlIiwidG9wSGlzdG9ncmFtQmFzZSIsImJvdHRvbUhpc3RvZ3JhbUJhc2UiLCJjb2x1bW5XaWR0aCIsImhhbGZXaWR0aCIsIl9pbnRlcm5hbF9yb3VuZGVkQ2VudGVyIiwibWluV2lkdGgiLCJTZXJpZXNIaXN0b2dyYW1QYW5lVmlldyIsImhpc3RvZ3JhbVN0eWxlRGVmYXVsdHMiLCJjcmVhdGVTZXJpZXMiLCJoaXN0b2dyYW1TZXJpZXMiLCJkZXRhY2giLCJfcHJpdmF0ZV9fcHJpbWl0aXZlIiwiX3ByaXZhdGVfX2F0dGFjaCIsInRleHRXYXRlcm1hcmtPcHRpb25zRGVmYXVsdHMiLCJob3J6QWxpZ24iLCJ2ZXJ0QWxpZ24iLCJsaW5lcyIsInRleHRXYXRlcm1hcmtMaW5lT3B0aW9uc0RlZmF1bHRzIiwiZm9udFN0eWxlIiwiVGV4dFdhdGVybWFya1JlbmRlcmVyIiwidGV4dEhlaWdodCIsIl9wcml2YXRlX19tZXRyaWNzIiwibGluZUhlaWdodCIsInZlcnRPZmZzZXQiLCJob3J6T2Zmc2V0IiwiX2ludGVybmFsX3ZlcnRPZmZzZXQiLCJmb250Q2FjaGUiLCJfcHJpdmF0ZV9fZm9udENhY2hlIiwiX3ByaXZhdGVfX21ldHJpY3NDYWNoZSIsIlRleHRXYXRlcm1hcmtQYW5lVmlldyIsImJ1aWxkUmVuZGVyZXJPcHRpb25zJDEiLCJidWlsZFJlbmRlcmVyTGluZU9wdGlvbnMiLCJsaW5lT3B0aW9uIiwibWVyZ2VMaW5lT3B0aW9uc1dpdGhEZWZhdWx0cyIsIm1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQyIiwiVGV4dFdhdGVybWFyayIsIl9wcml2YXRlX19wYW5lVmlld3MiLCJfaW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSIsImNyZWF0ZVRleHRXYXRlcm1hcmsiLCJpbWFnZVdhdGVybWFya09wdGlvbnNEZWZhdWx0cyIsIkltYWdlV2F0ZXJtYXJrUmVuZGVyZXIiLCJfcHJpdmF0ZV9fZGV0ZXJtaW5lUGxhY2VtZW50IiwiX2ludGVybmFsX2ltZ0VsZW1lbnQiLCJnbG9iYWxBbHBoYSIsIm1heEhlaWdodCIsIl9pbnRlcm5hbF9pbWdIZWlnaHQiLCJpbWdIZWlnaHQiLCJfaW50ZXJuYWxfaW1nV2lkdGgiLCJpbWdXaWR0aCIsInBsb3RDZW50cmVYIiwicGxvdENlbnRyZVkiLCJwYWRkaW5nU2l6ZSIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0Iiwic2NhbGVYIiwic2NhbGVZIiwic2NhbGVUb1VzZSIsImRyYXdXaWR0aCIsImRyYXdIZWlnaHQiLCJJbWFnZVdhdGVybWFya1BhbmVWaWV3IiwiX2ludGVybmFsX3N0YXRlVXBkYXRlIiwiX2ludGVybmFsX2ltYWdlV2lkdGgiLCJfcHJpdmF0ZV9faW1hZ2VXaWR0aCIsIl9pbnRlcm5hbF9pbWFnZUhlaWdodCIsIl9wcml2YXRlX19pbWFnZUhlaWdodCIsIl9pbnRlcm5hbF9pbWFnZSIsIl9wcml2YXRlX19pbWFnZSIsIl9pbnRlcm5hbF9vcHRpb25zVXBkYXRlIiwiYnVpbGRSZW5kZXJlck9wdGlvbnMiLCJpbWdFbGVtZW50IiwibWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzJDEiLCJJbWFnZVdhdGVybWFyayIsImF0dGFjaGVkUGFyYW1zIiwiX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUiLCJfcHJpdmF0ZV9faW1nRWxlbWVudCIsIkltYWdlIiwib25sb2FkIiwiaW1hZ2VIZWlnaHQiLCJuYXR1cmFsSGVpZ2h0IiwiaW1hZ2VXaWR0aCIsIm5hdHVyYWxXaWR0aCIsInB2IiwiX3ByaXZhdGVfX2ltYWdlVXJsIiwiX3ByaXZhdGVfX3VwZGF0ZU9wdGlvbnMiLCJpbWFnZVVybCIsImNyZWF0ZUltYWdlV2F0ZXJtYXJrIiwiU2VyaWVzUHJpbWl0aXZlQWRhcHRlciIsInNlcmllc01hcmtlck9wdGlvbnNEZWZhdWx0cyIsInNoYXBlU2l6ZSIsInNoYXBlIiwiY2FsY3VsYXRlU2hhcGVIZWlnaHQiLCJzaGFwZU1hcmdpbiIsImNhbGN1bGF0ZUFkanVzdGVkTWFyZ2luIiwiaGFzU2lkZSIsImhhc0luQmFyIiwiZHJhd0Fycm93IiwidXAiLCJjb29yZHMiLCJhcnJvd1NpemUiLCJoYWxmQXJyb3dTaXplIiwiX2ludGVybmFsX3BpeGVsUmF0aW8iLCJiYXNlU2l6ZSIsImhhbGZCYXNlU2l6ZSIsImhpdFRlc3RBcnJvdyIsInRyaWFuZ2xlVG9sZXJhbmNlIiwicmVjdFRvbGVyYW5jZSIsImJhc2VMZWZ0IiwiYmFzZVJpZ2h0IiwiYmFzZVRvcCIsImJhc2VCb3R0b20iLCJpc0luVHJpYW5nbGVCb3VuZHMiLCJoZWFkTGVmdCIsImhlYWRSaWdodCIsImhlYWRUb3AiLCJoZWFkQm90dG9tIiwiZHgiLCJkeSIsImRyYXdDaXJjbGUiLCJjaXJjbGVTaXplIiwiaGFsZlNpemUiLCJoaXRUZXN0Q2lyY2xlIiwidG9sZXJhbmNlIiwiZGlzdCIsImRyYXdTcXVhcmUiLCJzcXVhcmVTaXplIiwiaGl0VGVzdFNxdWFyZSIsImRyYXdUZXh0IiwiaGl0VGVzdFRleHQiLCJ0ZXh0WCIsInRleHRZIiwiU2VyaWVzTWFya2Vyc1JlbmRlcmVyIiwiX3ByaXZhdGVfX3pPcmRlciIsImhpdFRlc3RJdGVtIiwiX2ludGVybmFsX2NvbnRlbnQiLCJkcmF3SXRlbSIsImJpdG1hcFNoYXBlSXRlbUNvb3JkaW5hdGVzIiwiZHJhd1NoYXBlIiwiY29vcmRpbmF0ZXMiLCJfaW50ZXJuYWxfc2hhcGUiLCJoaXRUZXN0U2hhcGUiLCJpc1ByaWNlTWFya2VyIiwiZ2V0UHJpY2UiLCJtYXJrZXIiLCJpc1ZhbHVlRGF0YSIsImlzT2hsY0RhdGEiLCJmaWxsU2l6ZUFuZFkiLCJyZW5kZXJlckl0ZW0iLCJvZmZzZXRzIiwiaWdub3JlT2Zmc2V0Iiwic2l6ZU11bHRpcGxpZXIiLCJfaW50ZXJuYWxfYWJvdmVCYXIiLCJfaW50ZXJuYWxfYmVsb3dCYXIiLCJTZXJpZXNNYXJrZXJzUGFuZVZpZXciLCJfaW50ZXJuYWxfX21ha2VWYWxpZCIsIl9pbnRlcm5hbF9zZXRNYXJrZXJzIiwibWFya2VycyIsIl9wcml2YXRlX19tYXJrZXJzIiwiX3ByaXZhdGVfX2RhdGFJbnZhbGlkYXRlZCIsIl9pbnRlcm5hbF91cGRhdGVPcHRpb25zIiwic2VyaWVzTWFya2VycyIsIl9pbnRlcm5hbF9pbnRlcm5hbElkIiwidmlzaWJsZUJhcnNSYW5nZSIsInByZXZUaW1lSW5kZXgiLCJzaGFwZU1hcmdpbiQxIiwiZGF0YUF0IiwibWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzIiwiU2VyaWVzTWFya2Vyc1ByaW1pdGl2ZSIsIl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMiLCJfcHJpdmF0ZV9fcmVjYWxjdWxhdGlvblJlcXVpcmVkIiwiX3ByaXZhdGVfX2RhdGFDaGFuZ2VkSGFuZGxlciIsIl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zSW52YWxpZGF0ZWQiLCJfcHJpdmF0ZV9fbWFya2Vyc1Bvc2l0aW9ucyIsIl9pbnRlcm5hbF9tYXJrZXJzIiwiX3ByaXZhdGVfX3VwZGF0ZUFsbFZpZXdzIiwiX3ByaXZhdGVfX2dldEF1dG9TY2FsZU1hcmdpbnMiLCJfcHJpdmF0ZV9fY2FjaGVkQmFyU3BhY2luZyIsIm1hcmdpblZhbHVlIiwicG9zaXRpb25zIiwiX3ByaXZhdGVfX2dldE1hcmtlclBvc2l0aW9ucyIsIl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zIiwiYWJvdmVCYXIiLCJpbkJhciIsImJlbG93QmFyIiwiYXRQcmljZVRvcCIsImF0UHJpY2VCb3R0b20iLCJhdFByaWNlTWlkZGxlIiwiX3ByaXZhdGVfX2luZGV4ZWRNYXJrZXJzIiwiZmlyc3REYXRhSW5kZXgiLCJzZXJpZXNEYXRhQnlJbmRleCIsImZpbmFsSW5kZXgiLCJiYXNlTWFya2VyIiwiU2VyaWVzTWFya2Vyc1ByaW1pdGl2ZVdyYXBwZXIiLCJzZXRNYXJrZXJzIiwiY3JlYXRlU2VyaWVzTWFya2VycyIsIkV4cGlyaW5nTWFya2VyTWFuYWdlciIsIl9pbnRlcm5hbF9zZXRNYXJrZXIiLCJ0aW1lb3V0IiwiX2ludGVybmFsX2NsZWFyTWFya2VyIiwidGltZW91dElkIiwiX3ByaXZhdGVfX3RyaWdnZXJVcGRhdGUiLCJtYXJrZXJXaXRoVGltZW91dCIsIl9pbnRlcm5hbF90aW1lb3V0SWQiLCJfaW50ZXJuYWxfZXhwaXJlc0F0IiwiX2ludGVybmFsX2NsZWFyQWxsTWFya2VycyIsIl9pbnRlcm5hbF9nZXRNYXJrZXJzIiwiYWN0aXZlTWFya2VycyIsIl9pbnRlcm5hbF9zZXRVcGRhdGVDYWxsYmFjayIsIl9wcml2YXRlX191cGRhdGVDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwidXBEb3duTWFya2Vyc1BsdWdpbk9wdGlvbkRlZmF1bHRzIiwicG9zaXRpdmVDb2xvciIsIm5lZ2F0aXZlQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5RHVyYXRpb24iLCJNYXJrZXJzUHJpbWl0aXZlUmVuZGVyZXIiLCJyYWQiLCJjZW50cmVYIiwiX3ByaXZhdGVfX2dldENvbG9yIiwiX2ludGVybmFsX3NpZ24iLCJfcHJpdmF0ZV9fbmV1dHJhbENvbG9yIiwiX3ByaXZhdGVfX3Bvc2l0aXZlQ29sb3IiLCJfcHJpdmF0ZV9fbmVnYXRpdmVDb2xvciIsIm5ldXRyYWxDb2xvciIsImlzQXJlYVN0eWxlT3B0aW9ucyIsIm9wdHMiLCJnZXROZXV0cmFsQ29sb3IiLCJNYXJrZXJzUHJpbWl0aXZlUGFuZVZpZXciLCJpc0xpbmVEYXRhIiwiVXBEb3duTWFya2Vyc1ByaW1pdGl2ZSIsIl9wcml2YXRlX19tYXJrZXJzTWFuYWdlciIsIl9wcml2YXRlX19tYW5hZ2VkRGF0YVBvaW50cyIsImhvcnpLZXkiLCJleGlzdGluZ1ByaWNlIiwiZ2V0U2lnbiIsIl9pbnRlcm5hbF9jbGVhck1hcmtlcnMiLCJvbGRWYWx1ZSIsIlNlcmllc1VwRG93bk1hcmtlclByaW1pdGl2ZVdyYXBwZXIiLCJjbGVhck1hcmtlcnMiLCJjcmVhdGVVcERvd25NYXJrZXJzIiwiY3VzdG9tU2VyaWVzRGVmYXVsdE9wdGlvbnMiLCJ2ZXJzaW9uIiwiQXJlYVNlcmllcyIsIkJhclNlcmllcyIsIkJhc2VsaW5lU2VyaWVzIiwiQ2FuZGxlc3RpY2tTZXJpZXMiLCJIaXN0b2dyYW1TZXJpZXMiLCJMaW5lU2VyaWVzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\n"));

/***/ })

}]);